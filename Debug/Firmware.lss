
Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d8  00800200  00003dc8  00003e5c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003dc8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001306  008002d8  008002d8  00003f34  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003f34  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000590  00000000  00000000  00003f90  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000077b0  00000000  00000000  00004520  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001aa5  00000000  00000000  0000bcd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004043  00000000  00000000  0000d775  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001380  00000000  00000000  000117b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002015  00000000  00000000  00012b38  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000065ac  00000000  00000000  00014b4d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000005d0  00000000  00000000  0001b0f9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	da c0       	rjmp	.+436    	; 0x1b6 <__ctors_end>
       2:	00 00       	nop
       4:	f4 c3       	rjmp	.+2024   	; 0x7ee <__vector_1>
       6:	00 00       	nop
       8:	f7 c0       	rjmp	.+494    	; 0x1f8 <__bad_interrupt>
       a:	00 00       	nop
       c:	f5 c0       	rjmp	.+490    	; 0x1f8 <__bad_interrupt>
       e:	00 00       	nop
      10:	f3 c0       	rjmp	.+486    	; 0x1f8 <__bad_interrupt>
      12:	00 00       	nop
      14:	f1 c0       	rjmp	.+482    	; 0x1f8 <__bad_interrupt>
      16:	00 00       	nop
      18:	ef c0       	rjmp	.+478    	; 0x1f8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ed c0       	rjmp	.+474    	; 0x1f8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	eb c0       	rjmp	.+470    	; 0x1f8 <__bad_interrupt>
      22:	00 00       	nop
      24:	e9 c0       	rjmp	.+466    	; 0x1f8 <__bad_interrupt>
      26:	00 00       	nop
      28:	e7 c0       	rjmp	.+462    	; 0x1f8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e5 c0       	rjmp	.+458    	; 0x1f8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	e3 c0       	rjmp	.+454    	; 0x1f8 <__bad_interrupt>
      32:	00 00       	nop
      34:	11 c4       	rjmp	.+2082   	; 0x858 <__vector_13>
      36:	00 00       	nop
      38:	df c0       	rjmp	.+446    	; 0x1f8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	dd c0       	rjmp	.+442    	; 0x1f8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	db c0       	rjmp	.+438    	; 0x1f8 <__bad_interrupt>
      42:	00 00       	nop
      44:	d9 c0       	rjmp	.+434    	; 0x1f8 <__bad_interrupt>
      46:	00 00       	nop
      48:	d7 c0       	rjmp	.+430    	; 0x1f8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d5 c0       	rjmp	.+426    	; 0x1f8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	d3 c0       	rjmp	.+422    	; 0x1f8 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 be 08 	jmp	0x117c	; 0x117c <__vector_21>
      58:	cf c0       	rjmp	.+414    	; 0x1f8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	cd c0       	rjmp	.+410    	; 0x1f8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	0c 94 4d 18 	jmp	0x309a	; 0x309a <__vector_24>
      64:	0c 94 e9 15 	jmp	0x2bd2	; 0x2bd2 <__vector_25>
      68:	0c 94 2b 16 	jmp	0x2c56	; 0x2c56 <__vector_26>
      6c:	c5 c0       	rjmp	.+394    	; 0x1f8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	c3 c0       	rjmp	.+390    	; 0x1f8 <__bad_interrupt>
      72:	00 00       	nop
      74:	c1 c0       	rjmp	.+386    	; 0x1f8 <__bad_interrupt>
      76:	00 00       	nop
      78:	bf c0       	rjmp	.+382    	; 0x1f8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	bd c0       	rjmp	.+378    	; 0x1f8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	bb c0       	rjmp	.+374    	; 0x1f8 <__bad_interrupt>
      82:	00 00       	nop
      84:	b9 c0       	rjmp	.+370    	; 0x1f8 <__bad_interrupt>
      86:	00 00       	nop
      88:	b7 c0       	rjmp	.+366    	; 0x1f8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b5 c0       	rjmp	.+362    	; 0x1f8 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 77 16 	jmp	0x2cee	; 0x2cee <__vector_36>
      94:	0c 94 b9 16 	jmp	0x2d72	; 0x2d72 <__vector_37>
      98:	af c0       	rjmp	.+350    	; 0x1f8 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ad c0       	rjmp	.+346    	; 0x1f8 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ab c0       	rjmp	.+342    	; 0x1f8 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	a9 c0       	rjmp	.+338    	; 0x1f8 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	a7 c0       	rjmp	.+334    	; 0x1f8 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	a5 c0       	rjmp	.+330    	; 0x1f8 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a3 c0       	rjmp	.+326    	; 0x1f8 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a1 c0       	rjmp	.+322    	; 0x1f8 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	9f c0       	rjmp	.+318    	; 0x1f8 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	9d c0       	rjmp	.+314    	; 0x1f8 <__bad_interrupt>
      be:	00 00       	nop
      c0:	9b c0       	rjmp	.+310    	; 0x1f8 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	99 c0       	rjmp	.+306    	; 0x1f8 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	97 c0       	rjmp	.+302    	; 0x1f8 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	87 11       	cpse	r24, r7
      ce:	87 11       	cpse	r24, r7
      d0:	87 11       	cpse	r24, r7
      d2:	bf 11       	cpse	r27, r15
      d4:	ae 11       	cpse	r26, r14
      d6:	bc 11       	cpse	r27, r12
      d8:	87 11       	cpse	r24, r7
      da:	87 11       	cpse	r24, r7
      dc:	bf 11       	cpse	r27, r15
      de:	ae 11       	cpse	r26, r14
      e0:	5d 13       	cpse	r21, r29
      e2:	65 13       	cpse	r22, r21
      e4:	6d 13       	cpse	r22, r29
      e6:	75 13       	cpse	r23, r21
      e8:	7d 13       	cpse	r23, r29
      ea:	81 13       	cpse	r24, r17
      ec:	7e 14       	cp	r7, r14
      ee:	7e 14       	cp	r7, r14
      f0:	7e 14       	cp	r7, r14
      f2:	7e 14       	cp	r7, r14
      f4:	7e 14       	cp	r7, r14
      f6:	7e 14       	cp	r7, r14
      f8:	7e 14       	cp	r7, r14
      fa:	57 14       	cp	r5, r7
      fc:	7e 14       	cp	r7, r14
      fe:	7a 14       	cp	r7, r10
     100:	c4 13       	cpse	r28, r20
     102:	7e 14       	cp	r7, r14
     104:	7e 14       	cp	r7, r14
     106:	7e 14       	cp	r7, r14
     108:	7e 14       	cp	r7, r14
     10a:	7e 14       	cp	r7, r14
     10c:	7e 14       	cp	r7, r14
     10e:	7e 14       	cp	r7, r14
     110:	7e 14       	cp	r7, r14
     112:	7e 14       	cp	r7, r14
     114:	7e 14       	cp	r7, r14
     116:	7e 14       	cp	r7, r14
     118:	7e 14       	cp	r7, r14
     11a:	7e 14       	cp	r7, r14
     11c:	7e 14       	cp	r7, r14
     11e:	7e 14       	cp	r7, r14
     120:	59 13       	cpse	r21, r25
     122:	61 13       	cpse	r22, r17
     124:	69 13       	cpse	r22, r25
     126:	71 13       	cpse	r23, r17
     128:	79 13       	cpse	r23, r25
     12a:	55 14       	cp	r5, r5
     12c:	7e 14       	cp	r7, r14
     12e:	7e 14       	cp	r7, r14
     130:	7e 14       	cp	r7, r14
     132:	7e 14       	cp	r7, r14
     134:	7e 14       	cp	r7, r14
     136:	7e 14       	cp	r7, r14
     138:	7e 14       	cp	r7, r14
     13a:	7e 14       	cp	r7, r14
     13c:	7e 14       	cp	r7, r14
     13e:	7c 14       	cp	r7, r12
     140:	fb 13       	cpse	r31, r27

00000142 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     142:	0f 2e       	mov	r0, r31
     144:	f3 eb       	ldi	r31, 0xB3	; 179
     146:	ef 2e       	mov	r14, r31
     148:	fd e0       	ldi	r31, 0x0D	; 13
     14a:	ff 2e       	mov	r15, r31
     14c:	f0 2d       	mov	r31, r0
     14e:	cb e8       	ldi	r28, 0x8B	; 139
     150:	dd e0       	ldi	r29, 0x0D	; 13
     152:	27 c0       	rjmp	.+78     	; 0x1a2 <prvIdleTask+0x60>
     154:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <vTaskSuspendAll>
     158:	18 81       	ld	r17, Y
     15a:	0e 94 ef 0d 	call	0x1bde	; 0x1bde <xTaskResumeAll>
     15e:	11 23       	and	r17, r17
     160:	01 f1       	breq	.+64     	; 0x1a2 <prvIdleTask+0x60>
     162:	0f b6       	in	r0, 0x3f	; 63
     164:	f8 94       	cli
     166:	0f 92       	push	r0
     168:	e0 91 90 0d 	lds	r30, 0x0D90
     16c:	f0 91 91 0d 	lds	r31, 0x0D91
     170:	06 81       	ldd	r16, Z+6	; 0x06
     172:	17 81       	ldd	r17, Z+7	; 0x07
     174:	c8 01       	movw	r24, r16
     176:	02 96       	adiw	r24, 0x02	; 2
     178:	4e d6       	rcall	.+3228   	; 0xe16 <uxListRemove>
     17a:	80 91 89 0d 	lds	r24, 0x0D89
     17e:	81 50       	subi	r24, 0x01	; 1
     180:	80 93 89 0d 	sts	0x0D89, r24
     184:	80 91 8a 0d 	lds	r24, 0x0D8A
     188:	81 50       	subi	r24, 0x01	; 1
     18a:	80 93 8a 0d 	sts	0x0D8A, r24
     18e:	0f 90       	pop	r0
     190:	0f be       	out	0x3f, r0	; 63
     192:	f8 01       	movw	r30, r16
     194:	87 89       	ldd	r24, Z+23	; 0x17
     196:	90 8d       	ldd	r25, Z+24	; 0x18
     198:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vPortFree>
     19c:	c8 01       	movw	r24, r16
     19e:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vPortFree>
     1a2:	80 91 8a 0d 	lds	r24, 0x0D8A
     1a6:	81 11       	cpse	r24, r1
     1a8:	d5 cf       	rjmp	.-86     	; 0x154 <prvIdleTask+0x12>
     1aa:	f7 01       	movw	r30, r14
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	c0 f3       	brcs	.-16     	; 0x1a2 <prvIdleTask+0x60>
     1b2:	0f d7       	rcall	.+3614   	; 0xfd2 <vPortYield>
     1b4:	f6 cf       	rjmp	.-20     	; 0x1a2 <prvIdleTask+0x60>

000001b6 <__ctors_end>:
     1b6:	11 24       	eor	r1, r1
     1b8:	1f be       	out	0x3f, r1	; 63
     1ba:	cf ef       	ldi	r28, 0xFF	; 255
     1bc:	d1 e2       	ldi	r29, 0x21	; 33
     1be:	de bf       	out	0x3e, r29	; 62
     1c0:	cd bf       	out	0x3d, r28	; 61
     1c2:	00 e0       	ldi	r16, 0x00	; 0
     1c4:	0c bf       	out	0x3c, r16	; 60

000001c6 <__do_copy_data>:
     1c6:	12 e0       	ldi	r17, 0x02	; 2
     1c8:	a0 e0       	ldi	r26, 0x00	; 0
     1ca:	b2 e0       	ldi	r27, 0x02	; 2
     1cc:	e8 ec       	ldi	r30, 0xC8	; 200
     1ce:	fd e3       	ldi	r31, 0x3D	; 61
     1d0:	00 e0       	ldi	r16, 0x00	; 0
     1d2:	0b bf       	out	0x3b, r16	; 59
     1d4:	02 c0       	rjmp	.+4      	; 0x1da <__do_copy_data+0x14>
     1d6:	07 90       	elpm	r0, Z+
     1d8:	0d 92       	st	X+, r0
     1da:	a8 3d       	cpi	r26, 0xD8	; 216
     1dc:	b1 07       	cpc	r27, r17
     1de:	d9 f7       	brne	.-10     	; 0x1d6 <__do_copy_data+0x10>

000001e0 <__do_clear_bss>:
     1e0:	25 e1       	ldi	r18, 0x15	; 21
     1e2:	a8 ed       	ldi	r26, 0xD8	; 216
     1e4:	b2 e0       	ldi	r27, 0x02	; 2
     1e6:	01 c0       	rjmp	.+2      	; 0x1ea <.do_clear_bss_start>

000001e8 <.do_clear_bss_loop>:
     1e8:	1d 92       	st	X+, r1

000001ea <.do_clear_bss_start>:
     1ea:	ae 3d       	cpi	r26, 0xDE	; 222
     1ec:	b2 07       	cpc	r27, r18
     1ee:	e1 f7       	brne	.-8      	; 0x1e8 <.do_clear_bss_loop>
     1f0:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <main>
     1f4:	0c 94 e2 1e 	jmp	0x3dc4	; 0x3dc4 <_exit>

000001f8 <__bad_interrupt>:
     1f8:	03 cf       	rjmp	.-506    	; 0x0 <__vectors>

000001fa <_bt_status_call_back>:
	uint8_t _sreg = SREG;
	cli();
	int16_t _tmp = _z_gyro;
	SREG = _sreg;
	return _tmp;
}
     1fa:	10 92 38 03 	sts	0x0338, r1
     1fe:	e0 91 36 03 	lds	r30, 0x0336
     202:	f0 91 37 03 	lds	r31, 0x0337
     206:	30 97       	sbiw	r30, 0x00	; 0
     208:	09 f0       	breq	.+2      	; 0x20c <_bt_status_call_back+0x12>
     20a:	19 95       	eicall
     20c:	08 95       	ret

0000020e <_bt_call_back>:
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	1f 92       	push	r1
     214:	1f 92       	push	r1
     216:	cd b7       	in	r28, 0x3d	; 61
     218:	de b7       	in	r29, 0x3e	; 62
     21a:	6a 83       	std	Y+2, r22	; 0x02
     21c:	80 91 38 03 	lds	r24, 0x0338
     220:	88 23       	and	r24, r24
     222:	19 f0       	breq	.+6      	; 0x22a <_bt_call_back+0x1c>
     224:	86 2f       	mov	r24, r22
     226:	a0 d4       	rcall	.+2368   	; 0xb68 <dialog_byte_received>
     228:	13 c0       	rjmp	.+38     	; 0x250 <_bt_call_back+0x42>
     22a:	80 91 34 03 	lds	r24, 0x0334
     22e:	90 91 35 03 	lds	r25, 0x0335
     232:	00 97       	sbiw	r24, 0x00	; 0
     234:	69 f0       	breq	.+26     	; 0x250 <_bt_call_back+0x42>
     236:	19 82       	std	Y+1, r1	; 0x01
     238:	20 e0       	ldi	r18, 0x00	; 0
     23a:	ae 01       	movw	r20, r28
     23c:	4f 5f       	subi	r20, 0xFF	; 255
     23e:	5f 4f       	sbci	r21, 0xFF	; 255
     240:	be 01       	movw	r22, r28
     242:	6e 5f       	subi	r22, 0xFE	; 254
     244:	7f 4f       	sbci	r23, 0xFF	; 255
     246:	0e 94 98 0a 	call	0x1530	; 0x1530 <xQueueGenericSendFromISR>
     24a:	89 81       	ldd	r24, Y+1	; 0x01
     24c:	81 11       	cpse	r24, r1
     24e:	c1 d6       	rcall	.+3458   	; 0xfd2 <vPortYield>
     250:	0f 90       	pop	r0
     252:	0f 90       	pop	r0
     254:	df 91       	pop	r29
     256:	cf 91       	pop	r28
     258:	08 95       	ret

0000025a <_mpu9250_read_reg>:
     25a:	df 92       	push	r13
     25c:	ef 92       	push	r14
     25e:	ff 92       	push	r15
     260:	0f 93       	push	r16
     262:	1f 93       	push	r17
     264:	cf 93       	push	r28
     266:	df 93       	push	r29
     268:	cd b7       	in	r28, 0x3d	; 61
     26a:	de b7       	in	r29, 0x3e	; 62
     26c:	d6 2e       	mov	r13, r22
     26e:	ed b6       	in	r14, 0x3d	; 61
     270:	fe b6       	in	r15, 0x3e	; 62
     272:	26 2f       	mov	r18, r22
     274:	30 e0       	ldi	r19, 0x00	; 0
     276:	2f 5f       	subi	r18, 0xFF	; 255
     278:	3f 4f       	sbci	r19, 0xFF	; 255
     27a:	4d b7       	in	r20, 0x3d	; 61
     27c:	5e b7       	in	r21, 0x3e	; 62
     27e:	42 1b       	sub	r20, r18
     280:	53 0b       	sbc	r21, r19
     282:	0f b6       	in	r0, 0x3f	; 63
     284:	f8 94       	cli
     286:	5e bf       	out	0x3e, r21	; 62
     288:	0f be       	out	0x3f, r0	; 63
     28a:	4d bf       	out	0x3d, r20	; 61
     28c:	0d b7       	in	r16, 0x3d	; 61
     28e:	1e b7       	in	r17, 0x3e	; 62
     290:	0f 5f       	subi	r16, 0xFF	; 255
     292:	1f 4f       	sbci	r17, 0xFF	; 255
     294:	98 01       	movw	r18, r16
     296:	80 68       	ori	r24, 0x80	; 128
     298:	ed b7       	in	r30, 0x3d	; 61
     29a:	fe b7       	in	r31, 0x3e	; 62
     29c:	81 83       	std	Z+1, r24	; 0x01
     29e:	66 23       	and	r22, r22
     2a0:	41 f0       	breq	.+16     	; 0x2b2 <_mpu9250_read_reg+0x58>
     2a2:	81 e0       	ldi	r24, 0x01	; 1
     2a4:	f9 01       	movw	r30, r18
     2a6:	e8 0f       	add	r30, r24
     2a8:	f1 1d       	adc	r31, r1
     2aa:	10 82       	st	Z, r1
     2ac:	8f 5f       	subi	r24, 0xFF	; 255
     2ae:	d8 16       	cp	r13, r24
     2b0:	c8 f7       	brcc	.-14     	; 0x2a4 <_mpu9250_read_reg+0x4a>
     2b2:	80 e7       	ldi	r24, 0x70	; 112
     2b4:	93 e0       	ldi	r25, 0x03	; 3
     2b6:	3d d3       	rcall	.+1658   	; 0x932 <buffer_clear>
     2b8:	41 e0       	ldi	r20, 0x01	; 1
     2ba:	4d 0d       	add	r20, r13
     2bc:	b8 01       	movw	r22, r16
     2be:	80 91 9d 03 	lds	r24, 0x039D
     2c2:	90 91 9e 03 	lds	r25, 0x039E
     2c6:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <spi_send_string>
     2ca:	0f b6       	in	r0, 0x3f	; 63
     2cc:	f8 94       	cli
     2ce:	fe be       	out	0x3e, r15	; 62
     2d0:	0f be       	out	0x3f, r0	; 63
     2d2:	ed be       	out	0x3d, r14	; 61
     2d4:	df 91       	pop	r29
     2d6:	cf 91       	pop	r28
     2d8:	1f 91       	pop	r17
     2da:	0f 91       	pop	r16
     2dc:	ff 90       	pop	r15
     2de:	ef 90       	pop	r14
     2e0:	df 90       	pop	r13
     2e2:	08 95       	ret

000002e4 <_send_bytes_to_bt>:
     2e4:	46 2f       	mov	r20, r22
     2e6:	bc 01       	movw	r22, r24
     2e8:	80 91 9b 03 	lds	r24, 0x039B
     2ec:	90 91 9c 03 	lds	r25, 0x039C
     2f0:	0c 94 aa 15 	jmp	0x2b54	; 0x2b54 <serial_send_bytes>
     2f4:	08 95       	ret

000002f6 <_mpu9250_call_back>:
     2f6:	1f 93       	push	r17
     2f8:	cf 93       	push	r28
     2fa:	df 93       	push	r29
     2fc:	00 d0       	rcall	.+0      	; 0x2fe <_mpu9250_call_back+0x8>
     2fe:	1f 92       	push	r1
     300:	cd b7       	in	r28, 0x3d	; 61
     302:	de b7       	in	r29, 0x3e	; 62
     304:	80 91 db 02 	lds	r24, 0x02DB
     308:	82 30       	cpi	r24, 0x02	; 2
     30a:	c1 f1       	breq	.+112    	; 0x37c <_mpu9250_call_back+0x86>
     30c:	28 f4       	brcc	.+10     	; 0x318 <_mpu9250_call_back+0x22>
     30e:	88 23       	and	r24, r24
     310:	51 f0       	breq	.+20     	; 0x326 <_mpu9250_call_back+0x30>
     312:	81 30       	cpi	r24, 0x01	; 1
     314:	c9 f0       	breq	.+50     	; 0x348 <_mpu9250_call_back+0x52>
     316:	f1 c0       	rjmp	.+482    	; 0x4fa <_mpu9250_call_back+0x204>
     318:	83 30       	cpi	r24, 0x03	; 3
     31a:	09 f4       	brne	.+2      	; 0x31e <_mpu9250_call_back+0x28>
     31c:	3f c0       	rjmp	.+126    	; 0x39c <_mpu9250_call_back+0xa6>
     31e:	85 30       	cpi	r24, 0x05	; 5
     320:	09 f4       	brne	.+2      	; 0x324 <_mpu9250_call_back+0x2e>
     322:	94 c0       	rjmp	.+296    	; 0x44c <_mpu9250_call_back+0x156>
     324:	ea c0       	rjmp	.+468    	; 0x4fa <_mpu9250_call_back+0x204>
     326:	81 e0       	ldi	r24, 0x01	; 1
     328:	80 93 db 02 	sts	0x02DB, r24
     32c:	8c e1       	ldi	r24, 0x1C	; 28
     32e:	8b 83       	std	Y+3, r24	; 0x03
     330:	1c 82       	std	Y+4, r1	; 0x04
     332:	42 e0       	ldi	r20, 0x02	; 2
     334:	be 01       	movw	r22, r28
     336:	6d 5f       	subi	r22, 0xFD	; 253
     338:	7f 4f       	sbci	r23, 0xFF	; 255
     33a:	80 91 9d 03 	lds	r24, 0x039D
     33e:	90 91 9e 03 	lds	r25, 0x039E
     342:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <spi_send_string>
     346:	d9 c0       	rjmp	.+434    	; 0x4fa <_mpu9250_call_back+0x204>
     348:	80 e7       	ldi	r24, 0x70	; 112
     34a:	93 e0       	ldi	r25, 0x03	; 3
     34c:	ef d2       	rcall	.+1502   	; 0x92c <buffer_no_of_items>
     34e:	82 30       	cpi	r24, 0x02	; 2
     350:	09 f0       	breq	.+2      	; 0x354 <_mpu9250_call_back+0x5e>
     352:	d3 c0       	rjmp	.+422    	; 0x4fa <_mpu9250_call_back+0x204>
     354:	80 93 db 02 	sts	0x02DB, r24
     358:	80 e7       	ldi	r24, 0x70	; 112
     35a:	93 e0       	ldi	r25, 0x03	; 3
     35c:	ea d2       	rcall	.+1492   	; 0x932 <buffer_clear>
     35e:	8b e1       	ldi	r24, 0x1B	; 27
     360:	8b 83       	std	Y+3, r24	; 0x03
     362:	88 e0       	ldi	r24, 0x08	; 8
     364:	8c 83       	std	Y+4, r24	; 0x04
     366:	42 e0       	ldi	r20, 0x02	; 2
     368:	be 01       	movw	r22, r28
     36a:	6d 5f       	subi	r22, 0xFD	; 253
     36c:	7f 4f       	sbci	r23, 0xFF	; 255
     36e:	80 91 9d 03 	lds	r24, 0x039D
     372:	90 91 9e 03 	lds	r25, 0x039E
     376:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <spi_send_string>
     37a:	bf c0       	rjmp	.+382    	; 0x4fa <_mpu9250_call_back+0x204>
     37c:	80 e7       	ldi	r24, 0x70	; 112
     37e:	93 e0       	ldi	r25, 0x03	; 3
     380:	d5 d2       	rcall	.+1450   	; 0x92c <buffer_no_of_items>
     382:	82 30       	cpi	r24, 0x02	; 2
     384:	09 f0       	breq	.+2      	; 0x388 <_mpu9250_call_back+0x92>
     386:	b9 c0       	rjmp	.+370    	; 0x4fa <_mpu9250_call_back+0x204>
     388:	83 e0       	ldi	r24, 0x03	; 3
     38a:	80 93 db 02 	sts	0x02DB, r24
     38e:	80 e7       	ldi	r24, 0x70	; 112
     390:	93 e0       	ldi	r25, 0x03	; 3
     392:	cf d2       	rcall	.+1438   	; 0x932 <buffer_clear>
     394:	66 e0       	ldi	r22, 0x06	; 6
     396:	8b e3       	ldi	r24, 0x3B	; 59
     398:	60 df       	rcall	.-320    	; 0x25a <_mpu9250_read_reg>
     39a:	af c0       	rjmp	.+350    	; 0x4fa <_mpu9250_call_back+0x204>
     39c:	80 e7       	ldi	r24, 0x70	; 112
     39e:	93 e0       	ldi	r25, 0x03	; 3
     3a0:	c5 d2       	rcall	.+1418   	; 0x92c <buffer_no_of_items>
     3a2:	87 30       	cpi	r24, 0x07	; 7
     3a4:	09 f0       	breq	.+2      	; 0x3a8 <_mpu9250_call_back+0xb2>
     3a6:	a9 c0       	rjmp	.+338    	; 0x4fa <_mpu9250_call_back+0x204>
     3a8:	1f b7       	in	r17, 0x3f	; 63
     3aa:	f8 94       	cli
     3ac:	be 01       	movw	r22, r28
     3ae:	6f 5f       	subi	r22, 0xFF	; 255
     3b0:	7f 4f       	sbci	r23, 0xFF	; 255
     3b2:	80 e7       	ldi	r24, 0x70	; 112
     3b4:	93 e0       	ldi	r25, 0x03	; 3
     3b6:	8a d2       	rcall	.+1300   	; 0x8cc <buffer_get_item>
     3b8:	be 01       	movw	r22, r28
     3ba:	6e 5f       	subi	r22, 0xFE	; 254
     3bc:	7f 4f       	sbci	r23, 0xFF	; 255
     3be:	80 e7       	ldi	r24, 0x70	; 112
     3c0:	93 e0       	ldi	r25, 0x03	; 3
     3c2:	84 d2       	rcall	.+1288   	; 0x8cc <buffer_get_item>
     3c4:	be 01       	movw	r22, r28
     3c6:	6f 5f       	subi	r22, 0xFF	; 255
     3c8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ca:	80 e7       	ldi	r24, 0x70	; 112
     3cc:	93 e0       	ldi	r25, 0x03	; 3
     3ce:	7e d2       	rcall	.+1276   	; 0x8cc <buffer_get_item>
     3d0:	8a 81       	ldd	r24, Y+2	; 0x02
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	98 2f       	mov	r25, r24
     3d6:	88 27       	eor	r24, r24
     3d8:	29 81       	ldd	r18, Y+1	; 0x01
     3da:	82 2b       	or	r24, r18
     3dc:	90 93 44 03 	sts	0x0344, r25
     3e0:	80 93 43 03 	sts	0x0343, r24
     3e4:	be 01       	movw	r22, r28
     3e6:	6e 5f       	subi	r22, 0xFE	; 254
     3e8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ea:	80 e7       	ldi	r24, 0x70	; 112
     3ec:	93 e0       	ldi	r25, 0x03	; 3
     3ee:	6e d2       	rcall	.+1244   	; 0x8cc <buffer_get_item>
     3f0:	be 01       	movw	r22, r28
     3f2:	6f 5f       	subi	r22, 0xFF	; 255
     3f4:	7f 4f       	sbci	r23, 0xFF	; 255
     3f6:	80 e7       	ldi	r24, 0x70	; 112
     3f8:	93 e0       	ldi	r25, 0x03	; 3
     3fa:	68 d2       	rcall	.+1232   	; 0x8cc <buffer_get_item>
     3fc:	8a 81       	ldd	r24, Y+2	; 0x02
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	98 2f       	mov	r25, r24
     402:	88 27       	eor	r24, r24
     404:	29 81       	ldd	r18, Y+1	; 0x01
     406:	82 2b       	or	r24, r18
     408:	90 93 42 03 	sts	0x0342, r25
     40c:	80 93 41 03 	sts	0x0341, r24
     410:	be 01       	movw	r22, r28
     412:	6e 5f       	subi	r22, 0xFE	; 254
     414:	7f 4f       	sbci	r23, 0xFF	; 255
     416:	80 e7       	ldi	r24, 0x70	; 112
     418:	93 e0       	ldi	r25, 0x03	; 3
     41a:	58 d2       	rcall	.+1200   	; 0x8cc <buffer_get_item>
     41c:	be 01       	movw	r22, r28
     41e:	6f 5f       	subi	r22, 0xFF	; 255
     420:	7f 4f       	sbci	r23, 0xFF	; 255
     422:	80 e7       	ldi	r24, 0x70	; 112
     424:	93 e0       	ldi	r25, 0x03	; 3
     426:	52 d2       	rcall	.+1188   	; 0x8cc <buffer_get_item>
     428:	1f bf       	out	0x3f, r17	; 63
     42a:	8a 81       	ldd	r24, Y+2	; 0x02
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	98 2f       	mov	r25, r24
     430:	88 27       	eor	r24, r24
     432:	29 81       	ldd	r18, Y+1	; 0x01
     434:	82 2b       	or	r24, r18
     436:	90 93 40 03 	sts	0x0340, r25
     43a:	80 93 3f 03 	sts	0x033F, r24
     43e:	85 e0       	ldi	r24, 0x05	; 5
     440:	80 93 db 02 	sts	0x02DB, r24
     444:	66 e0       	ldi	r22, 0x06	; 6
     446:	83 e4       	ldi	r24, 0x43	; 67
     448:	08 df       	rcall	.-496    	; 0x25a <_mpu9250_read_reg>
     44a:	57 c0       	rjmp	.+174    	; 0x4fa <_mpu9250_call_back+0x204>
     44c:	80 e7       	ldi	r24, 0x70	; 112
     44e:	93 e0       	ldi	r25, 0x03	; 3
     450:	6d d2       	rcall	.+1242   	; 0x92c <buffer_no_of_items>
     452:	87 30       	cpi	r24, 0x07	; 7
     454:	09 f0       	breq	.+2      	; 0x458 <_mpu9250_call_back+0x162>
     456:	51 c0       	rjmp	.+162    	; 0x4fa <_mpu9250_call_back+0x204>
     458:	1f b7       	in	r17, 0x3f	; 63
     45a:	f8 94       	cli
     45c:	be 01       	movw	r22, r28
     45e:	6f 5f       	subi	r22, 0xFF	; 255
     460:	7f 4f       	sbci	r23, 0xFF	; 255
     462:	80 e7       	ldi	r24, 0x70	; 112
     464:	93 e0       	ldi	r25, 0x03	; 3
     466:	32 d2       	rcall	.+1124   	; 0x8cc <buffer_get_item>
     468:	be 01       	movw	r22, r28
     46a:	6e 5f       	subi	r22, 0xFE	; 254
     46c:	7f 4f       	sbci	r23, 0xFF	; 255
     46e:	80 e7       	ldi	r24, 0x70	; 112
     470:	93 e0       	ldi	r25, 0x03	; 3
     472:	2c d2       	rcall	.+1112   	; 0x8cc <buffer_get_item>
     474:	be 01       	movw	r22, r28
     476:	6f 5f       	subi	r22, 0xFF	; 255
     478:	7f 4f       	sbci	r23, 0xFF	; 255
     47a:	80 e7       	ldi	r24, 0x70	; 112
     47c:	93 e0       	ldi	r25, 0x03	; 3
     47e:	26 d2       	rcall	.+1100   	; 0x8cc <buffer_get_item>
     480:	8a 81       	ldd	r24, Y+2	; 0x02
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	98 2f       	mov	r25, r24
     486:	88 27       	eor	r24, r24
     488:	29 81       	ldd	r18, Y+1	; 0x01
     48a:	82 2b       	or	r24, r18
     48c:	90 93 3e 03 	sts	0x033E, r25
     490:	80 93 3d 03 	sts	0x033D, r24
     494:	be 01       	movw	r22, r28
     496:	6e 5f       	subi	r22, 0xFE	; 254
     498:	7f 4f       	sbci	r23, 0xFF	; 255
     49a:	80 e7       	ldi	r24, 0x70	; 112
     49c:	93 e0       	ldi	r25, 0x03	; 3
     49e:	16 d2       	rcall	.+1068   	; 0x8cc <buffer_get_item>
     4a0:	be 01       	movw	r22, r28
     4a2:	6f 5f       	subi	r22, 0xFF	; 255
     4a4:	7f 4f       	sbci	r23, 0xFF	; 255
     4a6:	80 e7       	ldi	r24, 0x70	; 112
     4a8:	93 e0       	ldi	r25, 0x03	; 3
     4aa:	10 d2       	rcall	.+1056   	; 0x8cc <buffer_get_item>
     4ac:	8a 81       	ldd	r24, Y+2	; 0x02
     4ae:	90 e0       	ldi	r25, 0x00	; 0
     4b0:	98 2f       	mov	r25, r24
     4b2:	88 27       	eor	r24, r24
     4b4:	29 81       	ldd	r18, Y+1	; 0x01
     4b6:	82 2b       	or	r24, r18
     4b8:	90 93 3c 03 	sts	0x033C, r25
     4bc:	80 93 3b 03 	sts	0x033B, r24
     4c0:	be 01       	movw	r22, r28
     4c2:	6e 5f       	subi	r22, 0xFE	; 254
     4c4:	7f 4f       	sbci	r23, 0xFF	; 255
     4c6:	80 e7       	ldi	r24, 0x70	; 112
     4c8:	93 e0       	ldi	r25, 0x03	; 3
     4ca:	00 d2       	rcall	.+1024   	; 0x8cc <buffer_get_item>
     4cc:	be 01       	movw	r22, r28
     4ce:	6f 5f       	subi	r22, 0xFF	; 255
     4d0:	7f 4f       	sbci	r23, 0xFF	; 255
     4d2:	80 e7       	ldi	r24, 0x70	; 112
     4d4:	93 e0       	ldi	r25, 0x03	; 3
     4d6:	fa d1       	rcall	.+1012   	; 0x8cc <buffer_get_item>
     4d8:	1f bf       	out	0x3f, r17	; 63
     4da:	8a 81       	ldd	r24, Y+2	; 0x02
     4dc:	90 e0       	ldi	r25, 0x00	; 0
     4de:	98 2f       	mov	r25, r24
     4e0:	88 27       	eor	r24, r24
     4e2:	29 81       	ldd	r18, Y+1	; 0x01
     4e4:	82 2b       	or	r24, r18
     4e6:	90 93 3a 03 	sts	0x033A, r25
     4ea:	80 93 39 03 	sts	0x0339, r24
     4ee:	83 e0       	ldi	r24, 0x03	; 3
     4f0:	80 93 db 02 	sts	0x02DB, r24
     4f4:	66 e0       	ldi	r22, 0x06	; 6
     4f6:	8b e3       	ldi	r24, 0x3B	; 59
     4f8:	b0 de       	rcall	.-672    	; 0x25a <_mpu9250_read_reg>
     4fa:	0f 90       	pop	r0
     4fc:	0f 90       	pop	r0
     4fe:	0f 90       	pop	r0
     500:	0f 90       	pop	r0
     502:	df 91       	pop	r29
     504:	cf 91       	pop	r28
     506:	1f 91       	pop	r17
     508:	08 95       	ret

0000050a <set_horn>:
     50a:	88 23       	and	r24, r24
     50c:	11 f0       	breq	.+4      	; 0x512 <set_horn+0x8>
     50e:	43 9a       	sbi	0x08, 3	; 8
     510:	08 95       	ret
     512:	43 98       	cbi	0x08, 3	; 8
     514:	08 95       	ret

00000516 <set_head_light>:
     516:	88 23       	and	r24, r24
     518:	11 f0       	breq	.+4      	; 0x51e <set_head_light+0x8>
     51a:	42 9a       	sbi	0x08, 2	; 8
     51c:	08 95       	ret
     51e:	42 98       	cbi	0x08, 2	; 8
     520:	08 95       	ret

00000522 <set_brake_light>:
     522:	88 23       	and	r24, r24
     524:	11 f0       	breq	.+4      	; 0x52a <set_brake_light+0x8>
     526:	41 9a       	sbi	0x08, 1	; 8
     528:	08 95       	ret
     52a:	41 98       	cbi	0x08, 1	; 8
     52c:	08 95       	ret

0000052e <set_motor_speed>:
     52e:	85 36       	cpi	r24, 0x65	; 101
     530:	08 f0       	brcs	.+2      	; 0x534 <set_motor_speed+0x6>
     532:	84 e6       	ldi	r24, 0x64	; 100
     534:	88 23       	and	r24, r24
     536:	a9 f0       	breq	.+42     	; 0x562 <set_motor_speed+0x34>
     538:	28 2f       	mov	r18, r24
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	af e7       	ldi	r26, 0x7F	; 127
     53e:	bc e0       	ldi	r27, 0x0C	; 12
     540:	0e 94 a8 1a 	call	0x3550	; 0x3550 <__umulhisi3>
     544:	24 e6       	ldi	r18, 0x64	; 100
     546:	30 e0       	ldi	r19, 0x00	; 0
     548:	40 e0       	ldi	r20, 0x00	; 0
     54a:	50 e0       	ldi	r21, 0x00	; 0
     54c:	0e 94 86 1a 	call	0x350c	; 0x350c <__divmodsi4>
     550:	30 93 99 00 	sts	0x0099, r19
     554:	20 93 98 00 	sts	0x0098, r18
     558:	30 93 9b 00 	sts	0x009B, r19
     55c:	20 93 9a 00 	sts	0x009A, r18
     560:	08 95       	ret
     562:	10 92 99 00 	sts	0x0099, r1
     566:	10 92 98 00 	sts	0x0098, r1
     56a:	10 92 9b 00 	sts	0x009B, r1
     56e:	10 92 9a 00 	sts	0x009A, r1
     572:	08 95       	ret

00000574 <init_main_board>:
     574:	8f 92       	push	r8
     576:	9f 92       	push	r9
     578:	af 92       	push	r10
     57a:	bf 92       	push	r11
     57c:	cf 92       	push	r12
     57e:	df 92       	push	r13
     580:	ef 92       	push	r14
     582:	0f 93       	push	r16
     584:	1f 93       	push	r17
     586:	3b 9a       	sbi	0x07, 3	; 7
     588:	3a 9a       	sbi	0x07, 2	; 7
     58a:	39 9a       	sbi	0x07, 1	; 7
     58c:	38 9a       	sbi	0x07, 0	; 7
     58e:	e0 e9       	ldi	r30, 0x90	; 144
     590:	f0 e0       	ldi	r31, 0x00	; 0
     592:	80 81       	ld	r24, Z
     594:	82 60       	ori	r24, 0x02	; 2
     596:	80 83       	st	Z, r24
     598:	a1 e9       	ldi	r26, 0x91	; 145
     59a:	b0 e0       	ldi	r27, 0x00	; 0
     59c:	8c 91       	ld	r24, X
     59e:	88 61       	ori	r24, 0x18	; 24
     5a0:	8c 93       	st	X, r24
     5a2:	8f e7       	ldi	r24, 0x7F	; 127
     5a4:	9c e0       	ldi	r25, 0x0C	; 12
     5a6:	90 93 99 00 	sts	0x0099, r25
     5aa:	80 93 98 00 	sts	0x0098, r24
     5ae:	20 81       	ld	r18, Z
     5b0:	20 6c       	ori	r18, 0xC0	; 192
     5b2:	20 83       	st	Z, r18
     5b4:	6b 9a       	sbi	0x0d, 3	; 13
     5b6:	90 93 9b 00 	sts	0x009B, r25
     5ba:	80 93 9a 00 	sts	0x009A, r24
     5be:	20 81       	ld	r18, Z
     5c0:	20 63       	ori	r18, 0x30	; 48
     5c2:	20 83       	st	Z, r18
     5c4:	6c 9a       	sbi	0x0d, 4	; 13
     5c6:	90 93 97 00 	sts	0x0097, r25
     5ca:	80 93 96 00 	sts	0x0096, r24
     5ce:	8c 91       	ld	r24, X
     5d0:	81 60       	ori	r24, 0x01	; 1
     5d2:	8c 93       	st	X, r24
     5d4:	80 e0       	ldi	r24, 0x00	; 0
     5d6:	ab df       	rcall	.-170    	; 0x52e <set_motor_speed>
     5d8:	e1 e8       	ldi	r30, 0x81	; 129
     5da:	f0 e0       	ldi	r31, 0x00	; 0
     5dc:	80 81       	ld	r24, Z
     5de:	86 60       	ori	r24, 0x06	; 6
     5e0:	80 83       	st	Z, r24
     5e2:	6a 98       	cbi	0x0d, 2	; 13
     5e4:	6d 9a       	sbi	0x0d, 5	; 13
     5e6:	75 98       	cbi	0x0e, 5	; 14
     5e8:	08 9a       	sbi	0x01, 0	; 1
     5ea:	10 98       	cbi	0x02, 0	; 2
     5ec:	09 9a       	sbi	0x01, 1	; 1
     5ee:	11 98       	cbi	0x02, 1	; 2
     5f0:	0a 9a       	sbi	0x01, 2	; 1
     5f2:	12 98       	cbi	0x02, 2	; 2
     5f4:	e9 e6       	ldi	r30, 0x69	; 105
     5f6:	f0 e0       	ldi	r31, 0x00	; 0
     5f8:	80 81       	ld	r24, Z
     5fa:	82 60       	ori	r24, 0x02	; 2
     5fc:	80 83       	st	Z, r24
     5fe:	e8 9a       	sbi	0x1d, 0	; 29
     600:	87 e0       	ldi	r24, 0x07	; 7
     602:	93 e0       	ldi	r25, 0x03	; 3
     604:	5e d1       	rcall	.+700    	; 0x8c2 <buffer_init>
     606:	8c ed       	ldi	r24, 0xDC	; 220
     608:	92 e0       	ldi	r25, 0x02	; 2
     60a:	5b d1       	rcall	.+694    	; 0x8c2 <buffer_init>
     60c:	0f 2e       	mov	r0, r31
     60e:	f7 e0       	ldi	r31, 0x07	; 7
     610:	8f 2e       	mov	r8, r31
     612:	f1 e0       	ldi	r31, 0x01	; 1
     614:	9f 2e       	mov	r9, r31
     616:	f0 2d       	mov	r31, r0
     618:	0f 2e       	mov	r0, r31
     61a:	fc ed       	ldi	r31, 0xDC	; 220
     61c:	af 2e       	mov	r10, r31
     61e:	f2 e0       	ldi	r31, 0x02	; 2
     620:	bf 2e       	mov	r11, r31
     622:	f0 2d       	mov	r31, r0
     624:	0f 2e       	mov	r0, r31
     626:	f7 e0       	ldi	r31, 0x07	; 7
     628:	cf 2e       	mov	r12, r31
     62a:	f3 e0       	ldi	r31, 0x03	; 3
     62c:	df 2e       	mov	r13, r31
     62e:	f0 2d       	mov	r31, r0
     630:	e1 2c       	mov	r14, r1
     632:	00 e0       	ldi	r16, 0x00	; 0
     634:	23 e0       	ldi	r18, 0x03	; 3
     636:	40 e8       	ldi	r20, 0x80	; 128
     638:	55 e2       	ldi	r21, 0x25	; 37
     63a:	60 e0       	ldi	r22, 0x00	; 0
     63c:	70 e0       	ldi	r23, 0x00	; 0
     63e:	80 e0       	ldi	r24, 0x00	; 0
     640:	0e 94 33 15 	call	0x2a66	; 0x2a66 <serial_new_instance>
     644:	90 93 9c 03 	sts	0x039C, r25
     648:	80 93 9b 03 	sts	0x039B, r24
     64c:	80 e7       	ldi	r24, 0x70	; 112
     64e:	93 e0       	ldi	r25, 0x03	; 3
     650:	38 d1       	rcall	.+624    	; 0x8c2 <buffer_init>
     652:	85 e4       	ldi	r24, 0x45	; 69
     654:	93 e0       	ldi	r25, 0x03	; 3
     656:	35 d1       	rcall	.+618    	; 0x8c2 <buffer_init>
     658:	8b e7       	ldi	r24, 0x7B	; 123
     65a:	91 e0       	ldi	r25, 0x01	; 1
     65c:	9f 93       	push	r25
     65e:	8f 93       	push	r24
     660:	0f 2e       	mov	r0, r31
     662:	f5 e4       	ldi	r31, 0x45	; 69
     664:	8f 2e       	mov	r8, r31
     666:	f3 e0       	ldi	r31, 0x03	; 3
     668:	9f 2e       	mov	r9, r31
     66a:	f0 2d       	mov	r31, r0
     66c:	0f 2e       	mov	r0, r31
     66e:	f0 e7       	ldi	r31, 0x70	; 112
     670:	af 2e       	mov	r10, r31
     672:	f3 e0       	ldi	r31, 0x03	; 3
     674:	bf 2e       	mov	r11, r31
     676:	f0 2d       	mov	r31, r0
     678:	c1 2c       	mov	r12, r1
     67a:	05 e2       	ldi	r16, 0x25	; 37
     67c:	10 e0       	ldi	r17, 0x00	; 0
     67e:	20 e0       	ldi	r18, 0x00	; 0
     680:	43 e0       	ldi	r20, 0x03	; 3
     682:	63 e0       	ldi	r22, 0x03	; 3
     684:	80 e1       	ldi	r24, 0x10	; 16
     686:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <spi_new_instance>
     68a:	90 93 9e 03 	sts	0x039E, r25
     68e:	80 93 9d 03 	sts	0x039D, r24
     692:	60 e0       	ldi	r22, 0x00	; 0
     694:	80 e0       	ldi	r24, 0x00	; 0
     696:	90 e0       	ldi	r25, 0x00	; 0
     698:	2e de       	rcall	.-932    	; 0x2f6 <_mpu9250_call_back>
     69a:	8b e9       	ldi	r24, 0x9B	; 155
     69c:	80 93 b3 00 	sts	0x00B3, r24
     6a0:	e1 eb       	ldi	r30, 0xB1	; 177
     6a2:	f0 e0       	ldi	r31, 0x00	; 0
     6a4:	80 81       	ld	r24, Z
     6a6:	82 60       	ori	r24, 0x02	; 2
     6a8:	80 83       	st	Z, r24
     6aa:	a0 e7       	ldi	r26, 0x70	; 112
     6ac:	b0 e0       	ldi	r27, 0x00	; 0
     6ae:	8c 91       	ld	r24, X
     6b0:	82 60       	ori	r24, 0x02	; 2
     6b2:	8c 93       	st	X, r24
     6b4:	80 81       	ld	r24, Z
     6b6:	85 60       	ori	r24, 0x05	; 5
     6b8:	80 83       	st	Z, r24
     6ba:	0f 90       	pop	r0
     6bc:	0f 90       	pop	r0
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	ef 90       	pop	r14
     6c4:	df 90       	pop	r13
     6c6:	cf 90       	pop	r12
     6c8:	bf 90       	pop	r11
     6ca:	af 90       	pop	r10
     6cc:	9f 90       	pop	r9
     6ce:	8f 90       	pop	r8
     6d0:	08 95       	ret

000006d2 <set_brake>:
     6d2:	85 36       	cpi	r24, 0x65	; 101
     6d4:	08 f0       	brcs	.+2      	; 0x6d8 <set_brake+0x6>
     6d6:	84 e6       	ldi	r24, 0x64	; 100
     6d8:	88 23       	and	r24, r24
     6da:	a9 f0       	breq	.+42     	; 0x706 <set_brake+0x34>
     6dc:	28 2f       	mov	r18, r24
     6de:	30 e0       	ldi	r19, 0x00	; 0
     6e0:	af e7       	ldi	r26, 0x7F	; 127
     6e2:	bc e0       	ldi	r27, 0x0C	; 12
     6e4:	0e 94 a8 1a 	call	0x3550	; 0x3550 <__umulhisi3>
     6e8:	24 e6       	ldi	r18, 0x64	; 100
     6ea:	30 e0       	ldi	r19, 0x00	; 0
     6ec:	40 e0       	ldi	r20, 0x00	; 0
     6ee:	50 e0       	ldi	r21, 0x00	; 0
     6f0:	0e 94 86 1a 	call	0x350c	; 0x350c <__divmodsi4>
     6f4:	30 93 99 00 	sts	0x0099, r19
     6f8:	20 93 98 00 	sts	0x0098, r18
     6fc:	10 92 9b 00 	sts	0x009B, r1
     700:	10 92 9a 00 	sts	0x009A, r1
     704:	08 95       	ret
     706:	10 92 99 00 	sts	0x0099, r1
     70a:	10 92 98 00 	sts	0x0098, r1
     70e:	10 92 9b 00 	sts	0x009B, r1
     712:	10 92 9a 00 	sts	0x009A, r1
     716:	08 95       	ret

00000718 <get_raw_x_accel>:
     718:	2f b7       	in	r18, 0x3f	; 63
     71a:	f8 94       	cli
     71c:	80 91 43 03 	lds	r24, 0x0343
     720:	90 91 44 03 	lds	r25, 0x0344
     724:	2f bf       	out	0x3f, r18	; 63
     726:	08 95       	ret

00000728 <get_raw_y_accel>:
     728:	2f b7       	in	r18, 0x3f	; 63
     72a:	f8 94       	cli
     72c:	80 91 41 03 	lds	r24, 0x0341
     730:	90 91 42 03 	lds	r25, 0x0342
     734:	2f bf       	out	0x3f, r18	; 63
     736:	08 95       	ret

00000738 <get_raw_z_accel>:
     738:	2f b7       	in	r18, 0x3f	; 63
     73a:	f8 94       	cli
     73c:	80 91 3f 03 	lds	r24, 0x033F
     740:	90 91 40 03 	lds	r25, 0x0340
     744:	2f bf       	out	0x3f, r18	; 63
     746:	08 95       	ret

00000748 <get_raw_x_rotation>:
     748:	2f b7       	in	r18, 0x3f	; 63
     74a:	f8 94       	cli
     74c:	80 91 3d 03 	lds	r24, 0x033D
     750:	90 91 3e 03 	lds	r25, 0x033E
     754:	2f bf       	out	0x3f, r18	; 63
     756:	08 95       	ret

00000758 <get_raw_y_rotation>:
     758:	2f b7       	in	r18, 0x3f	; 63
     75a:	f8 94       	cli
     75c:	80 91 3b 03 	lds	r24, 0x033B
     760:	90 91 3c 03 	lds	r25, 0x033C
     764:	2f bf       	out	0x3f, r18	; 63
     766:	08 95       	ret

00000768 <get_tacho_count>:

// ----------------------------------------------------------------------------------------------------------------------
uint16_t get_tacho_count() {
	static uint16_t _last_reading = 0;
	
	uint16_t _tmp = TACHO_TCNT_reg;
     768:	20 91 84 00 	lds	r18, 0x0084
     76c:	30 91 85 00 	lds	r19, 0x0085
	uint16_t _tmp_last = _tmp;
	
	if (_tmp < _last_reading) {
     770:	80 91 d9 02 	lds	r24, 0x02D9
     774:	90 91 da 02 	lds	r25, 0x02DA
     778:	28 17       	cp	r18, r24
     77a:	39 07       	cpc	r19, r25
     77c:	30 f4       	brcc	.+12     	; 0x78a <get_tacho_count+0x22>
		_tmp = (UINT16_MAX - _last_reading + _tmp);
     77e:	a9 01       	movw	r20, r18
     780:	48 1b       	sub	r20, r24
     782:	59 0b       	sbc	r21, r25
     784:	ca 01       	movw	r24, r20
     786:	01 97       	sbiw	r24, 0x01	; 1
     788:	04 c0       	rjmp	.+8      	; 0x792 <get_tacho_count+0x2a>
		} else {
		_tmp = _tmp-_last_reading;
     78a:	a9 01       	movw	r20, r18
     78c:	48 1b       	sub	r20, r24
     78e:	59 0b       	sbc	r21, r25
     790:	ca 01       	movw	r24, r20
	}
	_last_reading = _tmp_last;
     792:	30 93 da 02 	sts	0x02DA, r19
     796:	20 93 d9 02 	sts	0x02D9, r18
	
	return _tmp;
}
     79a:	08 95       	ret

0000079c <set_bt_reset>:

// ----------------------------------------------------------------------------------------------------------------------
void set_bt_reset(uint8_t state) {
	if (state) {
     79c:	88 23       	and	r24, r24
     79e:	11 f0       	breq	.+4      	; 0x7a4 <set_bt_reset+0x8>
		BT_RESET_PORT &= ~_BV(BT_RESET_PIN); // Set RESET low/active
     7a0:	10 98       	cbi	0x02, 0	; 2
     7a2:	08 95       	ret
		} else {
		BT_RESET_PORT |= _BV(BT_RESET_PIN); // Set RESET high/in-active
     7a4:	10 9a       	sbi	0x02, 0	; 2
     7a6:	08 95       	ret

000007a8 <bt_send_bytes>:
static void _send_bytes_to_bt(uint8_t *bytes, uint8_t len) {
	serial_send_bytes(_bt_serial_instance, bytes, len);
}

// ----------------------------------------------------------------------------------------------------------------------
uint8_t bt_send_bytes(uint8_t *bytes, uint8_t len) {
     7a8:	46 2f       	mov	r20, r22
	return serial_send_bytes(_bt_serial_instance, bytes, len);
     7aa:	bc 01       	movw	r22, r24
     7ac:	80 91 9b 03 	lds	r24, 0x039B
     7b0:	90 91 9c 03 	lds	r25, 0x039C
     7b4:	0c 94 aa 15 	jmp	0x2b54	; 0x2b54 <serial_send_bytes>
}
     7b8:	08 95       	ret

000007ba <init_bt_module>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void init_bt_module(void (*bt_status_call_back)(uint8_t result), QueueHandle_t RX_Que) {
	_xRxedCharsQ = RX_Que;
     7ba:	70 93 35 03 	sts	0x0335, r23
     7be:	60 93 34 03 	sts	0x0334, r22
	_app_bt_status_call_back = bt_status_call_back;
     7c2:	90 93 37 03 	sts	0x0337, r25
     7c6:	80 93 36 03 	sts	0x0336, r24
	_bt_dialog_active = 1;
     7ca:	81 e0       	ldi	r24, 0x01	; 1
     7cc:	80 93 38 03 	sts	0x0338, r24
	dialog_start(_dialog_bt_init_seq, _send_bytes_to_bt, _bt_status_call_back);
     7d0:	4d ef       	ldi	r20, 0xFD	; 253
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	62 e7       	ldi	r22, 0x72	; 114
     7d6:	71 e0       	ldi	r23, 0x01	; 1
     7d8:	87 e0       	ldi	r24, 0x07	; 7
     7da:	92 e0       	ldi	r25, 0x02	; 2
     7dc:	9d c1       	rjmp	.+826    	; 0xb18 <dialog_start>
     7de:	08 95       	ret

000007e0 <set_goal_line_semaphore>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void set_goal_line_semaphore(SemaphoreHandle_t goal_line_semaphore) {
	if (goal_line_semaphore) {
     7e0:	00 97       	sbiw	r24, 0x00	; 0
     7e2:	21 f0       	breq	.+8      	; 0x7ec <set_goal_line_semaphore+0xc>
		_goal_line_semaphore = goal_line_semaphore;
     7e4:	90 93 33 03 	sts	0x0333, r25
     7e8:	80 93 32 03 	sts	0x0332, r24
     7ec:	08 95       	ret

000007ee <__vector_1>:
	}
}

ISR(INT0_vect) {
     7ee:	1f 92       	push	r1
     7f0:	0f 92       	push	r0
     7f2:	0f b6       	in	r0, 0x3f	; 63
     7f4:	0f 92       	push	r0
     7f6:	11 24       	eor	r1, r1
     7f8:	0b b6       	in	r0, 0x3b	; 59
     7fa:	0f 92       	push	r0
     7fc:	2f 93       	push	r18
     7fe:	3f 93       	push	r19
     800:	4f 93       	push	r20
     802:	5f 93       	push	r21
     804:	6f 93       	push	r22
     806:	7f 93       	push	r23
     808:	8f 93       	push	r24
     80a:	9f 93       	push	r25
     80c:	af 93       	push	r26
     80e:	bf 93       	push	r27
     810:	ef 93       	push	r30
     812:	ff 93       	push	r31
	static signed portBASE_TYPE _higher_priority_task_woken;
	if (_goal_line_semaphore) {
     814:	80 91 32 03 	lds	r24, 0x0332
     818:	90 91 33 03 	lds	r25, 0x0333
     81c:	00 97       	sbiw	r24, 0x00	; 0
     81e:	49 f0       	breq	.+18     	; 0x832 <__vector_1+0x44>
		_higher_priority_task_woken = pdFALSE;
     820:	10 92 d8 02 	sts	0x02D8, r1

		xSemaphoreGiveFromISR(_goal_line_semaphore, &_higher_priority_task_woken);
     824:	68 ed       	ldi	r22, 0xD8	; 216
     826:	72 e0       	ldi	r23, 0x02	; 2
     828:	b5 d6       	rcall	.+3434   	; 0x1594 <xQueueGiveFromISR>
		
		if (_higher_priority_task_woken != pdFALSE) {
     82a:	80 91 d8 02 	lds	r24, 0x02D8
     82e:	81 11       	cpse	r24, r1
			portYIELD();
     830:	d0 d3       	rcall	.+1952   	; 0xfd2 <vPortYield>
		}
	}
}
     832:	ff 91       	pop	r31
     834:	ef 91       	pop	r30
     836:	bf 91       	pop	r27
     838:	af 91       	pop	r26
     83a:	9f 91       	pop	r25
     83c:	8f 91       	pop	r24
     83e:	7f 91       	pop	r23
     840:	6f 91       	pop	r22
     842:	5f 91       	pop	r21
     844:	4f 91       	pop	r20
     846:	3f 91       	pop	r19
     848:	2f 91       	pop	r18
     84a:	0f 90       	pop	r0
     84c:	0b be       	out	0x3b, r0	; 59
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
     852:	0f 90       	pop	r0
     854:	1f 90       	pop	r1
     856:	18 95       	reti

00000858 <__vector_13>:
	#elif ((DIALOG_HANDLER_PRESCALER == 1024))
	DIALOG_HANDLER_TCCRB_reg |= _BV(DIALOG_HANDLER_CS0_bit) | _BV(DIALOG_HANDLER_CS2_bit); ;    // Prescaler 1024 and Start Timer
	#endif
}

ISR(TIMER2_COMPA_vect) {
     858:	1f 92       	push	r1
     85a:	0f 92       	push	r0
     85c:	0f b6       	in	r0, 0x3f	; 63
     85e:	0f 92       	push	r0
     860:	11 24       	eor	r1, r1
     862:	0b b6       	in	r0, 0x3b	; 59
     864:	0f 92       	push	r0
     866:	2f 93       	push	r18
     868:	3f 93       	push	r19
     86a:	4f 93       	push	r20
     86c:	5f 93       	push	r21
     86e:	6f 93       	push	r22
     870:	7f 93       	push	r23
     872:	8f 93       	push	r24
     874:	9f 93       	push	r25
     876:	af 93       	push	r26
     878:	bf 93       	push	r27
     87a:	ef 93       	push	r30
     87c:	ff 93       	push	r31
	static uint8_t _count = 10;
	if (_bt_dialog_active) {
     87e:	80 91 38 03 	lds	r24, 0x0338
     882:	88 23       	and	r24, r24
     884:	59 f0       	breq	.+22     	; 0x89c <__vector_13+0x44>
		if (--_count == 0) {
     886:	80 91 06 02 	lds	r24, 0x0206
     88a:	81 50       	subi	r24, 0x01	; 1
     88c:	19 f0       	breq	.+6      	; 0x894 <__vector_13+0x3c>
     88e:	80 93 06 02 	sts	0x0206, r24
     892:	04 c0       	rjmp	.+8      	; 0x89c <__vector_13+0x44>
			_count = 10;
     894:	8a e0       	ldi	r24, 0x0A	; 10
     896:	80 93 06 02 	sts	0x0206, r24
			dialog_tick();
     89a:	4f d1       	rcall	.+670    	; 0xb3a <dialog_tick>
		}
	}
}
     89c:	ff 91       	pop	r31
     89e:	ef 91       	pop	r30
     8a0:	bf 91       	pop	r27
     8a2:	af 91       	pop	r26
     8a4:	9f 91       	pop	r25
     8a6:	8f 91       	pop	r24
     8a8:	7f 91       	pop	r23
     8aa:	6f 91       	pop	r22
     8ac:	5f 91       	pop	r21
     8ae:	4f 91       	pop	r20
     8b0:	3f 91       	pop	r19
     8b2:	2f 91       	pop	r18
     8b4:	0f 90       	pop	r0
     8b6:	0b be       	out	0x3b, r0	; 59
     8b8:	0f 90       	pop	r0
     8ba:	0f be       	out	0x3f, r0	; 63
     8bc:	0f 90       	pop	r0
     8be:	1f 90       	pop	r1
     8c0:	18 95       	reti

000008c2 <buffer_init>:
 @return true if buffer is empty.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_is_empty(buffer_struct_t *buffer) {
	return (buffer->no_in_buffer == 0);
}
     8c2:	fc 01       	movw	r30, r24
     8c4:	10 a6       	std	Z+40, r1	; 0x28
     8c6:	11 a6       	std	Z+41, r1	; 0x29
     8c8:	12 a6       	std	Z+42, r1	; 0x2a
     8ca:	08 95       	ret

000008cc <buffer_get_item>:
     8cc:	fc 01       	movw	r30, r24
     8ce:	82 a5       	ldd	r24, Z+42	; 0x2a
     8d0:	88 23       	and	r24, r24
     8d2:	a1 f0       	breq	.+40     	; 0x8fc <buffer_get_item+0x30>
     8d4:	81 a5       	ldd	r24, Z+41	; 0x29
     8d6:	df 01       	movw	r26, r30
     8d8:	a8 0f       	add	r26, r24
     8da:	b1 1d       	adc	r27, r1
     8dc:	8c 91       	ld	r24, X
     8de:	db 01       	movw	r26, r22
     8e0:	8c 93       	st	X, r24
     8e2:	81 a5       	ldd	r24, Z+41	; 0x29
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	01 96       	adiw	r24, 0x01	; 1
     8e8:	68 e2       	ldi	r22, 0x28	; 40
     8ea:	70 e0       	ldi	r23, 0x00	; 0
     8ec:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <__divmodhi4>
     8f0:	81 a7       	std	Z+41, r24	; 0x29
     8f2:	82 a5       	ldd	r24, Z+42	; 0x2a
     8f4:	81 50       	subi	r24, 0x01	; 1
     8f6:	82 a7       	std	Z+42, r24	; 0x2a
     8f8:	80 e0       	ldi	r24, 0x00	; 0
     8fa:	08 95       	ret
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	08 95       	ret

00000900 <buffer_put_item>:
     900:	fc 01       	movw	r30, r24
     902:	22 a5       	ldd	r18, Z+42	; 0x2a
     904:	28 32       	cpi	r18, 0x28	; 40
     906:	80 f4       	brcc	.+32     	; 0x928 <buffer_put_item+0x28>
     908:	80 a5       	ldd	r24, Z+40	; 0x28
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	df 01       	movw	r26, r30
     90e:	a8 0f       	add	r26, r24
     910:	b9 1f       	adc	r27, r25
     912:	6c 93       	st	X, r22
     914:	01 96       	adiw	r24, 0x01	; 1
     916:	68 e2       	ldi	r22, 0x28	; 40
     918:	70 e0       	ldi	r23, 0x00	; 0
     91a:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <__divmodhi4>
     91e:	80 a7       	std	Z+40, r24	; 0x28
     920:	2f 5f       	subi	r18, 0xFF	; 255
     922:	22 a7       	std	Z+42, r18	; 0x2a
     924:	80 e0       	ldi	r24, 0x00	; 0
     926:	08 95       	ret
     928:	82 e0       	ldi	r24, 0x02	; 2
     92a:	08 95       	ret

0000092c <buffer_no_of_items>:
 @return no of items in the buffer.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_no_of_items(buffer_struct_t *buffer) {
	return buffer->no_in_buffer;
}
     92c:	fc 01       	movw	r30, r24
     92e:	82 a5       	ldd	r24, Z+42	; 0x2a
     930:	08 95       	ret

00000932 <buffer_clear>:
 @ingroup buffer_function
 @brief Clear the content of the buffer.

 @param *buffer pointer to the buffer structure.
 **********************************************************************/
void buffer_clear(buffer_struct_t *buffer) {
     932:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     934:	10 a6       	std	Z+40, r1	; 0x28
	buffer->out_i = 0;
     936:	11 a6       	std	Z+41, r1	; 0x29
	buffer->no_in_buffer = 0;
     938:	12 a6       	std	Z+42, r1	; 0x2a
     93a:	08 95       	ret

0000093c <_dialog_prepare_for_next_byte>:

 When the function returns it has setup the state variable _dialog_await_state that will be used in dialog_char_received(), and the needed argument counters etc.
 */
static void _dialog_prepare_for_next_byte() {
  // esc char?
  if (*(_dialog_format.response_p) == '%') {
     93c:	e0 91 ac 03 	lds	r30, 0x03AC
     940:	f0 91 ad 03 	lds	r31, 0x03AD
     944:	80 81       	ld	r24, Z
     946:	85 32       	cpi	r24, 0x25	; 37
     948:	09 f0       	breq	.+2      	; 0x94c <_dialog_prepare_for_next_byte+0x10>
     94a:	85 c0       	rjmp	.+266    	; 0xa56 <_dialog_prepare_for_next_byte+0x11a>
    _dialog_format.response_p++;
     94c:	cf 01       	movw	r24, r30
     94e:	01 96       	adiw	r24, 0x01	; 1
     950:	90 93 ad 03 	sts	0x03AD, r25
     954:	80 93 ac 03 	sts	0x03AC, r24

    if (*(_dialog_format.response_p) == '%') {
     958:	81 81       	ldd	r24, Z+1	; 0x01
     95a:	85 32       	cpi	r24, 0x25	; 37
     95c:	19 f4       	brne	.+6      	; 0x964 <_dialog_prepare_for_next_byte+0x28>
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
     95e:	10 92 a3 03 	sts	0x03A3, r1
     962:	08 95       	ret
    } else if (*_dialog_format.response_p == '*') {
     964:	8a 32       	cpi	r24, 0x2A	; 42
     966:	e1 f5       	brne	.+120    	; 0x9e0 <_dialog_prepare_for_next_byte+0xa4>
      // Max args: %*nnB
      _dialog_format.response_p++;
     968:	cf 01       	movw	r24, r30
     96a:	02 96       	adiw	r24, 0x02	; 2
     96c:	90 93 ad 03 	sts	0x03AD, r25
     970:	80 93 ac 03 	sts	0x03AC, r24
     974:	33 96       	adiw	r30, 0x03	; 3
     976:	20 e0       	ldi	r18, 0x00	; 0
     978:	dc 01       	movw	r26, r24
     97a:	01 96       	adiw	r24, 0x01	; 1
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     97c:	22 0f       	add	r18, r18
     97e:	32 2f       	mov	r19, r18
     980:	33 0f       	add	r19, r19
     982:	33 0f       	add	r19, r19
     984:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     986:	20 53       	subi	r18, 0x30	; 48
     988:	3c 91       	ld	r19, X
     98a:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     98c:	31 91       	ld	r19, Z+
     98e:	32 34       	cpi	r19, 0x42	; 66
     990:	99 f7       	brne	.-26     	; 0x978 <_dialog_prepare_for_next_byte+0x3c>
     992:	20 93 ae 03 	sts	0x03AE, r18
      _dialog_format.response_p++;
     996:	12 96       	adiw	r26, 0x02	; 2
     998:	b0 93 ad 03 	sts	0x03AD, r27
     99c:	a0 93 ac 03 	sts	0x03AC, r26
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     9a0:	80 91 b0 03 	lds	r24, 0x03B0
     9a4:	90 91 b1 03 	lds	r25, 0x03B1
     9a8:	00 97       	sbiw	r24, 0x00	; 0
     9aa:	b1 f0       	breq	.+44     	; 0x9d8 <_dialog_prepare_for_next_byte+0x9c>
        _dialog_format.arg_index++;
     9ac:	ef ea       	ldi	r30, 0xAF	; 175
     9ae:	f3 e0       	ldi	r31, 0x03	; 3
     9b0:	20 81       	ld	r18, Z
     9b2:	2f 5f       	subi	r18, 0xFF	; 255
     9b4:	20 83       	st	Z, r18
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     9b6:	33 27       	eor	r19, r19
     9b8:	27 fd       	sbrc	r18, 7
     9ba:	30 95       	com	r19
     9bc:	f9 01       	movw	r30, r18
     9be:	ee 0f       	add	r30, r30
     9c0:	ff 1f       	adc	r31, r31
     9c2:	e2 0f       	add	r30, r18
     9c4:	f3 1f       	adc	r31, r19
     9c6:	e8 0f       	add	r30, r24
     9c8:	f9 1f       	adc	r31, r25
     9ca:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     9cc:	80 81       	ld	r24, Z
     9ce:	91 81       	ldd	r25, Z+1	; 0x01
     9d0:	90 93 b3 03 	sts	0x03B3, r25
     9d4:	80 93 b2 03 	sts	0x03B2, r24
      }
      _dialog_await_state = ARG_MAX_STATE;
     9d8:	82 e0       	ldi	r24, 0x02	; 2
     9da:	80 93 a3 03 	sts	0x03A3, r24
     9de:	08 95       	ret
     9e0:	80 91 ac 03 	lds	r24, 0x03AC
     9e4:	90 91 ad 03 	lds	r25, 0x03AD
     9e8:	dc 01       	movw	r26, r24
     9ea:	11 96       	adiw	r26, 0x01	; 1
    _dialog_format.response_p++;

    if (*(_dialog_format.response_p) == '%') {
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
    } else if (*_dialog_format.response_p == '*') {
     9ec:	20 e0       	ldi	r18, 0x00	; 0
     9ee:	fc 01       	movw	r30, r24
     9f0:	01 96       	adiw	r24, 0x01	; 1
    } else {
      // args: %nnB
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     9f2:	22 0f       	add	r18, r18
     9f4:	32 2f       	mov	r19, r18
     9f6:	33 0f       	add	r19, r19
     9f8:	33 0f       	add	r19, r19
     9fa:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     9fc:	20 53       	subi	r18, 0x30	; 48
     9fe:	30 81       	ld	r19, Z
     a00:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     a02:	3d 91       	ld	r19, X+
     a04:	32 34       	cpi	r19, 0x42	; 66
     a06:	99 f7       	brne	.-26     	; 0x9ee <_dialog_prepare_for_next_byte+0xb2>
     a08:	20 93 ae 03 	sts	0x03AE, r18
      _dialog_format.response_p++;
     a0c:	32 96       	adiw	r30, 0x02	; 2
     a0e:	f0 93 ad 03 	sts	0x03AD, r31
     a12:	e0 93 ac 03 	sts	0x03AC, r30
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     a16:	80 91 b0 03 	lds	r24, 0x03B0
     a1a:	90 91 b1 03 	lds	r25, 0x03B1
     a1e:	00 97       	sbiw	r24, 0x00	; 0
     a20:	b1 f0       	breq	.+44     	; 0xa4e <_dialog_prepare_for_next_byte+0x112>
        _dialog_format.arg_index++;
     a22:	af ea       	ldi	r26, 0xAF	; 175
     a24:	b3 e0       	ldi	r27, 0x03	; 3
     a26:	ec 91       	ld	r30, X
     a28:	ef 5f       	subi	r30, 0xFF	; 255
     a2a:	ec 93       	st	X, r30
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     a2c:	ff 27       	eor	r31, r31
     a2e:	e7 fd       	sbrc	r30, 7
     a30:	f0 95       	com	r31
     a32:	9f 01       	movw	r18, r30
     a34:	22 0f       	add	r18, r18
     a36:	33 1f       	adc	r19, r19
     a38:	e2 0f       	add	r30, r18
     a3a:	f3 1f       	adc	r31, r19
     a3c:	e8 0f       	add	r30, r24
     a3e:	f9 1f       	adc	r31, r25
     a40:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     a42:	80 81       	ld	r24, Z
     a44:	91 81       	ldd	r25, Z+1	; 0x01
     a46:	90 93 b3 03 	sts	0x03B3, r25
     a4a:	80 93 b2 03 	sts	0x03B2, r24
      }
      _dialog_await_state = ARG_STATE;
     a4e:	81 e0       	ldi	r24, 0x01	; 1
     a50:	80 93 a3 03 	sts	0x03A3, r24
     a54:	08 95       	ret
    }
  } else {
    _dialog_await_state = NORMAL_STATE;
     a56:	10 92 a3 03 	sts	0x03A3, r1
     a5a:	08 95       	ret

00000a5c <_dialog_goto_state>:
 IF the new state is either DIALOG_OK_STOP or DIALOG_ERROR_STOP then the call_back function will be called.
 ELSE the new State will be setup.

 @param[in] new_state the new state to goto.
 */
static void _dialog_goto_state(const uint8_t new_state) {
     a5c:	cf 93       	push	r28
     a5e:	df 93       	push	r29
  _dialog_second_counter = 0;
     a60:	10 92 a7 03 	sts	0x03A7, r1
  _dialog_current_state = new_state;
     a64:	80 93 a6 03 	sts	0x03A6, r24
  if (new_state == DIALOG_ERROR_STOP || new_state == DIALOG_OK_STOP) {
     a68:	92 e0       	ldi	r25, 0x02	; 2
     a6a:	98 0f       	add	r25, r24
     a6c:	92 30       	cpi	r25, 0x02	; 2
     a6e:	30 f4       	brcc	.+12     	; 0xa7c <_dialog_goto_state+0x20>
    (*_dialog_pf_call_back)(new_state);
     a70:	e0 91 9f 03 	lds	r30, 0x039F
     a74:	f0 91 a0 03 	lds	r31, 0x03A0
     a78:	19 95       	eicall
     a7a:	4b c0       	rjmp	.+150    	; 0xb12 <_dialog_goto_state+0xb6>
  } else {
    // Send command if any
    if (_dialog_seq[new_state].command_length != 0) {
     a7c:	9b e0       	ldi	r25, 0x0B	; 11
     a7e:	89 9f       	mul	r24, r25
     a80:	e0 01       	movw	r28, r0
     a82:	11 24       	eor	r1, r1
     a84:	a0 91 a4 03 	lds	r26, 0x03A4
     a88:	b0 91 a5 03 	lds	r27, 0x03A5
     a8c:	ac 0f       	add	r26, r28
     a8e:	bd 1f       	adc	r27, r29
     a90:	12 96       	adiw	r26, 0x02	; 2
     a92:	6c 91       	ld	r22, X
     a94:	12 97       	sbiw	r26, 0x02	; 2
     a96:	66 23       	and	r22, r22
     a98:	39 f0       	breq	.+14     	; 0xaa8 <_dialog_goto_state+0x4c>
      (*_dialog_pf_send)(_dialog_seq[new_state].command,
     a9a:	e0 91 a1 03 	lds	r30, 0x03A1
     a9e:	f0 91 a2 03 	lds	r31, 0x03A2
     aa2:	8d 91       	ld	r24, X+
     aa4:	9c 91       	ld	r25, X
     aa6:	19 95       	eicall
      _dialog_seq[new_state].command_length);
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
     aa8:	80 91 a4 03 	lds	r24, 0x03A4
     aac:	90 91 a5 03 	lds	r25, 0x03A5
     ab0:	c8 0f       	add	r28, r24
     ab2:	d9 1f       	adc	r29, r25
     ab4:	2d 81       	ldd	r18, Y+5	; 0x05
     ab6:	22 23       	and	r18, r18
     ab8:	51 f1       	breq	.+84     	; 0xb0e <_dialog_goto_state+0xb2>
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
                  _dialog_seq[new_state].responce_format;
     aba:	8b 81       	ldd	r24, Y+3	; 0x03
     abc:	9c 81       	ldd	r25, Y+4	; 0x04
 @param[in] response_format to be waited for..
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
     abe:	90 93 a9 03 	sts	0x03A9, r25
     ac2:	80 93 a8 03 	sts	0x03A8, r24
     ac6:	90 93 ad 03 	sts	0x03AD, r25
     aca:	80 93 ac 03 	sts	0x03AC, r24
                  _dialog_seq[new_state].responce_format;
  _dialog_format.arg_buffers = _dialog_seq[new_state].arg_buffers;
     ace:	e9 85       	ldd	r30, Y+9	; 0x09
     ad0:	fa 85       	ldd	r31, Y+10	; 0x0a
     ad2:	f0 93 b1 03 	sts	0x03B1, r31
     ad6:	e0 93 b0 03 	sts	0x03B0, r30
  _dialog_format.arg_index = -1;
     ada:	3f ef       	ldi	r19, 0xFF	; 255
     adc:	30 93 af 03 	sts	0x03AF, r19
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
     ae0:	30 97       	sbiw	r30, 0x00	; 0
     ae2:	31 f0       	breq	.+12     	; 0xaf0 <_dialog_goto_state+0x94>
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
     ae4:	40 81       	ld	r20, Z
     ae6:	51 81       	ldd	r21, Z+1	; 0x01
     ae8:	50 93 b3 03 	sts	0x03B3, r21
     aec:	40 93 b2 03 	sts	0x03B2, r20
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
                  + _dialog_seq[new_state].responce_format_length - 1;
     af0:	30 e0       	ldi	r19, 0x00	; 0
     af2:	21 50       	subi	r18, 0x01	; 1
     af4:	31 09       	sbc	r19, r1
     af6:	82 0f       	add	r24, r18
     af8:	93 1f       	adc	r25, r19
  _dialog_format.arg_index = -1;
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
     afa:	90 93 ab 03 	sts	0x03AB, r25
     afe:	80 93 aa 03 	sts	0x03AA, r24
                  + _dialog_seq[new_state].responce_format_length - 1;
  _dialog_prepare_for_next_byte();
     b02:	1c df       	rcall	.-456    	; 0x93c <_dialog_prepare_for_next_byte>
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
      _dialog_await(new_state);
      _dialog_second_counter = _dialog_seq[new_state].max_response_time
     b04:	8e 81       	ldd	r24, Y+6	; 0x06
     b06:	8f 5f       	subi	r24, 0xFF	; 255
     b08:	80 93 a7 03 	sts	0x03A7, r24
     b0c:	02 c0       	rjmp	.+4      	; 0xb12 <_dialog_goto_state+0xb6>
                      + 1; // add one because of 1 sec jitter in second timer
    } else {
      _dialog_goto_state(_dialog_seq[new_state].ok_state);
     b0e:	8f 81       	ldd	r24, Y+7	; 0x07
     b10:	a5 df       	rcall	.-182    	; 0xa5c <_dialog_goto_state>
    }
  }
}
     b12:	df 91       	pop	r29
     b14:	cf 91       	pop	r28
     b16:	08 95       	ret

00000b18 <dialog_start>:
 @endcode
 */
void dialog_start(dialog_seq_t *p_seq,
		void (*pf_send)(uint8_t *command, uint8_t command_length),
		void (*pf_call_back)(uint8_t result)) {
  _dialog_seq = p_seq;
     b18:	90 93 a5 03 	sts	0x03A5, r25
     b1c:	80 93 a4 03 	sts	0x03A4, r24
  _dialog_pf_send = pf_send;
     b20:	70 93 a2 03 	sts	0x03A2, r23
     b24:	60 93 a1 03 	sts	0x03A1, r22
  _dialog_pf_call_back = pf_call_back;
     b28:	50 93 a0 03 	sts	0x03A0, r21
     b2c:	40 93 9f 03 	sts	0x039F, r20
  _dialog_current_state = 0;
     b30:	10 92 a6 03 	sts	0x03A6, r1
  _dialog_goto_state(0);
     b34:	80 e0       	ldi	r24, 0x00	; 0
     b36:	92 cf       	rjmp	.-220    	; 0xa5c <_dialog_goto_state>
     b38:	08 95       	ret

00000b3a <dialog_tick>:
 @brief Housekeeping function that must be called every second when a dialog is active.

 If the maximum wait time is exceeded the the dialog will change to error state.
 */
void dialog_tick() {
  if (_dialog_second_counter) {
     b3a:	80 91 a7 03 	lds	r24, 0x03A7
     b3e:	88 23       	and	r24, r24
     b40:	91 f0       	breq	.+36     	; 0xb66 <dialog_tick+0x2c>
    if (--_dialog_second_counter == 0) {
     b42:	81 50       	subi	r24, 0x01	; 1
     b44:	80 93 a7 03 	sts	0x03A7, r24
     b48:	81 11       	cpse	r24, r1
     b4a:	0d c0       	rjmp	.+26     	; 0xb66 <dialog_tick+0x2c>
      _dialog_goto_state(_dialog_seq[_dialog_current_state].error_state);
     b4c:	80 91 a6 03 	lds	r24, 0x03A6
     b50:	e0 91 a4 03 	lds	r30, 0x03A4
     b54:	f0 91 a5 03 	lds	r31, 0x03A5
     b58:	9b e0       	ldi	r25, 0x0B	; 11
     b5a:	89 9f       	mul	r24, r25
     b5c:	e0 0d       	add	r30, r0
     b5e:	f1 1d       	adc	r31, r1
     b60:	11 24       	eor	r1, r1
     b62:	80 85       	ldd	r24, Z+8	; 0x08
     b64:	7b cf       	rjmp	.-266    	; 0xa5c <_dialog_goto_state>
     b66:	08 95       	ret

00000b68 <dialog_byte_received>:
If there are specified a pointer to an argument buffer in the current state of the dialog_seq, the received argument bytes will be stored in this buffer, else the argument values will be thrown away.

 When/If the expected response string is received the dialog state is changed to the current dialog states OK state.
 @param[in] byte received from device we are communication with.
 */
void dialog_byte_received(const uint8_t byte) {
     b68:	6f 92       	push	r6
     b6a:	7f 92       	push	r7
     b6c:	8f 92       	push	r8
     b6e:	9f 92       	push	r9
     b70:	af 92       	push	r10
     b72:	bf 92       	push	r11
     b74:	cf 92       	push	r12
     b76:	df 92       	push	r13
     b78:	ef 92       	push	r14
     b7a:	ff 92       	push	r15
     b7c:	0f 93       	push	r16
     b7e:	1f 93       	push	r17
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	98 2e       	mov	r9, r24
  uint8_t _retry;
  
  switch (_dialog_await_state) {
     b86:	80 91 a3 03 	lds	r24, 0x03A3
     b8a:	81 30       	cpi	r24, 0x01	; 1
     b8c:	09 f4       	brne	.+2      	; 0xb90 <dialog_byte_received+0x28>
     b8e:	42 c0       	rjmp	.+132    	; 0xc14 <dialog_byte_received+0xac>
     b90:	20 f0       	brcs	.+8      	; 0xb9a <dialog_byte_received+0x32>
     b92:	82 30       	cpi	r24, 0x02	; 2
     b94:	09 f4       	brne	.+2      	; 0xb98 <dialog_byte_received+0x30>
     b96:	70 c0       	rjmp	.+224    	; 0xc78 <dialog_byte_received+0x110>
     b98:	af c0       	rjmp	.+350    	; 0xcf8 <dialog_byte_received+0x190>
     b9a:	81 2c       	mov	r8, r1
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     b9c:	cc ea       	ldi	r28, 0xAC	; 172
     b9e:	d3 e0       	ldi	r29, 0x03	; 3
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     ba0:	0f 2e       	mov	r0, r31
     ba2:	f8 ea       	ldi	r31, 0xA8	; 168
     ba4:	cf 2e       	mov	r12, r31
     ba6:	f3 e0       	ldi	r31, 0x03	; 3
     ba8:	df 2e       	mov	r13, r31
     baa:	f0 2d       	mov	r31, r0

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     bac:	0f 2e       	mov	r0, r31
     bae:	ff ea       	ldi	r31, 0xAF	; 175
     bb0:	ef 2e       	mov	r14, r31
     bb2:	f3 e0       	ldi	r31, 0x03	; 3
     bb4:	ff 2e       	mov	r15, r31
     bb6:	f0 2d       	mov	r31, r0
        if (_dialog_format.arg_buffers != 0) {
     bb8:	00 eb       	ldi	r16, 0xB0	; 176
     bba:	13 e0       	ldi	r17, 0x03	; 3
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
        }

        if (!_retry) {
     bbc:	77 24       	eor	r7, r7
     bbe:	73 94       	inc	r7
     bc0:	61 2c       	mov	r6, r1
        _dialog_format.response_p = _dialog_format.response;

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
        if (_dialog_format.arg_buffers != 0) {
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     bc2:	0f 2e       	mov	r0, r31
     bc4:	f2 eb       	ldi	r31, 0xB2	; 178
     bc6:	af 2e       	mov	r10, r31
     bc8:	f3 e0       	ldi	r31, 0x03	; 3
     bca:	bf 2e       	mov	r11, r31
     bcc:	f0 2d       	mov	r31, r0
  
  switch (_dialog_await_state) {
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     bce:	e8 81       	ld	r30, Y
     bd0:	f9 81       	ldd	r31, Y+1	; 0x01
     bd2:	9f 01       	movw	r18, r30
     bd4:	2f 5f       	subi	r18, 0xFF	; 255
     bd6:	3f 4f       	sbci	r19, 0xFF	; 255
     bd8:	39 83       	std	Y+1, r19	; 0x01
     bda:	28 83       	st	Y, r18
     bdc:	80 81       	ld	r24, Z
     bde:	89 15       	cp	r24, r9
     be0:	a9 f0       	breq	.+42     	; 0xc0c <dialog_byte_received+0xa4>
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     be2:	d6 01       	movw	r26, r12
     be4:	8d 91       	ld	r24, X+
     be6:	9c 91       	ld	r25, X
     be8:	99 83       	std	Y+1, r25	; 0x01
     bea:	88 83       	st	Y, r24

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     bec:	f7 01       	movw	r30, r14
     bee:	10 82       	st	Z, r1
        if (_dialog_format.arg_buffers != 0) {
     bf0:	d8 01       	movw	r26, r16
     bf2:	ed 91       	ld	r30, X+
     bf4:	fc 91       	ld	r31, X
     bf6:	30 97       	sbiw	r30, 0x00	; 0
     bf8:	29 f0       	breq	.+10     	; 0xc04 <dialog_byte_received+0x9c>
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     bfa:	80 81       	ld	r24, Z
     bfc:	91 81       	ldd	r25, Z+1	; 0x01
     bfe:	f5 01       	movw	r30, r10
     c00:	91 83       	std	Z+1, r25	; 0x01
     c02:	80 83       	st	Z, r24
        }

        if (!_retry) {
     c04:	87 2d       	mov	r24, r7
     c06:	81 10       	cpse	r8, r1
     c08:	86 2d       	mov	r24, r6
          _retry = 1;
     c0a:	88 2e       	mov	r8, r24
        } else {
          _retry = 0;
        }
      }
      _dialog_prepare_for_next_byte();
     c0c:	97 de       	rcall	.-722    	; 0x93c <_dialog_prepare_for_next_byte>
    } while (_retry);
     c0e:	81 10       	cpse	r8, r1
     c10:	de cf       	rjmp	.-68     	; 0xbce <dialog_byte_received+0x66>
     c12:	72 c0       	rjmp	.+228    	; 0xcf8 <dialog_byte_received+0x190>
    break;

  case ARG_STATE:
    // Test if buffer is specified
    if (_dialog_format.arg_buffers != 0) {
     c14:	20 91 b0 03 	lds	r18, 0x03B0
     c18:	30 91 b1 03 	lds	r19, 0x03B1
     c1c:	21 15       	cp	r18, r1
     c1e:	31 05       	cpc	r19, r1
     c20:	11 f1       	breq	.+68     	; 0xc66 <dialog_byte_received+0xfe>
      *_dialog_format.arg_buf_p++ = byte;
     c22:	a2 eb       	ldi	r26, 0xB2	; 178
     c24:	b3 e0       	ldi	r27, 0x03	; 3
     c26:	ed 91       	ld	r30, X+
     c28:	fc 91       	ld	r31, X
     c2a:	11 97       	sbiw	r26, 0x01	; 1
     c2c:	cf 01       	movw	r24, r30
     c2e:	01 96       	adiw	r24, 0x01	; 1
     c30:	8d 93       	st	X+, r24
     c32:	9c 93       	st	X, r25
     c34:	90 82       	st	Z, r9
      // Update length of received argument in arg_buffers
      _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     c36:	e0 91 af 03 	lds	r30, 0x03AF
     c3a:	ff 27       	eor	r31, r31
     c3c:	e7 fd       	sbrc	r30, 7
     c3e:	f0 95       	com	r31
     c40:	cf 01       	movw	r24, r30
     c42:	88 0f       	add	r24, r24
     c44:	99 1f       	adc	r25, r25
     c46:	e8 0f       	add	r30, r24
     c48:	f9 1f       	adc	r31, r25
     c4a:	e2 0f       	add	r30, r18
     c4c:	f3 1f       	adc	r31, r19
     c4e:	82 81       	ldd	r24, Z+2	; 0x02
     c50:	8f 5f       	subi	r24, 0xFF	; 255
     c52:	82 83       	std	Z+2, r24	; 0x02

      // have we got all the bytes in the this argument
      if (--(_dialog_format.arg_cnt) == 0) {
     c54:	ee ea       	ldi	r30, 0xAE	; 174
     c56:	f3 e0       	ldi	r31, 0x03	; 3
     c58:	80 81       	ld	r24, Z
     c5a:	81 50       	subi	r24, 0x01	; 1
     c5c:	80 83       	st	Z, r24
     c5e:	81 11       	cpse	r24, r1
     c60:	4b c0       	rjmp	.+150    	; 0xcf8 <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     c62:	6c de       	rcall	.-808    	; 0x93c <_dialog_prepare_for_next_byte>
     c64:	49 c0       	rjmp	.+146    	; 0xcf8 <dialog_byte_received+0x190>
      }
    } else if (--(_dialog_format.arg_cnt) == 0) {
     c66:	ee ea       	ldi	r30, 0xAE	; 174
     c68:	f3 e0       	ldi	r31, 0x03	; 3
     c6a:	80 81       	ld	r24, Z
     c6c:	81 50       	subi	r24, 0x01	; 1
     c6e:	80 83       	st	Z, r24
     c70:	81 11       	cpse	r24, r1
     c72:	42 c0       	rjmp	.+132    	; 0xcf8 <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     c74:	63 de       	rcall	.-826    	; 0x93c <_dialog_prepare_for_next_byte>
     c76:	40 c0       	rjmp	.+128    	; 0xcf8 <dialog_byte_received+0x190>
    }
    break;

  case ARG_MAX_STATE:
    // Test if we still are receiving argument bytes
    if (byte != *_dialog_format.response_p) {
     c78:	e0 91 ac 03 	lds	r30, 0x03AC
     c7c:	f0 91 ad 03 	lds	r31, 0x03AD
     c80:	80 81       	ld	r24, Z
     c82:	89 15       	cp	r24, r9
     c84:	51 f1       	breq	.+84     	; 0xcda <dialog_byte_received+0x172>
      // Test if buffer is specified
      if (_dialog_format.arg_buffers != 0) {
     c86:	80 91 b0 03 	lds	r24, 0x03B0
     c8a:	90 91 b1 03 	lds	r25, 0x03B1
     c8e:	00 97       	sbiw	r24, 0x00	; 0
     c90:	09 f4       	brne	.+2      	; 0xc94 <dialog_byte_received+0x12c>
     c92:	4e c0       	rjmp	.+156    	; 0xd30 <dialog_byte_received+0x1c8>
        *_dialog_format.arg_buf_p++ = byte;
     c94:	a2 eb       	ldi	r26, 0xB2	; 178
     c96:	b3 e0       	ldi	r27, 0x03	; 3
     c98:	ed 91       	ld	r30, X+
     c9a:	fc 91       	ld	r31, X
     c9c:	11 97       	sbiw	r26, 0x01	; 1
     c9e:	9f 01       	movw	r18, r30
     ca0:	2f 5f       	subi	r18, 0xFF	; 255
     ca2:	3f 4f       	sbci	r19, 0xFF	; 255
     ca4:	2d 93       	st	X+, r18
     ca6:	3c 93       	st	X, r19
     ca8:	90 82       	st	Z, r9
        // Update length of received argument in arg_buffers
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     caa:	20 91 af 03 	lds	r18, 0x03AF
     cae:	33 27       	eor	r19, r19
     cb0:	27 fd       	sbrc	r18, 7
     cb2:	30 95       	com	r19
     cb4:	f9 01       	movw	r30, r18
     cb6:	ee 0f       	add	r30, r30
     cb8:	ff 1f       	adc	r31, r31
     cba:	e2 0f       	add	r30, r18
     cbc:	f3 1f       	adc	r31, r19
     cbe:	e8 0f       	add	r30, r24
     cc0:	f9 1f       	adc	r31, r25
     cc2:	82 81       	ldd	r24, Z+2	; 0x02
     cc4:	8f 5f       	subi	r24, 0xFF	; 255
     cc6:	82 83       	std	Z+2, r24	; 0x02

        // Have we received the maximum number of bytes in argument?
        if (--(_dialog_format.arg_cnt) == 0) {
     cc8:	ee ea       	ldi	r30, 0xAE	; 174
     cca:	f3 e0       	ldi	r31, 0x03	; 3
     ccc:	80 81       	ld	r24, Z
     cce:	81 50       	subi	r24, 0x01	; 1
     cd0:	80 83       	st	Z, r24
     cd2:	81 11       	cpse	r24, r1
     cd4:	11 c0       	rjmp	.+34     	; 0xcf8 <dialog_byte_received+0x190>
          _dialog_prepare_for_next_byte();
     cd6:	32 de       	rcall	.-924    	; 0x93c <_dialog_prepare_for_next_byte>
     cd8:	0f c0       	rjmp	.+30     	; 0xcf8 <dialog_byte_received+0x190>
        }
      }
    } else if (--(_dialog_format.arg_cnt) == 0) { // or have we received the maximum allowed no of bytes in the argument?
     cda:	ae ea       	ldi	r26, 0xAE	; 174
     cdc:	b3 e0       	ldi	r27, 0x03	; 3
     cde:	8c 91       	ld	r24, X
     ce0:	81 50       	subi	r24, 0x01	; 1
     ce2:	8c 93       	st	X, r24
     ce4:	81 11       	cpse	r24, r1
     ce6:	02 c0       	rjmp	.+4      	; 0xcec <dialog_byte_received+0x184>
      _dialog_prepare_for_next_byte();
     ce8:	29 de       	rcall	.-942    	; 0x93c <_dialog_prepare_for_next_byte>
     cea:	06 c0       	rjmp	.+12     	; 0xcf8 <dialog_byte_received+0x190>
    } else {
      // Next byte in normal response is received
      _dialog_format.response_p++;
     cec:	31 96       	adiw	r30, 0x01	; 1
     cee:	f0 93 ad 03 	sts	0x03AD, r31
     cf2:	e0 93 ac 03 	sts	0x03AC, r30
      _dialog_prepare_for_next_byte();
     cf6:	22 de       	rcall	.-956    	; 0x93c <_dialog_prepare_for_next_byte>
  default:
    break;
  }

  // Test if we are done - have received all bytes in this state of the dialog_seq
  if ((_dialog_await_state == NORMAL_STATE) && (_dialog_format.response_p > _dialog_format.last)) {
     cf8:	80 91 a3 03 	lds	r24, 0x03A3
     cfc:	81 11       	cpse	r24, r1
     cfe:	18 c0       	rjmp	.+48     	; 0xd30 <dialog_byte_received+0x1c8>
     d00:	20 91 ac 03 	lds	r18, 0x03AC
     d04:	30 91 ad 03 	lds	r19, 0x03AD
     d08:	80 91 aa 03 	lds	r24, 0x03AA
     d0c:	90 91 ab 03 	lds	r25, 0x03AB
     d10:	82 17       	cp	r24, r18
     d12:	93 07       	cpc	r25, r19
     d14:	68 f4       	brcc	.+26     	; 0xd30 <dialog_byte_received+0x1c8>
    // OK - goto OK state
    _dialog_goto_state(_dialog_seq[_dialog_current_state].ok_state);
     d16:	80 91 a6 03 	lds	r24, 0x03A6
     d1a:	e0 91 a4 03 	lds	r30, 0x03A4
     d1e:	f0 91 a5 03 	lds	r31, 0x03A5
     d22:	9b e0       	ldi	r25, 0x0B	; 11
     d24:	89 9f       	mul	r24, r25
     d26:	e0 0d       	add	r30, r0
     d28:	f1 1d       	adc	r31, r1
     d2a:	11 24       	eor	r1, r1
     d2c:	87 81       	ldd	r24, Z+7	; 0x07
     d2e:	96 de       	rcall	.-724    	; 0xa5c <_dialog_goto_state>
  }
}
     d30:	df 91       	pop	r29
     d32:	cf 91       	pop	r28
     d34:	1f 91       	pop	r17
     d36:	0f 91       	pop	r16
     d38:	ff 90       	pop	r15
     d3a:	ef 90       	pop	r14
     d3c:	df 90       	pop	r13
     d3e:	cf 90       	pop	r12
     d40:	bf 90       	pop	r11
     d42:	af 90       	pop	r10
     d44:	9f 90       	pop	r9
     d46:	8f 90       	pop	r8
     d48:	7f 90       	pop	r7
     d4a:	6f 90       	pop	r6
     d4c:	08 95       	ret

00000d4e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     d4e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d50:	03 96       	adiw	r24, 0x03	; 3
     d52:	92 83       	std	Z+2, r25	; 0x02
     d54:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d56:	2f ef       	ldi	r18, 0xFF	; 255
     d58:	3f ef       	ldi	r19, 0xFF	; 255
     d5a:	34 83       	std	Z+4, r19	; 0x04
     d5c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d5e:	96 83       	std	Z+6, r25	; 0x06
     d60:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d62:	90 87       	std	Z+8, r25	; 0x08
     d64:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     d66:	10 82       	st	Z, r1
     d68:	08 95       	ret

00000d6a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     d6a:	fc 01       	movw	r30, r24
     d6c:	11 86       	std	Z+9, r1	; 0x09
     d6e:	10 86       	std	Z+8, r1	; 0x08
     d70:	08 95       	ret

00000d72 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     d72:	cf 93       	push	r28
     d74:	df 93       	push	r29
     d76:	9c 01       	movw	r18, r24
     d78:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     d7a:	dc 01       	movw	r26, r24
     d7c:	11 96       	adiw	r26, 0x01	; 1
     d7e:	cd 91       	ld	r28, X+
     d80:	dc 91       	ld	r29, X
     d82:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     d84:	d3 83       	std	Z+3, r29	; 0x03
     d86:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     d88:	8c 81       	ldd	r24, Y+4	; 0x04
     d8a:	9d 81       	ldd	r25, Y+5	; 0x05
     d8c:	95 83       	std	Z+5, r25	; 0x05
     d8e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     d90:	8c 81       	ldd	r24, Y+4	; 0x04
     d92:	9d 81       	ldd	r25, Y+5	; 0x05
     d94:	dc 01       	movw	r26, r24
     d96:	13 96       	adiw	r26, 0x03	; 3
     d98:	7c 93       	st	X, r23
     d9a:	6e 93       	st	-X, r22
     d9c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     d9e:	7d 83       	std	Y+5, r23	; 0x05
     da0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     da2:	31 87       	std	Z+9, r19	; 0x09
     da4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     da6:	f9 01       	movw	r30, r18
     da8:	80 81       	ld	r24, Z
     daa:	8f 5f       	subi	r24, 0xFF	; 255
     dac:	80 83       	st	Z, r24
}
     dae:	df 91       	pop	r29
     db0:	cf 91       	pop	r28
     db2:	08 95       	ret

00000db4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     db4:	cf 93       	push	r28
     db6:	df 93       	push	r29
     db8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     dba:	48 81       	ld	r20, Y
     dbc:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     dbe:	4f 3f       	cpi	r20, 0xFF	; 255
     dc0:	2f ef       	ldi	r18, 0xFF	; 255
     dc2:	52 07       	cpc	r21, r18
     dc4:	21 f4       	brne	.+8      	; 0xdce <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     dc6:	fc 01       	movw	r30, r24
     dc8:	a7 81       	ldd	r26, Z+7	; 0x07
     dca:	b0 85       	ldd	r27, Z+8	; 0x08
     dcc:	0d c0       	rjmp	.+26     	; 0xde8 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dce:	dc 01       	movw	r26, r24
     dd0:	13 96       	adiw	r26, 0x03	; 3
     dd2:	12 96       	adiw	r26, 0x02	; 2
     dd4:	ed 91       	ld	r30, X+
     dd6:	fc 91       	ld	r31, X
     dd8:	13 97       	sbiw	r26, 0x03	; 3
     dda:	20 81       	ld	r18, Z
     ddc:	31 81       	ldd	r19, Z+1	; 0x01
     dde:	42 17       	cp	r20, r18
     de0:	53 07       	cpc	r21, r19
     de2:	10 f0       	brcs	.+4      	; 0xde8 <vListInsert+0x34>
     de4:	df 01       	movw	r26, r30
     de6:	f5 cf       	rjmp	.-22     	; 0xdd2 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     de8:	12 96       	adiw	r26, 0x02	; 2
     dea:	ed 91       	ld	r30, X+
     dec:	fc 91       	ld	r31, X
     dee:	13 97       	sbiw	r26, 0x03	; 3
     df0:	fb 83       	std	Y+3, r31	; 0x03
     df2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     df4:	d5 83       	std	Z+5, r29	; 0x05
     df6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     df8:	bd 83       	std	Y+5, r27	; 0x05
     dfa:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     dfc:	13 96       	adiw	r26, 0x03	; 3
     dfe:	dc 93       	st	X, r29
     e00:	ce 93       	st	-X, r28
     e02:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e04:	99 87       	std	Y+9, r25	; 0x09
     e06:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     e08:	fc 01       	movw	r30, r24
     e0a:	20 81       	ld	r18, Z
     e0c:	2f 5f       	subi	r18, 0xFF	; 255
     e0e:	20 83       	st	Z, r18
}
     e10:	df 91       	pop	r29
     e12:	cf 91       	pop	r28
     e14:	08 95       	ret

00000e16 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     e16:	cf 93       	push	r28
     e18:	df 93       	push	r29
     e1a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     e1c:	a0 85       	ldd	r26, Z+8	; 0x08
     e1e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     e20:	c2 81       	ldd	r28, Z+2	; 0x02
     e22:	d3 81       	ldd	r29, Z+3	; 0x03
     e24:	84 81       	ldd	r24, Z+4	; 0x04
     e26:	95 81       	ldd	r25, Z+5	; 0x05
     e28:	9d 83       	std	Y+5, r25	; 0x05
     e2a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e2c:	c4 81       	ldd	r28, Z+4	; 0x04
     e2e:	d5 81       	ldd	r29, Z+5	; 0x05
     e30:	82 81       	ldd	r24, Z+2	; 0x02
     e32:	93 81       	ldd	r25, Z+3	; 0x03
     e34:	9b 83       	std	Y+3, r25	; 0x03
     e36:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e38:	11 96       	adiw	r26, 0x01	; 1
     e3a:	cd 91       	ld	r28, X+
     e3c:	dc 91       	ld	r29, X
     e3e:	12 97       	sbiw	r26, 0x02	; 2
     e40:	ce 17       	cp	r28, r30
     e42:	df 07       	cpc	r29, r31
     e44:	31 f4       	brne	.+12     	; 0xe52 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e46:	8c 81       	ldd	r24, Y+4	; 0x04
     e48:	9d 81       	ldd	r25, Y+5	; 0x05
     e4a:	12 96       	adiw	r26, 0x02	; 2
     e4c:	9c 93       	st	X, r25
     e4e:	8e 93       	st	-X, r24
     e50:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     e52:	11 86       	std	Z+9, r1	; 0x09
     e54:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     e56:	8c 91       	ld	r24, X
     e58:	81 50       	subi	r24, 0x01	; 1
     e5a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     e5c:	df 91       	pop	r29
     e5e:	cf 91       	pop	r28
     e60:	08 95       	ret

00000e62 <pxPortInitialiseStack>:
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */

#if defined( portUSE_TIMER0 )
   /* Setup clock source and compare match behaviour. Assuming 328p*/
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     e62:	31 e1       	ldi	r19, 0x11	; 17
     e64:	fc 01       	movw	r30, r24
     e66:	30 83       	st	Z, r19
     e68:	31 97       	sbiw	r30, 0x01	; 1
     e6a:	22 e2       	ldi	r18, 0x22	; 34
     e6c:	20 83       	st	Z, r18
     e6e:	31 97       	sbiw	r30, 0x01	; 1
     e70:	a3 e3       	ldi	r26, 0x33	; 51
     e72:	a0 83       	st	Z, r26
     e74:	31 97       	sbiw	r30, 0x01	; 1
     e76:	60 83       	st	Z, r22
     e78:	31 97       	sbiw	r30, 0x01	; 1
     e7a:	70 83       	st	Z, r23
     e7c:	31 97       	sbiw	r30, 0x01	; 1
     e7e:	10 82       	st	Z, r1
     e80:	31 97       	sbiw	r30, 0x01	; 1
     e82:	10 82       	st	Z, r1
     e84:	31 97       	sbiw	r30, 0x01	; 1
     e86:	60 e8       	ldi	r22, 0x80	; 128
     e88:	60 83       	st	Z, r22
     e8a:	31 97       	sbiw	r30, 0x01	; 1
     e8c:	10 82       	st	Z, r1
     e8e:	31 97       	sbiw	r30, 0x01	; 1
     e90:	10 82       	st	Z, r1
     e92:	31 97       	sbiw	r30, 0x01	; 1
     e94:	10 82       	st	Z, r1
     e96:	31 97       	sbiw	r30, 0x01	; 1
     e98:	62 e0       	ldi	r22, 0x02	; 2
     e9a:	60 83       	st	Z, r22
     e9c:	31 97       	sbiw	r30, 0x01	; 1
     e9e:	63 e0       	ldi	r22, 0x03	; 3
     ea0:	60 83       	st	Z, r22
     ea2:	31 97       	sbiw	r30, 0x01	; 1
     ea4:	64 e0       	ldi	r22, 0x04	; 4
     ea6:	60 83       	st	Z, r22
     ea8:	31 97       	sbiw	r30, 0x01	; 1
     eaa:	65 e0       	ldi	r22, 0x05	; 5
     eac:	60 83       	st	Z, r22
     eae:	31 97       	sbiw	r30, 0x01	; 1
     eb0:	66 e0       	ldi	r22, 0x06	; 6
     eb2:	60 83       	st	Z, r22
     eb4:	31 97       	sbiw	r30, 0x01	; 1
     eb6:	67 e0       	ldi	r22, 0x07	; 7
     eb8:	60 83       	st	Z, r22
     eba:	31 97       	sbiw	r30, 0x01	; 1
     ebc:	68 e0       	ldi	r22, 0x08	; 8
     ebe:	60 83       	st	Z, r22
     ec0:	31 97       	sbiw	r30, 0x01	; 1
     ec2:	69 e0       	ldi	r22, 0x09	; 9
     ec4:	60 83       	st	Z, r22
     ec6:	31 97       	sbiw	r30, 0x01	; 1
     ec8:	60 e1       	ldi	r22, 0x10	; 16
     eca:	60 83       	st	Z, r22
     ecc:	31 97       	sbiw	r30, 0x01	; 1
     ece:	30 83       	st	Z, r19
     ed0:	31 97       	sbiw	r30, 0x01	; 1
     ed2:	32 e1       	ldi	r19, 0x12	; 18
     ed4:	30 83       	st	Z, r19
     ed6:	31 97       	sbiw	r30, 0x01	; 1
     ed8:	33 e1       	ldi	r19, 0x13	; 19
     eda:	30 83       	st	Z, r19
     edc:	31 97       	sbiw	r30, 0x01	; 1
     ede:	34 e1       	ldi	r19, 0x14	; 20
     ee0:	30 83       	st	Z, r19
     ee2:	31 97       	sbiw	r30, 0x01	; 1
     ee4:	35 e1       	ldi	r19, 0x15	; 21
     ee6:	30 83       	st	Z, r19
     ee8:	31 97       	sbiw	r30, 0x01	; 1
     eea:	36 e1       	ldi	r19, 0x16	; 22
     eec:	30 83       	st	Z, r19
     eee:	31 97       	sbiw	r30, 0x01	; 1
     ef0:	37 e1       	ldi	r19, 0x17	; 23
     ef2:	30 83       	st	Z, r19
     ef4:	31 97       	sbiw	r30, 0x01	; 1
     ef6:	38 e1       	ldi	r19, 0x18	; 24
     ef8:	30 83       	st	Z, r19
     efa:	31 97       	sbiw	r30, 0x01	; 1
     efc:	39 e1       	ldi	r19, 0x19	; 25
     efe:	30 83       	st	Z, r19
     f00:	31 97       	sbiw	r30, 0x01	; 1
     f02:	30 e2       	ldi	r19, 0x20	; 32
     f04:	30 83       	st	Z, r19
     f06:	31 97       	sbiw	r30, 0x01	; 1
     f08:	31 e2       	ldi	r19, 0x21	; 33
     f0a:	30 83       	st	Z, r19
     f0c:	31 97       	sbiw	r30, 0x01	; 1
     f0e:	20 83       	st	Z, r18
     f10:	31 97       	sbiw	r30, 0x01	; 1
     f12:	23 e2       	ldi	r18, 0x23	; 35
     f14:	20 83       	st	Z, r18
     f16:	31 97       	sbiw	r30, 0x01	; 1
     f18:	40 83       	st	Z, r20
     f1a:	31 97       	sbiw	r30, 0x01	; 1
     f1c:	50 83       	st	Z, r21
     f1e:	31 97       	sbiw	r30, 0x01	; 1
     f20:	26 e2       	ldi	r18, 0x26	; 38
     f22:	20 83       	st	Z, r18
     f24:	31 97       	sbiw	r30, 0x01	; 1
     f26:	27 e2       	ldi	r18, 0x27	; 39
     f28:	20 83       	st	Z, r18
     f2a:	31 97       	sbiw	r30, 0x01	; 1
     f2c:	28 e2       	ldi	r18, 0x28	; 40
     f2e:	20 83       	st	Z, r18
     f30:	31 97       	sbiw	r30, 0x01	; 1
     f32:	29 e2       	ldi	r18, 0x29	; 41
     f34:	20 83       	st	Z, r18
     f36:	31 97       	sbiw	r30, 0x01	; 1
     f38:	20 e3       	ldi	r18, 0x30	; 48
     f3a:	20 83       	st	Z, r18
     f3c:	31 97       	sbiw	r30, 0x01	; 1
     f3e:	21 e3       	ldi	r18, 0x31	; 49
     f40:	20 83       	st	Z, r18
     f42:	89 97       	sbiw	r24, 0x29	; 41
     f44:	08 95       	ret

00000f46 <xPortStartScheduler>:
     f46:	88 ee       	ldi	r24, 0xE8	; 232
     f48:	93 e0       	ldi	r25, 0x03	; 3
     f4a:	90 93 b7 03 	sts	0x03B7, r25
     f4e:	80 93 b6 03 	sts	0x03B6, r24
     f52:	90 93 b5 03 	sts	0x03B5, r25
     f56:	80 93 b4 03 	sts	0x03B4, r24
     f5a:	89 ef       	ldi	r24, 0xF9	; 249
     f5c:	87 bd       	out	0x27, r24	; 39
     f5e:	82 e0       	ldi	r24, 0x02	; 2
     f60:	84 bd       	out	0x24, r24	; 36
     f62:	83 e0       	ldi	r24, 0x03	; 3
     f64:	85 bd       	out	0x25, r24	; 37
     f66:	ee e6       	ldi	r30, 0x6E	; 110
     f68:	f0 e0       	ldi	r31, 0x00	; 0
     f6a:	80 81       	ld	r24, Z
     f6c:	82 60       	ori	r24, 0x02	; 2
     f6e:	80 83       	st	Z, r24
     f70:	a0 91 d7 0d 	lds	r26, 0x0DD7
     f74:	b0 91 d8 0d 	lds	r27, 0x0DD8
     f78:	cd 91       	ld	r28, X+
     f7a:	cd bf       	out	0x3d, r28	; 61
     f7c:	dd 91       	ld	r29, X+
     f7e:	de bf       	out	0x3e, r29	; 62
     f80:	ff 91       	pop	r31
     f82:	ef 91       	pop	r30
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	bf 91       	pop	r27
     f8a:	af 91       	pop	r26
     f8c:	9f 91       	pop	r25
     f8e:	8f 91       	pop	r24
     f90:	7f 91       	pop	r23
     f92:	6f 91       	pop	r22
     f94:	5f 91       	pop	r21
     f96:	4f 91       	pop	r20
     f98:	3f 91       	pop	r19
     f9a:	2f 91       	pop	r18
     f9c:	1f 91       	pop	r17
     f9e:	0f 91       	pop	r16
     fa0:	ff 90       	pop	r15
     fa2:	ef 90       	pop	r14
     fa4:	df 90       	pop	r13
     fa6:	cf 90       	pop	r12
     fa8:	bf 90       	pop	r11
     faa:	af 90       	pop	r10
     fac:	9f 90       	pop	r9
     fae:	8f 90       	pop	r8
     fb0:	7f 90       	pop	r7
     fb2:	6f 90       	pop	r6
     fb4:	5f 90       	pop	r5
     fb6:	4f 90       	pop	r4
     fb8:	3f 90       	pop	r3
     fba:	2f 90       	pop	r2
     fbc:	1f 90       	pop	r1
     fbe:	0f 90       	pop	r0
     fc0:	0c be       	out	0x3c, r0	; 60
     fc2:	0f 90       	pop	r0
     fc4:	0b be       	out	0x3b, r0	; 59
     fc6:	0f 90       	pop	r0
     fc8:	0f be       	out	0x3f, r0	; 63
     fca:	0f 90       	pop	r0
     fcc:	08 95       	ret
     fce:	81 e0       	ldi	r24, 0x01	; 1
     fd0:	08 95       	ret

00000fd2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     fd2:	0f 92       	push	r0
     fd4:	0f b6       	in	r0, 0x3f	; 63
     fd6:	f8 94       	cli
     fd8:	0f 92       	push	r0
     fda:	0b b6       	in	r0, 0x3b	; 59
     fdc:	0f 92       	push	r0
     fde:	0c b6       	in	r0, 0x3c	; 60
     fe0:	0f 92       	push	r0
     fe2:	1f 92       	push	r1
     fe4:	11 24       	eor	r1, r1
     fe6:	2f 92       	push	r2
     fe8:	3f 92       	push	r3
     fea:	4f 92       	push	r4
     fec:	5f 92       	push	r5
     fee:	6f 92       	push	r6
     ff0:	7f 92       	push	r7
     ff2:	8f 92       	push	r8
     ff4:	9f 92       	push	r9
     ff6:	af 92       	push	r10
     ff8:	bf 92       	push	r11
     ffa:	cf 92       	push	r12
     ffc:	df 92       	push	r13
     ffe:	ef 92       	push	r14
    1000:	ff 92       	push	r15
    1002:	0f 93       	push	r16
    1004:	1f 93       	push	r17
    1006:	2f 93       	push	r18
    1008:	3f 93       	push	r19
    100a:	4f 93       	push	r20
    100c:	5f 93       	push	r21
    100e:	6f 93       	push	r22
    1010:	7f 93       	push	r23
    1012:	8f 93       	push	r24
    1014:	9f 93       	push	r25
    1016:	af 93       	push	r26
    1018:	bf 93       	push	r27
    101a:	cf 93       	push	r28
    101c:	df 93       	push	r29
    101e:	ef 93       	push	r30
    1020:	ff 93       	push	r31
    1022:	a0 91 d7 0d 	lds	r26, 0x0DD7
    1026:	b0 91 d8 0d 	lds	r27, 0x0DD8
    102a:	0d b6       	in	r0, 0x3d	; 61
    102c:	0d 92       	st	X+, r0
    102e:	0e b6       	in	r0, 0x3e	; 62
    1030:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1032:	6e d6       	rcall	.+3292   	; 0x1d10 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1034:	a0 91 d7 0d 	lds	r26, 0x0DD7
    1038:	b0 91 d8 0d 	lds	r27, 0x0DD8
    103c:	cd 91       	ld	r28, X+
    103e:	cd bf       	out	0x3d, r28	; 61
    1040:	dd 91       	ld	r29, X+
    1042:	de bf       	out	0x3e, r29	; 62
    1044:	ff 91       	pop	r31
    1046:	ef 91       	pop	r30
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	bf 91       	pop	r27
    104e:	af 91       	pop	r26
    1050:	9f 91       	pop	r25
    1052:	8f 91       	pop	r24
    1054:	7f 91       	pop	r23
    1056:	6f 91       	pop	r22
    1058:	5f 91       	pop	r21
    105a:	4f 91       	pop	r20
    105c:	3f 91       	pop	r19
    105e:	2f 91       	pop	r18
    1060:	1f 91       	pop	r17
    1062:	0f 91       	pop	r16
    1064:	ff 90       	pop	r15
    1066:	ef 90       	pop	r14
    1068:	df 90       	pop	r13
    106a:	cf 90       	pop	r12
    106c:	bf 90       	pop	r11
    106e:	af 90       	pop	r10
    1070:	9f 90       	pop	r9
    1072:	8f 90       	pop	r8
    1074:	7f 90       	pop	r7
    1076:	6f 90       	pop	r6
    1078:	5f 90       	pop	r5
    107a:	4f 90       	pop	r4
    107c:	3f 90       	pop	r3
    107e:	2f 90       	pop	r2
    1080:	1f 90       	pop	r1
    1082:	0f 90       	pop	r0
    1084:	0c be       	out	0x3c, r0	; 60
    1086:	0f 90       	pop	r0
    1088:	0b be       	out	0x3b, r0	; 59
    108a:	0f 90       	pop	r0
    108c:	0f be       	out	0x3f, r0	; 63
    108e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1090:	08 95       	ret

00001092 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1092:	0f 92       	push	r0
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	0f 92       	push	r0
    109a:	0b b6       	in	r0, 0x3b	; 59
    109c:	0f 92       	push	r0
    109e:	0c b6       	in	r0, 0x3c	; 60
    10a0:	0f 92       	push	r0
    10a2:	1f 92       	push	r1
    10a4:	11 24       	eor	r1, r1
    10a6:	2f 92       	push	r2
    10a8:	3f 92       	push	r3
    10aa:	4f 92       	push	r4
    10ac:	5f 92       	push	r5
    10ae:	6f 92       	push	r6
    10b0:	7f 92       	push	r7
    10b2:	8f 92       	push	r8
    10b4:	9f 92       	push	r9
    10b6:	af 92       	push	r10
    10b8:	bf 92       	push	r11
    10ba:	cf 92       	push	r12
    10bc:	df 92       	push	r13
    10be:	ef 92       	push	r14
    10c0:	ff 92       	push	r15
    10c2:	0f 93       	push	r16
    10c4:	1f 93       	push	r17
    10c6:	2f 93       	push	r18
    10c8:	3f 93       	push	r19
    10ca:	4f 93       	push	r20
    10cc:	5f 93       	push	r21
    10ce:	6f 93       	push	r22
    10d0:	7f 93       	push	r23
    10d2:	8f 93       	push	r24
    10d4:	9f 93       	push	r25
    10d6:	af 93       	push	r26
    10d8:	bf 93       	push	r27
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
    10de:	ef 93       	push	r30
    10e0:	ff 93       	push	r31
    10e2:	a0 91 d7 0d 	lds	r26, 0x0DD7
    10e6:	b0 91 d8 0d 	lds	r27, 0x0DD8
    10ea:	0d b6       	in	r0, 0x3d	; 61
    10ec:	0d 92       	st	X+, r0
    10ee:	0e b6       	in	r0, 0x3e	; 62
    10f0:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
    10f2:	80 91 b4 03 	lds	r24, 0x03B4
    10f6:	90 91 b5 03 	lds	r25, 0x03B5
    10fa:	01 97       	sbiw	r24, 0x01	; 1
    10fc:	90 93 b5 03 	sts	0x03B5, r25
    1100:	80 93 b4 03 	sts	0x03B4, r24
    1104:	89 2b       	or	r24, r25
    1106:	41 f4       	brne	.+16     	; 0x1118 <vPortYieldFromTick+0x86>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
    1108:	80 91 b6 03 	lds	r24, 0x03B6
    110c:	90 91 b7 03 	lds	r25, 0x03B7
    1110:	90 93 b5 03 	sts	0x03B5, r25
    1114:	80 93 b4 03 	sts	0x03B4, r24
	}

	if( xTaskIncrementTick() != pdFALSE )
    1118:	a7 d4       	rcall	.+2382   	; 0x1a68 <xTaskIncrementTick>
    111a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    111c:	f9 d5       	rcall	.+3058   	; 0x1d10 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    111e:	a0 91 d7 0d 	lds	r26, 0x0DD7
    1122:	b0 91 d8 0d 	lds	r27, 0x0DD8
    1126:	cd 91       	ld	r28, X+
    1128:	cd bf       	out	0x3d, r28	; 61
    112a:	dd 91       	ld	r29, X+
    112c:	de bf       	out	0x3e, r29	; 62
    112e:	ff 91       	pop	r31
    1130:	ef 91       	pop	r30
    1132:	df 91       	pop	r29
    1134:	cf 91       	pop	r28
    1136:	bf 91       	pop	r27
    1138:	af 91       	pop	r26
    113a:	9f 91       	pop	r25
    113c:	8f 91       	pop	r24
    113e:	7f 91       	pop	r23
    1140:	6f 91       	pop	r22
    1142:	5f 91       	pop	r21
    1144:	4f 91       	pop	r20
    1146:	3f 91       	pop	r19
    1148:	2f 91       	pop	r18
    114a:	1f 91       	pop	r17
    114c:	0f 91       	pop	r16
    114e:	ff 90       	pop	r15
    1150:	ef 90       	pop	r14
    1152:	df 90       	pop	r13
    1154:	cf 90       	pop	r12
    1156:	bf 90       	pop	r11
    1158:	af 90       	pop	r10
    115a:	9f 90       	pop	r9
    115c:	8f 90       	pop	r8
    115e:	7f 90       	pop	r7
    1160:	6f 90       	pop	r6
    1162:	5f 90       	pop	r5
    1164:	4f 90       	pop	r4
    1166:	3f 90       	pop	r3
    1168:	2f 90       	pop	r2
    116a:	1f 90       	pop	r1
    116c:	0f 90       	pop	r0
    116e:	0c be       	out	0x3c, r0	; 60
    1170:	0f 90       	pop	r0
    1172:	0b be       	out	0x3b, r0	; 59
    1174:	0f 90       	pop	r0
    1176:	0f be       	out	0x3f, r0	; 63
    1178:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    117a:	08 95       	ret

0000117c <__vector_21>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
    117c:	8a df       	rcall	.-236    	; 0x1092 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    117e:	18 95       	reti

00001180 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1180:	cf 93       	push	r28
    1182:	df 93       	push	r29
    1184:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1186:	60 d4       	rcall	.+2240   	; 0x1a48 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1188:	80 91 b8 03 	lds	r24, 0x03B8
    118c:	90 91 b9 03 	lds	r25, 0x03B9
    1190:	89 2b       	or	r24, r25
    1192:	31 f4       	brne	.+12     	; 0x11a0 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1194:	8d eb       	ldi	r24, 0xBD	; 189
    1196:	93 e0       	ldi	r25, 0x03	; 3
    1198:	90 93 b9 03 	sts	0x03B9, r25
    119c:	80 93 b8 03 	sts	0x03B8, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    11a0:	40 91 ba 03 	lds	r20, 0x03BA
    11a4:	50 91 bb 03 	lds	r21, 0x03BB
    11a8:	9e 01       	movw	r18, r28
    11aa:	24 0f       	add	r18, r20
    11ac:	35 1f       	adc	r19, r21
    11ae:	23 3c       	cpi	r18, 0xC3	; 195
    11b0:	89 e0       	ldi	r24, 0x09	; 9
    11b2:	38 07       	cpc	r19, r24
    11b4:	70 f4       	brcc	.+28     	; 0x11d2 <pvPortMalloc+0x52>
    11b6:	42 17       	cp	r20, r18
    11b8:	53 07       	cpc	r21, r19
    11ba:	70 f4       	brcc	.+28     	; 0x11d8 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    11bc:	c0 91 b8 03 	lds	r28, 0x03B8
    11c0:	d0 91 b9 03 	lds	r29, 0x03B9
    11c4:	c4 0f       	add	r28, r20
    11c6:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    11c8:	30 93 bb 03 	sts	0x03BB, r19
    11cc:	20 93 ba 03 	sts	0x03BA, r18
    11d0:	05 c0       	rjmp	.+10     	; 0x11dc <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    11d2:	c0 e0       	ldi	r28, 0x00	; 0
    11d4:	d0 e0       	ldi	r29, 0x00	; 0
    11d6:	02 c0       	rjmp	.+4      	; 0x11dc <pvPortMalloc+0x5c>
    11d8:	c0 e0       	ldi	r28, 0x00	; 0
    11da:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    11dc:	00 d5       	rcall	.+2560   	; 0x1bde <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    11de:	ce 01       	movw	r24, r28
    11e0:	df 91       	pop	r29
    11e2:	cf 91       	pop	r28
    11e4:	08 95       	ret

000011e6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    11e6:	08 95       	ret

000011e8 <prvCopyDataToQueue>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    11e8:	1f 93       	push	r17
    11ea:	cf 93       	push	r28
    11ec:	df 93       	push	r29
    11ee:	ec 01       	movw	r28, r24
    11f0:	14 2f       	mov	r17, r20
    11f2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11f4:	88 23       	and	r24, r24
    11f6:	e9 f1       	breq	.+122    	; 0x1272 <prvCopyDataToQueue+0x8a>
    11f8:	41 11       	cpse	r20, r1
    11fa:	17 c0       	rjmp	.+46     	; 0x122a <prvCopyDataToQueue+0x42>
    11fc:	48 2f       	mov	r20, r24
    11fe:	50 e0       	ldi	r21, 0x00	; 0
    1200:	8c 81       	ldd	r24, Y+4	; 0x04
    1202:	9d 81       	ldd	r25, Y+5	; 0x05
    1204:	0e 94 0f 1c 	call	0x381e	; 0x381e <memcpy>
    1208:	2c 8d       	ldd	r18, Y+28	; 0x1c
    120a:	8c 81       	ldd	r24, Y+4	; 0x04
    120c:	9d 81       	ldd	r25, Y+5	; 0x05
    120e:	82 0f       	add	r24, r18
    1210:	91 1d       	adc	r25, r1
    1212:	9d 83       	std	Y+5, r25	; 0x05
    1214:	8c 83       	std	Y+4, r24	; 0x04
    1216:	2a 81       	ldd	r18, Y+2	; 0x02
    1218:	3b 81       	ldd	r19, Y+3	; 0x03
    121a:	82 17       	cp	r24, r18
    121c:	93 07       	cpc	r25, r19
    121e:	48 f1       	brcs	.+82     	; 0x1272 <prvCopyDataToQueue+0x8a>
    1220:	88 81       	ld	r24, Y
    1222:	99 81       	ldd	r25, Y+1	; 0x01
    1224:	9d 83       	std	Y+5, r25	; 0x05
    1226:	8c 83       	std	Y+4, r24	; 0x04
    1228:	24 c0       	rjmp	.+72     	; 0x1272 <prvCopyDataToQueue+0x8a>
    122a:	48 2f       	mov	r20, r24
    122c:	50 e0       	ldi	r21, 0x00	; 0
    122e:	8e 81       	ldd	r24, Y+6	; 0x06
    1230:	9f 81       	ldd	r25, Y+7	; 0x07
    1232:	0e 94 0f 1c 	call	0x381e	; 0x381e <memcpy>
    1236:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1238:	30 e0       	ldi	r19, 0x00	; 0
    123a:	31 95       	neg	r19
    123c:	21 95       	neg	r18
    123e:	31 09       	sbc	r19, r1
    1240:	8e 81       	ldd	r24, Y+6	; 0x06
    1242:	9f 81       	ldd	r25, Y+7	; 0x07
    1244:	82 0f       	add	r24, r18
    1246:	93 1f       	adc	r25, r19
    1248:	9f 83       	std	Y+7, r25	; 0x07
    124a:	8e 83       	std	Y+6, r24	; 0x06
    124c:	68 81       	ld	r22, Y
    124e:	79 81       	ldd	r23, Y+1	; 0x01
    1250:	86 17       	cp	r24, r22
    1252:	97 07       	cpc	r25, r23
    1254:	30 f4       	brcc	.+12     	; 0x1262 <prvCopyDataToQueue+0x7a>
    1256:	8a 81       	ldd	r24, Y+2	; 0x02
    1258:	9b 81       	ldd	r25, Y+3	; 0x03
    125a:	28 0f       	add	r18, r24
    125c:	39 1f       	adc	r19, r25
    125e:	3f 83       	std	Y+7, r19	; 0x07
    1260:	2e 83       	std	Y+6, r18	; 0x06
    1262:	12 30       	cpi	r17, 0x02	; 2
    1264:	31 f4       	brne	.+12     	; 0x1272 <prvCopyDataToQueue+0x8a>
    1266:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1268:	88 23       	and	r24, r24
    126a:	19 f0       	breq	.+6      	; 0x1272 <prvCopyDataToQueue+0x8a>
    126c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    126e:	81 50       	subi	r24, 0x01	; 1
    1270:	8a 8f       	std	Y+26, r24	; 0x1a
    1272:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1274:	8f 5f       	subi	r24, 0xFF	; 255
    1276:	8a 8f       	std	Y+26, r24	; 0x1a
    1278:	80 e0       	ldi	r24, 0x00	; 0
    127a:	df 91       	pop	r29
    127c:	cf 91       	pop	r28
    127e:	1f 91       	pop	r17
    1280:	08 95       	ret

00001282 <prvCopyDataFromQueue>:
    1282:	fc 01       	movw	r30, r24
    1284:	cb 01       	movw	r24, r22
    1286:	44 8d       	ldd	r20, Z+28	; 0x1c
    1288:	44 23       	and	r20, r20
    128a:	a1 f0       	breq	.+40     	; 0x12b4 <prvCopyDataFromQueue+0x32>
    128c:	50 e0       	ldi	r21, 0x00	; 0
    128e:	26 81       	ldd	r18, Z+6	; 0x06
    1290:	37 81       	ldd	r19, Z+7	; 0x07
    1292:	24 0f       	add	r18, r20
    1294:	35 1f       	adc	r19, r21
    1296:	37 83       	std	Z+7, r19	; 0x07
    1298:	26 83       	std	Z+6, r18	; 0x06
    129a:	62 81       	ldd	r22, Z+2	; 0x02
    129c:	73 81       	ldd	r23, Z+3	; 0x03
    129e:	26 17       	cp	r18, r22
    12a0:	37 07       	cpc	r19, r23
    12a2:	20 f0       	brcs	.+8      	; 0x12ac <prvCopyDataFromQueue+0x2a>
    12a4:	20 81       	ld	r18, Z
    12a6:	31 81       	ldd	r19, Z+1	; 0x01
    12a8:	37 83       	std	Z+7, r19	; 0x07
    12aa:	26 83       	std	Z+6, r18	; 0x06
    12ac:	66 81       	ldd	r22, Z+6	; 0x06
    12ae:	77 81       	ldd	r23, Z+7	; 0x07
    12b0:	0c 94 0f 1c 	jmp	0x381e	; 0x381e <memcpy>
    12b4:	08 95       	ret

000012b6 <prvUnlockQueue>:
    12b6:	0f 93       	push	r16
    12b8:	1f 93       	push	r17
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	ec 01       	movw	r28, r24
    12c0:	0f b6       	in	r0, 0x3f	; 63
    12c2:	f8 94       	cli
    12c4:	0f 92       	push	r0
    12c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12c8:	18 16       	cp	r1, r24
    12ca:	a4 f4       	brge	.+40     	; 0x12f4 <prvUnlockQueue+0x3e>
    12cc:	89 89       	ldd	r24, Y+17	; 0x11
    12ce:	88 23       	and	r24, r24
    12d0:	89 f0       	breq	.+34     	; 0x12f4 <prvUnlockQueue+0x3e>
    12d2:	8e 01       	movw	r16, r28
    12d4:	0f 5e       	subi	r16, 0xEF	; 239
    12d6:	1f 4f       	sbci	r17, 0xFF	; 255
    12d8:	03 c0       	rjmp	.+6      	; 0x12e0 <prvUnlockQueue+0x2a>
    12da:	89 89       	ldd	r24, Y+17	; 0x11
    12dc:	88 23       	and	r24, r24
    12de:	51 f0       	breq	.+20     	; 0x12f4 <prvUnlockQueue+0x3e>
    12e0:	c8 01       	movw	r24, r16
    12e2:	c6 d5       	rcall	.+2956   	; 0x1e70 <xTaskRemoveFromEventList>
    12e4:	81 11       	cpse	r24, r1
    12e6:	49 d6       	rcall	.+3218   	; 0x1f7a <vTaskMissedYield>
    12e8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12ea:	81 50       	subi	r24, 0x01	; 1
    12ec:	8e 8f       	std	Y+30, r24	; 0x1e
    12ee:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12f0:	18 16       	cp	r1, r24
    12f2:	9c f3       	brlt	.-26     	; 0x12da <prvUnlockQueue+0x24>
    12f4:	8f ef       	ldi	r24, 0xFF	; 255
    12f6:	8e 8f       	std	Y+30, r24	; 0x1e
    12f8:	0f 90       	pop	r0
    12fa:	0f be       	out	0x3f, r0	; 63
    12fc:	0f b6       	in	r0, 0x3f	; 63
    12fe:	f8 94       	cli
    1300:	0f 92       	push	r0
    1302:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1304:	18 16       	cp	r1, r24
    1306:	a4 f4       	brge	.+40     	; 0x1330 <prvUnlockQueue+0x7a>
    1308:	88 85       	ldd	r24, Y+8	; 0x08
    130a:	88 23       	and	r24, r24
    130c:	89 f0       	breq	.+34     	; 0x1330 <prvUnlockQueue+0x7a>
    130e:	8e 01       	movw	r16, r28
    1310:	08 5f       	subi	r16, 0xF8	; 248
    1312:	1f 4f       	sbci	r17, 0xFF	; 255
    1314:	03 c0       	rjmp	.+6      	; 0x131c <prvUnlockQueue+0x66>
    1316:	88 85       	ldd	r24, Y+8	; 0x08
    1318:	88 23       	and	r24, r24
    131a:	51 f0       	breq	.+20     	; 0x1330 <prvUnlockQueue+0x7a>
    131c:	c8 01       	movw	r24, r16
    131e:	a8 d5       	rcall	.+2896   	; 0x1e70 <xTaskRemoveFromEventList>
    1320:	81 11       	cpse	r24, r1
    1322:	2b d6       	rcall	.+3158   	; 0x1f7a <vTaskMissedYield>
    1324:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1326:	81 50       	subi	r24, 0x01	; 1
    1328:	8d 8f       	std	Y+29, r24	; 0x1d
    132a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    132c:	18 16       	cp	r1, r24
    132e:	9c f3       	brlt	.-26     	; 0x1316 <prvUnlockQueue+0x60>
    1330:	8f ef       	ldi	r24, 0xFF	; 255
    1332:	8d 8f       	std	Y+29, r24	; 0x1d
    1334:	0f 90       	pop	r0
    1336:	0f be       	out	0x3f, r0	; 63
    1338:	df 91       	pop	r29
    133a:	cf 91       	pop	r28
    133c:	1f 91       	pop	r17
    133e:	0f 91       	pop	r16
    1340:	08 95       	ret

00001342 <xQueueGenericReset>:
    1342:	cf 93       	push	r28
    1344:	df 93       	push	r29
    1346:	ec 01       	movw	r28, r24
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	0f 92       	push	r0
    134e:	88 81       	ld	r24, Y
    1350:	99 81       	ldd	r25, Y+1	; 0x01
    1352:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1354:	30 e0       	ldi	r19, 0x00	; 0
    1356:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1358:	72 9f       	mul	r23, r18
    135a:	a0 01       	movw	r20, r0
    135c:	73 9f       	mul	r23, r19
    135e:	50 0d       	add	r21, r0
    1360:	11 24       	eor	r1, r1
    1362:	fc 01       	movw	r30, r24
    1364:	e4 0f       	add	r30, r20
    1366:	f5 1f       	adc	r31, r21
    1368:	fb 83       	std	Y+3, r31	; 0x03
    136a:	ea 83       	std	Y+2, r30	; 0x02
    136c:	1a 8e       	std	Y+26, r1	; 0x1a
    136e:	9d 83       	std	Y+5, r25	; 0x05
    1370:	8c 83       	std	Y+4, r24	; 0x04
    1372:	42 1b       	sub	r20, r18
    1374:	53 0b       	sbc	r21, r19
    1376:	84 0f       	add	r24, r20
    1378:	95 1f       	adc	r25, r21
    137a:	9f 83       	std	Y+7, r25	; 0x07
    137c:	8e 83       	std	Y+6, r24	; 0x06
    137e:	8f ef       	ldi	r24, 0xFF	; 255
    1380:	8d 8f       	std	Y+29, r24	; 0x1d
    1382:	8e 8f       	std	Y+30, r24	; 0x1e
    1384:	61 11       	cpse	r22, r1
    1386:	0a c0       	rjmp	.+20     	; 0x139c <xQueueGenericReset+0x5a>
    1388:	88 85       	ldd	r24, Y+8	; 0x08
    138a:	88 23       	and	r24, r24
    138c:	69 f0       	breq	.+26     	; 0x13a8 <xQueueGenericReset+0x66>
    138e:	ce 01       	movw	r24, r28
    1390:	08 96       	adiw	r24, 0x08	; 8
    1392:	6e d5       	rcall	.+2780   	; 0x1e70 <xTaskRemoveFromEventList>
    1394:	81 30       	cpi	r24, 0x01	; 1
    1396:	41 f4       	brne	.+16     	; 0x13a8 <xQueueGenericReset+0x66>
    1398:	1c de       	rcall	.-968    	; 0xfd2 <vPortYield>
    139a:	06 c0       	rjmp	.+12     	; 0x13a8 <xQueueGenericReset+0x66>
    139c:	ce 01       	movw	r24, r28
    139e:	08 96       	adiw	r24, 0x08	; 8
    13a0:	d6 dc       	rcall	.-1620   	; 0xd4e <vListInitialise>
    13a2:	ce 01       	movw	r24, r28
    13a4:	41 96       	adiw	r24, 0x11	; 17
    13a6:	d3 dc       	rcall	.-1626   	; 0xd4e <vListInitialise>
    13a8:	0f 90       	pop	r0
    13aa:	0f be       	out	0x3f, r0	; 63
    13ac:	81 e0       	ldi	r24, 0x01	; 1
    13ae:	df 91       	pop	r29
    13b0:	cf 91       	pop	r28
    13b2:	08 95       	ret

000013b4 <xQueueGenericCreate>:
    13b4:	0f 93       	push	r16
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
    13bc:	08 2f       	mov	r16, r24
    13be:	16 2f       	mov	r17, r22
    13c0:	66 23       	and	r22, r22
    13c2:	b9 f0       	breq	.+46     	; 0x13f2 <xQueueGenericCreate+0x3e>
    13c4:	86 9f       	mul	r24, r22
    13c6:	c0 01       	movw	r24, r0
    13c8:	11 24       	eor	r1, r1
    13ca:	80 96       	adiw	r24, 0x20	; 32
    13cc:	d9 de       	rcall	.-590    	; 0x1180 <pvPortMalloc>
    13ce:	ec 01       	movw	r28, r24
    13d0:	00 97       	sbiw	r24, 0x00	; 0
    13d2:	21 f4       	brne	.+8      	; 0x13dc <xQueueGenericCreate+0x28>
    13d4:	14 c0       	rjmp	.+40     	; 0x13fe <xQueueGenericCreate+0x4a>
    13d6:	d9 83       	std	Y+1, r29	; 0x01
    13d8:	c8 83       	st	Y, r28
    13da:	05 c0       	rjmp	.+10     	; 0x13e6 <xQueueGenericCreate+0x32>
    13dc:	9c 01       	movw	r18, r24
    13de:	21 5e       	subi	r18, 0xE1	; 225
    13e0:	3f 4f       	sbci	r19, 0xFF	; 255
    13e2:	39 83       	std	Y+1, r19	; 0x01
    13e4:	28 83       	st	Y, r18
    13e6:	0b 8f       	std	Y+27, r16	; 0x1b
    13e8:	1c 8f       	std	Y+28, r17	; 0x1c
    13ea:	61 e0       	ldi	r22, 0x01	; 1
    13ec:	ce 01       	movw	r24, r28
    13ee:	a9 df       	rcall	.-174    	; 0x1342 <xQueueGenericReset>
    13f0:	06 c0       	rjmp	.+12     	; 0x13fe <xQueueGenericCreate+0x4a>
    13f2:	8f e1       	ldi	r24, 0x1F	; 31
    13f4:	90 e0       	ldi	r25, 0x00	; 0
    13f6:	c4 de       	rcall	.-632    	; 0x1180 <pvPortMalloc>
    13f8:	ec 01       	movw	r28, r24
    13fa:	00 97       	sbiw	r24, 0x00	; 0
    13fc:	61 f7       	brne	.-40     	; 0x13d6 <xQueueGenericCreate+0x22>
    13fe:	ce 01       	movw	r24, r28
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	1f 91       	pop	r17
    1406:	0f 91       	pop	r16
    1408:	08 95       	ret

0000140a <xQueueGenericSend>:
    140a:	9f 92       	push	r9
    140c:	af 92       	push	r10
    140e:	bf 92       	push	r11
    1410:	cf 92       	push	r12
    1412:	df 92       	push	r13
    1414:	ef 92       	push	r14
    1416:	ff 92       	push	r15
    1418:	0f 93       	push	r16
    141a:	1f 93       	push	r17
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	00 d0       	rcall	.+0      	; 0x1422 <xQueueGenericSend+0x18>
    1422:	1f 92       	push	r1
    1424:	1f 92       	push	r1
    1426:	cd b7       	in	r28, 0x3d	; 61
    1428:	de b7       	in	r29, 0x3e	; 62
    142a:	8c 01       	movw	r16, r24
    142c:	6b 01       	movw	r12, r22
    142e:	5d 83       	std	Y+5, r21	; 0x05
    1430:	4c 83       	std	Y+4, r20	; 0x04
    1432:	a2 2e       	mov	r10, r18
    1434:	b1 2c       	mov	r11, r1
    1436:	99 24       	eor	r9, r9
    1438:	93 94       	inc	r9
    143a:	7c 01       	movw	r14, r24
    143c:	88 e0       	ldi	r24, 0x08	; 8
    143e:	e8 0e       	add	r14, r24
    1440:	f1 1c       	adc	r15, r1
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	f8 94       	cli
    1446:	0f 92       	push	r0
    1448:	f8 01       	movw	r30, r16
    144a:	92 8d       	ldd	r25, Z+26	; 0x1a
    144c:	83 8d       	ldd	r24, Z+27	; 0x1b
    144e:	98 17       	cp	r25, r24
    1450:	18 f0       	brcs	.+6      	; 0x1458 <xQueueGenericSend+0x4e>
    1452:	f2 e0       	ldi	r31, 0x02	; 2
    1454:	af 12       	cpse	r10, r31
    1456:	15 c0       	rjmp	.+42     	; 0x1482 <xQueueGenericSend+0x78>
    1458:	4a 2d       	mov	r20, r10
    145a:	b6 01       	movw	r22, r12
    145c:	c8 01       	movw	r24, r16
    145e:	c4 de       	rcall	.-632    	; 0x11e8 <prvCopyDataToQueue>
    1460:	f8 01       	movw	r30, r16
    1462:	91 89       	ldd	r25, Z+17	; 0x11
    1464:	99 23       	and	r25, r25
    1466:	39 f0       	breq	.+14     	; 0x1476 <xQueueGenericSend+0x6c>
    1468:	c8 01       	movw	r24, r16
    146a:	41 96       	adiw	r24, 0x11	; 17
    146c:	01 d5       	rcall	.+2562   	; 0x1e70 <xTaskRemoveFromEventList>
    146e:	81 30       	cpi	r24, 0x01	; 1
    1470:	21 f4       	brne	.+8      	; 0x147a <xQueueGenericSend+0x70>
    1472:	af dd       	rcall	.-1186   	; 0xfd2 <vPortYield>
    1474:	02 c0       	rjmp	.+4      	; 0x147a <xQueueGenericSend+0x70>
    1476:	81 11       	cpse	r24, r1
    1478:	ac dd       	rcall	.-1192   	; 0xfd2 <vPortYield>
    147a:	0f 90       	pop	r0
    147c:	0f be       	out	0x3f, r0	; 63
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	46 c0       	rjmp	.+140    	; 0x150e <xQueueGenericSend+0x104>
    1482:	ec 81       	ldd	r30, Y+4	; 0x04
    1484:	fd 81       	ldd	r31, Y+5	; 0x05
    1486:	ef 2b       	or	r30, r31
    1488:	21 f4       	brne	.+8      	; 0x1492 <xQueueGenericSend+0x88>
    148a:	0f 90       	pop	r0
    148c:	0f be       	out	0x3f, r0	; 63
    148e:	80 e0       	ldi	r24, 0x00	; 0
    1490:	3e c0       	rjmp	.+124    	; 0x150e <xQueueGenericSend+0x104>
    1492:	b1 10       	cpse	r11, r1
    1494:	04 c0       	rjmp	.+8      	; 0x149e <xQueueGenericSend+0x94>
    1496:	ce 01       	movw	r24, r28
    1498:	01 96       	adiw	r24, 0x01	; 1
    149a:	32 d5       	rcall	.+2660   	; 0x1f00 <vTaskSetTimeOutState>
    149c:	b9 2c       	mov	r11, r9
    149e:	0f 90       	pop	r0
    14a0:	0f be       	out	0x3f, r0	; 63
    14a2:	d2 d2       	rcall	.+1444   	; 0x1a48 <vTaskSuspendAll>
    14a4:	0f b6       	in	r0, 0x3f	; 63
    14a6:	f8 94       	cli
    14a8:	0f 92       	push	r0
    14aa:	f8 01       	movw	r30, r16
    14ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    14ae:	8f 3f       	cpi	r24, 0xFF	; 255
    14b0:	09 f4       	brne	.+2      	; 0x14b4 <xQueueGenericSend+0xaa>
    14b2:	15 8e       	std	Z+29, r1	; 0x1d
    14b4:	f8 01       	movw	r30, r16
    14b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    14b8:	8f 3f       	cpi	r24, 0xFF	; 255
    14ba:	09 f4       	brne	.+2      	; 0x14be <xQueueGenericSend+0xb4>
    14bc:	16 8e       	std	Z+30, r1	; 0x1e
    14be:	0f 90       	pop	r0
    14c0:	0f be       	out	0x3f, r0	; 63
    14c2:	be 01       	movw	r22, r28
    14c4:	6c 5f       	subi	r22, 0xFC	; 252
    14c6:	7f 4f       	sbci	r23, 0xFF	; 255
    14c8:	ce 01       	movw	r24, r28
    14ca:	01 96       	adiw	r24, 0x01	; 1
    14cc:	24 d5       	rcall	.+2632   	; 0x1f16 <xTaskCheckForTimeOut>
    14ce:	81 11       	cpse	r24, r1
    14d0:	1a c0       	rjmp	.+52     	; 0x1506 <xQueueGenericSend+0xfc>
    14d2:	0f b6       	in	r0, 0x3f	; 63
    14d4:	f8 94       	cli
    14d6:	0f 92       	push	r0
    14d8:	f8 01       	movw	r30, r16
    14da:	92 8d       	ldd	r25, Z+26	; 0x1a
    14dc:	0f 90       	pop	r0
    14de:	0f be       	out	0x3f, r0	; 63
    14e0:	f8 01       	movw	r30, r16
    14e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    14e4:	98 13       	cpse	r25, r24
    14e6:	0b c0       	rjmp	.+22     	; 0x14fe <xQueueGenericSend+0xf4>
    14e8:	6c 81       	ldd	r22, Y+4	; 0x04
    14ea:	7d 81       	ldd	r23, Y+5	; 0x05
    14ec:	c7 01       	movw	r24, r14
    14ee:	88 d4       	rcall	.+2320   	; 0x1e00 <vTaskPlaceOnEventList>
    14f0:	c8 01       	movw	r24, r16
    14f2:	e1 de       	rcall	.-574    	; 0x12b6 <prvUnlockQueue>
    14f4:	74 d3       	rcall	.+1768   	; 0x1bde <xTaskResumeAll>
    14f6:	81 11       	cpse	r24, r1
    14f8:	a4 cf       	rjmp	.-184    	; 0x1442 <xQueueGenericSend+0x38>
    14fa:	6b dd       	rcall	.-1322   	; 0xfd2 <vPortYield>
    14fc:	a2 cf       	rjmp	.-188    	; 0x1442 <xQueueGenericSend+0x38>
    14fe:	c8 01       	movw	r24, r16
    1500:	da de       	rcall	.-588    	; 0x12b6 <prvUnlockQueue>
    1502:	6d d3       	rcall	.+1754   	; 0x1bde <xTaskResumeAll>
    1504:	9e cf       	rjmp	.-196    	; 0x1442 <xQueueGenericSend+0x38>
    1506:	c8 01       	movw	r24, r16
    1508:	d6 de       	rcall	.-596    	; 0x12b6 <prvUnlockQueue>
    150a:	69 d3       	rcall	.+1746   	; 0x1bde <xTaskResumeAll>
    150c:	80 e0       	ldi	r24, 0x00	; 0
    150e:	0f 90       	pop	r0
    1510:	0f 90       	pop	r0
    1512:	0f 90       	pop	r0
    1514:	0f 90       	pop	r0
    1516:	0f 90       	pop	r0
    1518:	df 91       	pop	r29
    151a:	cf 91       	pop	r28
    151c:	1f 91       	pop	r17
    151e:	0f 91       	pop	r16
    1520:	ff 90       	pop	r15
    1522:	ef 90       	pop	r14
    1524:	df 90       	pop	r13
    1526:	cf 90       	pop	r12
    1528:	bf 90       	pop	r11
    152a:	af 90       	pop	r10
    152c:	9f 90       	pop	r9
    152e:	08 95       	ret

00001530 <xQueueGenericSendFromISR>:
    1530:	0f 93       	push	r16
    1532:	1f 93       	push	r17
    1534:	cf 93       	push	r28
    1536:	df 93       	push	r29
    1538:	ec 01       	movw	r28, r24
    153a:	8a 01       	movw	r16, r20
    153c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    153e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1540:	98 17       	cp	r25, r24
    1542:	10 f0       	brcs	.+4      	; 0x1548 <xQueueGenericSendFromISR+0x18>
    1544:	22 30       	cpi	r18, 0x02	; 2
    1546:	d1 f4       	brne	.+52     	; 0x157c <xQueueGenericSendFromISR+0x4c>
    1548:	42 2f       	mov	r20, r18
    154a:	ce 01       	movw	r24, r28
    154c:	4d de       	rcall	.-870    	; 0x11e8 <prvCopyDataToQueue>
    154e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1550:	8f 3f       	cpi	r24, 0xFF	; 255
    1552:	79 f4       	brne	.+30     	; 0x1572 <xQueueGenericSendFromISR+0x42>
    1554:	89 89       	ldd	r24, Y+17	; 0x11
    1556:	88 23       	and	r24, r24
    1558:	99 f0       	breq	.+38     	; 0x1580 <xQueueGenericSendFromISR+0x50>
    155a:	ce 01       	movw	r24, r28
    155c:	41 96       	adiw	r24, 0x11	; 17
    155e:	88 d4       	rcall	.+2320   	; 0x1e70 <xTaskRemoveFromEventList>
    1560:	88 23       	and	r24, r24
    1562:	81 f0       	breq	.+32     	; 0x1584 <xQueueGenericSendFromISR+0x54>
    1564:	01 15       	cp	r16, r1
    1566:	11 05       	cpc	r17, r1
    1568:	79 f0       	breq	.+30     	; 0x1588 <xQueueGenericSendFromISR+0x58>
    156a:	81 e0       	ldi	r24, 0x01	; 1
    156c:	f8 01       	movw	r30, r16
    156e:	80 83       	st	Z, r24
    1570:	0c c0       	rjmp	.+24     	; 0x158a <xQueueGenericSendFromISR+0x5a>
    1572:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1574:	8f 5f       	subi	r24, 0xFF	; 255
    1576:	8e 8f       	std	Y+30, r24	; 0x1e
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	07 c0       	rjmp	.+14     	; 0x158a <xQueueGenericSendFromISR+0x5a>
    157c:	80 e0       	ldi	r24, 0x00	; 0
    157e:	05 c0       	rjmp	.+10     	; 0x158a <xQueueGenericSendFromISR+0x5a>
    1580:	81 e0       	ldi	r24, 0x01	; 1
    1582:	03 c0       	rjmp	.+6      	; 0x158a <xQueueGenericSendFromISR+0x5a>
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	01 c0       	rjmp	.+2      	; 0x158a <xQueueGenericSendFromISR+0x5a>
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	df 91       	pop	r29
    158c:	cf 91       	pop	r28
    158e:	1f 91       	pop	r17
    1590:	0f 91       	pop	r16
    1592:	08 95       	ret

00001594 <xQueueGiveFromISR>:
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	fc 01       	movw	r30, r24
    159a:	eb 01       	movw	r28, r22
    159c:	92 8d       	ldd	r25, Z+26	; 0x1a
    159e:	83 8d       	ldd	r24, Z+27	; 0x1b
    15a0:	98 17       	cp	r25, r24
    15a2:	c0 f4       	brcc	.+48     	; 0x15d4 <xQueueGiveFromISR+0x40>
    15a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    15a6:	8f 5f       	subi	r24, 0xFF	; 255
    15a8:	82 8f       	std	Z+26, r24	; 0x1a
    15aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    15ac:	8f 3f       	cpi	r24, 0xFF	; 255
    15ae:	69 f4       	brne	.+26     	; 0x15ca <xQueueGiveFromISR+0x36>
    15b0:	81 89       	ldd	r24, Z+17	; 0x11
    15b2:	88 23       	and	r24, r24
    15b4:	89 f0       	breq	.+34     	; 0x15d8 <xQueueGiveFromISR+0x44>
    15b6:	cf 01       	movw	r24, r30
    15b8:	41 96       	adiw	r24, 0x11	; 17
    15ba:	5a d4       	rcall	.+2228   	; 0x1e70 <xTaskRemoveFromEventList>
    15bc:	88 23       	and	r24, r24
    15be:	71 f0       	breq	.+28     	; 0x15dc <xQueueGiveFromISR+0x48>
    15c0:	20 97       	sbiw	r28, 0x00	; 0
    15c2:	71 f0       	breq	.+28     	; 0x15e0 <xQueueGiveFromISR+0x4c>
    15c4:	81 e0       	ldi	r24, 0x01	; 1
    15c6:	88 83       	st	Y, r24
    15c8:	0c c0       	rjmp	.+24     	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    15cc:	8f 5f       	subi	r24, 0xFF	; 255
    15ce:	86 8f       	std	Z+30, r24	; 0x1e
    15d0:	81 e0       	ldi	r24, 0x01	; 1
    15d2:	07 c0       	rjmp	.+14     	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	05 c0       	rjmp	.+10     	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15d8:	81 e0       	ldi	r24, 0x01	; 1
    15da:	03 c0       	rjmp	.+6      	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15dc:	81 e0       	ldi	r24, 0x01	; 1
    15de:	01 c0       	rjmp	.+2      	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15e0:	81 e0       	ldi	r24, 0x01	; 1
    15e2:	df 91       	pop	r29
    15e4:	cf 91       	pop	r28
    15e6:	08 95       	ret

000015e8 <xQueueGenericReceive>:
    15e8:	9f 92       	push	r9
    15ea:	af 92       	push	r10
    15ec:	bf 92       	push	r11
    15ee:	cf 92       	push	r12
    15f0:	df 92       	push	r13
    15f2:	ef 92       	push	r14
    15f4:	ff 92       	push	r15
    15f6:	0f 93       	push	r16
    15f8:	1f 93       	push	r17
    15fa:	cf 93       	push	r28
    15fc:	df 93       	push	r29
    15fe:	00 d0       	rcall	.+0      	; 0x1600 <xQueueGenericReceive+0x18>
    1600:	1f 92       	push	r1
    1602:	1f 92       	push	r1
    1604:	cd b7       	in	r28, 0x3d	; 61
    1606:	de b7       	in	r29, 0x3e	; 62
    1608:	8c 01       	movw	r16, r24
    160a:	6b 01       	movw	r12, r22
    160c:	5d 83       	std	Y+5, r21	; 0x05
    160e:	4c 83       	std	Y+4, r20	; 0x04
    1610:	b2 2e       	mov	r11, r18
    1612:	a1 2c       	mov	r10, r1
    1614:	99 24       	eor	r9, r9
    1616:	93 94       	inc	r9
    1618:	7c 01       	movw	r14, r24
    161a:	81 e1       	ldi	r24, 0x11	; 17
    161c:	e8 0e       	add	r14, r24
    161e:	f1 1c       	adc	r15, r1
    1620:	0f b6       	in	r0, 0x3f	; 63
    1622:	f8 94       	cli
    1624:	0f 92       	push	r0
    1626:	f8 01       	movw	r30, r16
    1628:	82 8d       	ldd	r24, Z+26	; 0x1a
    162a:	88 23       	and	r24, r24
    162c:	21 f1       	breq	.+72     	; 0x1676 <xQueueGenericReceive+0x8e>
    162e:	e6 80       	ldd	r14, Z+6	; 0x06
    1630:	f7 80       	ldd	r15, Z+7	; 0x07
    1632:	b6 01       	movw	r22, r12
    1634:	c8 01       	movw	r24, r16
    1636:	25 de       	rcall	.-950    	; 0x1282 <prvCopyDataFromQueue>
    1638:	b1 10       	cpse	r11, r1
    163a:	0e c0       	rjmp	.+28     	; 0x1658 <xQueueGenericReceive+0x70>
    163c:	f8 01       	movw	r30, r16
    163e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1640:	81 50       	subi	r24, 0x01	; 1
    1642:	82 8f       	std	Z+26, r24	; 0x1a
    1644:	80 85       	ldd	r24, Z+8	; 0x08
    1646:	88 23       	and	r24, r24
    1648:	91 f0       	breq	.+36     	; 0x166e <xQueueGenericReceive+0x86>
    164a:	c8 01       	movw	r24, r16
    164c:	08 96       	adiw	r24, 0x08	; 8
    164e:	10 d4       	rcall	.+2080   	; 0x1e70 <xTaskRemoveFromEventList>
    1650:	81 30       	cpi	r24, 0x01	; 1
    1652:	69 f4       	brne	.+26     	; 0x166e <xQueueGenericReceive+0x86>
    1654:	be dc       	rcall	.-1668   	; 0xfd2 <vPortYield>
    1656:	0b c0       	rjmp	.+22     	; 0x166e <xQueueGenericReceive+0x86>
    1658:	f8 01       	movw	r30, r16
    165a:	f7 82       	std	Z+7, r15	; 0x07
    165c:	e6 82       	std	Z+6, r14	; 0x06
    165e:	81 89       	ldd	r24, Z+17	; 0x11
    1660:	88 23       	and	r24, r24
    1662:	29 f0       	breq	.+10     	; 0x166e <xQueueGenericReceive+0x86>
    1664:	c8 01       	movw	r24, r16
    1666:	41 96       	adiw	r24, 0x11	; 17
    1668:	03 d4       	rcall	.+2054   	; 0x1e70 <xTaskRemoveFromEventList>
    166a:	81 11       	cpse	r24, r1
    166c:	b2 dc       	rcall	.-1692   	; 0xfd2 <vPortYield>
    166e:	0f 90       	pop	r0
    1670:	0f be       	out	0x3f, r0	; 63
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	44 c0       	rjmp	.+136    	; 0x16fe <xQueueGenericReceive+0x116>
    1676:	4c 81       	ldd	r20, Y+4	; 0x04
    1678:	5d 81       	ldd	r21, Y+5	; 0x05
    167a:	45 2b       	or	r20, r21
    167c:	21 f4       	brne	.+8      	; 0x1686 <xQueueGenericReceive+0x9e>
    167e:	0f 90       	pop	r0
    1680:	0f be       	out	0x3f, r0	; 63
    1682:	80 e0       	ldi	r24, 0x00	; 0
    1684:	3c c0       	rjmp	.+120    	; 0x16fe <xQueueGenericReceive+0x116>
    1686:	a1 10       	cpse	r10, r1
    1688:	04 c0       	rjmp	.+8      	; 0x1692 <xQueueGenericReceive+0xaa>
    168a:	ce 01       	movw	r24, r28
    168c:	01 96       	adiw	r24, 0x01	; 1
    168e:	38 d4       	rcall	.+2160   	; 0x1f00 <vTaskSetTimeOutState>
    1690:	a9 2c       	mov	r10, r9
    1692:	0f 90       	pop	r0
    1694:	0f be       	out	0x3f, r0	; 63
    1696:	d8 d1       	rcall	.+944    	; 0x1a48 <vTaskSuspendAll>
    1698:	0f b6       	in	r0, 0x3f	; 63
    169a:	f8 94       	cli
    169c:	0f 92       	push	r0
    169e:	f8 01       	movw	r30, r16
    16a0:	85 8d       	ldd	r24, Z+29	; 0x1d
    16a2:	8f 3f       	cpi	r24, 0xFF	; 255
    16a4:	09 f4       	brne	.+2      	; 0x16a8 <xQueueGenericReceive+0xc0>
    16a6:	15 8e       	std	Z+29, r1	; 0x1d
    16a8:	f8 01       	movw	r30, r16
    16aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    16ac:	8f 3f       	cpi	r24, 0xFF	; 255
    16ae:	09 f4       	brne	.+2      	; 0x16b2 <xQueueGenericReceive+0xca>
    16b0:	16 8e       	std	Z+30, r1	; 0x1e
    16b2:	0f 90       	pop	r0
    16b4:	0f be       	out	0x3f, r0	; 63
    16b6:	be 01       	movw	r22, r28
    16b8:	6c 5f       	subi	r22, 0xFC	; 252
    16ba:	7f 4f       	sbci	r23, 0xFF	; 255
    16bc:	ce 01       	movw	r24, r28
    16be:	01 96       	adiw	r24, 0x01	; 1
    16c0:	2a d4       	rcall	.+2132   	; 0x1f16 <xTaskCheckForTimeOut>
    16c2:	81 11       	cpse	r24, r1
    16c4:	18 c0       	rjmp	.+48     	; 0x16f6 <xQueueGenericReceive+0x10e>
    16c6:	0f b6       	in	r0, 0x3f	; 63
    16c8:	f8 94       	cli
    16ca:	0f 92       	push	r0
    16cc:	f8 01       	movw	r30, r16
    16ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	81 11       	cpse	r24, r1
    16d6:	0b c0       	rjmp	.+22     	; 0x16ee <xQueueGenericReceive+0x106>
    16d8:	6c 81       	ldd	r22, Y+4	; 0x04
    16da:	7d 81       	ldd	r23, Y+5	; 0x05
    16dc:	c7 01       	movw	r24, r14
    16de:	90 d3       	rcall	.+1824   	; 0x1e00 <vTaskPlaceOnEventList>
    16e0:	c8 01       	movw	r24, r16
    16e2:	e9 dd       	rcall	.-1070   	; 0x12b6 <prvUnlockQueue>
    16e4:	7c d2       	rcall	.+1272   	; 0x1bde <xTaskResumeAll>
    16e6:	81 11       	cpse	r24, r1
    16e8:	9b cf       	rjmp	.-202    	; 0x1620 <xQueueGenericReceive+0x38>
    16ea:	73 dc       	rcall	.-1818   	; 0xfd2 <vPortYield>
    16ec:	99 cf       	rjmp	.-206    	; 0x1620 <xQueueGenericReceive+0x38>
    16ee:	c8 01       	movw	r24, r16
    16f0:	e2 dd       	rcall	.-1084   	; 0x12b6 <prvUnlockQueue>
    16f2:	75 d2       	rcall	.+1258   	; 0x1bde <xTaskResumeAll>
    16f4:	95 cf       	rjmp	.-214    	; 0x1620 <xQueueGenericReceive+0x38>
    16f6:	c8 01       	movw	r24, r16
    16f8:	de dd       	rcall	.-1092   	; 0x12b6 <prvUnlockQueue>
    16fa:	71 d2       	rcall	.+1250   	; 0x1bde <xTaskResumeAll>
    16fc:	80 e0       	ldi	r24, 0x00	; 0
    16fe:	0f 90       	pop	r0
    1700:	0f 90       	pop	r0
    1702:	0f 90       	pop	r0
    1704:	0f 90       	pop	r0
    1706:	0f 90       	pop	r0
    1708:	df 91       	pop	r29
    170a:	cf 91       	pop	r28
    170c:	1f 91       	pop	r17
    170e:	0f 91       	pop	r16
    1710:	ff 90       	pop	r15
    1712:	ef 90       	pop	r14
    1714:	df 90       	pop	r13
    1716:	cf 90       	pop	r12
    1718:	bf 90       	pop	r11
    171a:	af 90       	pop	r10
    171c:	9f 90       	pop	r9
    171e:	08 95       	ret

00001720 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	f8 94       	cli
    172a:	0f 92       	push	r0
    172c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    172e:	8f 3f       	cpi	r24, 0xFF	; 255
    1730:	09 f4       	brne	.+2      	; 0x1734 <vQueueWaitForMessageRestricted+0x14>
    1732:	1d 8e       	std	Y+29, r1	; 0x1d
    1734:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1736:	8f 3f       	cpi	r24, 0xFF	; 255
    1738:	09 f4       	brne	.+2      	; 0x173c <vQueueWaitForMessageRestricted+0x1c>
    173a:	1e 8e       	std	Y+30, r1	; 0x1e
    173c:	0f 90       	pop	r0
    173e:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1740:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1742:	81 11       	cpse	r24, r1
    1744:	03 c0       	rjmp	.+6      	; 0x174c <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1746:	ce 01       	movw	r24, r28
    1748:	41 96       	adiw	r24, 0x11	; 17
    174a:	76 d3       	rcall	.+1772   	; 0x1e38 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    174c:	ce 01       	movw	r24, r28
    174e:	b3 dd       	rcall	.-1178   	; 0x12b6 <prvUnlockQueue>
	}
    1750:	df 91       	pop	r29
    1752:	cf 91       	pop	r28
    1754:	08 95       	ret

00001756 <prvResetNextTaskUnblockTime>:
    1756:	e0 91 9f 0d 	lds	r30, 0x0D9F
    175a:	f0 91 a0 0d 	lds	r31, 0x0DA0
    175e:	80 81       	ld	r24, Z
    1760:	81 11       	cpse	r24, r1
    1762:	07 c0       	rjmp	.+14     	; 0x1772 <prvResetNextTaskUnblockTime+0x1c>
    1764:	8f ef       	ldi	r24, 0xFF	; 255
    1766:	9f ef       	ldi	r25, 0xFF	; 255
    1768:	90 93 4a 02 	sts	0x024A, r25
    176c:	80 93 49 02 	sts	0x0249, r24
    1770:	08 95       	ret
    1772:	e0 91 9f 0d 	lds	r30, 0x0D9F
    1776:	f0 91 a0 0d 	lds	r31, 0x0DA0
    177a:	05 80       	ldd	r0, Z+5	; 0x05
    177c:	f6 81       	ldd	r31, Z+6	; 0x06
    177e:	e0 2d       	mov	r30, r0
    1780:	06 80       	ldd	r0, Z+6	; 0x06
    1782:	f7 81       	ldd	r31, Z+7	; 0x07
    1784:	e0 2d       	mov	r30, r0
    1786:	82 81       	ldd	r24, Z+2	; 0x02
    1788:	93 81       	ldd	r25, Z+3	; 0x03
    178a:	90 93 4a 02 	sts	0x024A, r25
    178e:	80 93 49 02 	sts	0x0249, r24
    1792:	08 95       	ret

00001794 <prvAddCurrentTaskToDelayedList>:
    1794:	cf 93       	push	r28
    1796:	df 93       	push	r29
    1798:	ec 01       	movw	r28, r24
    179a:	e0 91 d7 0d 	lds	r30, 0x0DD7
    179e:	f0 91 d8 0d 	lds	r31, 0x0DD8
    17a2:	93 83       	std	Z+3, r25	; 0x03
    17a4:	82 83       	std	Z+2, r24	; 0x02
    17a6:	80 91 87 0d 	lds	r24, 0x0D87
    17aa:	90 91 88 0d 	lds	r25, 0x0D88
    17ae:	c8 17       	cp	r28, r24
    17b0:	d9 07       	cpc	r29, r25
    17b2:	60 f4       	brcc	.+24     	; 0x17cc <prvAddCurrentTaskToDelayedList+0x38>
    17b4:	60 91 d7 0d 	lds	r22, 0x0DD7
    17b8:	70 91 d8 0d 	lds	r23, 0x0DD8
    17bc:	80 91 9d 0d 	lds	r24, 0x0D9D
    17c0:	90 91 9e 0d 	lds	r25, 0x0D9E
    17c4:	6e 5f       	subi	r22, 0xFE	; 254
    17c6:	7f 4f       	sbci	r23, 0xFF	; 255
    17c8:	f5 da       	rcall	.-2582   	; 0xdb4 <vListInsert>
    17ca:	16 c0       	rjmp	.+44     	; 0x17f8 <prvAddCurrentTaskToDelayedList+0x64>
    17cc:	60 91 d7 0d 	lds	r22, 0x0DD7
    17d0:	70 91 d8 0d 	lds	r23, 0x0DD8
    17d4:	80 91 9f 0d 	lds	r24, 0x0D9F
    17d8:	90 91 a0 0d 	lds	r25, 0x0DA0
    17dc:	6e 5f       	subi	r22, 0xFE	; 254
    17de:	7f 4f       	sbci	r23, 0xFF	; 255
    17e0:	e9 da       	rcall	.-2606   	; 0xdb4 <vListInsert>
    17e2:	80 91 49 02 	lds	r24, 0x0249
    17e6:	90 91 4a 02 	lds	r25, 0x024A
    17ea:	c8 17       	cp	r28, r24
    17ec:	d9 07       	cpc	r29, r25
    17ee:	20 f4       	brcc	.+8      	; 0x17f8 <prvAddCurrentTaskToDelayedList+0x64>
    17f0:	d0 93 4a 02 	sts	0x024A, r29
    17f4:	c0 93 49 02 	sts	0x0249, r28
    17f8:	df 91       	pop	r29
    17fa:	cf 91       	pop	r28
    17fc:	08 95       	ret

000017fe <xTaskGenericCreate>:
    17fe:	4f 92       	push	r4
    1800:	5f 92       	push	r5
    1802:	6f 92       	push	r6
    1804:	7f 92       	push	r7
    1806:	8f 92       	push	r8
    1808:	9f 92       	push	r9
    180a:	af 92       	push	r10
    180c:	bf 92       	push	r11
    180e:	cf 92       	push	r12
    1810:	df 92       	push	r13
    1812:	ef 92       	push	r14
    1814:	ff 92       	push	r15
    1816:	0f 93       	push	r16
    1818:	1f 93       	push	r17
    181a:	cf 93       	push	r28
    181c:	df 93       	push	r29
    181e:	4c 01       	movw	r8, r24
    1820:	5b 01       	movw	r10, r22
    1822:	2a 01       	movw	r4, r20
    1824:	39 01       	movw	r6, r18
    1826:	c1 14       	cp	r12, r1
    1828:	d1 04       	cpc	r13, r1
    182a:	31 f4       	brne	.+12     	; 0x1838 <xTaskGenericCreate+0x3a>
    182c:	ca 01       	movw	r24, r20
    182e:	a8 dc       	rcall	.-1712   	; 0x1180 <pvPortMalloc>
    1830:	6c 01       	movw	r12, r24
    1832:	00 97       	sbiw	r24, 0x00	; 0
    1834:	09 f4       	brne	.+2      	; 0x1838 <xTaskGenericCreate+0x3a>
    1836:	ca c0       	rjmp	.+404    	; 0x19cc <xTaskGenericCreate+0x1ce>
    1838:	86 e2       	ldi	r24, 0x26	; 38
    183a:	90 e0       	ldi	r25, 0x00	; 0
    183c:	a1 dc       	rcall	.-1726   	; 0x1180 <pvPortMalloc>
    183e:	ec 01       	movw	r28, r24
    1840:	00 97       	sbiw	r24, 0x00	; 0
    1842:	71 f0       	breq	.+28     	; 0x1860 <xTaskGenericCreate+0x62>
    1844:	d8 8e       	std	Y+24, r13	; 0x18
    1846:	cf 8a       	std	Y+23, r12	; 0x17
    1848:	81 e0       	ldi	r24, 0x01	; 1
    184a:	48 1a       	sub	r4, r24
    184c:	51 08       	sbc	r5, r1
    184e:	c4 0c       	add	r12, r4
    1850:	d5 1c       	adc	r13, r5
    1852:	d5 01       	movw	r26, r10
    1854:	8c 91       	ld	r24, X
    1856:	89 8f       	std	Y+25, r24	; 0x19
    1858:	8c 91       	ld	r24, X
    185a:	81 11       	cpse	r24, r1
    185c:	04 c0       	rjmp	.+8      	; 0x1866 <xTaskGenericCreate+0x68>
    185e:	14 c0       	rjmp	.+40     	; 0x1888 <xTaskGenericCreate+0x8a>
    1860:	c6 01       	movw	r24, r12
    1862:	c1 dc       	rcall	.-1662   	; 0x11e6 <vPortFree>
    1864:	b3 c0       	rjmp	.+358    	; 0x19cc <xTaskGenericCreate+0x1ce>
    1866:	ae 01       	movw	r20, r28
    1868:	46 5e       	subi	r20, 0xE6	; 230
    186a:	5f 4f       	sbci	r21, 0xFF	; 255
    186c:	f5 01       	movw	r30, r10
    186e:	31 96       	adiw	r30, 0x01	; 1
    1870:	27 e0       	ldi	r18, 0x07	; 7
    1872:	cf 01       	movw	r24, r30
    1874:	31 91       	ld	r19, Z+
    1876:	da 01       	movw	r26, r20
    1878:	3d 93       	st	X+, r19
    187a:	ad 01       	movw	r20, r26
    187c:	dc 01       	movw	r26, r24
    187e:	8c 91       	ld	r24, X
    1880:	88 23       	and	r24, r24
    1882:	11 f0       	breq	.+4      	; 0x1888 <xTaskGenericCreate+0x8a>
    1884:	21 50       	subi	r18, 0x01	; 1
    1886:	a9 f7       	brne	.-22     	; 0x1872 <xTaskGenericCreate+0x74>
    1888:	18 a2       	std	Y+32, r1	; 0x20
    188a:	10 2f       	mov	r17, r16
    188c:	04 30       	cpi	r16, 0x04	; 4
    188e:	08 f0       	brcs	.+2      	; 0x1892 <xTaskGenericCreate+0x94>
    1890:	13 e0       	ldi	r17, 0x03	; 3
    1892:	1e 8b       	std	Y+22, r17	; 0x16
    1894:	5e 01       	movw	r10, r28
    1896:	b2 e0       	ldi	r27, 0x02	; 2
    1898:	ab 0e       	add	r10, r27
    189a:	b1 1c       	adc	r11, r1
    189c:	c5 01       	movw	r24, r10
    189e:	65 da       	rcall	.-2870   	; 0xd6a <vListInitialiseItem>
    18a0:	ce 01       	movw	r24, r28
    18a2:	0c 96       	adiw	r24, 0x0c	; 12
    18a4:	62 da       	rcall	.-2876   	; 0xd6a <vListInitialiseItem>
    18a6:	d9 87       	std	Y+9, r29	; 0x09
    18a8:	c8 87       	std	Y+8, r28	; 0x08
    18aa:	84 e0       	ldi	r24, 0x04	; 4
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	81 1b       	sub	r24, r17
    18b0:	91 09       	sbc	r25, r1
    18b2:	9d 87       	std	Y+13, r25	; 0x0d
    18b4:	8c 87       	std	Y+12, r24	; 0x0c
    18b6:	db 8b       	std	Y+19, r29	; 0x13
    18b8:	ca 8b       	std	Y+18, r28	; 0x12
    18ba:	19 a2       	std	Y+33, r1	; 0x21
    18bc:	1a a2       	std	Y+34, r1	; 0x22
    18be:	1b a2       	std	Y+35, r1	; 0x23
    18c0:	1c a2       	std	Y+36, r1	; 0x24
    18c2:	1d a2       	std	Y+37, r1	; 0x25
    18c4:	a3 01       	movw	r20, r6
    18c6:	b4 01       	movw	r22, r8
    18c8:	c6 01       	movw	r24, r12
    18ca:	cb da       	rcall	.-2666   	; 0xe62 <pxPortInitialiseStack>
    18cc:	99 83       	std	Y+1, r25	; 0x01
    18ce:	88 83       	st	Y, r24
    18d0:	e1 14       	cp	r14, r1
    18d2:	f1 04       	cpc	r15, r1
    18d4:	19 f0       	breq	.+6      	; 0x18dc <xTaskGenericCreate+0xde>
    18d6:	f7 01       	movw	r30, r14
    18d8:	d1 83       	std	Z+1, r29	; 0x01
    18da:	c0 83       	st	Z, r28
    18dc:	0f b6       	in	r0, 0x3f	; 63
    18de:	f8 94       	cli
    18e0:	0f 92       	push	r0
    18e2:	80 91 89 0d 	lds	r24, 0x0D89
    18e6:	8f 5f       	subi	r24, 0xFF	; 255
    18e8:	80 93 89 0d 	sts	0x0D89, r24
    18ec:	80 91 d7 0d 	lds	r24, 0x0DD7
    18f0:	90 91 d8 0d 	lds	r25, 0x0DD8
    18f4:	89 2b       	or	r24, r25
    18f6:	69 f5       	brne	.+90     	; 0x1952 <xTaskGenericCreate+0x154>
    18f8:	d0 93 d8 0d 	sts	0x0DD8, r29
    18fc:	c0 93 d7 0d 	sts	0x0DD7, r28
    1900:	80 91 89 0d 	lds	r24, 0x0D89
    1904:	81 30       	cpi	r24, 0x01	; 1
    1906:	a1 f5       	brne	.+104    	; 0x1970 <xTaskGenericCreate+0x172>
    1908:	83 eb       	ldi	r24, 0xB3	; 179
    190a:	9d e0       	ldi	r25, 0x0D	; 13
    190c:	20 da       	rcall	.-3008   	; 0xd4e <vListInitialise>
    190e:	8c eb       	ldi	r24, 0xBC	; 188
    1910:	9d e0       	ldi	r25, 0x0D	; 13
    1912:	1d da       	rcall	.-3014   	; 0xd4e <vListInitialise>
    1914:	85 ec       	ldi	r24, 0xC5	; 197
    1916:	9d e0       	ldi	r25, 0x0D	; 13
    1918:	1a da       	rcall	.-3020   	; 0xd4e <vListInitialise>
    191a:	8e ec       	ldi	r24, 0xCE	; 206
    191c:	9d e0       	ldi	r25, 0x0D	; 13
    191e:	17 da       	rcall	.-3026   	; 0xd4e <vListInitialise>
    1920:	8a ea       	ldi	r24, 0xAA	; 170
    1922:	9d e0       	ldi	r25, 0x0D	; 13
    1924:	14 da       	rcall	.-3032   	; 0xd4e <vListInitialise>
    1926:	81 ea       	ldi	r24, 0xA1	; 161
    1928:	9d e0       	ldi	r25, 0x0D	; 13
    192a:	11 da       	rcall	.-3038   	; 0xd4e <vListInitialise>
    192c:	84 e9       	ldi	r24, 0x94	; 148
    192e:	9d e0       	ldi	r25, 0x0D	; 13
    1930:	0e da       	rcall	.-3044   	; 0xd4e <vListInitialise>
    1932:	8b e8       	ldi	r24, 0x8B	; 139
    1934:	9d e0       	ldi	r25, 0x0D	; 13
    1936:	0b da       	rcall	.-3050   	; 0xd4e <vListInitialise>
    1938:	8a ea       	ldi	r24, 0xAA	; 170
    193a:	9d e0       	ldi	r25, 0x0D	; 13
    193c:	90 93 a0 0d 	sts	0x0DA0, r25
    1940:	80 93 9f 0d 	sts	0x0D9F, r24
    1944:	81 ea       	ldi	r24, 0xA1	; 161
    1946:	9d e0       	ldi	r25, 0x0D	; 13
    1948:	90 93 9e 0d 	sts	0x0D9E, r25
    194c:	80 93 9d 0d 	sts	0x0D9D, r24
    1950:	0f c0       	rjmp	.+30     	; 0x1970 <xTaskGenericCreate+0x172>
    1952:	80 91 85 0d 	lds	r24, 0x0D85
    1956:	81 11       	cpse	r24, r1
    1958:	0b c0       	rjmp	.+22     	; 0x1970 <xTaskGenericCreate+0x172>
    195a:	e0 91 d7 0d 	lds	r30, 0x0DD7
    195e:	f0 91 d8 0d 	lds	r31, 0x0DD8
    1962:	86 89       	ldd	r24, Z+22	; 0x16
    1964:	08 17       	cp	r16, r24
    1966:	20 f0       	brcs	.+8      	; 0x1970 <xTaskGenericCreate+0x172>
    1968:	d0 93 d8 0d 	sts	0x0DD8, r29
    196c:	c0 93 d7 0d 	sts	0x0DD7, r28
    1970:	80 91 81 0d 	lds	r24, 0x0D81
    1974:	8f 5f       	subi	r24, 0xFF	; 255
    1976:	80 93 81 0d 	sts	0x0D81, r24
    197a:	8e 89       	ldd	r24, Y+22	; 0x16
    197c:	90 91 86 0d 	lds	r25, 0x0D86
    1980:	98 17       	cp	r25, r24
    1982:	10 f4       	brcc	.+4      	; 0x1988 <xTaskGenericCreate+0x18a>
    1984:	80 93 86 0d 	sts	0x0D86, r24
    1988:	90 e0       	ldi	r25, 0x00	; 0
    198a:	9c 01       	movw	r18, r24
    198c:	22 0f       	add	r18, r18
    198e:	33 1f       	adc	r19, r19
    1990:	22 0f       	add	r18, r18
    1992:	33 1f       	adc	r19, r19
    1994:	22 0f       	add	r18, r18
    1996:	33 1f       	adc	r19, r19
    1998:	82 0f       	add	r24, r18
    199a:	93 1f       	adc	r25, r19
    199c:	b5 01       	movw	r22, r10
    199e:	8d 54       	subi	r24, 0x4D	; 77
    19a0:	92 4f       	sbci	r25, 0xF2	; 242
    19a2:	e7 d9       	rcall	.-3122   	; 0xd72 <vListInsertEnd>
    19a4:	0f 90       	pop	r0
    19a6:	0f be       	out	0x3f, r0	; 63
    19a8:	80 91 85 0d 	lds	r24, 0x0D85
    19ac:	88 23       	and	r24, r24
    19ae:	51 f0       	breq	.+20     	; 0x19c4 <xTaskGenericCreate+0x1c6>
    19b0:	e0 91 d7 0d 	lds	r30, 0x0DD7
    19b4:	f0 91 d8 0d 	lds	r31, 0x0DD8
    19b8:	86 89       	ldd	r24, Z+22	; 0x16
    19ba:	80 17       	cp	r24, r16
    19bc:	28 f4       	brcc	.+10     	; 0x19c8 <xTaskGenericCreate+0x1ca>
    19be:	09 db       	rcall	.-2542   	; 0xfd2 <vPortYield>
    19c0:	81 e0       	ldi	r24, 0x01	; 1
    19c2:	05 c0       	rjmp	.+10     	; 0x19ce <xTaskGenericCreate+0x1d0>
    19c4:	81 e0       	ldi	r24, 0x01	; 1
    19c6:	03 c0       	rjmp	.+6      	; 0x19ce <xTaskGenericCreate+0x1d0>
    19c8:	81 e0       	ldi	r24, 0x01	; 1
    19ca:	01 c0       	rjmp	.+2      	; 0x19ce <xTaskGenericCreate+0x1d0>
    19cc:	8f ef       	ldi	r24, 0xFF	; 255
    19ce:	df 91       	pop	r29
    19d0:	cf 91       	pop	r28
    19d2:	1f 91       	pop	r17
    19d4:	0f 91       	pop	r16
    19d6:	ff 90       	pop	r15
    19d8:	ef 90       	pop	r14
    19da:	df 90       	pop	r13
    19dc:	cf 90       	pop	r12
    19de:	bf 90       	pop	r11
    19e0:	af 90       	pop	r10
    19e2:	9f 90       	pop	r9
    19e4:	8f 90       	pop	r8
    19e6:	7f 90       	pop	r7
    19e8:	6f 90       	pop	r6
    19ea:	5f 90       	pop	r5
    19ec:	4f 90       	pop	r4
    19ee:	08 95       	ret

000019f0 <vTaskStartScheduler>:
    19f0:	af 92       	push	r10
    19f2:	bf 92       	push	r11
    19f4:	cf 92       	push	r12
    19f6:	df 92       	push	r13
    19f8:	ef 92       	push	r14
    19fa:	ff 92       	push	r15
    19fc:	0f 93       	push	r16
    19fe:	a1 2c       	mov	r10, r1
    1a00:	b1 2c       	mov	r11, r1
    1a02:	c1 2c       	mov	r12, r1
    1a04:	d1 2c       	mov	r13, r1
    1a06:	e1 2c       	mov	r14, r1
    1a08:	f1 2c       	mov	r15, r1
    1a0a:	00 e0       	ldi	r16, 0x00	; 0
    1a0c:	20 e0       	ldi	r18, 0x00	; 0
    1a0e:	30 e0       	ldi	r19, 0x00	; 0
    1a10:	49 eb       	ldi	r20, 0xB9	; 185
    1a12:	50 e0       	ldi	r21, 0x00	; 0
    1a14:	66 e8       	ldi	r22, 0x86	; 134
    1a16:	72 e0       	ldi	r23, 0x02	; 2
    1a18:	81 ea       	ldi	r24, 0xA1	; 161
    1a1a:	90 e0       	ldi	r25, 0x00	; 0
    1a1c:	f0 de       	rcall	.-544    	; 0x17fe <xTaskGenericCreate>
    1a1e:	81 30       	cpi	r24, 0x01	; 1
    1a20:	59 f4       	brne	.+22     	; 0x1a38 <vTaskStartScheduler+0x48>
    1a22:	14 d3       	rcall	.+1576   	; 0x204c <xTimerCreateTimerTask>
    1a24:	81 30       	cpi	r24, 0x01	; 1
    1a26:	41 f4       	brne	.+16     	; 0x1a38 <vTaskStartScheduler+0x48>
    1a28:	f8 94       	cli
    1a2a:	80 93 85 0d 	sts	0x0D85, r24
    1a2e:	10 92 88 0d 	sts	0x0D88, r1
    1a32:	10 92 87 0d 	sts	0x0D87, r1
    1a36:	87 da       	rcall	.-2802   	; 0xf46 <xPortStartScheduler>
    1a38:	0f 91       	pop	r16
    1a3a:	ff 90       	pop	r15
    1a3c:	ef 90       	pop	r14
    1a3e:	df 90       	pop	r13
    1a40:	cf 90       	pop	r12
    1a42:	bf 90       	pop	r11
    1a44:	af 90       	pop	r10
    1a46:	08 95       	ret

00001a48 <vTaskSuspendAll>:
    1a48:	80 91 80 0d 	lds	r24, 0x0D80
    1a4c:	8f 5f       	subi	r24, 0xFF	; 255
    1a4e:	80 93 80 0d 	sts	0x0D80, r24
    1a52:	08 95       	ret

00001a54 <xTaskGetTickCount>:
    1a54:	0f b6       	in	r0, 0x3f	; 63
    1a56:	f8 94       	cli
    1a58:	0f 92       	push	r0
    1a5a:	80 91 87 0d 	lds	r24, 0x0D87
    1a5e:	90 91 88 0d 	lds	r25, 0x0D88
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	08 95       	ret

00001a68 <xTaskIncrementTick>:
    1a68:	cf 92       	push	r12
    1a6a:	df 92       	push	r13
    1a6c:	ef 92       	push	r14
    1a6e:	ff 92       	push	r15
    1a70:	0f 93       	push	r16
    1a72:	1f 93       	push	r17
    1a74:	cf 93       	push	r28
    1a76:	df 93       	push	r29
    1a78:	80 91 80 0d 	lds	r24, 0x0D80
    1a7c:	81 11       	cpse	r24, r1
    1a7e:	96 c0       	rjmp	.+300    	; 0x1bac <xTaskIncrementTick+0x144>
    1a80:	80 91 87 0d 	lds	r24, 0x0D87
    1a84:	90 91 88 0d 	lds	r25, 0x0D88
    1a88:	01 96       	adiw	r24, 0x01	; 1
    1a8a:	90 93 88 0d 	sts	0x0D88, r25
    1a8e:	80 93 87 0d 	sts	0x0D87, r24
    1a92:	e0 90 87 0d 	lds	r14, 0x0D87
    1a96:	f0 90 88 0d 	lds	r15, 0x0D88
    1a9a:	e1 14       	cp	r14, r1
    1a9c:	f1 04       	cpc	r15, r1
    1a9e:	b1 f4       	brne	.+44     	; 0x1acc <xTaskIncrementTick+0x64>
    1aa0:	80 91 9f 0d 	lds	r24, 0x0D9F
    1aa4:	90 91 a0 0d 	lds	r25, 0x0DA0
    1aa8:	20 91 9d 0d 	lds	r18, 0x0D9D
    1aac:	30 91 9e 0d 	lds	r19, 0x0D9E
    1ab0:	30 93 a0 0d 	sts	0x0DA0, r19
    1ab4:	20 93 9f 0d 	sts	0x0D9F, r18
    1ab8:	90 93 9e 0d 	sts	0x0D9E, r25
    1abc:	80 93 9d 0d 	sts	0x0D9D, r24
    1ac0:	80 91 82 0d 	lds	r24, 0x0D82
    1ac4:	8f 5f       	subi	r24, 0xFF	; 255
    1ac6:	80 93 82 0d 	sts	0x0D82, r24
    1aca:	45 de       	rcall	.-886    	; 0x1756 <prvResetNextTaskUnblockTime>
    1acc:	80 91 49 02 	lds	r24, 0x0249
    1ad0:	90 91 4a 02 	lds	r25, 0x024A
    1ad4:	e8 16       	cp	r14, r24
    1ad6:	f9 06       	cpc	r15, r25
    1ad8:	08 f4       	brcc	.+2      	; 0x1adc <xTaskIncrementTick+0x74>
    1ada:	51 c0       	rjmp	.+162    	; 0x1b7e <xTaskIncrementTick+0x116>
    1adc:	d1 2c       	mov	r13, r1
    1ade:	cc 24       	eor	r12, r12
    1ae0:	c3 94       	inc	r12
    1ae2:	01 c0       	rjmp	.+2      	; 0x1ae6 <xTaskIncrementTick+0x7e>
    1ae4:	dc 2c       	mov	r13, r12
    1ae6:	e0 91 9f 0d 	lds	r30, 0x0D9F
    1aea:	f0 91 a0 0d 	lds	r31, 0x0DA0
    1aee:	80 81       	ld	r24, Z
    1af0:	81 11       	cpse	r24, r1
    1af2:	07 c0       	rjmp	.+14     	; 0x1b02 <xTaskIncrementTick+0x9a>
    1af4:	8f ef       	ldi	r24, 0xFF	; 255
    1af6:	9f ef       	ldi	r25, 0xFF	; 255
    1af8:	90 93 4a 02 	sts	0x024A, r25
    1afc:	80 93 49 02 	sts	0x0249, r24
    1b00:	3f c0       	rjmp	.+126    	; 0x1b80 <xTaskIncrementTick+0x118>
    1b02:	e0 91 9f 0d 	lds	r30, 0x0D9F
    1b06:	f0 91 a0 0d 	lds	r31, 0x0DA0
    1b0a:	05 80       	ldd	r0, Z+5	; 0x05
    1b0c:	f6 81       	ldd	r31, Z+6	; 0x06
    1b0e:	e0 2d       	mov	r30, r0
    1b10:	c6 81       	ldd	r28, Z+6	; 0x06
    1b12:	d7 81       	ldd	r29, Z+7	; 0x07
    1b14:	2a 81       	ldd	r18, Y+2	; 0x02
    1b16:	3b 81       	ldd	r19, Y+3	; 0x03
    1b18:	e2 16       	cp	r14, r18
    1b1a:	f3 06       	cpc	r15, r19
    1b1c:	28 f4       	brcc	.+10     	; 0x1b28 <xTaskIncrementTick+0xc0>
    1b1e:	30 93 4a 02 	sts	0x024A, r19
    1b22:	20 93 49 02 	sts	0x0249, r18
    1b26:	2c c0       	rjmp	.+88     	; 0x1b80 <xTaskIncrementTick+0x118>
    1b28:	8e 01       	movw	r16, r28
    1b2a:	0e 5f       	subi	r16, 0xFE	; 254
    1b2c:	1f 4f       	sbci	r17, 0xFF	; 255
    1b2e:	c8 01       	movw	r24, r16
    1b30:	72 d9       	rcall	.-3356   	; 0xe16 <uxListRemove>
    1b32:	8c 89       	ldd	r24, Y+20	; 0x14
    1b34:	9d 89       	ldd	r25, Y+21	; 0x15
    1b36:	89 2b       	or	r24, r25
    1b38:	19 f0       	breq	.+6      	; 0x1b40 <xTaskIncrementTick+0xd8>
    1b3a:	ce 01       	movw	r24, r28
    1b3c:	0c 96       	adiw	r24, 0x0c	; 12
    1b3e:	6b d9       	rcall	.-3370   	; 0xe16 <uxListRemove>
    1b40:	2e 89       	ldd	r18, Y+22	; 0x16
    1b42:	80 91 86 0d 	lds	r24, 0x0D86
    1b46:	82 17       	cp	r24, r18
    1b48:	10 f4       	brcc	.+4      	; 0x1b4e <xTaskIncrementTick+0xe6>
    1b4a:	20 93 86 0d 	sts	0x0D86, r18
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	c9 01       	movw	r24, r18
    1b52:	88 0f       	add	r24, r24
    1b54:	99 1f       	adc	r25, r25
    1b56:	88 0f       	add	r24, r24
    1b58:	99 1f       	adc	r25, r25
    1b5a:	88 0f       	add	r24, r24
    1b5c:	99 1f       	adc	r25, r25
    1b5e:	82 0f       	add	r24, r18
    1b60:	93 1f       	adc	r25, r19
    1b62:	b8 01       	movw	r22, r16
    1b64:	8d 54       	subi	r24, 0x4D	; 77
    1b66:	92 4f       	sbci	r25, 0xF2	; 242
    1b68:	04 d9       	rcall	.-3576   	; 0xd72 <vListInsertEnd>
    1b6a:	e0 91 d7 0d 	lds	r30, 0x0DD7
    1b6e:	f0 91 d8 0d 	lds	r31, 0x0DD8
    1b72:	9e 89       	ldd	r25, Y+22	; 0x16
    1b74:	86 89       	ldd	r24, Z+22	; 0x16
    1b76:	98 17       	cp	r25, r24
    1b78:	08 f0       	brcs	.+2      	; 0x1b7c <xTaskIncrementTick+0x114>
    1b7a:	b4 cf       	rjmp	.-152    	; 0x1ae4 <xTaskIncrementTick+0x7c>
    1b7c:	b4 cf       	rjmp	.-152    	; 0x1ae6 <xTaskIncrementTick+0x7e>
    1b7e:	d1 2c       	mov	r13, r1
    1b80:	e0 91 d7 0d 	lds	r30, 0x0DD7
    1b84:	f0 91 d8 0d 	lds	r31, 0x0DD8
    1b88:	86 89       	ldd	r24, Z+22	; 0x16
    1b8a:	90 e0       	ldi	r25, 0x00	; 0
    1b8c:	fc 01       	movw	r30, r24
    1b8e:	ee 0f       	add	r30, r30
    1b90:	ff 1f       	adc	r31, r31
    1b92:	ee 0f       	add	r30, r30
    1b94:	ff 1f       	adc	r31, r31
    1b96:	ee 0f       	add	r30, r30
    1b98:	ff 1f       	adc	r31, r31
    1b9a:	8e 0f       	add	r24, r30
    1b9c:	9f 1f       	adc	r25, r31
    1b9e:	fc 01       	movw	r30, r24
    1ba0:	ed 54       	subi	r30, 0x4D	; 77
    1ba2:	f2 4f       	sbci	r31, 0xF2	; 242
    1ba4:	80 81       	ld	r24, Z
    1ba6:	82 30       	cpi	r24, 0x02	; 2
    1ba8:	40 f4       	brcc	.+16     	; 0x1bba <xTaskIncrementTick+0x152>
    1baa:	09 c0       	rjmp	.+18     	; 0x1bbe <xTaskIncrementTick+0x156>
    1bac:	80 91 84 0d 	lds	r24, 0x0D84
    1bb0:	8f 5f       	subi	r24, 0xFF	; 255
    1bb2:	80 93 84 0d 	sts	0x0D84, r24
    1bb6:	d1 2c       	mov	r13, r1
    1bb8:	02 c0       	rjmp	.+4      	; 0x1bbe <xTaskIncrementTick+0x156>
    1bba:	dd 24       	eor	r13, r13
    1bbc:	d3 94       	inc	r13
    1bbe:	80 91 83 0d 	lds	r24, 0x0D83
    1bc2:	88 23       	and	r24, r24
    1bc4:	11 f0       	breq	.+4      	; 0x1bca <xTaskIncrementTick+0x162>
    1bc6:	dd 24       	eor	r13, r13
    1bc8:	d3 94       	inc	r13
    1bca:	8d 2d       	mov	r24, r13
    1bcc:	df 91       	pop	r29
    1bce:	cf 91       	pop	r28
    1bd0:	1f 91       	pop	r17
    1bd2:	0f 91       	pop	r16
    1bd4:	ff 90       	pop	r15
    1bd6:	ef 90       	pop	r14
    1bd8:	df 90       	pop	r13
    1bda:	cf 90       	pop	r12
    1bdc:	08 95       	ret

00001bde <xTaskResumeAll>:
    1bde:	df 92       	push	r13
    1be0:	ef 92       	push	r14
    1be2:	ff 92       	push	r15
    1be4:	0f 93       	push	r16
    1be6:	1f 93       	push	r17
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	0f b6       	in	r0, 0x3f	; 63
    1bee:	f8 94       	cli
    1bf0:	0f 92       	push	r0
    1bf2:	80 91 80 0d 	lds	r24, 0x0D80
    1bf6:	81 50       	subi	r24, 0x01	; 1
    1bf8:	80 93 80 0d 	sts	0x0D80, r24
    1bfc:	80 91 80 0d 	lds	r24, 0x0D80
    1c00:	81 11       	cpse	r24, r1
    1c02:	5c c0       	rjmp	.+184    	; 0x1cbc <xTaskResumeAll+0xde>
    1c04:	80 91 89 0d 	lds	r24, 0x0D89
    1c08:	88 23       	and	r24, r24
    1c0a:	09 f4       	brne	.+2      	; 0x1c0e <xTaskResumeAll+0x30>
    1c0c:	59 c0       	rjmp	.+178    	; 0x1cc0 <xTaskResumeAll+0xe2>
    1c0e:	0f 2e       	mov	r0, r31
    1c10:	f4 e9       	ldi	r31, 0x94	; 148
    1c12:	ef 2e       	mov	r14, r31
    1c14:	fd e0       	ldi	r31, 0x0D	; 13
    1c16:	ff 2e       	mov	r15, r31
    1c18:	f0 2d       	mov	r31, r0
    1c1a:	dd 24       	eor	r13, r13
    1c1c:	d3 94       	inc	r13
    1c1e:	2d c0       	rjmp	.+90     	; 0x1c7a <xTaskResumeAll+0x9c>
    1c20:	e0 91 99 0d 	lds	r30, 0x0D99
    1c24:	f0 91 9a 0d 	lds	r31, 0x0D9A
    1c28:	c6 81       	ldd	r28, Z+6	; 0x06
    1c2a:	d7 81       	ldd	r29, Z+7	; 0x07
    1c2c:	ce 01       	movw	r24, r28
    1c2e:	0c 96       	adiw	r24, 0x0c	; 12
    1c30:	f2 d8       	rcall	.-3612   	; 0xe16 <uxListRemove>
    1c32:	8e 01       	movw	r16, r28
    1c34:	0e 5f       	subi	r16, 0xFE	; 254
    1c36:	1f 4f       	sbci	r17, 0xFF	; 255
    1c38:	c8 01       	movw	r24, r16
    1c3a:	ed d8       	rcall	.-3622   	; 0xe16 <uxListRemove>
    1c3c:	8e 89       	ldd	r24, Y+22	; 0x16
    1c3e:	90 91 86 0d 	lds	r25, 0x0D86
    1c42:	98 17       	cp	r25, r24
    1c44:	10 f4       	brcc	.+4      	; 0x1c4a <xTaskResumeAll+0x6c>
    1c46:	80 93 86 0d 	sts	0x0D86, r24
    1c4a:	90 e0       	ldi	r25, 0x00	; 0
    1c4c:	9c 01       	movw	r18, r24
    1c4e:	22 0f       	add	r18, r18
    1c50:	33 1f       	adc	r19, r19
    1c52:	22 0f       	add	r18, r18
    1c54:	33 1f       	adc	r19, r19
    1c56:	22 0f       	add	r18, r18
    1c58:	33 1f       	adc	r19, r19
    1c5a:	82 0f       	add	r24, r18
    1c5c:	93 1f       	adc	r25, r19
    1c5e:	b8 01       	movw	r22, r16
    1c60:	8d 54       	subi	r24, 0x4D	; 77
    1c62:	92 4f       	sbci	r25, 0xF2	; 242
    1c64:	86 d8       	rcall	.-3828   	; 0xd72 <vListInsertEnd>
    1c66:	e0 91 d7 0d 	lds	r30, 0x0DD7
    1c6a:	f0 91 d8 0d 	lds	r31, 0x0DD8
    1c6e:	9e 89       	ldd	r25, Y+22	; 0x16
    1c70:	86 89       	ldd	r24, Z+22	; 0x16
    1c72:	98 17       	cp	r25, r24
    1c74:	10 f0       	brcs	.+4      	; 0x1c7a <xTaskResumeAll+0x9c>
    1c76:	d0 92 83 0d 	sts	0x0D83, r13
    1c7a:	f7 01       	movw	r30, r14
    1c7c:	80 81       	ld	r24, Z
    1c7e:	81 11       	cpse	r24, r1
    1c80:	cf cf       	rjmp	.-98     	; 0x1c20 <xTaskResumeAll+0x42>
    1c82:	80 91 84 0d 	lds	r24, 0x0D84
    1c86:	88 23       	and	r24, r24
    1c88:	91 f0       	breq	.+36     	; 0x1cae <xTaskResumeAll+0xd0>
    1c8a:	80 91 84 0d 	lds	r24, 0x0D84
    1c8e:	88 23       	and	r24, r24
    1c90:	71 f0       	breq	.+28     	; 0x1cae <xTaskResumeAll+0xd0>
    1c92:	c1 e0       	ldi	r28, 0x01	; 1
    1c94:	e9 de       	rcall	.-558    	; 0x1a68 <xTaskIncrementTick>
    1c96:	81 11       	cpse	r24, r1
    1c98:	c0 93 83 0d 	sts	0x0D83, r28
    1c9c:	80 91 84 0d 	lds	r24, 0x0D84
    1ca0:	81 50       	subi	r24, 0x01	; 1
    1ca2:	80 93 84 0d 	sts	0x0D84, r24
    1ca6:	80 91 84 0d 	lds	r24, 0x0D84
    1caa:	81 11       	cpse	r24, r1
    1cac:	f3 cf       	rjmp	.-26     	; 0x1c94 <xTaskResumeAll+0xb6>
    1cae:	80 91 83 0d 	lds	r24, 0x0D83
    1cb2:	81 30       	cpi	r24, 0x01	; 1
    1cb4:	39 f4       	brne	.+14     	; 0x1cc4 <xTaskResumeAll+0xe6>
    1cb6:	8d d9       	rcall	.-3302   	; 0xfd2 <vPortYield>
    1cb8:	81 e0       	ldi	r24, 0x01	; 1
    1cba:	05 c0       	rjmp	.+10     	; 0x1cc6 <xTaskResumeAll+0xe8>
    1cbc:	80 e0       	ldi	r24, 0x00	; 0
    1cbe:	03 c0       	rjmp	.+6      	; 0x1cc6 <xTaskResumeAll+0xe8>
    1cc0:	80 e0       	ldi	r24, 0x00	; 0
    1cc2:	01 c0       	rjmp	.+2      	; 0x1cc6 <xTaskResumeAll+0xe8>
    1cc4:	80 e0       	ldi	r24, 0x00	; 0
    1cc6:	0f 90       	pop	r0
    1cc8:	0f be       	out	0x3f, r0	; 63
    1cca:	df 91       	pop	r29
    1ccc:	cf 91       	pop	r28
    1cce:	1f 91       	pop	r17
    1cd0:	0f 91       	pop	r16
    1cd2:	ff 90       	pop	r15
    1cd4:	ef 90       	pop	r14
    1cd6:	df 90       	pop	r13
    1cd8:	08 95       	ret

00001cda <vTaskDelay>:
    1cda:	cf 93       	push	r28
    1cdc:	df 93       	push	r29
    1cde:	ec 01       	movw	r28, r24
    1ce0:	00 97       	sbiw	r24, 0x00	; 0
    1ce2:	91 f0       	breq	.+36     	; 0x1d08 <vTaskDelay+0x2e>
    1ce4:	b1 de       	rcall	.-670    	; 0x1a48 <vTaskSuspendAll>
    1ce6:	80 91 87 0d 	lds	r24, 0x0D87
    1cea:	90 91 88 0d 	lds	r25, 0x0D88
    1cee:	c8 0f       	add	r28, r24
    1cf0:	d9 1f       	adc	r29, r25
    1cf2:	80 91 d7 0d 	lds	r24, 0x0DD7
    1cf6:	90 91 d8 0d 	lds	r25, 0x0DD8
    1cfa:	02 96       	adiw	r24, 0x02	; 2
    1cfc:	8c d8       	rcall	.-3816   	; 0xe16 <uxListRemove>
    1cfe:	ce 01       	movw	r24, r28
    1d00:	49 dd       	rcall	.-1390   	; 0x1794 <prvAddCurrentTaskToDelayedList>
    1d02:	6d df       	rcall	.-294    	; 0x1bde <xTaskResumeAll>
    1d04:	81 11       	cpse	r24, r1
    1d06:	01 c0       	rjmp	.+2      	; 0x1d0a <vTaskDelay+0x30>
    1d08:	64 d9       	rcall	.-3384   	; 0xfd2 <vPortYield>
    1d0a:	df 91       	pop	r29
    1d0c:	cf 91       	pop	r28
    1d0e:	08 95       	ret

00001d10 <vTaskSwitchContext>:
    1d10:	80 91 80 0d 	lds	r24, 0x0D80
    1d14:	88 23       	and	r24, r24
    1d16:	21 f0       	breq	.+8      	; 0x1d20 <vTaskSwitchContext+0x10>
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	80 93 83 0d 	sts	0x0D83, r24
    1d1e:	08 95       	ret
    1d20:	10 92 83 0d 	sts	0x0D83, r1
    1d24:	a0 91 d7 0d 	lds	r26, 0x0DD7
    1d28:	b0 91 d8 0d 	lds	r27, 0x0DD8
    1d2c:	e0 91 d7 0d 	lds	r30, 0x0DD7
    1d30:	f0 91 d8 0d 	lds	r31, 0x0DD8
    1d34:	2d 91       	ld	r18, X+
    1d36:	3c 91       	ld	r19, X
    1d38:	87 89       	ldd	r24, Z+23	; 0x17
    1d3a:	90 8d       	ldd	r25, Z+24	; 0x18
    1d3c:	82 17       	cp	r24, r18
    1d3e:	93 07       	cpc	r25, r19
    1d40:	58 f0       	brcs	.+22     	; 0x1d58 <vTaskSwitchContext+0x48>
    1d42:	60 91 d7 0d 	lds	r22, 0x0DD7
    1d46:	70 91 d8 0d 	lds	r23, 0x0DD8
    1d4a:	80 91 d7 0d 	lds	r24, 0x0DD7
    1d4e:	90 91 d8 0d 	lds	r25, 0x0DD8
    1d52:	67 5e       	subi	r22, 0xE7	; 231
    1d54:	7f 4f       	sbci	r23, 0xFF	; 255
    1d56:	86 d6       	rcall	.+3340   	; 0x2a64 <vApplicationStackOverflowHook>
    1d58:	80 91 86 0d 	lds	r24, 0x0D86
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	fc 01       	movw	r30, r24
    1d60:	ee 0f       	add	r30, r30
    1d62:	ff 1f       	adc	r31, r31
    1d64:	ee 0f       	add	r30, r30
    1d66:	ff 1f       	adc	r31, r31
    1d68:	ee 0f       	add	r30, r30
    1d6a:	ff 1f       	adc	r31, r31
    1d6c:	8e 0f       	add	r24, r30
    1d6e:	9f 1f       	adc	r25, r31
    1d70:	fc 01       	movw	r30, r24
    1d72:	ed 54       	subi	r30, 0x4D	; 77
    1d74:	f2 4f       	sbci	r31, 0xF2	; 242
    1d76:	80 81       	ld	r24, Z
    1d78:	81 11       	cpse	r24, r1
    1d7a:	17 c0       	rjmp	.+46     	; 0x1daa <vTaskSwitchContext+0x9a>
    1d7c:	80 91 86 0d 	lds	r24, 0x0D86
    1d80:	81 50       	subi	r24, 0x01	; 1
    1d82:	80 93 86 0d 	sts	0x0D86, r24
    1d86:	80 91 86 0d 	lds	r24, 0x0D86
    1d8a:	90 e0       	ldi	r25, 0x00	; 0
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	ee 0f       	add	r30, r30
    1d90:	ff 1f       	adc	r31, r31
    1d92:	ee 0f       	add	r30, r30
    1d94:	ff 1f       	adc	r31, r31
    1d96:	ee 0f       	add	r30, r30
    1d98:	ff 1f       	adc	r31, r31
    1d9a:	8e 0f       	add	r24, r30
    1d9c:	9f 1f       	adc	r25, r31
    1d9e:	fc 01       	movw	r30, r24
    1da0:	ed 54       	subi	r30, 0x4D	; 77
    1da2:	f2 4f       	sbci	r31, 0xF2	; 242
    1da4:	80 81       	ld	r24, Z
    1da6:	88 23       	and	r24, r24
    1da8:	49 f3       	breq	.-46     	; 0x1d7c <vTaskSwitchContext+0x6c>
    1daa:	e0 91 86 0d 	lds	r30, 0x0D86
    1dae:	f0 e0       	ldi	r31, 0x00	; 0
    1db0:	cf 01       	movw	r24, r30
    1db2:	88 0f       	add	r24, r24
    1db4:	99 1f       	adc	r25, r25
    1db6:	88 0f       	add	r24, r24
    1db8:	99 1f       	adc	r25, r25
    1dba:	88 0f       	add	r24, r24
    1dbc:	99 1f       	adc	r25, r25
    1dbe:	e8 0f       	add	r30, r24
    1dc0:	f9 1f       	adc	r31, r25
    1dc2:	ed 54       	subi	r30, 0x4D	; 77
    1dc4:	f2 4f       	sbci	r31, 0xF2	; 242
    1dc6:	a1 81       	ldd	r26, Z+1	; 0x01
    1dc8:	b2 81       	ldd	r27, Z+2	; 0x02
    1dca:	12 96       	adiw	r26, 0x02	; 2
    1dcc:	0d 90       	ld	r0, X+
    1dce:	bc 91       	ld	r27, X
    1dd0:	a0 2d       	mov	r26, r0
    1dd2:	b2 83       	std	Z+2, r27	; 0x02
    1dd4:	a1 83       	std	Z+1, r26	; 0x01
    1dd6:	cf 01       	movw	r24, r30
    1dd8:	03 96       	adiw	r24, 0x03	; 3
    1dda:	a8 17       	cp	r26, r24
    1ddc:	b9 07       	cpc	r27, r25
    1dde:	31 f4       	brne	.+12     	; 0x1dec <vTaskSwitchContext+0xdc>
    1de0:	12 96       	adiw	r26, 0x02	; 2
    1de2:	8d 91       	ld	r24, X+
    1de4:	9c 91       	ld	r25, X
    1de6:	13 97       	sbiw	r26, 0x03	; 3
    1de8:	92 83       	std	Z+2, r25	; 0x02
    1dea:	81 83       	std	Z+1, r24	; 0x01
    1dec:	01 80       	ldd	r0, Z+1	; 0x01
    1dee:	f2 81       	ldd	r31, Z+2	; 0x02
    1df0:	e0 2d       	mov	r30, r0
    1df2:	86 81       	ldd	r24, Z+6	; 0x06
    1df4:	97 81       	ldd	r25, Z+7	; 0x07
    1df6:	90 93 d8 0d 	sts	0x0DD8, r25
    1dfa:	80 93 d7 0d 	sts	0x0DD7, r24
    1dfe:	08 95       	ret

00001e00 <vTaskPlaceOnEventList>:
    1e00:	cf 93       	push	r28
    1e02:	df 93       	push	r29
    1e04:	eb 01       	movw	r28, r22
    1e06:	60 91 d7 0d 	lds	r22, 0x0DD7
    1e0a:	70 91 d8 0d 	lds	r23, 0x0DD8
    1e0e:	64 5f       	subi	r22, 0xF4	; 244
    1e10:	7f 4f       	sbci	r23, 0xFF	; 255
    1e12:	0e 94 da 06 	call	0xdb4	; 0xdb4 <vListInsert>
    1e16:	80 91 d7 0d 	lds	r24, 0x0DD7
    1e1a:	90 91 d8 0d 	lds	r25, 0x0DD8
    1e1e:	02 96       	adiw	r24, 0x02	; 2
    1e20:	0e 94 0b 07 	call	0xe16	; 0xe16 <uxListRemove>
    1e24:	80 91 87 0d 	lds	r24, 0x0D87
    1e28:	90 91 88 0d 	lds	r25, 0x0D88
    1e2c:	8c 0f       	add	r24, r28
    1e2e:	9d 1f       	adc	r25, r29
    1e30:	b1 dc       	rcall	.-1694   	; 0x1794 <prvAddCurrentTaskToDelayedList>
    1e32:	df 91       	pop	r29
    1e34:	cf 91       	pop	r28
    1e36:	08 95       	ret

00001e38 <vTaskPlaceOnEventListRestricted>:
    1e38:	cf 93       	push	r28
    1e3a:	df 93       	push	r29
    1e3c:	eb 01       	movw	r28, r22
    1e3e:	60 91 d7 0d 	lds	r22, 0x0DD7
    1e42:	70 91 d8 0d 	lds	r23, 0x0DD8
    1e46:	64 5f       	subi	r22, 0xF4	; 244
    1e48:	7f 4f       	sbci	r23, 0xFF	; 255
    1e4a:	0e 94 b9 06 	call	0xd72	; 0xd72 <vListInsertEnd>
    1e4e:	80 91 d7 0d 	lds	r24, 0x0DD7
    1e52:	90 91 d8 0d 	lds	r25, 0x0DD8
    1e56:	02 96       	adiw	r24, 0x02	; 2
    1e58:	0e 94 0b 07 	call	0xe16	; 0xe16 <uxListRemove>
    1e5c:	80 91 87 0d 	lds	r24, 0x0D87
    1e60:	90 91 88 0d 	lds	r25, 0x0D88
    1e64:	8c 0f       	add	r24, r28
    1e66:	9d 1f       	adc	r25, r29
    1e68:	95 dc       	rcall	.-1750   	; 0x1794 <prvAddCurrentTaskToDelayedList>
    1e6a:	df 91       	pop	r29
    1e6c:	cf 91       	pop	r28
    1e6e:	08 95       	ret

00001e70 <xTaskRemoveFromEventList>:
    1e70:	0f 93       	push	r16
    1e72:	1f 93       	push	r17
    1e74:	cf 93       	push	r28
    1e76:	df 93       	push	r29
    1e78:	dc 01       	movw	r26, r24
    1e7a:	15 96       	adiw	r26, 0x05	; 5
    1e7c:	ed 91       	ld	r30, X+
    1e7e:	fc 91       	ld	r31, X
    1e80:	16 97       	sbiw	r26, 0x06	; 6
    1e82:	c6 81       	ldd	r28, Z+6	; 0x06
    1e84:	d7 81       	ldd	r29, Z+7	; 0x07
    1e86:	8e 01       	movw	r16, r28
    1e88:	04 5f       	subi	r16, 0xF4	; 244
    1e8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e8c:	c8 01       	movw	r24, r16
    1e8e:	0e 94 0b 07 	call	0xe16	; 0xe16 <uxListRemove>
    1e92:	80 91 80 0d 	lds	r24, 0x0D80
    1e96:	81 11       	cpse	r24, r1
    1e98:	1c c0       	rjmp	.+56     	; 0x1ed2 <xTaskRemoveFromEventList+0x62>
    1e9a:	0a 50       	subi	r16, 0x0A	; 10
    1e9c:	11 09       	sbc	r17, r1
    1e9e:	c8 01       	movw	r24, r16
    1ea0:	0e 94 0b 07 	call	0xe16	; 0xe16 <uxListRemove>
    1ea4:	8e 89       	ldd	r24, Y+22	; 0x16
    1ea6:	90 91 86 0d 	lds	r25, 0x0D86
    1eaa:	98 17       	cp	r25, r24
    1eac:	10 f4       	brcc	.+4      	; 0x1eb2 <xTaskRemoveFromEventList+0x42>
    1eae:	80 93 86 0d 	sts	0x0D86, r24
    1eb2:	90 e0       	ldi	r25, 0x00	; 0
    1eb4:	9c 01       	movw	r18, r24
    1eb6:	22 0f       	add	r18, r18
    1eb8:	33 1f       	adc	r19, r19
    1eba:	22 0f       	add	r18, r18
    1ebc:	33 1f       	adc	r19, r19
    1ebe:	22 0f       	add	r18, r18
    1ec0:	33 1f       	adc	r19, r19
    1ec2:	82 0f       	add	r24, r18
    1ec4:	93 1f       	adc	r25, r19
    1ec6:	b8 01       	movw	r22, r16
    1ec8:	8d 54       	subi	r24, 0x4D	; 77
    1eca:	92 4f       	sbci	r25, 0xF2	; 242
    1ecc:	0e 94 b9 06 	call	0xd72	; 0xd72 <vListInsertEnd>
    1ed0:	05 c0       	rjmp	.+10     	; 0x1edc <xTaskRemoveFromEventList+0x6c>
    1ed2:	b8 01       	movw	r22, r16
    1ed4:	84 e9       	ldi	r24, 0x94	; 148
    1ed6:	9d e0       	ldi	r25, 0x0D	; 13
    1ed8:	0e 94 b9 06 	call	0xd72	; 0xd72 <vListInsertEnd>
    1edc:	e0 91 d7 0d 	lds	r30, 0x0DD7
    1ee0:	f0 91 d8 0d 	lds	r31, 0x0DD8
    1ee4:	9e 89       	ldd	r25, Y+22	; 0x16
    1ee6:	86 89       	ldd	r24, Z+22	; 0x16
    1ee8:	89 17       	cp	r24, r25
    1eea:	20 f4       	brcc	.+8      	; 0x1ef4 <xTaskRemoveFromEventList+0x84>
    1eec:	81 e0       	ldi	r24, 0x01	; 1
    1eee:	80 93 83 0d 	sts	0x0D83, r24
    1ef2:	01 c0       	rjmp	.+2      	; 0x1ef6 <xTaskRemoveFromEventList+0x86>
    1ef4:	80 e0       	ldi	r24, 0x00	; 0
    1ef6:	df 91       	pop	r29
    1ef8:	cf 91       	pop	r28
    1efa:	1f 91       	pop	r17
    1efc:	0f 91       	pop	r16
    1efe:	08 95       	ret

00001f00 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1f00:	20 91 82 0d 	lds	r18, 0x0D82
    1f04:	fc 01       	movw	r30, r24
    1f06:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1f08:	20 91 87 0d 	lds	r18, 0x0D87
    1f0c:	30 91 88 0d 	lds	r19, 0x0D88
    1f10:	32 83       	std	Z+2, r19	; 0x02
    1f12:	21 83       	std	Z+1, r18	; 0x01
    1f14:	08 95       	ret

00001f16 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1f16:	0f b6       	in	r0, 0x3f	; 63
    1f18:	f8 94       	cli
    1f1a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1f1c:	20 91 87 0d 	lds	r18, 0x0D87
    1f20:	30 91 88 0d 	lds	r19, 0x0D88
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1f24:	40 91 82 0d 	lds	r20, 0x0D82
    1f28:	dc 01       	movw	r26, r24
    1f2a:	5c 91       	ld	r21, X
    1f2c:	54 17       	cp	r21, r20
    1f2e:	39 f0       	breq	.+14     	; 0x1f3e <xTaskCheckForTimeOut+0x28>
    1f30:	11 96       	adiw	r26, 0x01	; 1
    1f32:	4d 91       	ld	r20, X+
    1f34:	5c 91       	ld	r21, X
    1f36:	12 97       	sbiw	r26, 0x02	; 2
    1f38:	24 17       	cp	r18, r20
    1f3a:	35 07       	cpc	r19, r21
    1f3c:	c0 f4       	brcc	.+48     	; 0x1f6e <xTaskCheckForTimeOut+0x58>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    1f3e:	dc 01       	movw	r26, r24
    1f40:	11 96       	adiw	r26, 0x01	; 1
    1f42:	ed 91       	ld	r30, X+
    1f44:	fc 91       	ld	r31, X
    1f46:	12 97       	sbiw	r26, 0x02	; 2
    1f48:	db 01       	movw	r26, r22
    1f4a:	4d 91       	ld	r20, X+
    1f4c:	5c 91       	ld	r21, X
    1f4e:	d9 01       	movw	r26, r18
    1f50:	ae 1b       	sub	r26, r30
    1f52:	bf 0b       	sbc	r27, r31
    1f54:	a4 17       	cp	r26, r20
    1f56:	b5 07       	cpc	r27, r21
    1f58:	60 f4       	brcc	.+24     	; 0x1f72 <xTaskCheckForTimeOut+0x5c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    1f5a:	e2 1b       	sub	r30, r18
    1f5c:	f3 0b       	sbc	r31, r19
    1f5e:	4e 0f       	add	r20, r30
    1f60:	5f 1f       	adc	r21, r31
    1f62:	fb 01       	movw	r30, r22
    1f64:	51 83       	std	Z+1, r21	; 0x01
    1f66:	40 83       	st	Z, r20
			vTaskSetTimeOutState( pxTimeOut );
    1f68:	cb df       	rcall	.-106    	; 0x1f00 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1f6a:	80 e0       	ldi	r24, 0x00	; 0
    1f6c:	03 c0       	rjmp	.+6      	; 0x1f74 <xTaskCheckForTimeOut+0x5e>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	01 c0       	rjmp	.+2      	; 0x1f74 <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1f72:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1f74:	0f 90       	pop	r0
    1f76:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1f78:	08 95       	ret

00001f7a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1f7a:	81 e0       	ldi	r24, 0x01	; 1
    1f7c:	80 93 83 0d 	sts	0x0D83, r24
    1f80:	08 95       	ret

00001f82 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1f82:	80 91 85 0d 	lds	r24, 0x0D85
    1f86:	88 23       	and	r24, r24
    1f88:	31 f0       	breq	.+12     	; 0x1f96 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1f8a:	80 91 80 0d 	lds	r24, 0x0D80
    1f8e:	81 11       	cpse	r24, r1
    1f90:	04 c0       	rjmp	.+8      	; 0x1f9a <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
    1f92:	82 e0       	ldi	r24, 0x02	; 2
    1f94:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1f96:	81 e0       	ldi	r24, 0x01	; 1
    1f98:	08 95       	ret
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1f9a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}

		return xReturn;
	}
    1f9c:	08 95       	ret

00001f9e <prvInsertTimerInActiveList>:

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    1f9e:	fc 01       	movw	r30, r24
    1fa0:	73 83       	std	Z+3, r23	; 0x03
    1fa2:	62 83       	std	Z+2, r22	; 0x02
    1fa4:	91 87       	std	Z+9, r25	; 0x09
    1fa6:	80 87       	std	Z+8, r24	; 0x08
    1fa8:	46 17       	cp	r20, r22
    1faa:	57 07       	cpc	r21, r23
    1fac:	90 f0       	brcs	.+36     	; 0x1fd2 <prvInsertTimerInActiveList+0x34>
    1fae:	42 1b       	sub	r20, r18
    1fb0:	53 0b       	sbc	r21, r19
    1fb2:	84 85       	ldd	r24, Z+12	; 0x0c
    1fb4:	95 85       	ldd	r25, Z+13	; 0x0d
    1fb6:	48 17       	cp	r20, r24
    1fb8:	59 07       	cpc	r21, r25
    1fba:	e0 f4       	brcc	.+56     	; 0x1ff4 <prvInsertTimerInActiveList+0x56>
    1fbc:	bf 01       	movw	r22, r30
    1fbe:	6e 5f       	subi	r22, 0xFE	; 254
    1fc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc2:	80 91 dd 0d 	lds	r24, 0x0DDD
    1fc6:	90 91 de 0d 	lds	r25, 0x0DDE
    1fca:	0e 94 da 06 	call	0xdb4	; 0xdb4 <vListInsert>
    1fce:	80 e0       	ldi	r24, 0x00	; 0
    1fd0:	08 95       	ret
    1fd2:	42 17       	cp	r20, r18
    1fd4:	53 07       	cpc	r21, r19
    1fd6:	18 f4       	brcc	.+6      	; 0x1fde <prvInsertTimerInActiveList+0x40>
    1fd8:	62 17       	cp	r22, r18
    1fda:	73 07       	cpc	r23, r19
    1fdc:	68 f4       	brcc	.+26     	; 0x1ff8 <prvInsertTimerInActiveList+0x5a>
    1fde:	bf 01       	movw	r22, r30
    1fe0:	6e 5f       	subi	r22, 0xFE	; 254
    1fe2:	7f 4f       	sbci	r23, 0xFF	; 255
    1fe4:	80 91 df 0d 	lds	r24, 0x0DDF
    1fe8:	90 91 e0 0d 	lds	r25, 0x0DE0
    1fec:	0e 94 da 06 	call	0xdb4	; 0xdb4 <vListInsert>
    1ff0:	80 e0       	ldi	r24, 0x00	; 0
    1ff2:	08 95       	ret
    1ff4:	81 e0       	ldi	r24, 0x01	; 1
    1ff6:	08 95       	ret
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	08 95       	ret

00001ffc <prvCheckForValidListAndQueue>:
    1ffc:	0f b6       	in	r0, 0x3f	; 63
    1ffe:	f8 94       	cli
    2000:	0f 92       	push	r0
    2002:	80 91 db 0d 	lds	r24, 0x0DDB
    2006:	90 91 dc 0d 	lds	r25, 0x0DDC
    200a:	89 2b       	or	r24, r25
    200c:	e1 f4       	brne	.+56     	; 0x2046 <prvCheckForValidListAndQueue+0x4a>
    200e:	8a ee       	ldi	r24, 0xEA	; 234
    2010:	9d e0       	ldi	r25, 0x0D	; 13
    2012:	0e 94 a7 06 	call	0xd4e	; 0xd4e <vListInitialise>
    2016:	81 ee       	ldi	r24, 0xE1	; 225
    2018:	9d e0       	ldi	r25, 0x0D	; 13
    201a:	0e 94 a7 06 	call	0xd4e	; 0xd4e <vListInitialise>
    201e:	8a ee       	ldi	r24, 0xEA	; 234
    2020:	9d e0       	ldi	r25, 0x0D	; 13
    2022:	90 93 e0 0d 	sts	0x0DE0, r25
    2026:	80 93 df 0d 	sts	0x0DDF, r24
    202a:	81 ee       	ldi	r24, 0xE1	; 225
    202c:	9d e0       	ldi	r25, 0x0D	; 13
    202e:	90 93 de 0d 	sts	0x0DDE, r25
    2032:	80 93 dd 0d 	sts	0x0DDD, r24
    2036:	40 e0       	ldi	r20, 0x00	; 0
    2038:	65 e0       	ldi	r22, 0x05	; 5
    203a:	8a e0       	ldi	r24, 0x0A	; 10
    203c:	bb d9       	rcall	.-3210   	; 0x13b4 <xQueueGenericCreate>
    203e:	90 93 dc 0d 	sts	0x0DDC, r25
    2042:	80 93 db 0d 	sts	0x0DDB, r24
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63
    204a:	08 95       	ret

0000204c <xTimerCreateTimerTask>:
    204c:	af 92       	push	r10
    204e:	bf 92       	push	r11
    2050:	cf 92       	push	r12
    2052:	df 92       	push	r13
    2054:	ef 92       	push	r14
    2056:	ff 92       	push	r15
    2058:	0f 93       	push	r16
    205a:	d0 df       	rcall	.-96     	; 0x1ffc <prvCheckForValidListAndQueue>
    205c:	80 91 db 0d 	lds	r24, 0x0DDB
    2060:	90 91 dc 0d 	lds	r25, 0x0DDC
    2064:	89 2b       	or	r24, r25
    2066:	89 f0       	breq	.+34     	; 0x208a <xTimerCreateTimerTask+0x3e>
    2068:	a1 2c       	mov	r10, r1
    206a:	b1 2c       	mov	r11, r1
    206c:	c1 2c       	mov	r12, r1
    206e:	d1 2c       	mov	r13, r1
    2070:	e1 2c       	mov	r14, r1
    2072:	f1 2c       	mov	r15, r1
    2074:	05 e0       	ldi	r16, 0x05	; 5
    2076:	20 e0       	ldi	r18, 0x00	; 0
    2078:	30 e0       	ldi	r19, 0x00	; 0
    207a:	49 eb       	ldi	r20, 0xB9	; 185
    207c:	50 e0       	ldi	r21, 0x00	; 0
    207e:	6b e8       	ldi	r22, 0x8B	; 139
    2080:	72 e0       	ldi	r23, 0x02	; 2
    2082:	80 e0       	ldi	r24, 0x00	; 0
    2084:	91 e1       	ldi	r25, 0x11	; 17
    2086:	bb db       	rcall	.-2186   	; 0x17fe <xTaskGenericCreate>
    2088:	01 c0       	rjmp	.+2      	; 0x208c <xTimerCreateTimerTask+0x40>
    208a:	80 e0       	ldi	r24, 0x00	; 0
    208c:	0f 91       	pop	r16
    208e:	ff 90       	pop	r15
    2090:	ef 90       	pop	r14
    2092:	df 90       	pop	r13
    2094:	cf 90       	pop	r12
    2096:	bf 90       	pop	r11
    2098:	af 90       	pop	r10
    209a:	08 95       	ret

0000209c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    209c:	0f 93       	push	r16
    209e:	1f 93       	push	r17
    20a0:	cf 93       	push	r28
    20a2:	df 93       	push	r29
    20a4:	00 d0       	rcall	.+0      	; 0x20a6 <xTimerGenericCommand+0xa>
    20a6:	1f 92       	push	r1
    20a8:	1f 92       	push	r1
    20aa:	cd b7       	in	r28, 0x3d	; 61
    20ac:	de b7       	in	r29, 0x3e	; 62
    20ae:	d9 01       	movw	r26, r18
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    20b0:	e0 91 db 0d 	lds	r30, 0x0DDB
    20b4:	f0 91 dc 0d 	lds	r31, 0x0DDC
    20b8:	30 97       	sbiw	r30, 0x00	; 0
    20ba:	49 f1       	breq	.+82     	; 0x210e <xTimerGenericCommand+0x72>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    20bc:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    20be:	5b 83       	std	Y+3, r21	; 0x03
    20c0:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    20c2:	9d 83       	std	Y+5, r25	; 0x05
    20c4:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    20c6:	66 30       	cpi	r22, 0x06	; 6
    20c8:	d4 f4       	brge	.+52     	; 0x20fe <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    20ca:	5b df       	rcall	.-330    	; 0x1f82 <xTaskGetSchedulerState>
    20cc:	82 30       	cpi	r24, 0x02	; 2
    20ce:	59 f4       	brne	.+22     	; 0x20e6 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    20d0:	20 e0       	ldi	r18, 0x00	; 0
    20d2:	a8 01       	movw	r20, r16
    20d4:	be 01       	movw	r22, r28
    20d6:	6f 5f       	subi	r22, 0xFF	; 255
    20d8:	7f 4f       	sbci	r23, 0xFF	; 255
    20da:	80 91 db 0d 	lds	r24, 0x0DDB
    20de:	90 91 dc 0d 	lds	r25, 0x0DDC
    20e2:	93 d9       	rcall	.-3290   	; 0x140a <xQueueGenericSend>
    20e4:	15 c0       	rjmp	.+42     	; 0x2110 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    20e6:	20 e0       	ldi	r18, 0x00	; 0
    20e8:	40 e0       	ldi	r20, 0x00	; 0
    20ea:	50 e0       	ldi	r21, 0x00	; 0
    20ec:	be 01       	movw	r22, r28
    20ee:	6f 5f       	subi	r22, 0xFF	; 255
    20f0:	7f 4f       	sbci	r23, 0xFF	; 255
    20f2:	80 91 db 0d 	lds	r24, 0x0DDB
    20f6:	90 91 dc 0d 	lds	r25, 0x0DDC
    20fa:	87 d9       	rcall	.-3314   	; 0x140a <xQueueGenericSend>
    20fc:	09 c0       	rjmp	.+18     	; 0x2110 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    20fe:	20 e0       	ldi	r18, 0x00	; 0
    2100:	ad 01       	movw	r20, r26
    2102:	be 01       	movw	r22, r28
    2104:	6f 5f       	subi	r22, 0xFF	; 255
    2106:	7f 4f       	sbci	r23, 0xFF	; 255
    2108:	cf 01       	movw	r24, r30
    210a:	12 da       	rcall	.-3036   	; 0x1530 <xQueueGenericSendFromISR>
    210c:	01 c0       	rjmp	.+2      	; 0x2110 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    210e:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2110:	0f 90       	pop	r0
    2112:	0f 90       	pop	r0
    2114:	0f 90       	pop	r0
    2116:	0f 90       	pop	r0
    2118:	0f 90       	pop	r0
    211a:	df 91       	pop	r29
    211c:	cf 91       	pop	r28
    211e:	1f 91       	pop	r17
    2120:	0f 91       	pop	r16
    2122:	08 95       	ret

00002124 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2124:	af 92       	push	r10
    2126:	bf 92       	push	r11
    2128:	cf 92       	push	r12
    212a:	df 92       	push	r13
    212c:	ef 92       	push	r14
    212e:	ff 92       	push	r15
    2130:	0f 93       	push	r16
    2132:	1f 93       	push	r17
    2134:	cf 93       	push	r28
    2136:	df 93       	push	r29
    2138:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    213a:	8c dc       	rcall	.-1768   	; 0x1a54 <xTaskGetTickCount>
    213c:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    213e:	80 91 d9 0d 	lds	r24, 0x0DD9
    2142:	90 91 da 0d 	lds	r25, 0x0DDA
    2146:	e8 16       	cp	r14, r24
    2148:	f9 06       	cpc	r15, r25
    214a:	08 f0       	brcs	.+2      	; 0x214e <prvSampleTimeNow+0x2a>
    214c:	47 c0       	rjmp	.+142    	; 0x21dc <prvSampleTimeNow+0xb8>
    214e:	2f c0       	rjmp	.+94     	; 0x21ae <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2150:	05 80       	ldd	r0, Z+5	; 0x05
    2152:	f6 81       	ldd	r31, Z+6	; 0x06
    2154:	e0 2d       	mov	r30, r0
    2156:	a0 80       	ld	r10, Z
    2158:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    215a:	c6 81       	ldd	r28, Z+6	; 0x06
    215c:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    215e:	8e 01       	movw	r16, r28
    2160:	0e 5f       	subi	r16, 0xFE	; 254
    2162:	1f 4f       	sbci	r17, 0xFF	; 255
    2164:	c8 01       	movw	r24, r16
    2166:	0e 94 0b 07 	call	0xe16	; 0xe16 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    216a:	e9 89       	ldd	r30, Y+17	; 0x11
    216c:	fa 89       	ldd	r31, Y+18	; 0x12
    216e:	ce 01       	movw	r24, r28
    2170:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2172:	8e 85       	ldd	r24, Y+14	; 0x0e
    2174:	81 30       	cpi	r24, 0x01	; 1
    2176:	d9 f4       	brne	.+54     	; 0x21ae <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2178:	8c 85       	ldd	r24, Y+12	; 0x0c
    217a:	9d 85       	ldd	r25, Y+13	; 0x0d
    217c:	8a 0d       	add	r24, r10
    217e:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2180:	a8 16       	cp	r10, r24
    2182:	b9 06       	cpc	r11, r25
    2184:	60 f4       	brcc	.+24     	; 0x219e <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2186:	9b 83       	std	Y+3, r25	; 0x03
    2188:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    218a:	d9 87       	std	Y+9, r29	; 0x09
    218c:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    218e:	b8 01       	movw	r22, r16
    2190:	80 91 df 0d 	lds	r24, 0x0DDF
    2194:	90 91 e0 0d 	lds	r25, 0x0DE0
    2198:	0e 94 da 06 	call	0xdb4	; 0xdb4 <vListInsert>
    219c:	08 c0       	rjmp	.+16     	; 0x21ae <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    219e:	00 e0       	ldi	r16, 0x00	; 0
    21a0:	10 e0       	ldi	r17, 0x00	; 0
    21a2:	20 e0       	ldi	r18, 0x00	; 0
    21a4:	30 e0       	ldi	r19, 0x00	; 0
    21a6:	a5 01       	movw	r20, r10
    21a8:	60 e0       	ldi	r22, 0x00	; 0
    21aa:	ce 01       	movw	r24, r28
    21ac:	77 df       	rcall	.-274    	; 0x209c <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    21ae:	e0 91 df 0d 	lds	r30, 0x0DDF
    21b2:	f0 91 e0 0d 	lds	r31, 0x0DE0
    21b6:	80 81       	ld	r24, Z
    21b8:	81 11       	cpse	r24, r1
    21ba:	ca cf       	rjmp	.-108    	; 0x2150 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    21bc:	80 91 dd 0d 	lds	r24, 0x0DDD
    21c0:	90 91 de 0d 	lds	r25, 0x0DDE
    21c4:	90 93 e0 0d 	sts	0x0DE0, r25
    21c8:	80 93 df 0d 	sts	0x0DDF, r24
	pxOverflowTimerList = pxTemp;
    21cc:	f0 93 de 0d 	sts	0x0DDE, r31
    21d0:	e0 93 dd 0d 	sts	0x0DDD, r30
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	f6 01       	movw	r30, r12
    21d8:	80 83       	st	Z, r24
    21da:	02 c0       	rjmp	.+4      	; 0x21e0 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    21dc:	f6 01       	movw	r30, r12
    21de:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    21e0:	f0 92 da 0d 	sts	0x0DDA, r15
    21e4:	e0 92 d9 0d 	sts	0x0DD9, r14

	return xTimeNow;
}
    21e8:	c7 01       	movw	r24, r14
    21ea:	df 91       	pop	r29
    21ec:	cf 91       	pop	r28
    21ee:	1f 91       	pop	r17
    21f0:	0f 91       	pop	r16
    21f2:	ff 90       	pop	r15
    21f4:	ef 90       	pop	r14
    21f6:	df 90       	pop	r13
    21f8:	cf 90       	pop	r12
    21fa:	bf 90       	pop	r11
    21fc:	af 90       	pop	r10
    21fe:	08 95       	ret

00002200 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2200:	cf 93       	push	r28
    2202:	df 93       	push	r29
    2204:	00 d0       	rcall	.+0      	; 0x2206 <prvTimerTask+0x6>
    2206:	00 d0       	rcall	.+0      	; 0x2208 <prvTimerTask+0x8>
    2208:	cd b7       	in	r28, 0x3d	; 61
    220a:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    220c:	ce 01       	movw	r24, r28
    220e:	01 96       	adiw	r24, 0x01	; 1
    2210:	6c 01       	movw	r12, r24
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2212:	81 2c       	mov	r8, r1
    2214:	91 2c       	mov	r9, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2216:	68 2e       	mov	r6, r24
    2218:	7d 2c       	mov	r7, r13
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    221a:	e0 91 df 0d 	lds	r30, 0x0DDF
    221e:	f0 91 e0 0d 	lds	r31, 0x0DE0
	if( *pxListWasEmpty == pdFALSE )
    2222:	80 81       	ld	r24, Z
    2224:	88 23       	and	r24, r24
    2226:	09 f4       	brne	.+2      	; 0x222a <prvTimerTask+0x2a>
    2228:	b7 c0       	rjmp	.+366    	; 0x2398 <prvTimerTask+0x198>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    222a:	05 80       	ldd	r0, Z+5	; 0x05
    222c:	f6 81       	ldd	r31, Z+6	; 0x06
    222e:	e0 2d       	mov	r30, r0
    2230:	e0 80       	ld	r14, Z
    2232:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2234:	09 dc       	rcall	.-2030   	; 0x1a48 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2236:	c6 01       	movw	r24, r12
    2238:	75 df       	rcall	.-278    	; 0x2124 <prvSampleTimeNow>
    223a:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    223c:	89 81       	ldd	r24, Y+1	; 0x01
    223e:	81 11       	cpse	r24, r1
    2240:	43 c0       	rjmp	.+134    	; 0x22c8 <prvTimerTask+0xc8>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2242:	0e 15       	cp	r16, r14
    2244:	1f 05       	cpc	r17, r15
    2246:	90 f1       	brcs	.+100    	; 0x22ac <prvTimerTask+0xac>
			{
				( void ) xTaskResumeAll();
    2248:	ca dc       	rcall	.-1644   	; 0x1bde <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    224a:	e0 91 df 0d 	lds	r30, 0x0DDF
    224e:	f0 91 e0 0d 	lds	r31, 0x0DE0
    2252:	05 80       	ldd	r0, Z+5	; 0x05
    2254:	f6 81       	ldd	r31, Z+6	; 0x06
    2256:	e0 2d       	mov	r30, r0
    2258:	a6 80       	ldd	r10, Z+6	; 0x06
    225a:	b7 80       	ldd	r11, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    225c:	c5 01       	movw	r24, r10
    225e:	02 96       	adiw	r24, 0x02	; 2
    2260:	0e 94 0b 07 	call	0xe16	; 0xe16 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2264:	d5 01       	movw	r26, r10
    2266:	1e 96       	adiw	r26, 0x0e	; 14
    2268:	8c 91       	ld	r24, X
    226a:	1e 97       	sbiw	r26, 0x0e	; 14
    226c:	81 30       	cpi	r24, 0x01	; 1
    226e:	a1 f4       	brne	.+40     	; 0x2298 <prvTimerTask+0x98>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2270:	1c 96       	adiw	r26, 0x0c	; 12
    2272:	6d 91       	ld	r22, X+
    2274:	7c 91       	ld	r23, X
    2276:	1d 97       	sbiw	r26, 0x0d	; 13
    2278:	6e 0d       	add	r22, r14
    227a:	7f 1d       	adc	r23, r15
    227c:	97 01       	movw	r18, r14
    227e:	a8 01       	movw	r20, r16
    2280:	c5 01       	movw	r24, r10
    2282:	8d de       	rcall	.-742    	; 0x1f9e <prvInsertTimerInActiveList>
    2284:	81 30       	cpi	r24, 0x01	; 1
    2286:	41 f4       	brne	.+16     	; 0x2298 <prvTimerTask+0x98>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2288:	08 2d       	mov	r16, r8
    228a:	19 2d       	mov	r17, r9
    228c:	28 2d       	mov	r18, r8
    228e:	39 2d       	mov	r19, r9
    2290:	a7 01       	movw	r20, r14
    2292:	60 e0       	ldi	r22, 0x00	; 0
    2294:	c5 01       	movw	r24, r10
    2296:	02 df       	rcall	.-508    	; 0x209c <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2298:	d5 01       	movw	r26, r10
    229a:	51 96       	adiw	r26, 0x11	; 17
    229c:	ed 91       	ld	r30, X+
    229e:	fc 91       	ld	r31, X
    22a0:	52 97       	sbiw	r26, 0x12	; 18
    22a2:	c5 01       	movw	r24, r10
    22a4:	19 95       	eicall
    22a6:	6b c0       	rjmp	.+214    	; 0x237e <prvTimerTask+0x17e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    22a8:	e8 2c       	mov	r14, r8
    22aa:	f9 2c       	mov	r15, r9
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    22ac:	b7 01       	movw	r22, r14
    22ae:	60 1b       	sub	r22, r16
    22b0:	71 0b       	sbc	r23, r17
    22b2:	80 91 db 0d 	lds	r24, 0x0DDB
    22b6:	90 91 dc 0d 	lds	r25, 0x0DDC
    22ba:	32 da       	rcall	.-2972   	; 0x1720 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    22bc:	90 dc       	rcall	.-1760   	; 0x1bde <xTaskResumeAll>
    22be:	81 11       	cpse	r24, r1
    22c0:	5e c0       	rjmp	.+188    	; 0x237e <prvTimerTask+0x17e>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    22c2:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <vPortYield>
    22c6:	5b c0       	rjmp	.+182    	; 0x237e <prvTimerTask+0x17e>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    22c8:	8a dc       	rcall	.-1772   	; 0x1bde <xTaskResumeAll>
    22ca:	59 c0       	rjmp	.+178    	; 0x237e <prvTimerTask+0x17e>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    22cc:	89 81       	ldd	r24, Y+1	; 0x01
    22ce:	88 23       	and	r24, r24
    22d0:	0c f4       	brge	.+2      	; 0x22d4 <prvTimerTask+0xd4>
    22d2:	55 c0       	rjmp	.+170    	; 0x237e <prvTimerTask+0x17e>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    22d4:	ec 80       	ldd	r14, Y+4	; 0x04
    22d6:	fd 80       	ldd	r15, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    22d8:	f7 01       	movw	r30, r14
    22da:	82 85       	ldd	r24, Z+10	; 0x0a
    22dc:	93 85       	ldd	r25, Z+11	; 0x0b
    22de:	89 2b       	or	r24, r25
    22e0:	21 f0       	breq	.+8      	; 0x22ea <prvTimerTask+0xea>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    22e2:	c7 01       	movw	r24, r14
    22e4:	02 96       	adiw	r24, 0x02	; 2
    22e6:	0e 94 0b 07 	call	0xe16	; 0xe16 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    22ea:	ce 01       	movw	r24, r28
    22ec:	06 96       	adiw	r24, 0x06	; 6
    22ee:	1a df       	rcall	.-460    	; 0x2124 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    22f0:	09 81       	ldd	r16, Y+1	; 0x01
    22f2:	11 27       	eor	r17, r17
    22f4:	07 fd       	sbrc	r16, 7
    22f6:	10 95       	com	r17
    22f8:	21 2f       	mov	r18, r17
    22fa:	31 2f       	mov	r19, r17
    22fc:	0a 30       	cpi	r16, 0x0A	; 10
    22fe:	11 05       	cpc	r17, r1
    2300:	08 f0       	brcs	.+2      	; 0x2304 <prvTimerTask+0x104>
    2302:	3d c0       	rjmp	.+122    	; 0x237e <prvTimerTask+0x17e>
    2304:	f8 01       	movw	r30, r16
    2306:	ea 59       	subi	r30, 0x9A	; 154
    2308:	ff 4f       	sbci	r31, 0xFF	; 255
    230a:	0c 94 a2 1a 	jmp	0x3544	; 0x3544 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    230e:	2a 81       	ldd	r18, Y+2	; 0x02
    2310:	3b 81       	ldd	r19, Y+3	; 0x03
    2312:	d7 01       	movw	r26, r14
    2314:	1c 96       	adiw	r26, 0x0c	; 12
    2316:	6d 91       	ld	r22, X+
    2318:	7c 91       	ld	r23, X
    231a:	1d 97       	sbiw	r26, 0x0d	; 13
    231c:	62 0f       	add	r22, r18
    231e:	73 1f       	adc	r23, r19
    2320:	ac 01       	movw	r20, r24
    2322:	c7 01       	movw	r24, r14
    2324:	3c de       	rcall	.-904    	; 0x1f9e <prvInsertTimerInActiveList>
    2326:	81 30       	cpi	r24, 0x01	; 1
    2328:	51 f5       	brne	.+84     	; 0x237e <prvTimerTask+0x17e>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    232a:	d7 01       	movw	r26, r14
    232c:	51 96       	adiw	r26, 0x11	; 17
    232e:	ed 91       	ld	r30, X+
    2330:	fc 91       	ld	r31, X
    2332:	52 97       	sbiw	r26, 0x12	; 18
    2334:	c7 01       	movw	r24, r14
    2336:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2338:	f7 01       	movw	r30, r14
    233a:	86 85       	ldd	r24, Z+14	; 0x0e
    233c:	81 30       	cpi	r24, 0x01	; 1
    233e:	f9 f4       	brne	.+62     	; 0x237e <prvTimerTask+0x17e>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2340:	44 85       	ldd	r20, Z+12	; 0x0c
    2342:	55 85       	ldd	r21, Z+13	; 0x0d
    2344:	8a 81       	ldd	r24, Y+2	; 0x02
    2346:	9b 81       	ldd	r25, Y+3	; 0x03
    2348:	48 0f       	add	r20, r24
    234a:	59 1f       	adc	r21, r25
    234c:	08 2d       	mov	r16, r8
    234e:	19 2d       	mov	r17, r9
    2350:	28 2d       	mov	r18, r8
    2352:	39 2d       	mov	r19, r9
    2354:	60 e0       	ldi	r22, 0x00	; 0
    2356:	c7 01       	movw	r24, r14
    2358:	a1 de       	rcall	.-702    	; 0x209c <xTimerGenericCommand>
    235a:	11 c0       	rjmp	.+34     	; 0x237e <prvTimerTask+0x17e>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    235c:	6a 81       	ldd	r22, Y+2	; 0x02
    235e:	7b 81       	ldd	r23, Y+3	; 0x03
    2360:	d7 01       	movw	r26, r14
    2362:	1d 96       	adiw	r26, 0x0d	; 13
    2364:	7c 93       	st	X, r23
    2366:	6e 93       	st	-X, r22
    2368:	1c 97       	sbiw	r26, 0x0c	; 12
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    236a:	68 0f       	add	r22, r24
    236c:	79 1f       	adc	r23, r25
    236e:	9c 01       	movw	r18, r24
    2370:	ac 01       	movw	r20, r24
    2372:	c7 01       	movw	r24, r14
    2374:	14 de       	rcall	.-984    	; 0x1f9e <prvInsertTimerInActiveList>
    2376:	03 c0       	rjmp	.+6      	; 0x237e <prvTimerTask+0x17e>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    2378:	c7 01       	movw	r24, r14
    237a:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    237e:	20 e0       	ldi	r18, 0x00	; 0
    2380:	48 2d       	mov	r20, r8
    2382:	59 2d       	mov	r21, r9
    2384:	66 2d       	mov	r22, r6
    2386:	77 2d       	mov	r23, r7
    2388:	80 91 db 0d 	lds	r24, 0x0DDB
    238c:	90 91 dc 0d 	lds	r25, 0x0DDC
    2390:	2b d9       	rcall	.-3498   	; 0x15e8 <xQueueGenericReceive>
    2392:	81 11       	cpse	r24, r1
    2394:	9b cf       	rjmp	.-202    	; 0x22cc <prvTimerTask+0xcc>
    2396:	41 cf       	rjmp	.-382    	; 0x221a <prvTimerTask+0x1a>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2398:	57 db       	rcall	.-2386   	; 0x1a48 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    239a:	c6 01       	movw	r24, r12
    239c:	c3 de       	rcall	.-634    	; 0x2124 <prvSampleTimeNow>
    239e:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    23a0:	89 81       	ldd	r24, Y+1	; 0x01
    23a2:	88 23       	and	r24, r24
    23a4:	09 f4       	brne	.+2      	; 0x23a8 <prvTimerTask+0x1a8>
    23a6:	80 cf       	rjmp	.-256    	; 0x22a8 <prvTimerTask+0xa8>
    23a8:	8f cf       	rjmp	.-226    	; 0x22c8 <prvTimerTask+0xc8>

000023aa <bt_status_call_back>:
		bt_initialised = 1;
		} else if (status == DIALOG_ERROR_STOP) {
		// What to do??
	}
}
void vTimerCallback( TimerHandle_t pxTimer ){
    23aa:	8f 3f       	cpi	r24, 0xFF	; 255
    23ac:	19 f4       	brne	.+6      	; 0x23b4 <bt_status_call_back+0xa>
    23ae:	81 e0       	ldi	r24, 0x01	; 1
    23b0:	80 93 51 10 	sts	0x1051, r24
    23b4:	08 95       	ret

000023b6 <vjustATask>:
    23b6:	20 e0       	ldi	r18, 0x00	; 0
    23b8:	4f ef       	ldi	r20, 0xFF	; 255
    23ba:	5f ef       	ldi	r21, 0xFF	; 255
    23bc:	60 e0       	ldi	r22, 0x00	; 0
    23be:	70 e0       	ldi	r23, 0x00	; 0
    23c0:	80 91 ce 15 	lds	r24, 0x15CE
    23c4:	90 91 cf 15 	lds	r25, 0x15CF
    23c8:	0f d9       	rcall	.-3554   	; 0x15e8 <xQueueGenericReceive>
    23ca:	f5 cf       	rjmp	.-22     	; 0x23b6 <vjustATask>

000023cc <learn>:
				break;
		}
	}
}

void learn() {
    23cc:	8f 92       	push	r8
    23ce:	9f 92       	push	r9
    23d0:	af 92       	push	r10
    23d2:	bf 92       	push	r11
    23d4:	cf 92       	push	r12
    23d6:	df 92       	push	r13
    23d8:	ef 92       	push	r14
    23da:	ff 92       	push	r15
    23dc:	0f 93       	push	r16
    23de:	1f 93       	push	r17
    23e0:	cf 93       	push	r28
    23e2:	df 93       	push	r29
    23e4:	cd b7       	in	r28, 0x3d	; 61
    23e6:	de b7       	in	r29, 0x3e	; 62
    23e8:	64 97       	sbiw	r28, 0x14	; 20
    23ea:	0f b6       	in	r0, 0x3f	; 63
    23ec:	f8 94       	cli
    23ee:	de bf       	out	0x3e, r29	; 62
    23f0:	0f be       	out	0x3f, r0	; 63
    23f2:	cd bf       	out	0x3d, r28	; 61
    23f4:	0f 2e       	mov	r0, r31
    23f6:	f4 e6       	ldi	r31, 0x64	; 100
    23f8:	ef 2e       	mov	r14, r31
    23fa:	f1 2c       	mov	r15, r1
    23fc:	f0 2d       	mov	r31, r0
			uint16_t raw_x = get_raw_x_accel();
			uint16_t raw_y = get_raw_y_accel();
			uint16_t raw_z = get_raw_z_accel();
			//uint16_t raw_rx = get_raw_x_rotation();
			//uint16_t raw_ry = get_raw_y_rotation();
			sprintf(buf, "%4d %4d %4d", raw_x, raw_y, raw_z);
    23fe:	0f 2e       	mov	r0, r31
    2400:	f3 e9       	ldi	r31, 0x93	; 147
    2402:	cf 2e       	mov	r12, r31
    2404:	f2 e0       	ldi	r31, 0x02	; 2
    2406:	df 2e       	mov	r13, r31
    2408:	f0 2d       	mov	r31, r0
    240a:	8e 01       	movw	r16, r28
    240c:	0f 5f       	subi	r16, 0xFF	; 255
    240e:	1f 4f       	sbci	r17, 0xFF	; 255
	int i;
	char buf[20];
	
	for (i= 0; i<100; i++)
	{
			uint16_t raw_x = get_raw_x_accel();
    2410:	0e 94 8c 03 	call	0x718	; 0x718 <get_raw_x_accel>
    2414:	b8 2e       	mov	r11, r24
    2416:	a9 2e       	mov	r10, r25
			uint16_t raw_y = get_raw_y_accel();
    2418:	0e 94 94 03 	call	0x728	; 0x728 <get_raw_y_accel>
    241c:	98 2e       	mov	r9, r24
    241e:	89 2e       	mov	r8, r25
			uint16_t raw_z = get_raw_z_accel();
    2420:	0e 94 9c 03 	call	0x738	; 0x738 <get_raw_z_accel>
			//uint16_t raw_rx = get_raw_x_rotation();
			//uint16_t raw_ry = get_raw_y_rotation();
			sprintf(buf, "%4d %4d %4d", raw_x, raw_y, raw_z);
    2424:	9f 93       	push	r25
    2426:	8f 93       	push	r24
    2428:	8f 92       	push	r8
    242a:	9f 92       	push	r9
    242c:	af 92       	push	r10
    242e:	bf 92       	push	r11
    2430:	df 92       	push	r13
    2432:	cf 92       	push	r12
    2434:	1f 93       	push	r17
    2436:	0f 93       	push	r16
    2438:	0e 94 20 1c 	call	0x3840	; 0x3840 <sprintf>
			bt_send_bytes((uint8_t *)buf, strlen(buf));
    243c:	f8 01       	movw	r30, r16
    243e:	01 90       	ld	r0, Z+
    2440:	00 20       	and	r0, r0
    2442:	e9 f7       	brne	.-6      	; 0x243e <learn+0x72>
    2444:	31 97       	sbiw	r30, 0x01	; 1
    2446:	bf 01       	movw	r22, r30
    2448:	60 1b       	sub	r22, r16
    244a:	71 0b       	sbc	r23, r17
    244c:	c8 01       	movw	r24, r16
    244e:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <bt_send_bytes>
			vTaskDelay( 100/ portTICK_PERIOD_MS);
    2452:	84 e6       	ldi	r24, 0x64	; 100
    2454:	90 e0       	ldi	r25, 0x00	; 0
    2456:	41 dc       	rcall	.-1918   	; 0x1cda <vTaskDelay>
    2458:	81 e0       	ldi	r24, 0x01	; 1
    245a:	e8 1a       	sub	r14, r24
    245c:	f1 08       	sbc	r15, r1

void learn() {
	int i;
	char buf[20];
	
	for (i= 0; i<100; i++)
    245e:	0f b6       	in	r0, 0x3f	; 63
    2460:	f8 94       	cli
    2462:	de bf       	out	0x3e, r29	; 62
    2464:	0f be       	out	0x3f, r0	; 63
    2466:	cd bf       	out	0x3d, r28	; 61
    2468:	e1 14       	cp	r14, r1
    246a:	f1 04       	cpc	r15, r1
    246c:	89 f6       	brne	.-94     	; 0x2410 <learn+0x44>
			//uint16_t raw_ry = get_raw_y_rotation();
			sprintf(buf, "%4d %4d %4d", raw_x, raw_y, raw_z);
			bt_send_bytes((uint8_t *)buf, strlen(buf));
			vTaskDelay( 100/ portTICK_PERIOD_MS);
	}
}
    246e:	64 96       	adiw	r28, 0x14	; 20
    2470:	0f b6       	in	r0, 0x3f	; 63
    2472:	f8 94       	cli
    2474:	de bf       	out	0x3e, r29	; 62
    2476:	0f be       	out	0x3f, r0	; 63
    2478:	cd bf       	out	0x3d, r28	; 61
    247a:	df 91       	pop	r29
    247c:	cf 91       	pop	r28
    247e:	1f 91       	pop	r17
    2480:	0f 91       	pop	r16
    2482:	ff 90       	pop	r15
    2484:	ef 90       	pop	r14
    2486:	df 90       	pop	r13
    2488:	cf 90       	pop	r12
    248a:	bf 90       	pop	r11
    248c:	af 90       	pop	r10
    248e:	9f 90       	pop	r9
    2490:	8f 90       	pop	r8
    2492:	08 95       	ret

00002494 <plannedTrackWithSpeedMeas>:

void plannedTrackWithSpeedMeas() {
    2494:	8f 92       	push	r8
    2496:	9f 92       	push	r9
    2498:	af 92       	push	r10
    249a:	bf 92       	push	r11
    249c:	cf 92       	push	r12
    249e:	df 92       	push	r13
    24a0:	ef 92       	push	r14
    24a2:	ff 92       	push	r15
    24a4:	0f 93       	push	r16
    24a6:	1f 93       	push	r17
    24a8:	cf 93       	push	r28
    24aa:	df 93       	push	r29
	get_tacho_count();
    24ac:	0e 94 b4 03 	call	0x768	; 0x768 <get_tacho_count>
	set_head_light(1);
    24b0:	81 e0       	ldi	r24, 0x01	; 1
    24b2:	0e 94 8b 02 	call	0x516	; 0x516 <set_head_light>
	uint16_t count = 0;
	uint16_t cumulTacho = get_tacho_count();
    24b6:	0e 94 b4 03 	call	0x768	; 0x768 <get_tacho_count>
    24ba:	ec 01       	movw	r28, r24
	uint16_t speedTacho;
	uint16_t curSpeed=0;
	uint16_t raceSpeed=0;
	uint16_t ticks = xTaskGetTickCount();
    24bc:	cb da       	rcall	.-2666   	; 0x1a54 <xTaskGetTickCount>
	while (cumulTacho < 1300)
    24be:	c4 31       	cpi	r28, 0x14	; 20
    24c0:	85 e0       	ldi	r24, 0x05	; 5
    24c2:	d8 07       	cpc	r29, r24
    24c4:	08 f0       	brcs	.+2      	; 0x24c8 <plannedTrackWithSpeedMeas+0x34>
    24c6:	49 c0       	rjmp	.+146    	; 0x255a <plannedTrackWithSpeedMeas+0xc6>
	set_head_light(1);
	uint16_t count = 0;
	uint16_t cumulTacho = get_tacho_count();
	uint16_t speedTacho;
	uint16_t curSpeed=0;
	uint16_t raceSpeed=0;
    24c8:	c1 2c       	mov	r12, r1
    24ca:	d1 2c       	mov	r13, r1
}

void plannedTrackWithSpeedMeas() {
	get_tacho_count();
	set_head_light(1);
	uint16_t count = 0;
    24cc:	e1 2c       	mov	r14, r1
    24ce:	f1 2c       	mov	r15, r1
	uint16_t curSpeed=0;
	uint16_t raceSpeed=0;
	uint16_t ticks = xTaskGetTickCount();
	while (cumulTacho < 1300)
	{
		vTaskDelay(20);
    24d0:	84 e1       	ldi	r24, 0x14	; 20
    24d2:	90 e0       	ldi	r25, 0x00	; 0
    24d4:	02 dc       	rcall	.-2044   	; 0x1cda <vTaskDelay>
		//ticks = xTaskGetTickCount() - ticks;
		speedTacho = get_tacho_count();
    24d6:	0e 94 b4 03 	call	0x768	; 0x768 <get_tacho_count>
    24da:	8c 01       	movw	r16, r24
		cumulTacho = cumulTacho + speedTacho;
    24dc:	c8 0f       	add	r28, r24
    24de:	d9 1f       	adc	r29, r25
		curSpeed = ((float)speedTacho/20)*100;
    24e0:	bc 01       	movw	r22, r24
    24e2:	80 e0       	ldi	r24, 0x00	; 0
    24e4:	90 e0       	ldi	r25, 0x00	; 0
    24e6:	ec d6       	rcall	.+3544   	; 0x32c0 <__floatunsisf>
    24e8:	20 e0       	ldi	r18, 0x00	; 0
    24ea:	30 e0       	ldi	r19, 0x00	; 0
    24ec:	40 ea       	ldi	r20, 0xA0	; 160
    24ee:	51 e4       	ldi	r21, 0x41	; 65
    24f0:	53 d6       	rcall	.+3238   	; 0x3198 <__divsf3>
    24f2:	20 e0       	ldi	r18, 0x00	; 0
    24f4:	30 e0       	ldi	r19, 0x00	; 0
    24f6:	48 ec       	ldi	r20, 0xC8	; 200
    24f8:	52 e4       	ldi	r21, 0x42	; 66
    24fa:	70 d7       	rcall	.+3808   	; 0x33dc <__mulsf3>
    24fc:	b5 d6       	rcall	.+3434   	; 0x3268 <__fixunssfsi>
    24fe:	4b 01       	movw	r8, r22
    2500:	5c 01       	movw	r10, r24
		if (curSpeed > raceSpeed)
    2502:	c6 16       	cp	r12, r22
    2504:	d7 06       	cpc	r13, r23
    2506:	20 f4       	brcc	.+8      	; 0x2510 <plannedTrackWithSpeedMeas+0x7c>
		{
			set_brake(100);
    2508:	84 e6       	ldi	r24, 0x64	; 100
    250a:	0e 94 69 03 	call	0x6d2	; 0x6d2 <set_brake>
    250e:	03 c0       	rjmp	.+6      	; 0x2516 <plannedTrackWithSpeedMeas+0x82>
		} else {
			set_motor_speed(100);
    2510:	84 e6       	ldi	r24, 0x64	; 100
    2512:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
		}
		if (cumulTacho >= accData[count])
    2516:	f7 01       	movw	r30, r14
    2518:	ee 0f       	add	r30, r30
    251a:	ff 1f       	adc	r31, r31
    251c:	ec 5a       	subi	r30, 0xAC	; 172
    251e:	ff 4e       	sbci	r31, 0xEF	; 239
    2520:	80 81       	ld	r24, Z
    2522:	91 81       	ldd	r25, Z+1	; 0x01
    2524:	c8 17       	cp	r28, r24
    2526:	d9 07       	cpc	r29, r25
    2528:	98 f0       	brcs	.+38     	; 0x2550 <plannedTrackWithSpeedMeas+0xbc>
		{
			raceSpeed = accData[count+1];
    252a:	f7 01       	movw	r30, r14
    252c:	ee 0f       	add	r30, r30
    252e:	ff 1f       	adc	r31, r31
    2530:	ea 5a       	subi	r30, 0xAA	; 170
    2532:	ff 4e       	sbci	r31, 0xEF	; 239
    2534:	c0 80       	ld	r12, Z
    2536:	d1 80       	ldd	r13, Z+1	; 0x01
			accData[count] = speedTacho;
    2538:	d7 01       	movw	r26, r14
    253a:	aa 0f       	add	r26, r26
    253c:	bb 1f       	adc	r27, r27
    253e:	ac 5a       	subi	r26, 0xAC	; 172
    2540:	bf 4e       	sbci	r27, 0xEF	; 239
    2542:	0d 93       	st	X+, r16
    2544:	1c 93       	st	X, r17
			accData[count+1] = curSpeed;
    2546:	91 82       	std	Z+1, r9	; 0x01
    2548:	80 82       	st	Z, r8
			count = count + 2;
    254a:	82 e0       	ldi	r24, 0x02	; 2
    254c:	e8 0e       	add	r14, r24
    254e:	f1 1c       	adc	r15, r1
	uint16_t cumulTacho = get_tacho_count();
	uint16_t speedTacho;
	uint16_t curSpeed=0;
	uint16_t raceSpeed=0;
	uint16_t ticks = xTaskGetTickCount();
	while (cumulTacho < 1300)
    2550:	c4 31       	cpi	r28, 0x14	; 20
    2552:	85 e0       	ldi	r24, 0x05	; 5
    2554:	d8 07       	cpc	r29, r24
    2556:	08 f4       	brcc	.+2      	; 0x255a <plannedTrackWithSpeedMeas+0xc6>
    2558:	bb cf       	rjmp	.-138    	; 0x24d0 <plannedTrackWithSpeedMeas+0x3c>
			accData[count] = speedTacho;
			accData[count+1] = curSpeed;
			count = count + 2;
		}
	}
	set_head_light(0);
    255a:	80 e0       	ldi	r24, 0x00	; 0
    255c:	0e 94 8b 02 	call	0x516	; 0x516 <set_head_light>
	curSpeed= 0.45;
	set_brake_light(0);
    2560:	80 e0       	ldi	r24, 0x00	; 0
    2562:	0e 94 91 02 	call	0x522	; 0x522 <set_brake_light>
	set_motor_speed(0);
    2566:	80 e0       	ldi	r24, 0x00	; 0
    2568:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
	curSpeed= 0.45;
	set_head_light(0);
    256c:	80 e0       	ldi	r24, 0x00	; 0
    256e:	0e 94 8b 02 	call	0x516	; 0x516 <set_head_light>
}
    2572:	df 91       	pop	r29
    2574:	cf 91       	pop	r28
    2576:	1f 91       	pop	r17
    2578:	0f 91       	pop	r16
    257a:	ff 90       	pop	r15
    257c:	ef 90       	pop	r14
    257e:	df 90       	pop	r13
    2580:	cf 90       	pop	r12
    2582:	bf 90       	pop	r11
    2584:	af 90       	pop	r10
    2586:	9f 90       	pop	r9
    2588:	8f 90       	pop	r8
    258a:	08 95       	ret

0000258c <plannedTrack>:

void plannedTrack() {
    258c:	ef 92       	push	r14
    258e:	ff 92       	push	r15
    2590:	0f 93       	push	r16
    2592:	1f 93       	push	r17
    2594:	cf 93       	push	r28
    2596:	df 93       	push	r29
	get_tacho_count();
    2598:	0e 94 b4 03 	call	0x768	; 0x768 <get_tacho_count>
	set_head_light(1);
    259c:	81 e0       	ldi	r24, 0x01	; 1
    259e:	0e 94 8b 02 	call	0x516	; 0x516 <set_head_light>
	uint16_t count = 0;
	//uint16_t prog[200]= {0,100,200,200};
	uint16_t tacho = get_tacho_count();
    25a2:	0e 94 b4 03 	call	0x768	; 0x768 <get_tacho_count>
    25a6:	ec 01       	movw	r28, r24
	//set_motor_speed(60);
	while (tacho < 1500)
    25a8:	cc 3d       	cpi	r28, 0xDC	; 220
    25aa:	85 e0       	ldi	r24, 0x05	; 5
    25ac:	d8 07       	cpc	r29, r24
    25ae:	08 f0       	brcs	.+2      	; 0x25b2 <plannedTrack+0x26>
    25b0:	45 c0       	rjmp	.+138    	; 0x263c <plannedTrack+0xb0>
}

void plannedTrack() {
	get_tacho_count();
	set_head_light(1);
	uint16_t count = 0;
    25b2:	00 e0       	ldi	r16, 0x00	; 0
    25b4:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t prog[200]= {0,100,200,200};
	uint16_t tacho = get_tacho_count();
	//set_motor_speed(60);
	while (tacho < 1500)
	{
		if (tacho >= accData[count])
    25b6:	f8 01       	movw	r30, r16
    25b8:	ee 0f       	add	r30, r30
    25ba:	ff 1f       	adc	r31, r31
    25bc:	ec 5a       	subi	r30, 0xAC	; 172
    25be:	ff 4e       	sbci	r31, 0xEF	; 239
    25c0:	80 81       	ld	r24, Z
    25c2:	91 81       	ldd	r25, Z+1	; 0x01
    25c4:	c8 17       	cp	r28, r24
    25c6:	d9 07       	cpc	r29, r25
    25c8:	80 f1       	brcs	.+96     	; 0x262a <plannedTrack+0x9e>
		{
			if (accData[count+1] <= 100)
    25ca:	78 01       	movw	r14, r16
    25cc:	8f ef       	ldi	r24, 0xFF	; 255
    25ce:	e8 1a       	sub	r14, r24
    25d0:	f8 0a       	sbc	r15, r24
    25d2:	f7 01       	movw	r30, r14
    25d4:	ee 0f       	add	r30, r30
    25d6:	ff 1f       	adc	r31, r31
    25d8:	ec 5a       	subi	r30, 0xAC	; 172
    25da:	ff 4e       	sbci	r31, 0xEF	; 239
    25dc:	80 81       	ld	r24, Z
    25de:	91 81       	ldd	r25, Z+1	; 0x01
    25e0:	85 36       	cpi	r24, 0x65	; 101
    25e2:	91 05       	cpc	r25, r1
    25e4:	60 f4       	brcc	.+24     	; 0x25fe <plannedTrack+0x72>
			{
				set_brake_light(0);
    25e6:	80 e0       	ldi	r24, 0x00	; 0
    25e8:	0e 94 91 02 	call	0x522	; 0x522 <set_brake_light>
				set_motor_speed(accData[count+1]);
    25ec:	f7 01       	movw	r30, r14
    25ee:	ee 0f       	add	r30, r30
    25f0:	ff 1f       	adc	r31, r31
    25f2:	ec 5a       	subi	r30, 0xAC	; 172
    25f4:	ff 4e       	sbci	r31, 0xEF	; 239
    25f6:	80 81       	ld	r24, Z
    25f8:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
    25fc:	09 c0       	rjmp	.+18     	; 0x2610 <plannedTrack+0x84>
			} else if (accData[count+1] > 100) {
				set_brake(accData[count+1]-100);
    25fe:	84 56       	subi	r24, 0x64	; 100
    2600:	0e 94 69 03 	call	0x6d2	; 0x6d2 <set_brake>
				set_brake_light(1);
    2604:	81 e0       	ldi	r24, 0x01	; 1
    2606:	0e 94 91 02 	call	0x522	; 0x522 <set_brake_light>
				set_motor_speed(0);
    260a:	80 e0       	ldi	r24, 0x00	; 0
    260c:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
			} else {
				set_motor_speed(0);
			}
			nextVal= accData[count+1];
    2610:	f7 01       	movw	r30, r14
    2612:	ee 0f       	add	r30, r30
    2614:	ff 1f       	adc	r31, r31
    2616:	ec 5a       	subi	r30, 0xAC	; 172
    2618:	ff 4e       	sbci	r31, 0xEF	; 239
    261a:	80 81       	ld	r24, Z
    261c:	91 81       	ldd	r25, Z+1	; 0x01
    261e:	90 93 53 10 	sts	0x1053, r25
    2622:	80 93 52 10 	sts	0x1052, r24
			count = count + 2;
    2626:	0e 5f       	subi	r16, 0xFE	; 254
    2628:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		tacho = tacho + get_tacho_count();
    262a:	0e 94 b4 03 	call	0x768	; 0x768 <get_tacho_count>
    262e:	c8 0f       	add	r28, r24
    2630:	d9 1f       	adc	r29, r25
	set_head_light(1);
	uint16_t count = 0;
	//uint16_t prog[200]= {0,100,200,200};
	uint16_t tacho = get_tacho_count();
	//set_motor_speed(60);
	while (tacho < 1500)
    2632:	cc 3d       	cpi	r28, 0xDC	; 220
    2634:	85 e0       	ldi	r24, 0x05	; 5
    2636:	d8 07       	cpc	r29, r24
    2638:	08 f4       	brcc	.+2      	; 0x263c <plannedTrack+0xb0>
    263a:	bd cf       	rjmp	.-134    	; 0x25b6 <plannedTrack+0x2a>
			nextVal= accData[count+1];
			count = count + 2;
		}
		tacho = tacho + get_tacho_count();
	}
	set_brake_light(0);
    263c:	80 e0       	ldi	r24, 0x00	; 0
    263e:	0e 94 91 02 	call	0x522	; 0x522 <set_brake_light>
	set_head_light(0);
    2642:	80 e0       	ldi	r24, 0x00	; 0
    2644:	0e 94 8b 02 	call	0x516	; 0x516 <set_head_light>
	set_motor_speed(0);
    2648:	80 e0       	ldi	r24, 0x00	; 0
    264a:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
	count +1;
}
    264e:	df 91       	pop	r29
    2650:	cf 91       	pop	r28
    2652:	1f 91       	pop	r17
    2654:	0f 91       	pop	r16
    2656:	ff 90       	pop	r15
    2658:	ef 90       	pop	r14
    265a:	08 95       	ret

0000265c <bt_com_call_back>:
}
void vTimerCallback( TimerHandle_t pxTimer ){
	//xSemaphoreGive(xSemaphore);
}

void bt_com_call_back(uint8_t byte) {
    265c:	2f 92       	push	r2
    265e:	3f 92       	push	r3
    2660:	4f 92       	push	r4
    2662:	5f 92       	push	r5
    2664:	6f 92       	push	r6
    2666:	7f 92       	push	r7
    2668:	8f 92       	push	r8
    266a:	9f 92       	push	r9
    266c:	af 92       	push	r10
    266e:	bf 92       	push	r11
    2670:	cf 92       	push	r12
    2672:	df 92       	push	r13
    2674:	ef 92       	push	r14
    2676:	ff 92       	push	r15
    2678:	0f 93       	push	r16
    267a:	1f 93       	push	r17
    267c:	cf 93       	push	r28
    267e:	df 93       	push	r29
    2680:	cd b7       	in	r28, 0x3d	; 61
    2682:	de b7       	in	r29, 0x3e	; 62
    2684:	aa 97       	sbiw	r28, 0x2a	; 42
    2686:	0f b6       	in	r0, 0x3f	; 63
    2688:	f8 94       	cli
    268a:	de bf       	out	0x3e, r29	; 62
    268c:	0f be       	out	0x3f, r0	; 63
    268e:	cd bf       	out	0x3d, r28	; 61
	char buf[40];
	
	if (bt_initialised) {
    2690:	90 91 51 10 	lds	r25, 0x1051
    2694:	99 23       	and	r25, r25
    2696:	09 f4       	brne	.+2      	; 0x269a <bt_com_call_back+0x3e>
    2698:	56 c1       	rjmp	.+684    	; 0x2946 <bt_com_call_back+0x2ea>
		switch (byte) {
    269a:	48 2f       	mov	r20, r24
    269c:	50 e0       	ldi	r21, 0x00	; 0
    269e:	fa 01       	movw	r30, r20
    26a0:	e1 54       	subi	r30, 0x41	; 65
    26a2:	f1 09       	sbc	r31, r1
    26a4:	e1 33       	cpi	r30, 0x31	; 49
    26a6:	f1 05       	cpc	r31, r1
    26a8:	08 f0       	brcs	.+2      	; 0x26ac <bt_com_call_back+0x50>
    26aa:	28 c1       	rjmp	.+592    	; 0x28fc <bt_com_call_back+0x2a0>
    26ac:	e0 59       	subi	r30, 0x90	; 144
    26ae:	ff 4f       	sbci	r31, 0xFF	; 255
    26b0:	49 c7       	rjmp	.+3730   	; 0x3544 <__tablejump2__>
			case 'a': {
				set_head_light(0);
    26b2:	80 e0       	ldi	r24, 0x00	; 0
    26b4:	0e 94 8b 02 	call	0x516	; 0x516 <set_head_light>
				break;
    26b8:	46 c1       	rjmp	.+652    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'A': {
				set_head_light(1);
    26ba:	81 e0       	ldi	r24, 0x01	; 1
    26bc:	0e 94 8b 02 	call	0x516	; 0x516 <set_head_light>
				break;
    26c0:	42 c1       	rjmp	.+644    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'b': {
				set_brake_light(0);
    26c2:	80 e0       	ldi	r24, 0x00	; 0
    26c4:	0e 94 91 02 	call	0x522	; 0x522 <set_brake_light>
				break;
    26c8:	3e c1       	rjmp	.+636    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'B': {
				set_brake_light(1);
    26ca:	81 e0       	ldi	r24, 0x01	; 1
    26cc:	0e 94 91 02 	call	0x522	; 0x522 <set_brake_light>
				break;
    26d0:	3a c1       	rjmp	.+628    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'c': {
				set_horn(0);
    26d2:	80 e0       	ldi	r24, 0x00	; 0
    26d4:	0e 94 85 02 	call	0x50a	; 0x50a <set_horn>
				break;
    26d8:	36 c1       	rjmp	.+620    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'C': {
				set_horn(1);
    26da:	81 e0       	ldi	r24, 0x01	; 1
    26dc:	0e 94 85 02 	call	0x50a	; 0x50a <set_horn>
				break;
    26e0:	32 c1       	rjmp	.+612    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'd': {
				set_motor_speed(0);
    26e2:	80 e0       	ldi	r24, 0x00	; 0
    26e4:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
				break;
    26e8:	2e c1       	rjmp	.+604    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'D': {
				set_motor_speed(65);
    26ea:	81 e4       	ldi	r24, 0x41	; 65
    26ec:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
				break;
    26f0:	2a c1       	rjmp	.+596    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'e': {
				set_brake(0);
    26f2:	80 e0       	ldi	r24, 0x00	; 0
    26f4:	0e 94 69 03 	call	0x6d2	; 0x6d2 <set_brake>
				break;
    26f8:	26 c1       	rjmp	.+588    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'E': {
				set_brake(100);
    26fa:	84 e6       	ldi	r24, 0x64	; 100
    26fc:	0e 94 69 03 	call	0x6d2	; 0x6d2 <set_brake>
				break;
    2700:	22 c1       	rjmp	.+580    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'F': {
				uint16_t raw_x = get_raw_x_accel();
    2702:	0e 94 8c 03 	call	0x718	; 0x718 <get_raw_x_accel>
    2706:	18 2f       	mov	r17, r24
    2708:	09 2f       	mov	r16, r25
				uint16_t raw_y = get_raw_y_accel();
    270a:	0e 94 94 03 	call	0x728	; 0x728 <get_raw_y_accel>
    270e:	f8 2e       	mov	r15, r24
    2710:	e9 2e       	mov	r14, r25
				tick = xTaskGetTickCount();
    2712:	a0 d9       	rcall	.-3264   	; 0x1a54 <xTaskGetTickCount>
    2714:	90 93 d9 15 	sts	0x15D9, r25
    2718:	80 93 d8 15 	sts	0x15D8, r24
				//uint16_t raw_z = get_raw_z_accel();
				uint16_t raw_rx = get_raw_x_rotation();
    271c:	0e 94 a4 03 	call	0x748	; 0x748 <get_raw_x_rotation>
    2720:	d8 2e       	mov	r13, r24
    2722:	c9 2e       	mov	r12, r25
				uint16_t raw_ry = get_raw_y_rotation();
    2724:	0e 94 ac 03 	call	0x758	; 0x758 <get_raw_y_rotation>
    2728:	b8 2e       	mov	r11, r24
    272a:	a9 2e       	mov	r10, r25
				uint16_t tacho = get_tacho_count();
    272c:	0e 94 b4 03 	call	0x768	; 0x768 <get_tacho_count>
				sprintf(buf, "x%4dy%4dz%4dr%4dq%4dt%4d", raw_x, raw_y, tick, raw_rx, raw_ry, tacho);
    2730:	9f 93       	push	r25
    2732:	8f 93       	push	r24
    2734:	af 92       	push	r10
    2736:	bf 92       	push	r11
    2738:	cf 92       	push	r12
    273a:	df 92       	push	r13
    273c:	80 91 d9 15 	lds	r24, 0x15D9
    2740:	8f 93       	push	r24
    2742:	80 91 d8 15 	lds	r24, 0x15D8
    2746:	8f 93       	push	r24
    2748:	ef 92       	push	r14
    274a:	ff 92       	push	r15
    274c:	0f 93       	push	r16
    274e:	1f 93       	push	r17
    2750:	8f e9       	ldi	r24, 0x9F	; 159
    2752:	92 e0       	ldi	r25, 0x02	; 2
    2754:	9f 93       	push	r25
    2756:	8f 93       	push	r24
    2758:	8e 01       	movw	r16, r28
    275a:	0f 5f       	subi	r16, 0xFF	; 255
    275c:	1f 4f       	sbci	r17, 0xFF	; 255
    275e:	1f 93       	push	r17
    2760:	0f 93       	push	r16
    2762:	0e 94 20 1c 	call	0x3840	; 0x3840 <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    2766:	f8 01       	movw	r30, r16
    2768:	01 90       	ld	r0, Z+
    276a:	00 20       	and	r0, r0
    276c:	e9 f7       	brne	.-6      	; 0x2768 <bt_com_call_back+0x10c>
    276e:	31 97       	sbiw	r30, 0x01	; 1
    2770:	bf 01       	movw	r22, r30
    2772:	60 1b       	sub	r22, r16
    2774:	71 0b       	sbc	r23, r17
    2776:	c8 01       	movw	r24, r16
    2778:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <bt_send_bytes>
				break;
    277c:	0f b6       	in	r0, 0x3f	; 63
    277e:	f8 94       	cli
    2780:	de bf       	out	0x3e, r29	; 62
    2782:	0f be       	out	0x3f, r0	; 63
    2784:	cd bf       	out	0x3d, r28	; 61
    2786:	df c0       	rjmp	.+446    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'Q': {
				int sl;
				set_motor_speed(65);
    2788:	81 e4       	ldi	r24, 0x41	; 65
    278a:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
    278e:	03 ef       	ldi	r16, 0xF3	; 243
    2790:	1d e0       	ldi	r17, 0x0D	; 13
    2792:	0f 2e       	mov	r0, r31
    2794:	fb e5       	ldi	r31, 0x5B	; 91
    2796:	ef 2e       	mov	r14, r31
    2798:	fe e1       	ldi	r31, 0x1E	; 30
    279a:	ff 2e       	mov	r15, r31
    279c:	f0 2d       	mov	r31, r0
				//set_head_light(1);
				//xTimer = xTimerCreate( "Timer",( 100 ), pdTRUE,( void * ) 42, vTimerCallback);
				for (sl = 0; sl < 350; sl++)
				{
					samplingData[sl][0] = get_raw_x_accel();
    279e:	0e 94 8c 03 	call	0x718	; 0x718 <get_raw_x_accel>
    27a2:	f8 01       	movw	r30, r16
    27a4:	91 83       	std	Z+1, r25	; 0x01
    27a6:	80 83       	st	Z, r24
					samplingData[sl][1] = get_raw_y_accel();
    27a8:	0e 94 94 03 	call	0x728	; 0x728 <get_raw_y_accel>
    27ac:	f8 01       	movw	r30, r16
    27ae:	93 83       	std	Z+3, r25	; 0x03
    27b0:	82 83       	std	Z+2, r24	; 0x02
					samplingData[sl][2] = xTaskGetTickCount();
    27b2:	50 d9       	rcall	.-3424   	; 0x1a54 <xTaskGetTickCount>
    27b4:	f8 01       	movw	r30, r16
    27b6:	95 83       	std	Z+5, r25	; 0x05
    27b8:	84 83       	std	Z+4, r24	; 0x04
					//uint16_t raw_z = get_raw_z_accel();
					samplingData[sl][3] = get_raw_x_rotation();
    27ba:	0e 94 a4 03 	call	0x748	; 0x748 <get_raw_x_rotation>
    27be:	f8 01       	movw	r30, r16
    27c0:	97 83       	std	Z+7, r25	; 0x07
    27c2:	86 83       	std	Z+6, r24	; 0x06
					samplingData[sl][4] = get_raw_y_rotation();
    27c4:	0e 94 ac 03 	call	0x758	; 0x758 <get_raw_y_rotation>
    27c8:	f8 01       	movw	r30, r16
    27ca:	91 87       	std	Z+9, r25	; 0x09
    27cc:	80 87       	std	Z+8, r24	; 0x08
					samplingData[sl][5] = get_tacho_count();
    27ce:	0e 94 b4 03 	call	0x768	; 0x768 <get_tacho_count>
    27d2:	f8 01       	movw	r30, r16
    27d4:	93 87       	std	Z+11, r25	; 0x0b
    27d6:	82 87       	std	Z+10, r24	; 0x0a
					//xTimerStart(xTimer,0);
					vTaskDelay(50);
    27d8:	82 e3       	ldi	r24, 0x32	; 50
    27da:	90 e0       	ldi	r25, 0x00	; 0
    27dc:	7e da       	rcall	.-2820   	; 0x1cda <vTaskDelay>
    27de:	04 5f       	subi	r16, 0xF4	; 244
    27e0:	1f 4f       	sbci	r17, 0xFF	; 255
			case 'Q': {
				int sl;
				set_motor_speed(65);
				//set_head_light(1);
				//xTimer = xTimerCreate( "Timer",( 100 ), pdTRUE,( void * ) 42, vTimerCallback);
				for (sl = 0; sl < 350; sl++)
    27e2:	0e 15       	cp	r16, r14
    27e4:	1f 05       	cpc	r17, r15
    27e6:	d9 f6       	brne	.-74     	; 0x279e <bt_com_call_back+0x142>
					samplingData[sl][4] = get_raw_y_rotation();
					samplingData[sl][5] = get_tacho_count();
					//xTimerStart(xTimer,0);
					vTaskDelay(50);
				}
				set_brake_light(1);
    27e8:	81 e0       	ldi	r24, 0x01	; 1
    27ea:	0e 94 91 02 	call	0x522	; 0x522 <set_brake_light>
				set_motor_speed(0);
    27ee:	80 e0       	ldi	r24, 0x00	; 0
    27f0:	0e 94 97 02 	call	0x52e	; 0x52e <set_motor_speed>
				break;
    27f4:	a8 c0       	rjmp	.+336    	; 0x2946 <bt_com_call_back+0x2ea>
    27f6:	03 ef       	ldi	r16, 0xF3	; 243
    27f8:	1d e0       	ldi	r17, 0x0D	; 13
    27fa:	0f 2e       	mov	r0, r31
    27fc:	fb e5       	ldi	r31, 0x5B	; 91
    27fe:	af 2e       	mov	r10, r31
    2800:	fe e1       	ldi	r31, 0x1E	; 30
    2802:	bf 2e       	mov	r11, r31
    2804:	f0 2d       	mov	r31, r0
					//uint16_t raw_z = get_raw_z_accel();
					raw_rx =  samplingData[sl][3];
					raw_ry = samplingData[sl][4];
					tacho = samplingData[sl][5];
					vTaskDelay(150);
					sprintf(buf, "x%4dy%4dz%4dr%4dq%4dt%4d", raw_x, raw_y, tick, raw_rx, raw_ry, tacho);
    2806:	0f 2e       	mov	r0, r31
    2808:	ff e9       	ldi	r31, 0x9F	; 159
    280a:	cf 2e       	mov	r12, r31
    280c:	f2 e0       	ldi	r31, 0x02	; 2
    280e:	df 2e       	mov	r13, r31
    2810:	f0 2d       	mov	r31, r0
    2812:	ce 01       	movw	r24, r28
    2814:	01 96       	adiw	r24, 0x01	; 1
    2816:	7c 01       	movw	r14, r24
				uint16_t raw_rx;
				uint16_t raw_ry;
				uint16_t tacho;
				for (sl = 0; sl < 350; sl++)
				{
					raw_x = samplingData[sl][0];
    2818:	f8 01       	movw	r30, r16
    281a:	f0 81       	ld	r31, Z
    281c:	f9 a7       	std	Y+41, r31	; 0x29
    281e:	f8 01       	movw	r30, r16
    2820:	f1 81       	ldd	r31, Z+1	; 0x01
    2822:	fa a7       	std	Y+42, r31	; 0x2a
					raw_y = samplingData[sl][1];
    2824:	f8 01       	movw	r30, r16
    2826:	92 80       	ldd	r9, Z+2	; 0x02
    2828:	83 80       	ldd	r8, Z+3	; 0x03
					tick = samplingData[sl][2];
    282a:	84 81       	ldd	r24, Z+4	; 0x04
    282c:	95 81       	ldd	r25, Z+5	; 0x05
    282e:	90 93 d9 15 	sts	0x15D9, r25
    2832:	80 93 d8 15 	sts	0x15D8, r24
					//uint16_t raw_z = get_raw_z_accel();
					raw_rx =  samplingData[sl][3];
    2836:	76 80       	ldd	r7, Z+6	; 0x06
    2838:	67 80       	ldd	r6, Z+7	; 0x07
					raw_ry = samplingData[sl][4];
    283a:	50 84       	ldd	r5, Z+8	; 0x08
    283c:	41 84       	ldd	r4, Z+9	; 0x09
					tacho = samplingData[sl][5];
    283e:	32 84       	ldd	r3, Z+10	; 0x0a
    2840:	23 84       	ldd	r2, Z+11	; 0x0b
					vTaskDelay(150);
    2842:	86 e9       	ldi	r24, 0x96	; 150
    2844:	90 e0       	ldi	r25, 0x00	; 0
    2846:	49 da       	rcall	.-2926   	; 0x1cda <vTaskDelay>
					sprintf(buf, "x%4dy%4dz%4dr%4dq%4dt%4d", raw_x, raw_y, tick, raw_rx, raw_ry, tacho);
    2848:	2f 92       	push	r2
    284a:	3f 92       	push	r3
    284c:	4f 92       	push	r4
    284e:	5f 92       	push	r5
    2850:	6f 92       	push	r6
    2852:	7f 92       	push	r7
    2854:	80 91 d9 15 	lds	r24, 0x15D9
    2858:	8f 93       	push	r24
    285a:	80 91 d8 15 	lds	r24, 0x15D8
    285e:	8f 93       	push	r24
    2860:	8f 92       	push	r8
    2862:	9f 92       	push	r9
    2864:	fa a5       	ldd	r31, Y+42	; 0x2a
    2866:	ff 93       	push	r31
    2868:	89 a5       	ldd	r24, Y+41	; 0x29
    286a:	8f 93       	push	r24
    286c:	df 92       	push	r13
    286e:	cf 92       	push	r12
    2870:	ff 92       	push	r15
    2872:	ef 92       	push	r14
    2874:	e5 d7       	rcall	.+4042   	; 0x3840 <sprintf>
					bt_send_bytes((uint8_t *)buf, strlen(buf));
    2876:	f7 01       	movw	r30, r14
    2878:	01 90       	ld	r0, Z+
    287a:	00 20       	and	r0, r0
    287c:	e9 f7       	brne	.-6      	; 0x2878 <bt_com_call_back+0x21c>
    287e:	31 97       	sbiw	r30, 0x01	; 1
    2880:	bf 01       	movw	r22, r30
    2882:	6e 19       	sub	r22, r14
    2884:	7f 09       	sbc	r23, r15
    2886:	c7 01       	movw	r24, r14
    2888:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <bt_send_bytes>
    288c:	04 5f       	subi	r16, 0xF4	; 244
    288e:	1f 4f       	sbci	r17, 0xFF	; 255
				uint16_t raw_y;
				//uint16_t raw_z = get_raw_z_accel();
				uint16_t raw_rx;
				uint16_t raw_ry;
				uint16_t tacho;
				for (sl = 0; sl < 350; sl++)
    2890:	0f b6       	in	r0, 0x3f	; 63
    2892:	f8 94       	cli
    2894:	de bf       	out	0x3e, r29	; 62
    2896:	0f be       	out	0x3f, r0	; 63
    2898:	cd bf       	out	0x3d, r28	; 61
    289a:	0a 15       	cp	r16, r10
    289c:	1b 05       	cpc	r17, r11
    289e:	09 f0       	breq	.+2      	; 0x28a2 <bt_com_call_back+0x246>
    28a0:	bb cf       	rjmp	.-138    	; 0x2818 <bt_com_call_back+0x1bc>
					tacho = samplingData[sl][5];
					vTaskDelay(150);
					sprintf(buf, "x%4dy%4dz%4dr%4dq%4dt%4d", raw_x, raw_y, tick, raw_rx, raw_ry, tacho);
					bt_send_bytes((uint8_t *)buf, strlen(buf));
				}
				set_brake_light(0);
    28a2:	80 e0       	ldi	r24, 0x00	; 0
    28a4:	0e 94 91 02 	call	0x522	; 0x522 <set_brake_light>
				break;
    28a8:	4e c0       	rjmp	.+156    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'f': {
				learn();
    28aa:	90 dd       	rcall	.-1248   	; 0x23cc <learn>
				break;
    28ac:	4c c0       	rjmp	.+152    	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'N': {
				tick = xTaskGetTickCount();
    28ae:	d2 d8       	rcall	.-3676   	; 0x1a54 <xTaskGetTickCount>
    28b0:	80 93 d8 15 	sts	0x15D8, r24
    28b4:	90 93 d9 15 	sts	0x15D9, r25
				sprintf(buf, "%d", tick);
    28b8:	9f 93       	push	r25
    28ba:	8f 93       	push	r24
    28bc:	88 eb       	ldi	r24, 0xB8	; 184
    28be:	92 e0       	ldi	r25, 0x02	; 2
    28c0:	9f 93       	push	r25
    28c2:	8f 93       	push	r24
    28c4:	8e 01       	movw	r16, r28
    28c6:	0f 5f       	subi	r16, 0xFF	; 255
    28c8:	1f 4f       	sbci	r17, 0xFF	; 255
    28ca:	1f 93       	push	r17
    28cc:	0f 93       	push	r16
    28ce:	b8 d7       	rcall	.+3952   	; 0x3840 <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    28d0:	f8 01       	movw	r30, r16
    28d2:	01 90       	ld	r0, Z+
    28d4:	00 20       	and	r0, r0
    28d6:	e9 f7       	brne	.-6      	; 0x28d2 <bt_com_call_back+0x276>
    28d8:	31 97       	sbiw	r30, 0x01	; 1
    28da:	bf 01       	movw	r22, r30
    28dc:	60 1b       	sub	r22, r16
    28de:	71 0b       	sbc	r23, r17
    28e0:	c8 01       	movw	r24, r16
    28e2:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <bt_send_bytes>
				break;
    28e6:	0f 90       	pop	r0
    28e8:	0f 90       	pop	r0
    28ea:	0f 90       	pop	r0
    28ec:	0f 90       	pop	r0
    28ee:	0f 90       	pop	r0
    28f0:	0f 90       	pop	r0
    28f2:	29 c0       	rjmp	.+82     	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'P': {
				plannedTrack();
    28f4:	4b de       	rcall	.-874    	; 0x258c <plannedTrack>
				break;
    28f6:	27 c0       	rjmp	.+78     	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			case 'p': {
				plannedTrackWithSpeedMeas();
    28f8:	cd dd       	rcall	.-1126   	; 0x2494 <plannedTrackWithSpeedMeas>
				break;
    28fa:	25 c0       	rjmp	.+74     	; 0x2946 <bt_com_call_back+0x2ea>
			}
			
			default:
				sendValue[charCount] = byte;
    28fc:	90 91 50 10 	lds	r25, 0x1050
    2900:	e9 2f       	mov	r30, r25
    2902:	f0 e0       	ldi	r31, 0x00	; 0
    2904:	e5 5b       	subi	r30, 0xB5	; 181
    2906:	ff 4e       	sbci	r31, 0xEF	; 239
    2908:	80 83       	st	Z, r24
				charCount++;
    290a:	9f 5f       	subi	r25, 0xFF	; 255
    290c:	90 93 50 10 	sts	0x1050, r25
				if(byte == 33) {
    2910:	81 32       	cpi	r24, 0x21	; 33
    2912:	c9 f4       	brne	.+50     	; 0x2946 <bt_com_call_back+0x2ea>
					accData[nextVal] = atoi(sendValue);
    2914:	00 91 52 10 	lds	r16, 0x1052
    2918:	10 91 53 10 	lds	r17, 0x1053
    291c:	8b e4       	ldi	r24, 0x4B	; 75
    291e:	90 e1       	ldi	r25, 0x10	; 16
    2920:	61 d7       	rcall	.+3778   	; 0x37e4 <atoi>
    2922:	f8 01       	movw	r30, r16
    2924:	ee 0f       	add	r30, r30
    2926:	ff 1f       	adc	r31, r31
    2928:	ec 5a       	subi	r30, 0xAC	; 172
    292a:	ff 4e       	sbci	r31, 0xEF	; 239
    292c:	91 83       	std	Z+1, r25	; 0x01
    292e:	80 83       	st	Z, r24
					nextVal++;
    2930:	80 91 52 10 	lds	r24, 0x1052
    2934:	90 91 53 10 	lds	r25, 0x1053
    2938:	01 96       	adiw	r24, 0x01	; 1
    293a:	90 93 53 10 	sts	0x1053, r25
    293e:	80 93 52 10 	sts	0x1052, r24
					charCount=0;
    2942:	10 92 50 10 	sts	0x1050, r1
				}
				break;
		}
	}
}
    2946:	aa 96       	adiw	r28, 0x2a	; 42
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	f8 94       	cli
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	0f be       	out	0x3f, r0	; 63
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	df 91       	pop	r29
    2954:	cf 91       	pop	r28
    2956:	1f 91       	pop	r17
    2958:	0f 91       	pop	r16
    295a:	ff 90       	pop	r15
    295c:	ef 90       	pop	r14
    295e:	df 90       	pop	r13
    2960:	cf 90       	pop	r12
    2962:	bf 90       	pop	r11
    2964:	af 90       	pop	r10
    2966:	9f 90       	pop	r9
    2968:	8f 90       	pop	r8
    296a:	7f 90       	pop	r7
    296c:	6f 90       	pop	r6
    296e:	5f 90       	pop	r5
    2970:	4f 90       	pop	r4
    2972:	3f 90       	pop	r3
    2974:	2f 90       	pop	r2
    2976:	08 95       	ret

00002978 <vstartupTask>:
		// Wait for goal line is passed
		xSemaphoreTake(goal_line_semaphore, portMAX_DELAY);
	}
}

static void vstartupTask( void *pvParameters ) {
    2978:	cf 93       	push	r28
    297a:	df 93       	push	r29
    297c:	1f 92       	push	r1
    297e:	cd b7       	in	r28, 0x3d	; 61
    2980:	de b7       	in	r29, 0x3e	; 62
	/* The parameters are not used. */
	( void ) pvParameters;
	
	goal_line_semaphore = xSemaphoreCreateBinary();
    2982:	43 e0       	ldi	r20, 0x03	; 3
    2984:	60 e0       	ldi	r22, 0x00	; 0
    2986:	81 e0       	ldi	r24, 0x01	; 1
    2988:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xQueueGenericCreate>
    298c:	90 93 cf 15 	sts	0x15CF, r25
    2990:	80 93 ce 15 	sts	0x15CE, r24
	_xBT_received_chars_queue = xQueueCreate( _BT_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
    2994:	40 e0       	ldi	r20, 0x00	; 0
    2996:	61 e0       	ldi	r22, 0x01	; 1
    2998:	8e e1       	ldi	r24, 0x1E	; 30
    299a:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xQueueGenericCreate>
    299e:	90 93 cd 15 	sts	0x15CD, r25
    29a2:	80 93 cc 15 	sts	0x15CC, r24
	
	if( goal_line_semaphore == NULL ) {
    29a6:	80 91 ce 15 	lds	r24, 0x15CE
    29aa:	90 91 cf 15 	lds	r25, 0x15CF
    29ae:	00 97       	sbiw	r24, 0x00	; 0
    29b0:	11 f0       	breq	.+4      	; 0x29b6 <vstartupTask+0x3e>
		/* There was insufficient OpenRTOS heap available for the semaphore to
		be created successfully. */
		// What to do here ?????????????????????????????????
		} else {
		set_goal_line_semaphore(goal_line_semaphore);
    29b2:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <set_goal_line_semaphore>
	}
	
	// Initialize Bluetooth Module
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    29b6:	88 ee       	ldi	r24, 0xE8	; 232
    29b8:	93 e0       	ldi	r25, 0x03	; 3
    29ba:	8f d9       	rcall	.-3298   	; 0x1cda <vTaskDelay>
	set_bt_reset(0);  // Disable reset line of Blue tooth module
    29bc:	80 e0       	ldi	r24, 0x00	; 0
    29be:	0e 94 ce 03 	call	0x79c	; 0x79c <set_bt_reset>
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    29c2:	88 ee       	ldi	r24, 0xE8	; 232
    29c4:	93 e0       	ldi	r25, 0x03	; 3
    29c6:	89 d9       	rcall	.-3310   	; 0x1cda <vTaskDelay>
	init_bt_module(bt_status_call_back, _xBT_received_chars_queue);
    29c8:	60 91 cc 15 	lds	r22, 0x15CC
    29cc:	70 91 cd 15 	lds	r23, 0x15CD
    29d0:	85 ed       	ldi	r24, 0xD5	; 213
    29d2:	91 e1       	ldi	r25, 0x11	; 17
    29d4:	0e 94 dd 03 	call	0x7ba	; 0x7ba <init_bt_module>
	
	xTaskCreate( vjustATask, "JustATask", configMINIMAL_STACK_SIZE, NULL, just_a_task_TASK_PRIORITY, NULL );
    29d8:	a1 2c       	mov	r10, r1
    29da:	b1 2c       	mov	r11, r1
    29dc:	c1 2c       	mov	r12, r1
    29de:	d1 2c       	mov	r13, r1
    29e0:	e1 2c       	mov	r14, r1
    29e2:	f1 2c       	mov	r15, r1
    29e4:	01 e0       	ldi	r16, 0x01	; 1
    29e6:	20 e0       	ldi	r18, 0x00	; 0
    29e8:	30 e0       	ldi	r19, 0x00	; 0
    29ea:	49 eb       	ldi	r20, 0xB9	; 185
    29ec:	50 e0       	ldi	r21, 0x00	; 0
    29ee:	6b eb       	ldi	r22, 0xBB	; 187
    29f0:	72 e0       	ldi	r23, 0x02	; 2
    29f2:	8b ed       	ldi	r24, 0xDB	; 219
    29f4:	91 e1       	ldi	r25, 0x11	; 17
    29f6:	0e 94 ff 0b 	call	0x17fe	; 0x17fe <xTaskGenericCreate>
	uint8_t _byte;
	for( ;; ) {
		xQueueReceive( _xBT_received_chars_queue, &_byte, portMAX_DELAY );
    29fa:	20 e0       	ldi	r18, 0x00	; 0
    29fc:	4f ef       	ldi	r20, 0xFF	; 255
    29fe:	5f ef       	ldi	r21, 0xFF	; 255
    2a00:	be 01       	movw	r22, r28
    2a02:	6f 5f       	subi	r22, 0xFF	; 255
    2a04:	7f 4f       	sbci	r23, 0xFF	; 255
    2a06:	80 91 cc 15 	lds	r24, 0x15CC
    2a0a:	90 91 cd 15 	lds	r25, 0x15CD
    2a0e:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <xQueueGenericReceive>
		bt_com_call_back(_byte);
    2a12:	89 81       	ldd	r24, Y+1	; 0x01
    2a14:	23 de       	rcall	.-954    	; 0x265c <bt_com_call_back>
    2a16:	f1 cf       	rjmp	.-30     	; 0x29fa <vstartupTask+0x82>

00002a18 <main>:
	}
}

int main(void)
{
    2a18:	af 92       	push	r10
    2a1a:	bf 92       	push	r11
    2a1c:	cf 92       	push	r12
    2a1e:	df 92       	push	r13
    2a20:	ef 92       	push	r14
    2a22:	ff 92       	push	r15
    2a24:	0f 93       	push	r16
	init_main_board();
    2a26:	0e 94 ba 02 	call	0x574	; 0x574 <init_main_board>
	xTaskCreate( vstartupTask, "StartupTask", configMINIMAL_STACK_SIZE, NULL, startup_TASK_PRIORITY, NULL );
    2a2a:	a1 2c       	mov	r10, r1
    2a2c:	b1 2c       	mov	r11, r1
    2a2e:	c1 2c       	mov	r12, r1
    2a30:	d1 2c       	mov	r13, r1
    2a32:	e1 2c       	mov	r14, r1
    2a34:	f1 2c       	mov	r15, r1
    2a36:	00 e0       	ldi	r16, 0x00	; 0
    2a38:	20 e0       	ldi	r18, 0x00	; 0
    2a3a:	30 e0       	ldi	r19, 0x00	; 0
    2a3c:	49 eb       	ldi	r20, 0xB9	; 185
    2a3e:	50 e0       	ldi	r21, 0x00	; 0
    2a40:	65 ec       	ldi	r22, 0xC5	; 197
    2a42:	72 e0       	ldi	r23, 0x02	; 2
    2a44:	8c eb       	ldi	r24, 0xBC	; 188
    2a46:	94 e1       	ldi	r25, 0x14	; 20
    2a48:	0e 94 ff 0b 	call	0x17fe	; 0x17fe <xTaskGenericCreate>
	vTaskStartScheduler();
    2a4c:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vTaskStartScheduler>
}
    2a50:	80 e0       	ldi	r24, 0x00	; 0
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	0f 91       	pop	r16
    2a56:	ff 90       	pop	r15
    2a58:	ef 90       	pop	r14
    2a5a:	df 90       	pop	r13
    2a5c:	cf 90       	pop	r12
    2a5e:	bf 90       	pop	r11
    2a60:	af 90       	pop	r10
    2a62:	08 95       	ret

00002a64 <vApplicationStackOverflowHook>:


// Called is TASK Stack overflows
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
    2a64:	08 95       	ret

00002a66 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
    2a66:	4f 92       	push	r4
    2a68:	5f 92       	push	r5
    2a6a:	6f 92       	push	r6
    2a6c:	7f 92       	push	r7
    2a6e:	8f 92       	push	r8
    2a70:	9f 92       	push	r9
    2a72:	af 92       	push	r10
    2a74:	bf 92       	push	r11
    2a76:	cf 92       	push	r12
    2a78:	df 92       	push	r13
    2a7a:	ff 92       	push	r15
    2a7c:	0f 93       	push	r16
    2a7e:	1f 93       	push	r17
    2a80:	cf 93       	push	r28
    2a82:	df 93       	push	r29
    2a84:	cd b7       	in	r28, 0x3d	; 61
    2a86:	de b7       	in	r29, 0x3e	; 62
    2a88:	f8 2e       	mov	r15, r24
    2a8a:	2a 01       	movw	r4, r20
    2a8c:	3b 01       	movw	r6, r22
    2a8e:	88 e0       	ldi	r24, 0x08	; 8
    2a90:	90 e0       	ldi	r25, 0x00	; 0
    2a92:	81 d5       	rcall	.+2818   	; 0x3596 <malloc>
    2a94:	8c 01       	movw	r16, r24
    2a96:	8f 2d       	mov	r24, r15
    2a98:	90 e0       	ldi	r25, 0x00	; 0
    2a9a:	88 0f       	add	r24, r24
    2a9c:	99 1f       	adc	r25, r25
    2a9e:	fc 01       	movw	r30, r24
    2aa0:	e0 53       	subi	r30, 0x30	; 48
    2aa2:	fa 4e       	sbci	r31, 0xEA	; 234
    2aa4:	11 83       	std	Z+1, r17	; 0x01
    2aa6:	00 83       	st	Z, r16
    2aa8:	fc 01       	movw	r30, r24
    2aaa:	e5 5b       	subi	r30, 0xB5	; 181
    2aac:	fd 4f       	sbci	r31, 0xFD	; 253
    2aae:	80 81       	ld	r24, Z
    2ab0:	91 81       	ldd	r25, Z+1	; 0x01
    2ab2:	d8 01       	movw	r26, r16
    2ab4:	11 96       	adiw	r26, 0x01	; 1
    2ab6:	9c 93       	st	X, r25
    2ab8:	8e 93       	st	-X, r24
    2aba:	13 96       	adiw	r26, 0x03	; 3
    2abc:	bc 92       	st	X, r11
    2abe:	ae 92       	st	-X, r10
    2ac0:	12 97       	sbiw	r26, 0x02	; 2
    2ac2:	15 96       	adiw	r26, 0x05	; 5
    2ac4:	dc 92       	st	X, r13
    2ac6:	ce 92       	st	-X, r12
    2ac8:	14 97       	sbiw	r26, 0x04	; 4
    2aca:	17 96       	adiw	r26, 0x07	; 7
    2acc:	9c 92       	st	X, r9
    2ace:	8e 92       	st	-X, r8
    2ad0:	16 97       	sbiw	r26, 0x06	; 6
    2ad2:	ff b6       	in	r15, 0x3f	; 63
    2ad4:	f8 94       	cli
    2ad6:	d8 01       	movw	r26, r16
    2ad8:	ed 91       	ld	r30, X+
    2ada:	fc 91       	ld	r31, X
    2adc:	11 97       	sbiw	r26, 0x01	; 1
    2ade:	36 97       	sbiw	r30, 0x06	; 6
    2ae0:	80 81       	ld	r24, Z
    2ae2:	82 60       	ori	r24, 0x02	; 2
    2ae4:	80 83       	st	Z, r24
    2ae6:	cd 90       	ld	r12, X+
    2ae8:	dc 90       	ld	r13, X
    2aea:	44 0c       	add	r4, r4
    2aec:	55 1c       	adc	r5, r5
    2aee:	66 1c       	adc	r6, r6
    2af0:	77 1c       	adc	r7, r7
    2af2:	44 0c       	add	r4, r4
    2af4:	55 1c       	adc	r5, r5
    2af6:	66 1c       	adc	r6, r6
    2af8:	77 1c       	adc	r7, r7
    2afa:	a3 01       	movw	r20, r6
    2afc:	92 01       	movw	r18, r4
    2afe:	22 0f       	add	r18, r18
    2b00:	33 1f       	adc	r19, r19
    2b02:	44 1f       	adc	r20, r20
    2b04:	55 1f       	adc	r21, r21
    2b06:	60 e0       	ldi	r22, 0x00	; 0
    2b08:	74 e2       	ldi	r23, 0x24	; 36
    2b0a:	84 ef       	ldi	r24, 0xF4	; 244
    2b0c:	90 e0       	ldi	r25, 0x00	; 0
    2b0e:	dc d4       	rcall	.+2488   	; 0x34c8 <__udivmodsi4>
    2b10:	21 50       	subi	r18, 0x01	; 1
    2b12:	f6 01       	movw	r30, r12
    2b14:	32 97       	sbiw	r30, 0x02	; 2
    2b16:	20 83       	st	Z, r18
    2b18:	d8 01       	movw	r26, r16
    2b1a:	ed 91       	ld	r30, X+
    2b1c:	fc 91       	ld	r31, X
    2b1e:	11 97       	sbiw	r26, 0x01	; 1
    2b20:	35 97       	sbiw	r30, 0x05	; 5
    2b22:	88 e9       	ldi	r24, 0x98	; 152
    2b24:	80 83       	st	Z, r24
    2b26:	ed 91       	ld	r30, X+
    2b28:	fc 91       	ld	r31, X
    2b2a:	34 97       	sbiw	r30, 0x04	; 4
    2b2c:	86 e0       	ldi	r24, 0x06	; 6
    2b2e:	80 83       	st	Z, r24
    2b30:	ff be       	out	0x3f, r15	; 63
    2b32:	c8 01       	movw	r24, r16
    2b34:	df 91       	pop	r29
    2b36:	cf 91       	pop	r28
    2b38:	1f 91       	pop	r17
    2b3a:	0f 91       	pop	r16
    2b3c:	ff 90       	pop	r15
    2b3e:	df 90       	pop	r13
    2b40:	cf 90       	pop	r12
    2b42:	bf 90       	pop	r11
    2b44:	af 90       	pop	r10
    2b46:	9f 90       	pop	r9
    2b48:	8f 90       	pop	r8
    2b4a:	7f 90       	pop	r7
    2b4c:	6f 90       	pop	r6
    2b4e:	5f 90       	pop	r5
    2b50:	4f 90       	pop	r4
    2b52:	08 95       	ret

00002b54 <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
    2b54:	ef 92       	push	r14
    2b56:	ff 92       	push	r15
    2b58:	0f 93       	push	r16
    2b5a:	1f 93       	push	r17
    2b5c:	cf 93       	push	r28
    2b5e:	df 93       	push	r29
    2b60:	8c 01       	movw	r16, r24
    2b62:	e4 2e       	mov	r14, r20
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    2b64:	dc 01       	movw	r26, r24
    2b66:	12 96       	adiw	r26, 0x02	; 2
    2b68:	ed 91       	ld	r30, X+
    2b6a:	fc 91       	ld	r31, X
    2b6c:	13 97       	sbiw	r26, 0x03	; 3
    2b6e:	30 97       	sbiw	r30, 0x00	; 0
    2b70:	69 f0       	breq	.+26     	; 0x2b8c <serial_send_bytes+0x38>
    2b72:	24 2f       	mov	r18, r20
    2b74:	30 e0       	ldi	r19, 0x00	; 0
    2b76:	42 a5       	ldd	r20, Z+42	; 0x2a
    2b78:	88 e2       	ldi	r24, 0x28	; 40
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	84 1b       	sub	r24, r20
    2b7e:	91 09       	sbc	r25, r1
    2b80:	82 17       	cp	r24, r18
    2b82:	93 07       	cpc	r25, r19
    2b84:	e4 f0       	brlt	.+56     	; 0x2bbe <serial_send_bytes+0x6a>
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2b86:	e1 10       	cpse	r14, r1
    2b88:	05 c0       	rjmp	.+10     	; 0x2b94 <serial_send_bytes+0x40>
    2b8a:	10 c0       	rjmp	.+32     	; 0x2bac <serial_send_bytes+0x58>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    2b8c:	b1 e0       	ldi	r27, 0x01	; 1
    2b8e:	b4 17       	cp	r27, r20
    2b90:	c0 f0       	brcs	.+48     	; 0x2bc2 <serial_send_bytes+0x6e>
    2b92:	f9 cf       	rjmp	.-14     	; 0x2b86 <serial_send_bytes+0x32>
    2b94:	c6 2f       	mov	r28, r22
    2b96:	d7 2f       	mov	r29, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2b98:	f1 2c       	mov	r15, r1
		buffer_put_item(handle->_tx_buf, buf[i]);
    2b9a:	69 91       	ld	r22, Y+
    2b9c:	f8 01       	movw	r30, r16
    2b9e:	82 81       	ldd	r24, Z+2	; 0x02
    2ba0:	93 81       	ldd	r25, Z+3	; 0x03
    2ba2:	0e 94 80 04 	call	0x900	; 0x900 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2ba6:	f3 94       	inc	r15
    2ba8:	fe 10       	cpse	r15, r14
    2baa:	f7 cf       	rjmp	.-18     	; 0x2b9a <serial_send_bytes+0x46>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
    2bac:	d8 01       	movw	r26, r16
    2bae:	ed 91       	ld	r30, X+
    2bb0:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
    2bb2:	35 97       	sbiw	r30, 0x05	; 5
    2bb4:	80 81       	ld	r24, Z
    2bb6:	80 62       	ori	r24, 0x20	; 32
    2bb8:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
    2bba:	80 e0       	ldi	r24, 0x00	; 0
    2bbc:	03 c0       	rjmp	.+6      	; 0x2bc4 <serial_send_bytes+0x70>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
    2bbe:	82 e0       	ldi	r24, 0x02	; 2
    2bc0:	01 c0       	rjmp	.+2      	; 0x2bc4 <serial_send_bytes+0x70>
    2bc2:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
    2bc4:	df 91       	pop	r29
    2bc6:	cf 91       	pop	r28
    2bc8:	1f 91       	pop	r17
    2bca:	0f 91       	pop	r16
    2bcc:	ff 90       	pop	r15
    2bce:	ef 90       	pop	r14
    2bd0:	08 95       	ret

00002bd2 <__vector_25>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    2bd2:	1f 92       	push	r1
    2bd4:	0f 92       	push	r0
    2bd6:	0f b6       	in	r0, 0x3f	; 63
    2bd8:	0f 92       	push	r0
    2bda:	11 24       	eor	r1, r1
    2bdc:	0b b6       	in	r0, 0x3b	; 59
    2bde:	0f 92       	push	r0
    2be0:	2f 93       	push	r18
    2be2:	3f 93       	push	r19
    2be4:	4f 93       	push	r20
    2be6:	5f 93       	push	r21
    2be8:	6f 93       	push	r22
    2bea:	7f 93       	push	r23
    2bec:	8f 93       	push	r24
    2bee:	9f 93       	push	r25
    2bf0:	af 93       	push	r26
    2bf2:	bf 93       	push	r27
    2bf4:	cf 93       	push	r28
    2bf6:	ef 93       	push	r30
    2bf8:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    2bfa:	e0 91 d0 15 	lds	r30, 0x15D0
    2bfe:	f0 91 d1 15 	lds	r31, 0x15D1
    2c02:	30 97       	sbiw	r30, 0x00	; 0
    2c04:	a1 f0       	breq	.+40     	; 0x2c2e <__vector_25+0x5c>
		item = UDR0;
    2c06:	c0 91 c6 00 	lds	r28, 0x00C6
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
    2c0a:	6c 2f       	mov	r22, r28
    2c0c:	84 81       	ldd	r24, Z+4	; 0x04
    2c0e:	95 81       	ldd	r25, Z+5	; 0x05
    2c10:	0e 94 80 04 	call	0x900	; 0x900 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
    2c14:	80 91 d0 15 	lds	r24, 0x15D0
    2c18:	90 91 d1 15 	lds	r25, 0x15D1
    2c1c:	dc 01       	movw	r26, r24
    2c1e:	16 96       	adiw	r26, 0x06	; 6
    2c20:	ed 91       	ld	r30, X+
    2c22:	fc 91       	ld	r31, X
    2c24:	17 97       	sbiw	r26, 0x07	; 7
    2c26:	30 97       	sbiw	r30, 0x00	; 0
    2c28:	11 f0       	breq	.+4      	; 0x2c2e <__vector_25+0x5c>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
    2c2a:	6c 2f       	mov	r22, r28
    2c2c:	19 95       	eicall
		}
	}
}
    2c2e:	ff 91       	pop	r31
    2c30:	ef 91       	pop	r30
    2c32:	cf 91       	pop	r28
    2c34:	bf 91       	pop	r27
    2c36:	af 91       	pop	r26
    2c38:	9f 91       	pop	r25
    2c3a:	8f 91       	pop	r24
    2c3c:	7f 91       	pop	r23
    2c3e:	6f 91       	pop	r22
    2c40:	5f 91       	pop	r21
    2c42:	4f 91       	pop	r20
    2c44:	3f 91       	pop	r19
    2c46:	2f 91       	pop	r18
    2c48:	0f 90       	pop	r0
    2c4a:	0b be       	out	0x3b, r0	; 59
    2c4c:	0f 90       	pop	r0
    2c4e:	0f be       	out	0x3f, r0	; 63
    2c50:	0f 90       	pop	r0
    2c52:	1f 90       	pop	r1
    2c54:	18 95       	reti

00002c56 <__vector_26>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
    2c56:	1f 92       	push	r1
    2c58:	0f 92       	push	r0
    2c5a:	0f b6       	in	r0, 0x3f	; 63
    2c5c:	0f 92       	push	r0
    2c5e:	11 24       	eor	r1, r1
    2c60:	0b b6       	in	r0, 0x3b	; 59
    2c62:	0f 92       	push	r0
    2c64:	2f 93       	push	r18
    2c66:	3f 93       	push	r19
    2c68:	4f 93       	push	r20
    2c6a:	5f 93       	push	r21
    2c6c:	6f 93       	push	r22
    2c6e:	7f 93       	push	r23
    2c70:	8f 93       	push	r24
    2c72:	9f 93       	push	r25
    2c74:	af 93       	push	r26
    2c76:	bf 93       	push	r27
    2c78:	ef 93       	push	r30
    2c7a:	ff 93       	push	r31
    2c7c:	cf 93       	push	r28
    2c7e:	df 93       	push	r29
    2c80:	1f 92       	push	r1
    2c82:	cd b7       	in	r28, 0x3d	; 61
    2c84:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    2c86:	e0 91 d0 15 	lds	r30, 0x15D0
    2c8a:	f0 91 d1 15 	lds	r31, 0x15D1
    2c8e:	30 97       	sbiw	r30, 0x00	; 0
    2c90:	99 f0       	breq	.+38     	; 0x2cb8 <__vector_26+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
    2c92:	be 01       	movw	r22, r28
    2c94:	6f 5f       	subi	r22, 0xFF	; 255
    2c96:	7f 4f       	sbci	r23, 0xFF	; 255
    2c98:	82 81       	ldd	r24, Z+2	; 0x02
    2c9a:	93 81       	ldd	r25, Z+3	; 0x03
    2c9c:	0e 94 66 04 	call	0x8cc	; 0x8cc <buffer_get_item>
    2ca0:	81 11       	cpse	r24, r1
    2ca2:	04 c0       	rjmp	.+8      	; 0x2cac <__vector_26+0x56>
			UDR0 = item;
    2ca4:	89 81       	ldd	r24, Y+1	; 0x01
    2ca6:	80 93 c6 00 	sts	0x00C6, r24
    2caa:	0b c0       	rjmp	.+22     	; 0x2cc2 <__vector_26+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
    2cac:	e1 ec       	ldi	r30, 0xC1	; 193
    2cae:	f0 e0       	ldi	r31, 0x00	; 0
    2cb0:	80 81       	ld	r24, Z
    2cb2:	8f 7d       	andi	r24, 0xDF	; 223
    2cb4:	80 83       	st	Z, r24
    2cb6:	05 c0       	rjmp	.+10     	; 0x2cc2 <__vector_26+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    2cb8:	e1 ec       	ldi	r30, 0xC1	; 193
    2cba:	f0 e0       	ldi	r31, 0x00	; 0
    2cbc:	80 81       	ld	r24, Z
    2cbe:	8f 7d       	andi	r24, 0xDF	; 223
    2cc0:	80 83       	st	Z, r24
	}
}
    2cc2:	0f 90       	pop	r0
    2cc4:	df 91       	pop	r29
    2cc6:	cf 91       	pop	r28
    2cc8:	ff 91       	pop	r31
    2cca:	ef 91       	pop	r30
    2ccc:	bf 91       	pop	r27
    2cce:	af 91       	pop	r26
    2cd0:	9f 91       	pop	r25
    2cd2:	8f 91       	pop	r24
    2cd4:	7f 91       	pop	r23
    2cd6:	6f 91       	pop	r22
    2cd8:	5f 91       	pop	r21
    2cda:	4f 91       	pop	r20
    2cdc:	3f 91       	pop	r19
    2cde:	2f 91       	pop	r18
    2ce0:	0f 90       	pop	r0
    2ce2:	0b be       	out	0x3b, r0	; 59
    2ce4:	0f 90       	pop	r0
    2ce6:	0f be       	out	0x3f, r0	; 63
    2ce8:	0f 90       	pop	r0
    2cea:	1f 90       	pop	r1
    2cec:	18 95       	reti

00002cee <__vector_36>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    2cee:	1f 92       	push	r1
    2cf0:	0f 92       	push	r0
    2cf2:	0f b6       	in	r0, 0x3f	; 63
    2cf4:	0f 92       	push	r0
    2cf6:	11 24       	eor	r1, r1
    2cf8:	0b b6       	in	r0, 0x3b	; 59
    2cfa:	0f 92       	push	r0
    2cfc:	2f 93       	push	r18
    2cfe:	3f 93       	push	r19
    2d00:	4f 93       	push	r20
    2d02:	5f 93       	push	r21
    2d04:	6f 93       	push	r22
    2d06:	7f 93       	push	r23
    2d08:	8f 93       	push	r24
    2d0a:	9f 93       	push	r25
    2d0c:	af 93       	push	r26
    2d0e:	bf 93       	push	r27
    2d10:	cf 93       	push	r28
    2d12:	ef 93       	push	r30
    2d14:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    2d16:	e0 91 d2 15 	lds	r30, 0x15D2
    2d1a:	f0 91 d3 15 	lds	r31, 0x15D3
    2d1e:	30 97       	sbiw	r30, 0x00	; 0
    2d20:	a1 f0       	breq	.+40     	; 0x2d4a <__vector_36+0x5c>
		item = UDR1;
    2d22:	c0 91 ce 00 	lds	r28, 0x00CE
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    2d26:	6c 2f       	mov	r22, r28
    2d28:	84 81       	ldd	r24, Z+4	; 0x04
    2d2a:	95 81       	ldd	r25, Z+5	; 0x05
    2d2c:	0e 94 80 04 	call	0x900	; 0x900 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    2d30:	80 91 d2 15 	lds	r24, 0x15D2
    2d34:	90 91 d3 15 	lds	r25, 0x15D3
    2d38:	dc 01       	movw	r26, r24
    2d3a:	16 96       	adiw	r26, 0x06	; 6
    2d3c:	ed 91       	ld	r30, X+
    2d3e:	fc 91       	ld	r31, X
    2d40:	17 97       	sbiw	r26, 0x07	; 7
    2d42:	30 97       	sbiw	r30, 0x00	; 0
    2d44:	11 f0       	breq	.+4      	; 0x2d4a <__vector_36+0x5c>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    2d46:	6c 2f       	mov	r22, r28
    2d48:	19 95       	eicall
		}
	}
}
    2d4a:	ff 91       	pop	r31
    2d4c:	ef 91       	pop	r30
    2d4e:	cf 91       	pop	r28
    2d50:	bf 91       	pop	r27
    2d52:	af 91       	pop	r26
    2d54:	9f 91       	pop	r25
    2d56:	8f 91       	pop	r24
    2d58:	7f 91       	pop	r23
    2d5a:	6f 91       	pop	r22
    2d5c:	5f 91       	pop	r21
    2d5e:	4f 91       	pop	r20
    2d60:	3f 91       	pop	r19
    2d62:	2f 91       	pop	r18
    2d64:	0f 90       	pop	r0
    2d66:	0b be       	out	0x3b, r0	; 59
    2d68:	0f 90       	pop	r0
    2d6a:	0f be       	out	0x3f, r0	; 63
    2d6c:	0f 90       	pop	r0
    2d6e:	1f 90       	pop	r1
    2d70:	18 95       	reti

00002d72 <__vector_37>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    2d72:	1f 92       	push	r1
    2d74:	0f 92       	push	r0
    2d76:	0f b6       	in	r0, 0x3f	; 63
    2d78:	0f 92       	push	r0
    2d7a:	11 24       	eor	r1, r1
    2d7c:	0b b6       	in	r0, 0x3b	; 59
    2d7e:	0f 92       	push	r0
    2d80:	2f 93       	push	r18
    2d82:	3f 93       	push	r19
    2d84:	4f 93       	push	r20
    2d86:	5f 93       	push	r21
    2d88:	6f 93       	push	r22
    2d8a:	7f 93       	push	r23
    2d8c:	8f 93       	push	r24
    2d8e:	9f 93       	push	r25
    2d90:	af 93       	push	r26
    2d92:	bf 93       	push	r27
    2d94:	ef 93       	push	r30
    2d96:	ff 93       	push	r31
    2d98:	cf 93       	push	r28
    2d9a:	df 93       	push	r29
    2d9c:	1f 92       	push	r1
    2d9e:	cd b7       	in	r28, 0x3d	; 61
    2da0:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    2da2:	e0 91 d2 15 	lds	r30, 0x15D2
    2da6:	f0 91 d3 15 	lds	r31, 0x15D3
    2daa:	30 97       	sbiw	r30, 0x00	; 0
    2dac:	99 f0       	breq	.+38     	; 0x2dd4 <__vector_37+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    2dae:	be 01       	movw	r22, r28
    2db0:	6f 5f       	subi	r22, 0xFF	; 255
    2db2:	7f 4f       	sbci	r23, 0xFF	; 255
    2db4:	82 81       	ldd	r24, Z+2	; 0x02
    2db6:	93 81       	ldd	r25, Z+3	; 0x03
    2db8:	0e 94 66 04 	call	0x8cc	; 0x8cc <buffer_get_item>
    2dbc:	81 11       	cpse	r24, r1
    2dbe:	04 c0       	rjmp	.+8      	; 0x2dc8 <__vector_37+0x56>
			UDR1 = item;
    2dc0:	89 81       	ldd	r24, Y+1	; 0x01
    2dc2:	80 93 ce 00 	sts	0x00CE, r24
    2dc6:	0b c0       	rjmp	.+22     	; 0x2dde <__vector_37+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    2dc8:	e9 ec       	ldi	r30, 0xC9	; 201
    2dca:	f0 e0       	ldi	r31, 0x00	; 0
    2dcc:	80 81       	ld	r24, Z
    2dce:	8f 7d       	andi	r24, 0xDF	; 223
    2dd0:	80 83       	st	Z, r24
    2dd2:	05 c0       	rjmp	.+10     	; 0x2dde <__vector_37+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    2dd4:	e9 ec       	ldi	r30, 0xC9	; 201
    2dd6:	f0 e0       	ldi	r31, 0x00	; 0
    2dd8:	80 81       	ld	r24, Z
    2dda:	8f 7d       	andi	r24, 0xDF	; 223
    2ddc:	80 83       	st	Z, r24
	}
}
    2dde:	0f 90       	pop	r0
    2de0:	df 91       	pop	r29
    2de2:	cf 91       	pop	r28
    2de4:	ff 91       	pop	r31
    2de6:	ef 91       	pop	r30
    2de8:	bf 91       	pop	r27
    2dea:	af 91       	pop	r26
    2dec:	9f 91       	pop	r25
    2dee:	8f 91       	pop	r24
    2df0:	7f 91       	pop	r23
    2df2:	6f 91       	pop	r22
    2df4:	5f 91       	pop	r21
    2df6:	4f 91       	pop	r20
    2df8:	3f 91       	pop	r19
    2dfa:	2f 91       	pop	r18
    2dfc:	0f 90       	pop	r0
    2dfe:	0b be       	out	0x3b, r0	; 59
    2e00:	0f 90       	pop	r0
    2e02:	0f be       	out	0x3f, r0	; 63
    2e04:	0f 90       	pop	r0
    2e06:	1f 90       	pop	r1
    2e08:	18 95       	reti

00002e0a <_select_instance>:
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    2e0a:	e0 91 d5 15 	lds	r30, 0x15D5
    2e0e:	f0 91 d6 15 	lds	r31, 0x15D6
    2e12:	30 97       	sbiw	r30, 0x00	; 0
    2e14:	01 f1       	breq	.+64     	; 0x2e56 <_select_instance+0x4c>
    2e16:	23 81       	ldd	r18, Z+3	; 0x03
    2e18:	21 30       	cpi	r18, 0x01	; 1
    2e1a:	79 f4       	brne	.+30     	; 0x2e3a <_select_instance+0x30>
    2e1c:	a0 81       	ld	r26, Z
    2e1e:	b1 81       	ldd	r27, Z+1	; 0x01
    2e20:	4c 91       	ld	r20, X
    2e22:	21 e0       	ldi	r18, 0x01	; 1
    2e24:	30 e0       	ldi	r19, 0x00	; 0
    2e26:	02 80       	ldd	r0, Z+2	; 0x02
    2e28:	02 c0       	rjmp	.+4      	; 0x2e2e <_select_instance+0x24>
    2e2a:	22 0f       	add	r18, r18
    2e2c:	33 1f       	adc	r19, r19
    2e2e:	0a 94       	dec	r0
    2e30:	e2 f7       	brpl	.-8      	; 0x2e2a <_select_instance+0x20>
    2e32:	20 95       	com	r18
    2e34:	24 23       	and	r18, r20
    2e36:	2c 93       	st	X, r18
    2e38:	0e c0       	rjmp	.+28     	; 0x2e56 <_select_instance+0x4c>
    2e3a:	a0 81       	ld	r26, Z
    2e3c:	b1 81       	ldd	r27, Z+1	; 0x01
    2e3e:	6c 91       	ld	r22, X
    2e40:	41 e0       	ldi	r20, 0x01	; 1
    2e42:	50 e0       	ldi	r21, 0x00	; 0
    2e44:	9a 01       	movw	r18, r20
    2e46:	02 80       	ldd	r0, Z+2	; 0x02
    2e48:	02 c0       	rjmp	.+4      	; 0x2e4e <_select_instance+0x44>
    2e4a:	22 0f       	add	r18, r18
    2e4c:	33 1f       	adc	r19, r19
    2e4e:	0a 94       	dec	r0
    2e50:	e2 f7       	brpl	.-8      	; 0x2e4a <_select_instance+0x40>
    2e52:	26 2b       	or	r18, r22
    2e54:	2c 93       	st	X, r18
    2e56:	90 93 d6 15 	sts	0x15D6, r25
    2e5a:	80 93 d5 15 	sts	0x15D5, r24
    2e5e:	00 97       	sbiw	r24, 0x00	; 0
    2e60:	69 f0       	breq	.+26     	; 0x2e7c <_select_instance+0x72>
    2e62:	10 92 d7 15 	sts	0x15D7, r1
    2e66:	2c b5       	in	r18, 0x2c	; 44
    2e68:	2f 73       	andi	r18, 0x3F	; 63
    2e6a:	2c bd       	out	0x2c, r18	; 44
    2e6c:	fc 01       	movw	r30, r24
    2e6e:	24 81       	ldd	r18, Z+4	; 0x04
    2e70:	2c bd       	out	0x2c, r18	; 44
    2e72:	85 81       	ldd	r24, Z+5	; 0x05
    2e74:	8d bd       	out	0x2d, r24	; 45
    2e76:	8c b5       	in	r24, 0x2c	; 44
    2e78:	80 64       	ori	r24, 0x40	; 64
    2e7a:	8c bd       	out	0x2c, r24	; 44
    2e7c:	08 95       	ret

00002e7e <spi_new_instance>:
    2e7e:	6f 92       	push	r6
    2e80:	7f 92       	push	r7
    2e82:	8f 92       	push	r8
    2e84:	9f 92       	push	r9
    2e86:	af 92       	push	r10
    2e88:	bf 92       	push	r11
    2e8a:	cf 92       	push	r12
    2e8c:	df 92       	push	r13
    2e8e:	ef 92       	push	r14
    2e90:	ff 92       	push	r15
    2e92:	0f 93       	push	r16
    2e94:	1f 93       	push	r17
    2e96:	cf 93       	push	r28
    2e98:	df 93       	push	r29
    2e9a:	cd b7       	in	r28, 0x3d	; 61
    2e9c:	de b7       	in	r29, 0x3e	; 62
    2e9e:	d8 2e       	mov	r13, r24
    2ea0:	f6 2e       	mov	r15, r22
    2ea2:	64 2e       	mov	r6, r20
    2ea4:	72 2e       	mov	r7, r18
    2ea6:	80 91 d4 15 	lds	r24, 0x15D4
    2eaa:	81 11       	cpse	r24, r1
    2eac:	06 c0       	rjmp	.+12     	; 0x2eba <spi_new_instance+0x3c>
    2eae:	84 b1       	in	r24, 0x04	; 4
    2eb0:	87 60       	ori	r24, 0x07	; 7
    2eb2:	84 b9       	out	0x04, r24	; 4
    2eb4:	81 e0       	ldi	r24, 0x01	; 1
    2eb6:	80 93 d4 15 	sts	0x15D4, r24
    2eba:	8c e0       	ldi	r24, 0x0C	; 12
    2ebc:	90 e0       	ldi	r25, 0x00	; 0
    2ebe:	6b d3       	rcall	.+1750   	; 0x3596 <malloc>
    2ec0:	fc 01       	movw	r30, r24
    2ec2:	00 83       	st	Z, r16
    2ec4:	11 83       	std	Z+1, r17	; 0x01
    2ec6:	e2 82       	std	Z+2, r14	; 0x02
    2ec8:	a0 2f       	mov	r26, r16
    2eca:	b1 2f       	mov	r27, r17
    2ecc:	4e 91       	ld	r20, -X
    2ece:	21 e0       	ldi	r18, 0x01	; 1
    2ed0:	30 e0       	ldi	r19, 0x00	; 0
    2ed2:	c9 01       	movw	r24, r18
    2ed4:	02 c0       	rjmp	.+4      	; 0x2eda <spi_new_instance+0x5c>
    2ed6:	88 0f       	add	r24, r24
    2ed8:	99 1f       	adc	r25, r25
    2eda:	ea 94       	dec	r14
    2edc:	e2 f7       	brpl	.-8      	; 0x2ed6 <spi_new_instance+0x58>
    2ede:	84 2b       	or	r24, r20
    2ee0:	8c 93       	st	X, r24
    2ee2:	c3 82       	std	Z+3, r12	; 0x03
    2ee4:	66 0c       	add	r6, r6
    2ee6:	66 0c       	add	r6, r6
    2ee8:	76 28       	or	r7, r6
    2eea:	af 2d       	mov	r26, r15
    2eec:	bb 27       	eor	r27, r27
    2eee:	a7 fd       	sbrc	r26, 7
    2ef0:	b0 95       	com	r27
    2ef2:	af 52       	subi	r26, 0x2F	; 47
    2ef4:	bd 4f       	sbci	r27, 0xFD	; 253
    2ef6:	6c 90       	ld	r6, X
    2ef8:	d6 28       	or	r13, r6
    2efa:	d7 28       	or	r13, r7
    2efc:	d4 82       	std	Z+4, r13	; 0x04
    2efe:	83 e0       	ldi	r24, 0x03	; 3
    2f00:	8f 15       	cp	r24, r15
    2f02:	14 f4       	brge	.+4      	; 0x2f08 <spi_new_instance+0x8a>
    2f04:	81 e0       	ldi	r24, 0x01	; 1
    2f06:	85 83       	std	Z+5, r24	; 0x05
    2f08:	97 82       	std	Z+7, r9	; 0x07
    2f0a:	86 82       	std	Z+6, r8	; 0x06
    2f0c:	b1 86       	std	Z+9, r11	; 0x09
    2f0e:	a0 86       	std	Z+8, r10	; 0x08
    2f10:	8a 89       	ldd	r24, Y+18	; 0x12
    2f12:	9b 89       	ldd	r25, Y+19	; 0x13
    2f14:	93 87       	std	Z+11, r25	; 0x0b
    2f16:	82 87       	std	Z+10, r24	; 0x0a
    2f18:	6f b7       	in	r22, 0x3f	; 63
    2f1a:	f8 94       	cli
    2f1c:	80 91 d5 15 	lds	r24, 0x15D5
    2f20:	90 91 d6 15 	lds	r25, 0x15D6
    2f24:	f0 93 d6 15 	sts	0x15D6, r31
    2f28:	e0 93 d5 15 	sts	0x15D5, r30
    2f2c:	23 81       	ldd	r18, Z+3	; 0x03
    2f2e:	21 30       	cpi	r18, 0x01	; 1
    2f30:	81 f4       	brne	.+32     	; 0x2f52 <spi_new_instance+0xd4>
    2f32:	a0 81       	ld	r26, Z
    2f34:	b1 81       	ldd	r27, Z+1	; 0x01
    2f36:	7c 91       	ld	r23, X
    2f38:	41 e0       	ldi	r20, 0x01	; 1
    2f3a:	50 e0       	ldi	r21, 0x00	; 0
    2f3c:	9a 01       	movw	r18, r20
    2f3e:	02 80       	ldd	r0, Z+2	; 0x02
    2f40:	02 c0       	rjmp	.+4      	; 0x2f46 <spi_new_instance+0xc8>
    2f42:	22 0f       	add	r18, r18
    2f44:	33 1f       	adc	r19, r19
    2f46:	0a 94       	dec	r0
    2f48:	e2 f7       	brpl	.-8      	; 0x2f42 <spi_new_instance+0xc4>
    2f4a:	20 95       	com	r18
    2f4c:	27 23       	and	r18, r23
    2f4e:	2c 93       	st	X, r18
    2f50:	0e c0       	rjmp	.+28     	; 0x2f6e <spi_new_instance+0xf0>
    2f52:	a0 81       	ld	r26, Z
    2f54:	b1 81       	ldd	r27, Z+1	; 0x01
    2f56:	7c 91       	ld	r23, X
    2f58:	41 e0       	ldi	r20, 0x01	; 1
    2f5a:	50 e0       	ldi	r21, 0x00	; 0
    2f5c:	9a 01       	movw	r18, r20
    2f5e:	02 80       	ldd	r0, Z+2	; 0x02
    2f60:	02 c0       	rjmp	.+4      	; 0x2f66 <spi_new_instance+0xe8>
    2f62:	22 0f       	add	r18, r18
    2f64:	33 1f       	adc	r19, r19
    2f66:	0a 94       	dec	r0
    2f68:	e2 f7       	brpl	.-8      	; 0x2f62 <spi_new_instance+0xe4>
    2f6a:	27 2b       	or	r18, r23
    2f6c:	2c 93       	st	X, r18
    2f6e:	90 93 d6 15 	sts	0x15D6, r25
    2f72:	80 93 d5 15 	sts	0x15D5, r24
    2f76:	6f bf       	out	0x3f, r22	; 63
    2f78:	cf 01       	movw	r24, r30
    2f7a:	df 91       	pop	r29
    2f7c:	cf 91       	pop	r28
    2f7e:	1f 91       	pop	r17
    2f80:	0f 91       	pop	r16
    2f82:	ff 90       	pop	r15
    2f84:	ef 90       	pop	r14
    2f86:	df 90       	pop	r13
    2f88:	cf 90       	pop	r12
    2f8a:	bf 90       	pop	r11
    2f8c:	af 90       	pop	r10
    2f8e:	9f 90       	pop	r9
    2f90:	8f 90       	pop	r8
    2f92:	7f 90       	pop	r7
    2f94:	6f 90       	pop	r6
    2f96:	08 95       	ret

00002f98 <spi_send_string>:
SPI_ILLEGAL_INSTANCE: instance is null.
@param spi to send to.
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
    2f98:	df 92       	push	r13
    2f9a:	ef 92       	push	r14
    2f9c:	ff 92       	push	r15
    2f9e:	0f 93       	push	r16
    2fa0:	1f 93       	push	r17
    2fa2:	cf 93       	push	r28
    2fa4:	df 93       	push	r29
    2fa6:	ec 01       	movw	r28, r24
    2fa8:	8b 01       	movw	r16, r22
    2faa:	f4 2e       	mov	r15, r20
	if (spi == 0) {
    2fac:	00 97       	sbiw	r24, 0x00	; 0
    2fae:	09 f4       	brne	.+2      	; 0x2fb2 <spi_send_string+0x1a>
    2fb0:	6b c0       	rjmp	.+214    	; 0x3088 <spi_send_string+0xf0>
		return SPI_ILLEGAL_INSTANCE;
	}

	// Select correct instance
	if (_this != spi ) {
    2fb2:	80 91 d5 15 	lds	r24, 0x15D5
    2fb6:	90 91 d6 15 	lds	r25, 0x15D6
    2fba:	8c 17       	cp	r24, r28
    2fbc:	9d 07       	cpc	r25, r29
    2fbe:	11 f0       	breq	.+4      	; 0x2fc4 <spi_send_string+0x2c>
		_select_instance(spi);
    2fc0:	ce 01       	movw	r24, r28
    2fc2:	23 df       	rcall	.-442    	; 0x2e0a <_select_instance>
	uint8_t tmp = 0;

	// Critical section
	{
		// disable interrupt
		uint8_t c_sreg = SREG;
    2fc4:	ef b6       	in	r14, 0x3f	; 63
		cli();
    2fc6:	f8 94       	cli

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
    2fc8:	ee 81       	ldd	r30, Y+6	; 0x06
    2fca:	ff 81       	ldd	r31, Y+7	; 0x07
    2fcc:	30 97       	sbiw	r30, 0x00	; 0
    2fce:	61 f0       	breq	.+24     	; 0x2fe8 <spi_send_string+0x50>
    2fd0:	2f 2d       	mov	r18, r15
    2fd2:	30 e0       	ldi	r19, 0x00	; 0
    2fd4:	42 a5       	ldd	r20, Z+42	; 0x2a
    2fd6:	88 e2       	ldi	r24, 0x28	; 40
    2fd8:	90 e0       	ldi	r25, 0x00	; 0
    2fda:	84 1b       	sub	r24, r20
    2fdc:	91 09       	sbc	r25, r1
    2fde:	82 17       	cp	r24, r18
    2fe0:	93 07       	cpc	r25, r19
    2fe2:	0c f4       	brge	.+2      	; 0x2fe6 <spi_send_string+0x4e>
    2fe4:	48 c0       	rjmp	.+144    	; 0x3076 <spi_send_string+0xde>
    2fe6:	04 c0       	rjmp	.+8      	; 0x2ff0 <spi_send_string+0x58>
    2fe8:	81 e0       	ldi	r24, 0x01	; 1
    2fea:	8f 15       	cp	r24, r15
    2fec:	08 f4       	brcc	.+2      	; 0x2ff0 <spi_send_string+0x58>
    2fee:	45 c0       	rjmp	.+138    	; 0x307a <spi_send_string+0xe2>
			result = SPI_NO_ROOM_IN_TX_BUFFER;
			} else {
			// If SPI in idle send the first byte
			if (!_spi_active) {
    2ff0:	80 91 d7 15 	lds	r24, 0x15D7
    2ff4:	81 11       	cpse	r24, r1
    2ff6:	30 c0       	rjmp	.+96     	; 0x3058 <spi_send_string+0xc0>
				_spi_active = 1;
    2ff8:	81 e0       	ldi	r24, 0x01	; 1
    2ffa:	80 93 d7 15 	sts	0x15D7, r24
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    2ffe:	e0 91 d5 15 	lds	r30, 0x15D5
    3002:	f0 91 d6 15 	lds	r31, 0x15D6
    3006:	83 81       	ldd	r24, Z+3	; 0x03
    3008:	81 30       	cpi	r24, 0x01	; 1
    300a:	79 f4       	brne	.+30     	; 0x302a <spi_send_string+0x92>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    300c:	a0 81       	ld	r26, Z
    300e:	b1 81       	ldd	r27, Z+1	; 0x01
    3010:	4c 91       	ld	r20, X
    3012:	21 e0       	ldi	r18, 0x01	; 1
    3014:	30 e0       	ldi	r19, 0x00	; 0
    3016:	c9 01       	movw	r24, r18
    3018:	02 80       	ldd	r0, Z+2	; 0x02
    301a:	02 c0       	rjmp	.+4      	; 0x3020 <spi_send_string+0x88>
    301c:	88 0f       	add	r24, r24
    301e:	99 1f       	adc	r25, r25
    3020:	0a 94       	dec	r0
    3022:	e2 f7       	brpl	.-8      	; 0x301c <spi_send_string+0x84>
    3024:	84 2b       	or	r24, r20
    3026:	8c 93       	st	X, r24
    3028:	0e c0       	rjmp	.+28     	; 0x3046 <spi_send_string+0xae>
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
		}
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    302a:	a0 81       	ld	r26, Z
    302c:	b1 81       	ldd	r27, Z+1	; 0x01
    302e:	2c 91       	ld	r18, X
    3030:	81 e0       	ldi	r24, 0x01	; 1
    3032:	90 e0       	ldi	r25, 0x00	; 0
    3034:	02 80       	ldd	r0, Z+2	; 0x02
    3036:	02 c0       	rjmp	.+4      	; 0x303c <spi_send_string+0xa4>
    3038:	88 0f       	add	r24, r24
    303a:	99 1f       	adc	r25, r25
    303c:	0a 94       	dec	r0
    303e:	e2 f7       	brpl	.-8      	; 0x3038 <spi_send_string+0xa0>
    3040:	80 95       	com	r24
    3042:	82 23       	and	r24, r18
    3044:	8c 93       	st	X, r24
			// If SPI in idle send the first byte
			if (!_spi_active) {
				_spi_active = 1;
				_set_cs(CS_ACTIVE);
				// Enable SPI interrupt
				SPCR |= _BV(SPIE);
    3046:	8c b5       	in	r24, 0x2c	; 44
    3048:	80 68       	ori	r24, 0x80	; 128
    304a:	8c bd       	out	0x2c, r24	; 44
				// Send first byte
				SPDR =buf[0];
    304c:	f8 01       	movw	r30, r16
    304e:	80 81       	ld	r24, Z
    3050:	8e bd       	out	0x2e, r24	; 46

				tmp = 1;
    3052:	dd 24       	eor	r13, r13
    3054:	d3 94       	inc	r13
    3056:	01 c0       	rjmp	.+2      	; 0x305a <spi_send_string+0xc2>
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
	uint8_t tmp = 0;
    3058:	d1 2c       	mov	r13, r1
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    305a:	df 14       	cp	r13, r15
    305c:	80 f4       	brcc	.+32     	; 0x307e <spi_send_string+0xe6>
				buffer_put_item(spi->_tx_buf, buf[i]);
    305e:	f8 01       	movw	r30, r16
    3060:	ed 0d       	add	r30, r13
    3062:	f1 1d       	adc	r31, r1
    3064:	60 81       	ld	r22, Z
    3066:	8e 81       	ldd	r24, Y+6	; 0x06
    3068:	9f 81       	ldd	r25, Y+7	; 0x07
    306a:	0e 94 80 04 	call	0x900	; 0x900 <buffer_put_item>
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    306e:	d3 94       	inc	r13
    3070:	df 14       	cp	r13, r15
    3072:	a8 f3       	brcs	.-22     	; 0x305e <spi_send_string+0xc6>
    3074:	06 c0       	rjmp	.+12     	; 0x3082 <spi_send_string+0xea>
		uint8_t c_sreg = SREG;
		cli();

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
			result = SPI_NO_ROOM_IN_TX_BUFFER;
    3076:	81 e0       	ldi	r24, 0x01	; 1
    3078:	05 c0       	rjmp	.+10     	; 0x3084 <spi_send_string+0xec>
    307a:	81 e0       	ldi	r24, 0x01	; 1
    307c:	03 c0       	rjmp	.+6      	; 0x3084 <spi_send_string+0xec>
	// Select correct instance
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
    307e:	80 e0       	ldi	r24, 0x00	; 0
    3080:	01 c0       	rjmp	.+2      	; 0x3084 <spi_send_string+0xec>
    3082:	80 e0       	ldi	r24, 0x00	; 0
				buffer_put_item(spi->_tx_buf, buf[i]);
			}
		}

		// restore interrupt state
		SREG = c_sreg;
    3084:	ef be       	out	0x3f, r14	; 63
	}

	return result;
    3086:	01 c0       	rjmp	.+2      	; 0x308a <spi_send_string+0xf2>
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
	if (spi == 0) {
		return SPI_ILLEGAL_INSTANCE;
    3088:	83 e0       	ldi	r24, 0x03	; 3
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    308a:	df 91       	pop	r29
    308c:	cf 91       	pop	r28
    308e:	1f 91       	pop	r17
    3090:	0f 91       	pop	r16
    3092:	ff 90       	pop	r15
    3094:	ef 90       	pop	r14
    3096:	df 90       	pop	r13
    3098:	08 95       	ret

0000309a <__vector_24>:

/* ======================================================================================================================= */
/**
@todo Documentation
*/
ISR(SPI_STC_vect) {
    309a:	1f 92       	push	r1
    309c:	0f 92       	push	r0
    309e:	0f b6       	in	r0, 0x3f	; 63
    30a0:	0f 92       	push	r0
    30a2:	11 24       	eor	r1, r1
    30a4:	0b b6       	in	r0, 0x3b	; 59
    30a6:	0f 92       	push	r0
    30a8:	2f 93       	push	r18
    30aa:	3f 93       	push	r19
    30ac:	4f 93       	push	r20
    30ae:	5f 93       	push	r21
    30b0:	6f 93       	push	r22
    30b2:	7f 93       	push	r23
    30b4:	8f 93       	push	r24
    30b6:	9f 93       	push	r25
    30b8:	af 93       	push	r26
    30ba:	bf 93       	push	r27
    30bc:	ef 93       	push	r30
    30be:	ff 93       	push	r31
    30c0:	cf 93       	push	r28
    30c2:	df 93       	push	r29
    30c4:	1f 92       	push	r1
    30c6:	cd b7       	in	r28, 0x3d	; 61
    30c8:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	#if SPI_USE_BUFFER == 1
	// store received byte if receive buffer available

	if (_this->_rx_buf != 0){
    30ca:	e0 91 d5 15 	lds	r30, 0x15D5
    30ce:	f0 91 d6 15 	lds	r31, 0x15D6
    30d2:	80 85       	ldd	r24, Z+8	; 0x08
    30d4:	91 85       	ldd	r25, Z+9	; 0x09
    30d6:	00 97       	sbiw	r24, 0x00	; 0
    30d8:	19 f0       	breq	.+6      	; 0x30e0 <__vector_24+0x46>
		buffer_put_item(_this->_rx_buf, SPDR);
    30da:	6e b5       	in	r22, 0x2e	; 46
    30dc:	0e 94 80 04 	call	0x900	; 0x900 <buffer_put_item>
	}
	// more bytes to send?
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
    30e0:	e0 91 d5 15 	lds	r30, 0x15D5
    30e4:	f0 91 d6 15 	lds	r31, 0x15D6
    30e8:	be 01       	movw	r22, r28
    30ea:	6f 5f       	subi	r22, 0xFF	; 255
    30ec:	7f 4f       	sbci	r23, 0xFF	; 255
    30ee:	86 81       	ldd	r24, Z+6	; 0x06
    30f0:	97 81       	ldd	r25, Z+7	; 0x07
    30f2:	0e 94 66 04 	call	0x8cc	; 0x8cc <buffer_get_item>
    30f6:	81 11       	cpse	r24, r1
    30f8:	03 c0       	rjmp	.+6      	; 0x3100 <__vector_24+0x66>
		_spi_send_byte(item);
    30fa:	89 81       	ldd	r24, Y+1	; 0x01
// Indexed by SPI_CLOCK_DIVIDER_xx defines
static const uint8_t _prescaler_mask [] = {0b00,0b01,0b10,0b11,0b00,0b01,0b10};

// Send a byte to the SPI-bus
static inline void _spi_send_byte(uint8_t byte) {
	SPDR = byte;
    30fc:	8e bd       	out	0x2e, r24	; 46
    30fe:	29 c0       	rjmp	.+82     	; 0x3152 <__vector_24+0xb8>
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
		_spi_send_byte(item);
		} else {
		// No
		// Disable SPI interrupt
		SPCR &= ~_BV(SPIE);
    3100:	8c b5       	in	r24, 0x2c	; 44
    3102:	8f 77       	andi	r24, 0x7F	; 127
    3104:	8c bd       	out	0x2c, r24	; 44
		_spi_active = 0;
    3106:	10 92 d7 15 	sts	0x15D7, r1
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    310a:	e0 91 d5 15 	lds	r30, 0x15D5
    310e:	f0 91 d6 15 	lds	r31, 0x15D6
    3112:	83 81       	ldd	r24, Z+3	; 0x03
    3114:	81 30       	cpi	r24, 0x01	; 1
    3116:	79 f4       	brne	.+30     	; 0x3136 <__vector_24+0x9c>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    3118:	a0 81       	ld	r26, Z
    311a:	b1 81       	ldd	r27, Z+1	; 0x01
    311c:	2c 91       	ld	r18, X
    311e:	81 e0       	ldi	r24, 0x01	; 1
    3120:	90 e0       	ldi	r25, 0x00	; 0
    3122:	02 80       	ldd	r0, Z+2	; 0x02
    3124:	02 c0       	rjmp	.+4      	; 0x312a <__vector_24+0x90>
    3126:	88 0f       	add	r24, r24
    3128:	99 1f       	adc	r25, r25
    312a:	0a 94       	dec	r0
    312c:	e2 f7       	brpl	.-8      	; 0x3126 <__vector_24+0x8c>
    312e:	80 95       	com	r24
    3130:	82 23       	and	r24, r18
    3132:	8c 93       	st	X, r24
    3134:	0e c0       	rjmp	.+28     	; 0x3152 <__vector_24+0xb8>
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);

			} else {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    3136:	a0 81       	ld	r26, Z
    3138:	b1 81       	ldd	r27, Z+1	; 0x01
    313a:	4c 91       	ld	r20, X
    313c:	21 e0       	ldi	r18, 0x01	; 1
    313e:	30 e0       	ldi	r19, 0x00	; 0
    3140:	c9 01       	movw	r24, r18
    3142:	02 80       	ldd	r0, Z+2	; 0x02
    3144:	02 c0       	rjmp	.+4      	; 0x314a <__vector_24+0xb0>
    3146:	88 0f       	add	r24, r24
    3148:	99 1f       	adc	r25, r25
    314a:	0a 94       	dec	r0
    314c:	e2 f7       	brpl	.-8      	; 0x3146 <__vector_24+0xac>
    314e:	84 2b       	or	r24, r20
    3150:	8c 93       	st	X, r24
	_spi_active = 0;
	_set_cs(CS_INACTIVE);
	#endif

	// If handler defined - call it with instance and received byte.
	if (_this->_call_back)
    3152:	80 91 d5 15 	lds	r24, 0x15D5
    3156:	90 91 d6 15 	lds	r25, 0x15D6
    315a:	dc 01       	movw	r26, r24
    315c:	1a 96       	adiw	r26, 0x0a	; 10
    315e:	ed 91       	ld	r30, X+
    3160:	fc 91       	ld	r31, X
    3162:	1b 97       	sbiw	r26, 0x0b	; 11
    3164:	30 97       	sbiw	r30, 0x00	; 0
    3166:	11 f0       	breq	.+4      	; 0x316c <__vector_24+0xd2>
	{
		_this->_call_back(_this, item);
    3168:	69 81       	ldd	r22, Y+1	; 0x01
    316a:	19 95       	eicall
	}
    316c:	0f 90       	pop	r0
    316e:	df 91       	pop	r29
    3170:	cf 91       	pop	r28
    3172:	ff 91       	pop	r31
    3174:	ef 91       	pop	r30
    3176:	bf 91       	pop	r27
    3178:	af 91       	pop	r26
    317a:	9f 91       	pop	r25
    317c:	8f 91       	pop	r24
    317e:	7f 91       	pop	r23
    3180:	6f 91       	pop	r22
    3182:	5f 91       	pop	r21
    3184:	4f 91       	pop	r20
    3186:	3f 91       	pop	r19
    3188:	2f 91       	pop	r18
    318a:	0f 90       	pop	r0
    318c:	0b be       	out	0x3b, r0	; 59
    318e:	0f 90       	pop	r0
    3190:	0f be       	out	0x3f, r0	; 63
    3192:	0f 90       	pop	r0
    3194:	1f 90       	pop	r1
    3196:	18 95       	reti

00003198 <__divsf3>:
    3198:	0c d0       	rcall	.+24     	; 0x31b2 <__divsf3x>
    319a:	e6 c0       	rjmp	.+460    	; 0x3368 <__fp_round>
    319c:	de d0       	rcall	.+444    	; 0x335a <__fp_pscB>
    319e:	40 f0       	brcs	.+16     	; 0x31b0 <__divsf3+0x18>
    31a0:	d5 d0       	rcall	.+426    	; 0x334c <__fp_pscA>
    31a2:	30 f0       	brcs	.+12     	; 0x31b0 <__divsf3+0x18>
    31a4:	21 f4       	brne	.+8      	; 0x31ae <__divsf3+0x16>
    31a6:	5f 3f       	cpi	r21, 0xFF	; 255
    31a8:	19 f0       	breq	.+6      	; 0x31b0 <__divsf3+0x18>
    31aa:	c7 c0       	rjmp	.+398    	; 0x333a <__fp_inf>
    31ac:	51 11       	cpse	r21, r1
    31ae:	10 c1       	rjmp	.+544    	; 0x33d0 <__fp_szero>
    31b0:	ca c0       	rjmp	.+404    	; 0x3346 <__fp_nan>

000031b2 <__divsf3x>:
    31b2:	eb d0       	rcall	.+470    	; 0x338a <__fp_split3>
    31b4:	98 f3       	brcs	.-26     	; 0x319c <__divsf3+0x4>

000031b6 <__divsf3_pse>:
    31b6:	99 23       	and	r25, r25
    31b8:	c9 f3       	breq	.-14     	; 0x31ac <__divsf3+0x14>
    31ba:	55 23       	and	r21, r21
    31bc:	b1 f3       	breq	.-20     	; 0x31aa <__divsf3+0x12>
    31be:	95 1b       	sub	r25, r21
    31c0:	55 0b       	sbc	r21, r21
    31c2:	bb 27       	eor	r27, r27
    31c4:	aa 27       	eor	r26, r26
    31c6:	62 17       	cp	r22, r18
    31c8:	73 07       	cpc	r23, r19
    31ca:	84 07       	cpc	r24, r20
    31cc:	38 f0       	brcs	.+14     	; 0x31dc <__divsf3_pse+0x26>
    31ce:	9f 5f       	subi	r25, 0xFF	; 255
    31d0:	5f 4f       	sbci	r21, 0xFF	; 255
    31d2:	22 0f       	add	r18, r18
    31d4:	33 1f       	adc	r19, r19
    31d6:	44 1f       	adc	r20, r20
    31d8:	aa 1f       	adc	r26, r26
    31da:	a9 f3       	breq	.-22     	; 0x31c6 <__divsf3_pse+0x10>
    31dc:	33 d0       	rcall	.+102    	; 0x3244 <__divsf3_pse+0x8e>
    31de:	0e 2e       	mov	r0, r30
    31e0:	3a f0       	brmi	.+14     	; 0x31f0 <__divsf3_pse+0x3a>
    31e2:	e0 e8       	ldi	r30, 0x80	; 128
    31e4:	30 d0       	rcall	.+96     	; 0x3246 <__divsf3_pse+0x90>
    31e6:	91 50       	subi	r25, 0x01	; 1
    31e8:	50 40       	sbci	r21, 0x00	; 0
    31ea:	e6 95       	lsr	r30
    31ec:	00 1c       	adc	r0, r0
    31ee:	ca f7       	brpl	.-14     	; 0x31e2 <__divsf3_pse+0x2c>
    31f0:	29 d0       	rcall	.+82     	; 0x3244 <__divsf3_pse+0x8e>
    31f2:	fe 2f       	mov	r31, r30
    31f4:	27 d0       	rcall	.+78     	; 0x3244 <__divsf3_pse+0x8e>
    31f6:	66 0f       	add	r22, r22
    31f8:	77 1f       	adc	r23, r23
    31fa:	88 1f       	adc	r24, r24
    31fc:	bb 1f       	adc	r27, r27
    31fe:	26 17       	cp	r18, r22
    3200:	37 07       	cpc	r19, r23
    3202:	48 07       	cpc	r20, r24
    3204:	ab 07       	cpc	r26, r27
    3206:	b0 e8       	ldi	r27, 0x80	; 128
    3208:	09 f0       	breq	.+2      	; 0x320c <__divsf3_pse+0x56>
    320a:	bb 0b       	sbc	r27, r27
    320c:	80 2d       	mov	r24, r0
    320e:	bf 01       	movw	r22, r30
    3210:	ff 27       	eor	r31, r31
    3212:	93 58       	subi	r25, 0x83	; 131
    3214:	5f 4f       	sbci	r21, 0xFF	; 255
    3216:	2a f0       	brmi	.+10     	; 0x3222 <__divsf3_pse+0x6c>
    3218:	9e 3f       	cpi	r25, 0xFE	; 254
    321a:	51 05       	cpc	r21, r1
    321c:	68 f0       	brcs	.+26     	; 0x3238 <__divsf3_pse+0x82>
    321e:	8d c0       	rjmp	.+282    	; 0x333a <__fp_inf>
    3220:	d7 c0       	rjmp	.+430    	; 0x33d0 <__fp_szero>
    3222:	5f 3f       	cpi	r21, 0xFF	; 255
    3224:	ec f3       	brlt	.-6      	; 0x3220 <__divsf3_pse+0x6a>
    3226:	98 3e       	cpi	r25, 0xE8	; 232
    3228:	dc f3       	brlt	.-10     	; 0x3220 <__divsf3_pse+0x6a>
    322a:	86 95       	lsr	r24
    322c:	77 95       	ror	r23
    322e:	67 95       	ror	r22
    3230:	b7 95       	ror	r27
    3232:	f7 95       	ror	r31
    3234:	9f 5f       	subi	r25, 0xFF	; 255
    3236:	c9 f7       	brne	.-14     	; 0x322a <__divsf3_pse+0x74>
    3238:	88 0f       	add	r24, r24
    323a:	91 1d       	adc	r25, r1
    323c:	96 95       	lsr	r25
    323e:	87 95       	ror	r24
    3240:	97 f9       	bld	r25, 7
    3242:	08 95       	ret
    3244:	e1 e0       	ldi	r30, 0x01	; 1
    3246:	66 0f       	add	r22, r22
    3248:	77 1f       	adc	r23, r23
    324a:	88 1f       	adc	r24, r24
    324c:	bb 1f       	adc	r27, r27
    324e:	62 17       	cp	r22, r18
    3250:	73 07       	cpc	r23, r19
    3252:	84 07       	cpc	r24, r20
    3254:	ba 07       	cpc	r27, r26
    3256:	20 f0       	brcs	.+8      	; 0x3260 <__divsf3_pse+0xaa>
    3258:	62 1b       	sub	r22, r18
    325a:	73 0b       	sbc	r23, r19
    325c:	84 0b       	sbc	r24, r20
    325e:	ba 0b       	sbc	r27, r26
    3260:	ee 1f       	adc	r30, r30
    3262:	88 f7       	brcc	.-30     	; 0x3246 <__divsf3_pse+0x90>
    3264:	e0 95       	com	r30
    3266:	08 95       	ret

00003268 <__fixunssfsi>:
    3268:	98 d0       	rcall	.+304    	; 0x339a <__fp_splitA>
    326a:	88 f0       	brcs	.+34     	; 0x328e <__fixunssfsi+0x26>
    326c:	9f 57       	subi	r25, 0x7F	; 127
    326e:	90 f0       	brcs	.+36     	; 0x3294 <__fixunssfsi+0x2c>
    3270:	b9 2f       	mov	r27, r25
    3272:	99 27       	eor	r25, r25
    3274:	b7 51       	subi	r27, 0x17	; 23
    3276:	a0 f0       	brcs	.+40     	; 0x32a0 <__fixunssfsi+0x38>
    3278:	d1 f0       	breq	.+52     	; 0x32ae <__fixunssfsi+0x46>
    327a:	66 0f       	add	r22, r22
    327c:	77 1f       	adc	r23, r23
    327e:	88 1f       	adc	r24, r24
    3280:	99 1f       	adc	r25, r25
    3282:	1a f0       	brmi	.+6      	; 0x328a <__fixunssfsi+0x22>
    3284:	ba 95       	dec	r27
    3286:	c9 f7       	brne	.-14     	; 0x327a <__fixunssfsi+0x12>
    3288:	12 c0       	rjmp	.+36     	; 0x32ae <__fixunssfsi+0x46>
    328a:	b1 30       	cpi	r27, 0x01	; 1
    328c:	81 f0       	breq	.+32     	; 0x32ae <__fixunssfsi+0x46>
    328e:	9f d0       	rcall	.+318    	; 0x33ce <__fp_zero>
    3290:	b1 e0       	ldi	r27, 0x01	; 1
    3292:	08 95       	ret
    3294:	9c c0       	rjmp	.+312    	; 0x33ce <__fp_zero>
    3296:	67 2f       	mov	r22, r23
    3298:	78 2f       	mov	r23, r24
    329a:	88 27       	eor	r24, r24
    329c:	b8 5f       	subi	r27, 0xF8	; 248
    329e:	39 f0       	breq	.+14     	; 0x32ae <__fixunssfsi+0x46>
    32a0:	b9 3f       	cpi	r27, 0xF9	; 249
    32a2:	cc f3       	brlt	.-14     	; 0x3296 <__fixunssfsi+0x2e>
    32a4:	86 95       	lsr	r24
    32a6:	77 95       	ror	r23
    32a8:	67 95       	ror	r22
    32aa:	b3 95       	inc	r27
    32ac:	d9 f7       	brne	.-10     	; 0x32a4 <__fixunssfsi+0x3c>
    32ae:	3e f4       	brtc	.+14     	; 0x32be <__fixunssfsi+0x56>
    32b0:	90 95       	com	r25
    32b2:	80 95       	com	r24
    32b4:	70 95       	com	r23
    32b6:	61 95       	neg	r22
    32b8:	7f 4f       	sbci	r23, 0xFF	; 255
    32ba:	8f 4f       	sbci	r24, 0xFF	; 255
    32bc:	9f 4f       	sbci	r25, 0xFF	; 255
    32be:	08 95       	ret

000032c0 <__floatunsisf>:
    32c0:	e8 94       	clt
    32c2:	09 c0       	rjmp	.+18     	; 0x32d6 <__floatsisf+0x12>

000032c4 <__floatsisf>:
    32c4:	97 fb       	bst	r25, 7
    32c6:	3e f4       	brtc	.+14     	; 0x32d6 <__floatsisf+0x12>
    32c8:	90 95       	com	r25
    32ca:	80 95       	com	r24
    32cc:	70 95       	com	r23
    32ce:	61 95       	neg	r22
    32d0:	7f 4f       	sbci	r23, 0xFF	; 255
    32d2:	8f 4f       	sbci	r24, 0xFF	; 255
    32d4:	9f 4f       	sbci	r25, 0xFF	; 255
    32d6:	99 23       	and	r25, r25
    32d8:	a9 f0       	breq	.+42     	; 0x3304 <__floatsisf+0x40>
    32da:	f9 2f       	mov	r31, r25
    32dc:	96 e9       	ldi	r25, 0x96	; 150
    32de:	bb 27       	eor	r27, r27
    32e0:	93 95       	inc	r25
    32e2:	f6 95       	lsr	r31
    32e4:	87 95       	ror	r24
    32e6:	77 95       	ror	r23
    32e8:	67 95       	ror	r22
    32ea:	b7 95       	ror	r27
    32ec:	f1 11       	cpse	r31, r1
    32ee:	f8 cf       	rjmp	.-16     	; 0x32e0 <__floatsisf+0x1c>
    32f0:	fa f4       	brpl	.+62     	; 0x3330 <__floatsisf+0x6c>
    32f2:	bb 0f       	add	r27, r27
    32f4:	11 f4       	brne	.+4      	; 0x32fa <__floatsisf+0x36>
    32f6:	60 ff       	sbrs	r22, 0
    32f8:	1b c0       	rjmp	.+54     	; 0x3330 <__floatsisf+0x6c>
    32fa:	6f 5f       	subi	r22, 0xFF	; 255
    32fc:	7f 4f       	sbci	r23, 0xFF	; 255
    32fe:	8f 4f       	sbci	r24, 0xFF	; 255
    3300:	9f 4f       	sbci	r25, 0xFF	; 255
    3302:	16 c0       	rjmp	.+44     	; 0x3330 <__floatsisf+0x6c>
    3304:	88 23       	and	r24, r24
    3306:	11 f0       	breq	.+4      	; 0x330c <__floatsisf+0x48>
    3308:	96 e9       	ldi	r25, 0x96	; 150
    330a:	11 c0       	rjmp	.+34     	; 0x332e <__floatsisf+0x6a>
    330c:	77 23       	and	r23, r23
    330e:	21 f0       	breq	.+8      	; 0x3318 <__floatsisf+0x54>
    3310:	9e e8       	ldi	r25, 0x8E	; 142
    3312:	87 2f       	mov	r24, r23
    3314:	76 2f       	mov	r23, r22
    3316:	05 c0       	rjmp	.+10     	; 0x3322 <__floatsisf+0x5e>
    3318:	66 23       	and	r22, r22
    331a:	71 f0       	breq	.+28     	; 0x3338 <__floatsisf+0x74>
    331c:	96 e8       	ldi	r25, 0x86	; 134
    331e:	86 2f       	mov	r24, r22
    3320:	70 e0       	ldi	r23, 0x00	; 0
    3322:	60 e0       	ldi	r22, 0x00	; 0
    3324:	2a f0       	brmi	.+10     	; 0x3330 <__floatsisf+0x6c>
    3326:	9a 95       	dec	r25
    3328:	66 0f       	add	r22, r22
    332a:	77 1f       	adc	r23, r23
    332c:	88 1f       	adc	r24, r24
    332e:	da f7       	brpl	.-10     	; 0x3326 <__floatsisf+0x62>
    3330:	88 0f       	add	r24, r24
    3332:	96 95       	lsr	r25
    3334:	87 95       	ror	r24
    3336:	97 f9       	bld	r25, 7
    3338:	08 95       	ret

0000333a <__fp_inf>:
    333a:	97 f9       	bld	r25, 7
    333c:	9f 67       	ori	r25, 0x7F	; 127
    333e:	80 e8       	ldi	r24, 0x80	; 128
    3340:	70 e0       	ldi	r23, 0x00	; 0
    3342:	60 e0       	ldi	r22, 0x00	; 0
    3344:	08 95       	ret

00003346 <__fp_nan>:
    3346:	9f ef       	ldi	r25, 0xFF	; 255
    3348:	80 ec       	ldi	r24, 0xC0	; 192
    334a:	08 95       	ret

0000334c <__fp_pscA>:
    334c:	00 24       	eor	r0, r0
    334e:	0a 94       	dec	r0
    3350:	16 16       	cp	r1, r22
    3352:	17 06       	cpc	r1, r23
    3354:	18 06       	cpc	r1, r24
    3356:	09 06       	cpc	r0, r25
    3358:	08 95       	ret

0000335a <__fp_pscB>:
    335a:	00 24       	eor	r0, r0
    335c:	0a 94       	dec	r0
    335e:	12 16       	cp	r1, r18
    3360:	13 06       	cpc	r1, r19
    3362:	14 06       	cpc	r1, r20
    3364:	05 06       	cpc	r0, r21
    3366:	08 95       	ret

00003368 <__fp_round>:
    3368:	09 2e       	mov	r0, r25
    336a:	03 94       	inc	r0
    336c:	00 0c       	add	r0, r0
    336e:	11 f4       	brne	.+4      	; 0x3374 <__fp_round+0xc>
    3370:	88 23       	and	r24, r24
    3372:	52 f0       	brmi	.+20     	; 0x3388 <__fp_round+0x20>
    3374:	bb 0f       	add	r27, r27
    3376:	40 f4       	brcc	.+16     	; 0x3388 <__fp_round+0x20>
    3378:	bf 2b       	or	r27, r31
    337a:	11 f4       	brne	.+4      	; 0x3380 <__fp_round+0x18>
    337c:	60 ff       	sbrs	r22, 0
    337e:	04 c0       	rjmp	.+8      	; 0x3388 <__fp_round+0x20>
    3380:	6f 5f       	subi	r22, 0xFF	; 255
    3382:	7f 4f       	sbci	r23, 0xFF	; 255
    3384:	8f 4f       	sbci	r24, 0xFF	; 255
    3386:	9f 4f       	sbci	r25, 0xFF	; 255
    3388:	08 95       	ret

0000338a <__fp_split3>:
    338a:	57 fd       	sbrc	r21, 7
    338c:	90 58       	subi	r25, 0x80	; 128
    338e:	44 0f       	add	r20, r20
    3390:	55 1f       	adc	r21, r21
    3392:	59 f0       	breq	.+22     	; 0x33aa <__fp_splitA+0x10>
    3394:	5f 3f       	cpi	r21, 0xFF	; 255
    3396:	71 f0       	breq	.+28     	; 0x33b4 <__fp_splitA+0x1a>
    3398:	47 95       	ror	r20

0000339a <__fp_splitA>:
    339a:	88 0f       	add	r24, r24
    339c:	97 fb       	bst	r25, 7
    339e:	99 1f       	adc	r25, r25
    33a0:	61 f0       	breq	.+24     	; 0x33ba <__fp_splitA+0x20>
    33a2:	9f 3f       	cpi	r25, 0xFF	; 255
    33a4:	79 f0       	breq	.+30     	; 0x33c4 <__fp_splitA+0x2a>
    33a6:	87 95       	ror	r24
    33a8:	08 95       	ret
    33aa:	12 16       	cp	r1, r18
    33ac:	13 06       	cpc	r1, r19
    33ae:	14 06       	cpc	r1, r20
    33b0:	55 1f       	adc	r21, r21
    33b2:	f2 cf       	rjmp	.-28     	; 0x3398 <__fp_split3+0xe>
    33b4:	46 95       	lsr	r20
    33b6:	f1 df       	rcall	.-30     	; 0x339a <__fp_splitA>
    33b8:	08 c0       	rjmp	.+16     	; 0x33ca <__fp_splitA+0x30>
    33ba:	16 16       	cp	r1, r22
    33bc:	17 06       	cpc	r1, r23
    33be:	18 06       	cpc	r1, r24
    33c0:	99 1f       	adc	r25, r25
    33c2:	f1 cf       	rjmp	.-30     	; 0x33a6 <__fp_splitA+0xc>
    33c4:	86 95       	lsr	r24
    33c6:	71 05       	cpc	r23, r1
    33c8:	61 05       	cpc	r22, r1
    33ca:	08 94       	sec
    33cc:	08 95       	ret

000033ce <__fp_zero>:
    33ce:	e8 94       	clt

000033d0 <__fp_szero>:
    33d0:	bb 27       	eor	r27, r27
    33d2:	66 27       	eor	r22, r22
    33d4:	77 27       	eor	r23, r23
    33d6:	cb 01       	movw	r24, r22
    33d8:	97 f9       	bld	r25, 7
    33da:	08 95       	ret

000033dc <__mulsf3>:
    33dc:	0b d0       	rcall	.+22     	; 0x33f4 <__mulsf3x>
    33de:	c4 cf       	rjmp	.-120    	; 0x3368 <__fp_round>
    33e0:	b5 df       	rcall	.-150    	; 0x334c <__fp_pscA>
    33e2:	28 f0       	brcs	.+10     	; 0x33ee <__mulsf3+0x12>
    33e4:	ba df       	rcall	.-140    	; 0x335a <__fp_pscB>
    33e6:	18 f0       	brcs	.+6      	; 0x33ee <__mulsf3+0x12>
    33e8:	95 23       	and	r25, r21
    33ea:	09 f0       	breq	.+2      	; 0x33ee <__mulsf3+0x12>
    33ec:	a6 cf       	rjmp	.-180    	; 0x333a <__fp_inf>
    33ee:	ab cf       	rjmp	.-170    	; 0x3346 <__fp_nan>
    33f0:	11 24       	eor	r1, r1
    33f2:	ee cf       	rjmp	.-36     	; 0x33d0 <__fp_szero>

000033f4 <__mulsf3x>:
    33f4:	ca df       	rcall	.-108    	; 0x338a <__fp_split3>
    33f6:	a0 f3       	brcs	.-24     	; 0x33e0 <__mulsf3+0x4>

000033f8 <__mulsf3_pse>:
    33f8:	95 9f       	mul	r25, r21
    33fa:	d1 f3       	breq	.-12     	; 0x33f0 <__mulsf3+0x14>
    33fc:	95 0f       	add	r25, r21
    33fe:	50 e0       	ldi	r21, 0x00	; 0
    3400:	55 1f       	adc	r21, r21
    3402:	62 9f       	mul	r22, r18
    3404:	f0 01       	movw	r30, r0
    3406:	72 9f       	mul	r23, r18
    3408:	bb 27       	eor	r27, r27
    340a:	f0 0d       	add	r31, r0
    340c:	b1 1d       	adc	r27, r1
    340e:	63 9f       	mul	r22, r19
    3410:	aa 27       	eor	r26, r26
    3412:	f0 0d       	add	r31, r0
    3414:	b1 1d       	adc	r27, r1
    3416:	aa 1f       	adc	r26, r26
    3418:	64 9f       	mul	r22, r20
    341a:	66 27       	eor	r22, r22
    341c:	b0 0d       	add	r27, r0
    341e:	a1 1d       	adc	r26, r1
    3420:	66 1f       	adc	r22, r22
    3422:	82 9f       	mul	r24, r18
    3424:	22 27       	eor	r18, r18
    3426:	b0 0d       	add	r27, r0
    3428:	a1 1d       	adc	r26, r1
    342a:	62 1f       	adc	r22, r18
    342c:	73 9f       	mul	r23, r19
    342e:	b0 0d       	add	r27, r0
    3430:	a1 1d       	adc	r26, r1
    3432:	62 1f       	adc	r22, r18
    3434:	83 9f       	mul	r24, r19
    3436:	a0 0d       	add	r26, r0
    3438:	61 1d       	adc	r22, r1
    343a:	22 1f       	adc	r18, r18
    343c:	74 9f       	mul	r23, r20
    343e:	33 27       	eor	r19, r19
    3440:	a0 0d       	add	r26, r0
    3442:	61 1d       	adc	r22, r1
    3444:	23 1f       	adc	r18, r19
    3446:	84 9f       	mul	r24, r20
    3448:	60 0d       	add	r22, r0
    344a:	21 1d       	adc	r18, r1
    344c:	82 2f       	mov	r24, r18
    344e:	76 2f       	mov	r23, r22
    3450:	6a 2f       	mov	r22, r26
    3452:	11 24       	eor	r1, r1
    3454:	9f 57       	subi	r25, 0x7F	; 127
    3456:	50 40       	sbci	r21, 0x00	; 0
    3458:	8a f0       	brmi	.+34     	; 0x347c <__mulsf3_pse+0x84>
    345a:	e1 f0       	breq	.+56     	; 0x3494 <__mulsf3_pse+0x9c>
    345c:	88 23       	and	r24, r24
    345e:	4a f0       	brmi	.+18     	; 0x3472 <__mulsf3_pse+0x7a>
    3460:	ee 0f       	add	r30, r30
    3462:	ff 1f       	adc	r31, r31
    3464:	bb 1f       	adc	r27, r27
    3466:	66 1f       	adc	r22, r22
    3468:	77 1f       	adc	r23, r23
    346a:	88 1f       	adc	r24, r24
    346c:	91 50       	subi	r25, 0x01	; 1
    346e:	50 40       	sbci	r21, 0x00	; 0
    3470:	a9 f7       	brne	.-22     	; 0x345c <__mulsf3_pse+0x64>
    3472:	9e 3f       	cpi	r25, 0xFE	; 254
    3474:	51 05       	cpc	r21, r1
    3476:	70 f0       	brcs	.+28     	; 0x3494 <__mulsf3_pse+0x9c>
    3478:	60 cf       	rjmp	.-320    	; 0x333a <__fp_inf>
    347a:	aa cf       	rjmp	.-172    	; 0x33d0 <__fp_szero>
    347c:	5f 3f       	cpi	r21, 0xFF	; 255
    347e:	ec f3       	brlt	.-6      	; 0x347a <__mulsf3_pse+0x82>
    3480:	98 3e       	cpi	r25, 0xE8	; 232
    3482:	dc f3       	brlt	.-10     	; 0x347a <__mulsf3_pse+0x82>
    3484:	86 95       	lsr	r24
    3486:	77 95       	ror	r23
    3488:	67 95       	ror	r22
    348a:	b7 95       	ror	r27
    348c:	f7 95       	ror	r31
    348e:	e7 95       	ror	r30
    3490:	9f 5f       	subi	r25, 0xFF	; 255
    3492:	c1 f7       	brne	.-16     	; 0x3484 <__mulsf3_pse+0x8c>
    3494:	fe 2b       	or	r31, r30
    3496:	88 0f       	add	r24, r24
    3498:	91 1d       	adc	r25, r1
    349a:	96 95       	lsr	r25
    349c:	87 95       	ror	r24
    349e:	97 f9       	bld	r25, 7
    34a0:	08 95       	ret

000034a2 <__divmodhi4>:
    34a2:	97 fb       	bst	r25, 7
    34a4:	07 2e       	mov	r0, r23
    34a6:	16 f4       	brtc	.+4      	; 0x34ac <__divmodhi4+0xa>
    34a8:	00 94       	com	r0
    34aa:	06 d0       	rcall	.+12     	; 0x34b8 <__divmodhi4_neg1>
    34ac:	77 fd       	sbrc	r23, 7
    34ae:	08 d0       	rcall	.+16     	; 0x34c0 <__divmodhi4_neg2>
    34b0:	5e d0       	rcall	.+188    	; 0x356e <__udivmodhi4>
    34b2:	07 fc       	sbrc	r0, 7
    34b4:	05 d0       	rcall	.+10     	; 0x34c0 <__divmodhi4_neg2>
    34b6:	3e f4       	brtc	.+14     	; 0x34c6 <__divmodhi4_exit>

000034b8 <__divmodhi4_neg1>:
    34b8:	90 95       	com	r25
    34ba:	81 95       	neg	r24
    34bc:	9f 4f       	sbci	r25, 0xFF	; 255
    34be:	08 95       	ret

000034c0 <__divmodhi4_neg2>:
    34c0:	70 95       	com	r23
    34c2:	61 95       	neg	r22
    34c4:	7f 4f       	sbci	r23, 0xFF	; 255

000034c6 <__divmodhi4_exit>:
    34c6:	08 95       	ret

000034c8 <__udivmodsi4>:
    34c8:	a1 e2       	ldi	r26, 0x21	; 33
    34ca:	1a 2e       	mov	r1, r26
    34cc:	aa 1b       	sub	r26, r26
    34ce:	bb 1b       	sub	r27, r27
    34d0:	fd 01       	movw	r30, r26
    34d2:	0d c0       	rjmp	.+26     	; 0x34ee <__udivmodsi4_ep>

000034d4 <__udivmodsi4_loop>:
    34d4:	aa 1f       	adc	r26, r26
    34d6:	bb 1f       	adc	r27, r27
    34d8:	ee 1f       	adc	r30, r30
    34da:	ff 1f       	adc	r31, r31
    34dc:	a2 17       	cp	r26, r18
    34de:	b3 07       	cpc	r27, r19
    34e0:	e4 07       	cpc	r30, r20
    34e2:	f5 07       	cpc	r31, r21
    34e4:	20 f0       	brcs	.+8      	; 0x34ee <__udivmodsi4_ep>
    34e6:	a2 1b       	sub	r26, r18
    34e8:	b3 0b       	sbc	r27, r19
    34ea:	e4 0b       	sbc	r30, r20
    34ec:	f5 0b       	sbc	r31, r21

000034ee <__udivmodsi4_ep>:
    34ee:	66 1f       	adc	r22, r22
    34f0:	77 1f       	adc	r23, r23
    34f2:	88 1f       	adc	r24, r24
    34f4:	99 1f       	adc	r25, r25
    34f6:	1a 94       	dec	r1
    34f8:	69 f7       	brne	.-38     	; 0x34d4 <__udivmodsi4_loop>
    34fa:	60 95       	com	r22
    34fc:	70 95       	com	r23
    34fe:	80 95       	com	r24
    3500:	90 95       	com	r25
    3502:	9b 01       	movw	r18, r22
    3504:	ac 01       	movw	r20, r24
    3506:	bd 01       	movw	r22, r26
    3508:	cf 01       	movw	r24, r30
    350a:	08 95       	ret

0000350c <__divmodsi4>:
    350c:	05 2e       	mov	r0, r21
    350e:	97 fb       	bst	r25, 7
    3510:	16 f4       	brtc	.+4      	; 0x3516 <__divmodsi4+0xa>
    3512:	00 94       	com	r0
    3514:	0f d0       	rcall	.+30     	; 0x3534 <__negsi2>
    3516:	57 fd       	sbrc	r21, 7
    3518:	05 d0       	rcall	.+10     	; 0x3524 <__divmodsi4_neg2>
    351a:	d6 df       	rcall	.-84     	; 0x34c8 <__udivmodsi4>
    351c:	07 fc       	sbrc	r0, 7
    351e:	02 d0       	rcall	.+4      	; 0x3524 <__divmodsi4_neg2>
    3520:	46 f4       	brtc	.+16     	; 0x3532 <__divmodsi4_exit>
    3522:	08 c0       	rjmp	.+16     	; 0x3534 <__negsi2>

00003524 <__divmodsi4_neg2>:
    3524:	50 95       	com	r21
    3526:	40 95       	com	r20
    3528:	30 95       	com	r19
    352a:	21 95       	neg	r18
    352c:	3f 4f       	sbci	r19, 0xFF	; 255
    352e:	4f 4f       	sbci	r20, 0xFF	; 255
    3530:	5f 4f       	sbci	r21, 0xFF	; 255

00003532 <__divmodsi4_exit>:
    3532:	08 95       	ret

00003534 <__negsi2>:
    3534:	90 95       	com	r25
    3536:	80 95       	com	r24
    3538:	70 95       	com	r23
    353a:	61 95       	neg	r22
    353c:	7f 4f       	sbci	r23, 0xFF	; 255
    353e:	8f 4f       	sbci	r24, 0xFF	; 255
    3540:	9f 4f       	sbci	r25, 0xFF	; 255
    3542:	08 95       	ret

00003544 <__tablejump2__>:
    3544:	ee 0f       	add	r30, r30
    3546:	ff 1f       	adc	r31, r31

00003548 <__tablejump__>:
    3548:	05 90       	lpm	r0, Z+
    354a:	f4 91       	lpm	r31, Z
    354c:	e0 2d       	mov	r30, r0
    354e:	19 94       	eijmp

00003550 <__umulhisi3>:
    3550:	a2 9f       	mul	r26, r18
    3552:	b0 01       	movw	r22, r0
    3554:	b3 9f       	mul	r27, r19
    3556:	c0 01       	movw	r24, r0
    3558:	a3 9f       	mul	r26, r19
    355a:	70 0d       	add	r23, r0
    355c:	81 1d       	adc	r24, r1
    355e:	11 24       	eor	r1, r1
    3560:	91 1d       	adc	r25, r1
    3562:	b2 9f       	mul	r27, r18
    3564:	70 0d       	add	r23, r0
    3566:	81 1d       	adc	r24, r1
    3568:	11 24       	eor	r1, r1
    356a:	91 1d       	adc	r25, r1
    356c:	08 95       	ret

0000356e <__udivmodhi4>:
    356e:	aa 1b       	sub	r26, r26
    3570:	bb 1b       	sub	r27, r27
    3572:	51 e1       	ldi	r21, 0x11	; 17
    3574:	07 c0       	rjmp	.+14     	; 0x3584 <__udivmodhi4_ep>

00003576 <__udivmodhi4_loop>:
    3576:	aa 1f       	adc	r26, r26
    3578:	bb 1f       	adc	r27, r27
    357a:	a6 17       	cp	r26, r22
    357c:	b7 07       	cpc	r27, r23
    357e:	10 f0       	brcs	.+4      	; 0x3584 <__udivmodhi4_ep>
    3580:	a6 1b       	sub	r26, r22
    3582:	b7 0b       	sbc	r27, r23

00003584 <__udivmodhi4_ep>:
    3584:	88 1f       	adc	r24, r24
    3586:	99 1f       	adc	r25, r25
    3588:	5a 95       	dec	r21
    358a:	a9 f7       	brne	.-22     	; 0x3576 <__udivmodhi4_loop>
    358c:	80 95       	com	r24
    358e:	90 95       	com	r25
    3590:	bc 01       	movw	r22, r24
    3592:	cd 01       	movw	r24, r26
    3594:	08 95       	ret

00003596 <malloc>:
    3596:	cf 93       	push	r28
    3598:	df 93       	push	r29
    359a:	82 30       	cpi	r24, 0x02	; 2
    359c:	91 05       	cpc	r25, r1
    359e:	10 f4       	brcc	.+4      	; 0x35a4 <malloc+0xe>
    35a0:	82 e0       	ldi	r24, 0x02	; 2
    35a2:	90 e0       	ldi	r25, 0x00	; 0
    35a4:	e0 91 dc 15 	lds	r30, 0x15DC
    35a8:	f0 91 dd 15 	lds	r31, 0x15DD
    35ac:	20 e0       	ldi	r18, 0x00	; 0
    35ae:	30 e0       	ldi	r19, 0x00	; 0
    35b0:	a0 e0       	ldi	r26, 0x00	; 0
    35b2:	b0 e0       	ldi	r27, 0x00	; 0
    35b4:	30 97       	sbiw	r30, 0x00	; 0
    35b6:	39 f1       	breq	.+78     	; 0x3606 <malloc+0x70>
    35b8:	40 81       	ld	r20, Z
    35ba:	51 81       	ldd	r21, Z+1	; 0x01
    35bc:	48 17       	cp	r20, r24
    35be:	59 07       	cpc	r21, r25
    35c0:	b8 f0       	brcs	.+46     	; 0x35f0 <malloc+0x5a>
    35c2:	48 17       	cp	r20, r24
    35c4:	59 07       	cpc	r21, r25
    35c6:	71 f4       	brne	.+28     	; 0x35e4 <malloc+0x4e>
    35c8:	82 81       	ldd	r24, Z+2	; 0x02
    35ca:	93 81       	ldd	r25, Z+3	; 0x03
    35cc:	10 97       	sbiw	r26, 0x00	; 0
    35ce:	29 f0       	breq	.+10     	; 0x35da <malloc+0x44>
    35d0:	13 96       	adiw	r26, 0x03	; 3
    35d2:	9c 93       	st	X, r25
    35d4:	8e 93       	st	-X, r24
    35d6:	12 97       	sbiw	r26, 0x02	; 2
    35d8:	2c c0       	rjmp	.+88     	; 0x3632 <malloc+0x9c>
    35da:	90 93 dd 15 	sts	0x15DD, r25
    35de:	80 93 dc 15 	sts	0x15DC, r24
    35e2:	27 c0       	rjmp	.+78     	; 0x3632 <malloc+0x9c>
    35e4:	21 15       	cp	r18, r1
    35e6:	31 05       	cpc	r19, r1
    35e8:	31 f0       	breq	.+12     	; 0x35f6 <malloc+0x60>
    35ea:	42 17       	cp	r20, r18
    35ec:	53 07       	cpc	r21, r19
    35ee:	18 f0       	brcs	.+6      	; 0x35f6 <malloc+0x60>
    35f0:	a9 01       	movw	r20, r18
    35f2:	db 01       	movw	r26, r22
    35f4:	01 c0       	rjmp	.+2      	; 0x35f8 <malloc+0x62>
    35f6:	ef 01       	movw	r28, r30
    35f8:	9a 01       	movw	r18, r20
    35fa:	bd 01       	movw	r22, r26
    35fc:	df 01       	movw	r26, r30
    35fe:	02 80       	ldd	r0, Z+2	; 0x02
    3600:	f3 81       	ldd	r31, Z+3	; 0x03
    3602:	e0 2d       	mov	r30, r0
    3604:	d7 cf       	rjmp	.-82     	; 0x35b4 <malloc+0x1e>
    3606:	21 15       	cp	r18, r1
    3608:	31 05       	cpc	r19, r1
    360a:	f9 f0       	breq	.+62     	; 0x364a <malloc+0xb4>
    360c:	28 1b       	sub	r18, r24
    360e:	39 0b       	sbc	r19, r25
    3610:	24 30       	cpi	r18, 0x04	; 4
    3612:	31 05       	cpc	r19, r1
    3614:	80 f4       	brcc	.+32     	; 0x3636 <malloc+0xa0>
    3616:	8a 81       	ldd	r24, Y+2	; 0x02
    3618:	9b 81       	ldd	r25, Y+3	; 0x03
    361a:	61 15       	cp	r22, r1
    361c:	71 05       	cpc	r23, r1
    361e:	21 f0       	breq	.+8      	; 0x3628 <malloc+0x92>
    3620:	fb 01       	movw	r30, r22
    3622:	93 83       	std	Z+3, r25	; 0x03
    3624:	82 83       	std	Z+2, r24	; 0x02
    3626:	04 c0       	rjmp	.+8      	; 0x3630 <malloc+0x9a>
    3628:	90 93 dd 15 	sts	0x15DD, r25
    362c:	80 93 dc 15 	sts	0x15DC, r24
    3630:	fe 01       	movw	r30, r28
    3632:	32 96       	adiw	r30, 0x02	; 2
    3634:	44 c0       	rjmp	.+136    	; 0x36be <malloc+0x128>
    3636:	fe 01       	movw	r30, r28
    3638:	e2 0f       	add	r30, r18
    363a:	f3 1f       	adc	r31, r19
    363c:	81 93       	st	Z+, r24
    363e:	91 93       	st	Z+, r25
    3640:	22 50       	subi	r18, 0x02	; 2
    3642:	31 09       	sbc	r19, r1
    3644:	39 83       	std	Y+1, r19	; 0x01
    3646:	28 83       	st	Y, r18
    3648:	3a c0       	rjmp	.+116    	; 0x36be <malloc+0x128>
    364a:	20 91 da 15 	lds	r18, 0x15DA
    364e:	30 91 db 15 	lds	r19, 0x15DB
    3652:	23 2b       	or	r18, r19
    3654:	41 f4       	brne	.+16     	; 0x3666 <malloc+0xd0>
    3656:	20 91 02 02 	lds	r18, 0x0202
    365a:	30 91 03 02 	lds	r19, 0x0203
    365e:	30 93 db 15 	sts	0x15DB, r19
    3662:	20 93 da 15 	sts	0x15DA, r18
    3666:	20 91 00 02 	lds	r18, 0x0200
    366a:	30 91 01 02 	lds	r19, 0x0201
    366e:	21 15       	cp	r18, r1
    3670:	31 05       	cpc	r19, r1
    3672:	41 f4       	brne	.+16     	; 0x3684 <malloc+0xee>
    3674:	2d b7       	in	r18, 0x3d	; 61
    3676:	3e b7       	in	r19, 0x3e	; 62
    3678:	40 91 04 02 	lds	r20, 0x0204
    367c:	50 91 05 02 	lds	r21, 0x0205
    3680:	24 1b       	sub	r18, r20
    3682:	35 0b       	sbc	r19, r21
    3684:	e0 91 da 15 	lds	r30, 0x15DA
    3688:	f0 91 db 15 	lds	r31, 0x15DB
    368c:	e2 17       	cp	r30, r18
    368e:	f3 07       	cpc	r31, r19
    3690:	a0 f4       	brcc	.+40     	; 0x36ba <malloc+0x124>
    3692:	2e 1b       	sub	r18, r30
    3694:	3f 0b       	sbc	r19, r31
    3696:	28 17       	cp	r18, r24
    3698:	39 07       	cpc	r19, r25
    369a:	78 f0       	brcs	.+30     	; 0x36ba <malloc+0x124>
    369c:	ac 01       	movw	r20, r24
    369e:	4e 5f       	subi	r20, 0xFE	; 254
    36a0:	5f 4f       	sbci	r21, 0xFF	; 255
    36a2:	24 17       	cp	r18, r20
    36a4:	35 07       	cpc	r19, r21
    36a6:	48 f0       	brcs	.+18     	; 0x36ba <malloc+0x124>
    36a8:	4e 0f       	add	r20, r30
    36aa:	5f 1f       	adc	r21, r31
    36ac:	50 93 db 15 	sts	0x15DB, r21
    36b0:	40 93 da 15 	sts	0x15DA, r20
    36b4:	81 93       	st	Z+, r24
    36b6:	91 93       	st	Z+, r25
    36b8:	02 c0       	rjmp	.+4      	; 0x36be <malloc+0x128>
    36ba:	e0 e0       	ldi	r30, 0x00	; 0
    36bc:	f0 e0       	ldi	r31, 0x00	; 0
    36be:	cf 01       	movw	r24, r30
    36c0:	df 91       	pop	r29
    36c2:	cf 91       	pop	r28
    36c4:	08 95       	ret

000036c6 <free>:
    36c6:	cf 93       	push	r28
    36c8:	df 93       	push	r29
    36ca:	00 97       	sbiw	r24, 0x00	; 0
    36cc:	09 f4       	brne	.+2      	; 0x36d0 <free+0xa>
    36ce:	87 c0       	rjmp	.+270    	; 0x37de <free+0x118>
    36d0:	fc 01       	movw	r30, r24
    36d2:	32 97       	sbiw	r30, 0x02	; 2
    36d4:	13 82       	std	Z+3, r1	; 0x03
    36d6:	12 82       	std	Z+2, r1	; 0x02
    36d8:	c0 91 dc 15 	lds	r28, 0x15DC
    36dc:	d0 91 dd 15 	lds	r29, 0x15DD
    36e0:	20 97       	sbiw	r28, 0x00	; 0
    36e2:	81 f4       	brne	.+32     	; 0x3704 <free+0x3e>
    36e4:	20 81       	ld	r18, Z
    36e6:	31 81       	ldd	r19, Z+1	; 0x01
    36e8:	28 0f       	add	r18, r24
    36ea:	39 1f       	adc	r19, r25
    36ec:	80 91 da 15 	lds	r24, 0x15DA
    36f0:	90 91 db 15 	lds	r25, 0x15DB
    36f4:	82 17       	cp	r24, r18
    36f6:	93 07       	cpc	r25, r19
    36f8:	79 f5       	brne	.+94     	; 0x3758 <free+0x92>
    36fa:	f0 93 db 15 	sts	0x15DB, r31
    36fe:	e0 93 da 15 	sts	0x15DA, r30
    3702:	6d c0       	rjmp	.+218    	; 0x37de <free+0x118>
    3704:	de 01       	movw	r26, r28
    3706:	20 e0       	ldi	r18, 0x00	; 0
    3708:	30 e0       	ldi	r19, 0x00	; 0
    370a:	ae 17       	cp	r26, r30
    370c:	bf 07       	cpc	r27, r31
    370e:	50 f4       	brcc	.+20     	; 0x3724 <free+0x5e>
    3710:	12 96       	adiw	r26, 0x02	; 2
    3712:	4d 91       	ld	r20, X+
    3714:	5c 91       	ld	r21, X
    3716:	13 97       	sbiw	r26, 0x03	; 3
    3718:	9d 01       	movw	r18, r26
    371a:	41 15       	cp	r20, r1
    371c:	51 05       	cpc	r21, r1
    371e:	09 f1       	breq	.+66     	; 0x3762 <free+0x9c>
    3720:	da 01       	movw	r26, r20
    3722:	f3 cf       	rjmp	.-26     	; 0x370a <free+0x44>
    3724:	b3 83       	std	Z+3, r27	; 0x03
    3726:	a2 83       	std	Z+2, r26	; 0x02
    3728:	40 81       	ld	r20, Z
    372a:	51 81       	ldd	r21, Z+1	; 0x01
    372c:	84 0f       	add	r24, r20
    372e:	95 1f       	adc	r25, r21
    3730:	8a 17       	cp	r24, r26
    3732:	9b 07       	cpc	r25, r27
    3734:	71 f4       	brne	.+28     	; 0x3752 <free+0x8c>
    3736:	8d 91       	ld	r24, X+
    3738:	9c 91       	ld	r25, X
    373a:	11 97       	sbiw	r26, 0x01	; 1
    373c:	84 0f       	add	r24, r20
    373e:	95 1f       	adc	r25, r21
    3740:	02 96       	adiw	r24, 0x02	; 2
    3742:	91 83       	std	Z+1, r25	; 0x01
    3744:	80 83       	st	Z, r24
    3746:	12 96       	adiw	r26, 0x02	; 2
    3748:	8d 91       	ld	r24, X+
    374a:	9c 91       	ld	r25, X
    374c:	13 97       	sbiw	r26, 0x03	; 3
    374e:	93 83       	std	Z+3, r25	; 0x03
    3750:	82 83       	std	Z+2, r24	; 0x02
    3752:	21 15       	cp	r18, r1
    3754:	31 05       	cpc	r19, r1
    3756:	29 f4       	brne	.+10     	; 0x3762 <free+0x9c>
    3758:	f0 93 dd 15 	sts	0x15DD, r31
    375c:	e0 93 dc 15 	sts	0x15DC, r30
    3760:	3e c0       	rjmp	.+124    	; 0x37de <free+0x118>
    3762:	d9 01       	movw	r26, r18
    3764:	13 96       	adiw	r26, 0x03	; 3
    3766:	fc 93       	st	X, r31
    3768:	ee 93       	st	-X, r30
    376a:	12 97       	sbiw	r26, 0x02	; 2
    376c:	4d 91       	ld	r20, X+
    376e:	5d 91       	ld	r21, X+
    3770:	a4 0f       	add	r26, r20
    3772:	b5 1f       	adc	r27, r21
    3774:	ea 17       	cp	r30, r26
    3776:	fb 07       	cpc	r31, r27
    3778:	79 f4       	brne	.+30     	; 0x3798 <free+0xd2>
    377a:	80 81       	ld	r24, Z
    377c:	91 81       	ldd	r25, Z+1	; 0x01
    377e:	84 0f       	add	r24, r20
    3780:	95 1f       	adc	r25, r21
    3782:	02 96       	adiw	r24, 0x02	; 2
    3784:	d9 01       	movw	r26, r18
    3786:	11 96       	adiw	r26, 0x01	; 1
    3788:	9c 93       	st	X, r25
    378a:	8e 93       	st	-X, r24
    378c:	82 81       	ldd	r24, Z+2	; 0x02
    378e:	93 81       	ldd	r25, Z+3	; 0x03
    3790:	13 96       	adiw	r26, 0x03	; 3
    3792:	9c 93       	st	X, r25
    3794:	8e 93       	st	-X, r24
    3796:	12 97       	sbiw	r26, 0x02	; 2
    3798:	e0 e0       	ldi	r30, 0x00	; 0
    379a:	f0 e0       	ldi	r31, 0x00	; 0
    379c:	8a 81       	ldd	r24, Y+2	; 0x02
    379e:	9b 81       	ldd	r25, Y+3	; 0x03
    37a0:	00 97       	sbiw	r24, 0x00	; 0
    37a2:	19 f0       	breq	.+6      	; 0x37aa <free+0xe4>
    37a4:	fe 01       	movw	r30, r28
    37a6:	ec 01       	movw	r28, r24
    37a8:	f9 cf       	rjmp	.-14     	; 0x379c <free+0xd6>
    37aa:	ce 01       	movw	r24, r28
    37ac:	02 96       	adiw	r24, 0x02	; 2
    37ae:	28 81       	ld	r18, Y
    37b0:	39 81       	ldd	r19, Y+1	; 0x01
    37b2:	82 0f       	add	r24, r18
    37b4:	93 1f       	adc	r25, r19
    37b6:	20 91 da 15 	lds	r18, 0x15DA
    37ba:	30 91 db 15 	lds	r19, 0x15DB
    37be:	28 17       	cp	r18, r24
    37c0:	39 07       	cpc	r19, r25
    37c2:	69 f4       	brne	.+26     	; 0x37de <free+0x118>
    37c4:	30 97       	sbiw	r30, 0x00	; 0
    37c6:	29 f4       	brne	.+10     	; 0x37d2 <free+0x10c>
    37c8:	10 92 dd 15 	sts	0x15DD, r1
    37cc:	10 92 dc 15 	sts	0x15DC, r1
    37d0:	02 c0       	rjmp	.+4      	; 0x37d6 <free+0x110>
    37d2:	13 82       	std	Z+3, r1	; 0x03
    37d4:	12 82       	std	Z+2, r1	; 0x02
    37d6:	d0 93 db 15 	sts	0x15DB, r29
    37da:	c0 93 da 15 	sts	0x15DA, r28
    37de:	df 91       	pop	r29
    37e0:	cf 91       	pop	r28
    37e2:	08 95       	ret

000037e4 <atoi>:
    37e4:	fc 01       	movw	r30, r24
    37e6:	88 27       	eor	r24, r24
    37e8:	99 27       	eor	r25, r25
    37ea:	e8 94       	clt
    37ec:	21 91       	ld	r18, Z+
    37ee:	20 32       	cpi	r18, 0x20	; 32
    37f0:	e9 f3       	breq	.-6      	; 0x37ec <atoi+0x8>
    37f2:	29 30       	cpi	r18, 0x09	; 9
    37f4:	10 f0       	brcs	.+4      	; 0x37fa <atoi+0x16>
    37f6:	2e 30       	cpi	r18, 0x0E	; 14
    37f8:	c8 f3       	brcs	.-14     	; 0x37ec <atoi+0x8>
    37fa:	2b 32       	cpi	r18, 0x2B	; 43
    37fc:	39 f0       	breq	.+14     	; 0x380c <atoi+0x28>
    37fe:	2d 32       	cpi	r18, 0x2D	; 45
    3800:	31 f4       	brne	.+12     	; 0x380e <atoi+0x2a>
    3802:	68 94       	set
    3804:	03 c0       	rjmp	.+6      	; 0x380c <atoi+0x28>
    3806:	14 d0       	rcall	.+40     	; 0x3830 <__mulhi_const_10>
    3808:	82 0f       	add	r24, r18
    380a:	91 1d       	adc	r25, r1
    380c:	21 91       	ld	r18, Z+
    380e:	20 53       	subi	r18, 0x30	; 48
    3810:	2a 30       	cpi	r18, 0x0A	; 10
    3812:	c8 f3       	brcs	.-14     	; 0x3806 <atoi+0x22>
    3814:	1e f4       	brtc	.+6      	; 0x381c <atoi+0x38>
    3816:	90 95       	com	r25
    3818:	81 95       	neg	r24
    381a:	9f 4f       	sbci	r25, 0xFF	; 255
    381c:	08 95       	ret

0000381e <memcpy>:
    381e:	fb 01       	movw	r30, r22
    3820:	dc 01       	movw	r26, r24
    3822:	02 c0       	rjmp	.+4      	; 0x3828 <memcpy+0xa>
    3824:	01 90       	ld	r0, Z+
    3826:	0d 92       	st	X+, r0
    3828:	41 50       	subi	r20, 0x01	; 1
    382a:	50 40       	sbci	r21, 0x00	; 0
    382c:	d8 f7       	brcc	.-10     	; 0x3824 <memcpy+0x6>
    382e:	08 95       	ret

00003830 <__mulhi_const_10>:
    3830:	7a e0       	ldi	r23, 0x0A	; 10
    3832:	97 9f       	mul	r25, r23
    3834:	90 2d       	mov	r25, r0
    3836:	87 9f       	mul	r24, r23
    3838:	80 2d       	mov	r24, r0
    383a:	91 0d       	add	r25, r1
    383c:	11 24       	eor	r1, r1
    383e:	08 95       	ret

00003840 <sprintf>:
    3840:	0f 93       	push	r16
    3842:	1f 93       	push	r17
    3844:	cf 93       	push	r28
    3846:	df 93       	push	r29
    3848:	cd b7       	in	r28, 0x3d	; 61
    384a:	de b7       	in	r29, 0x3e	; 62
    384c:	2e 97       	sbiw	r28, 0x0e	; 14
    384e:	0f b6       	in	r0, 0x3f	; 63
    3850:	f8 94       	cli
    3852:	de bf       	out	0x3e, r29	; 62
    3854:	0f be       	out	0x3f, r0	; 63
    3856:	cd bf       	out	0x3d, r28	; 61
    3858:	0e 89       	ldd	r16, Y+22	; 0x16
    385a:	1f 89       	ldd	r17, Y+23	; 0x17
    385c:	86 e0       	ldi	r24, 0x06	; 6
    385e:	8c 83       	std	Y+4, r24	; 0x04
    3860:	1a 83       	std	Y+2, r17	; 0x02
    3862:	09 83       	std	Y+1, r16	; 0x01
    3864:	8f ef       	ldi	r24, 0xFF	; 255
    3866:	9f e7       	ldi	r25, 0x7F	; 127
    3868:	9e 83       	std	Y+6, r25	; 0x06
    386a:	8d 83       	std	Y+5, r24	; 0x05
    386c:	ae 01       	movw	r20, r28
    386e:	46 5e       	subi	r20, 0xE6	; 230
    3870:	5f 4f       	sbci	r21, 0xFF	; 255
    3872:	68 8d       	ldd	r22, Y+24	; 0x18
    3874:	79 8d       	ldd	r23, Y+25	; 0x19
    3876:	ce 01       	movw	r24, r28
    3878:	01 96       	adiw	r24, 0x01	; 1
    387a:	10 d0       	rcall	.+32     	; 0x389c <vfprintf>
    387c:	ef 81       	ldd	r30, Y+7	; 0x07
    387e:	f8 85       	ldd	r31, Y+8	; 0x08
    3880:	e0 0f       	add	r30, r16
    3882:	f1 1f       	adc	r31, r17
    3884:	10 82       	st	Z, r1
    3886:	2e 96       	adiw	r28, 0x0e	; 14
    3888:	0f b6       	in	r0, 0x3f	; 63
    388a:	f8 94       	cli
    388c:	de bf       	out	0x3e, r29	; 62
    388e:	0f be       	out	0x3f, r0	; 63
    3890:	cd bf       	out	0x3d, r28	; 61
    3892:	df 91       	pop	r29
    3894:	cf 91       	pop	r28
    3896:	1f 91       	pop	r17
    3898:	0f 91       	pop	r16
    389a:	08 95       	ret

0000389c <vfprintf>:
    389c:	2f 92       	push	r2
    389e:	3f 92       	push	r3
    38a0:	4f 92       	push	r4
    38a2:	5f 92       	push	r5
    38a4:	6f 92       	push	r6
    38a6:	7f 92       	push	r7
    38a8:	8f 92       	push	r8
    38aa:	9f 92       	push	r9
    38ac:	af 92       	push	r10
    38ae:	bf 92       	push	r11
    38b0:	cf 92       	push	r12
    38b2:	df 92       	push	r13
    38b4:	ef 92       	push	r14
    38b6:	ff 92       	push	r15
    38b8:	0f 93       	push	r16
    38ba:	1f 93       	push	r17
    38bc:	cf 93       	push	r28
    38be:	df 93       	push	r29
    38c0:	cd b7       	in	r28, 0x3d	; 61
    38c2:	de b7       	in	r29, 0x3e	; 62
    38c4:	2c 97       	sbiw	r28, 0x0c	; 12
    38c6:	0f b6       	in	r0, 0x3f	; 63
    38c8:	f8 94       	cli
    38ca:	de bf       	out	0x3e, r29	; 62
    38cc:	0f be       	out	0x3f, r0	; 63
    38ce:	cd bf       	out	0x3d, r28	; 61
    38d0:	7c 01       	movw	r14, r24
    38d2:	6b 01       	movw	r12, r22
    38d4:	8a 01       	movw	r16, r20
    38d6:	fc 01       	movw	r30, r24
    38d8:	17 82       	std	Z+7, r1	; 0x07
    38da:	16 82       	std	Z+6, r1	; 0x06
    38dc:	83 81       	ldd	r24, Z+3	; 0x03
    38de:	81 ff       	sbrs	r24, 1
    38e0:	b0 c1       	rjmp	.+864    	; 0x3c42 <vfprintf+0x3a6>
    38e2:	ce 01       	movw	r24, r28
    38e4:	01 96       	adiw	r24, 0x01	; 1
    38e6:	4c 01       	movw	r8, r24
    38e8:	f7 01       	movw	r30, r14
    38ea:	93 81       	ldd	r25, Z+3	; 0x03
    38ec:	f6 01       	movw	r30, r12
    38ee:	93 fd       	sbrc	r25, 3
    38f0:	85 91       	lpm	r24, Z+
    38f2:	93 ff       	sbrs	r25, 3
    38f4:	81 91       	ld	r24, Z+
    38f6:	6f 01       	movw	r12, r30
    38f8:	88 23       	and	r24, r24
    38fa:	09 f4       	brne	.+2      	; 0x38fe <vfprintf+0x62>
    38fc:	9e c1       	rjmp	.+828    	; 0x3c3a <vfprintf+0x39e>
    38fe:	85 32       	cpi	r24, 0x25	; 37
    3900:	39 f4       	brne	.+14     	; 0x3910 <vfprintf+0x74>
    3902:	93 fd       	sbrc	r25, 3
    3904:	85 91       	lpm	r24, Z+
    3906:	93 ff       	sbrs	r25, 3
    3908:	81 91       	ld	r24, Z+
    390a:	6f 01       	movw	r12, r30
    390c:	85 32       	cpi	r24, 0x25	; 37
    390e:	21 f4       	brne	.+8      	; 0x3918 <vfprintf+0x7c>
    3910:	b7 01       	movw	r22, r14
    3912:	90 e0       	ldi	r25, 0x00	; 0
    3914:	c7 d1       	rcall	.+910    	; 0x3ca4 <fputc>
    3916:	e8 cf       	rjmp	.-48     	; 0x38e8 <vfprintf+0x4c>
    3918:	51 2c       	mov	r5, r1
    391a:	31 2c       	mov	r3, r1
    391c:	20 e0       	ldi	r18, 0x00	; 0
    391e:	20 32       	cpi	r18, 0x20	; 32
    3920:	a0 f4       	brcc	.+40     	; 0x394a <vfprintf+0xae>
    3922:	8b 32       	cpi	r24, 0x2B	; 43
    3924:	69 f0       	breq	.+26     	; 0x3940 <vfprintf+0xa4>
    3926:	30 f4       	brcc	.+12     	; 0x3934 <vfprintf+0x98>
    3928:	80 32       	cpi	r24, 0x20	; 32
    392a:	59 f0       	breq	.+22     	; 0x3942 <vfprintf+0xa6>
    392c:	83 32       	cpi	r24, 0x23	; 35
    392e:	69 f4       	brne	.+26     	; 0x394a <vfprintf+0xae>
    3930:	20 61       	ori	r18, 0x10	; 16
    3932:	2c c0       	rjmp	.+88     	; 0x398c <vfprintf+0xf0>
    3934:	8d 32       	cpi	r24, 0x2D	; 45
    3936:	39 f0       	breq	.+14     	; 0x3946 <vfprintf+0xaa>
    3938:	80 33       	cpi	r24, 0x30	; 48
    393a:	39 f4       	brne	.+14     	; 0x394a <vfprintf+0xae>
    393c:	21 60       	ori	r18, 0x01	; 1
    393e:	26 c0       	rjmp	.+76     	; 0x398c <vfprintf+0xf0>
    3940:	22 60       	ori	r18, 0x02	; 2
    3942:	24 60       	ori	r18, 0x04	; 4
    3944:	23 c0       	rjmp	.+70     	; 0x398c <vfprintf+0xf0>
    3946:	28 60       	ori	r18, 0x08	; 8
    3948:	21 c0       	rjmp	.+66     	; 0x398c <vfprintf+0xf0>
    394a:	27 fd       	sbrc	r18, 7
    394c:	27 c0       	rjmp	.+78     	; 0x399c <vfprintf+0x100>
    394e:	30 ed       	ldi	r19, 0xD0	; 208
    3950:	38 0f       	add	r19, r24
    3952:	3a 30       	cpi	r19, 0x0A	; 10
    3954:	78 f4       	brcc	.+30     	; 0x3974 <vfprintf+0xd8>
    3956:	26 ff       	sbrs	r18, 6
    3958:	06 c0       	rjmp	.+12     	; 0x3966 <vfprintf+0xca>
    395a:	fa e0       	ldi	r31, 0x0A	; 10
    395c:	5f 9e       	mul	r5, r31
    395e:	30 0d       	add	r19, r0
    3960:	11 24       	eor	r1, r1
    3962:	53 2e       	mov	r5, r19
    3964:	13 c0       	rjmp	.+38     	; 0x398c <vfprintf+0xf0>
    3966:	8a e0       	ldi	r24, 0x0A	; 10
    3968:	38 9e       	mul	r3, r24
    396a:	30 0d       	add	r19, r0
    396c:	11 24       	eor	r1, r1
    396e:	33 2e       	mov	r3, r19
    3970:	20 62       	ori	r18, 0x20	; 32
    3972:	0c c0       	rjmp	.+24     	; 0x398c <vfprintf+0xf0>
    3974:	8e 32       	cpi	r24, 0x2E	; 46
    3976:	21 f4       	brne	.+8      	; 0x3980 <vfprintf+0xe4>
    3978:	26 fd       	sbrc	r18, 6
    397a:	5f c1       	rjmp	.+702    	; 0x3c3a <vfprintf+0x39e>
    397c:	20 64       	ori	r18, 0x40	; 64
    397e:	06 c0       	rjmp	.+12     	; 0x398c <vfprintf+0xf0>
    3980:	8c 36       	cpi	r24, 0x6C	; 108
    3982:	11 f4       	brne	.+4      	; 0x3988 <vfprintf+0xec>
    3984:	20 68       	ori	r18, 0x80	; 128
    3986:	02 c0       	rjmp	.+4      	; 0x398c <vfprintf+0xf0>
    3988:	88 36       	cpi	r24, 0x68	; 104
    398a:	41 f4       	brne	.+16     	; 0x399c <vfprintf+0x100>
    398c:	f6 01       	movw	r30, r12
    398e:	93 fd       	sbrc	r25, 3
    3990:	85 91       	lpm	r24, Z+
    3992:	93 ff       	sbrs	r25, 3
    3994:	81 91       	ld	r24, Z+
    3996:	6f 01       	movw	r12, r30
    3998:	81 11       	cpse	r24, r1
    399a:	c1 cf       	rjmp	.-126    	; 0x391e <vfprintf+0x82>
    399c:	98 2f       	mov	r25, r24
    399e:	9f 7d       	andi	r25, 0xDF	; 223
    39a0:	95 54       	subi	r25, 0x45	; 69
    39a2:	93 30       	cpi	r25, 0x03	; 3
    39a4:	28 f4       	brcc	.+10     	; 0x39b0 <vfprintf+0x114>
    39a6:	0c 5f       	subi	r16, 0xFC	; 252
    39a8:	1f 4f       	sbci	r17, 0xFF	; 255
    39aa:	ff e3       	ldi	r31, 0x3F	; 63
    39ac:	f9 83       	std	Y+1, r31	; 0x01
    39ae:	0d c0       	rjmp	.+26     	; 0x39ca <vfprintf+0x12e>
    39b0:	83 36       	cpi	r24, 0x63	; 99
    39b2:	31 f0       	breq	.+12     	; 0x39c0 <vfprintf+0x124>
    39b4:	83 37       	cpi	r24, 0x73	; 115
    39b6:	71 f0       	breq	.+28     	; 0x39d4 <vfprintf+0x138>
    39b8:	83 35       	cpi	r24, 0x53	; 83
    39ba:	09 f0       	breq	.+2      	; 0x39be <vfprintf+0x122>
    39bc:	57 c0       	rjmp	.+174    	; 0x3a6c <vfprintf+0x1d0>
    39be:	21 c0       	rjmp	.+66     	; 0x3a02 <vfprintf+0x166>
    39c0:	f8 01       	movw	r30, r16
    39c2:	80 81       	ld	r24, Z
    39c4:	89 83       	std	Y+1, r24	; 0x01
    39c6:	0e 5f       	subi	r16, 0xFE	; 254
    39c8:	1f 4f       	sbci	r17, 0xFF	; 255
    39ca:	44 24       	eor	r4, r4
    39cc:	43 94       	inc	r4
    39ce:	51 2c       	mov	r5, r1
    39d0:	54 01       	movw	r10, r8
    39d2:	14 c0       	rjmp	.+40     	; 0x39fc <vfprintf+0x160>
    39d4:	38 01       	movw	r6, r16
    39d6:	f2 e0       	ldi	r31, 0x02	; 2
    39d8:	6f 0e       	add	r6, r31
    39da:	71 1c       	adc	r7, r1
    39dc:	f8 01       	movw	r30, r16
    39de:	a0 80       	ld	r10, Z
    39e0:	b1 80       	ldd	r11, Z+1	; 0x01
    39e2:	26 ff       	sbrs	r18, 6
    39e4:	03 c0       	rjmp	.+6      	; 0x39ec <vfprintf+0x150>
    39e6:	65 2d       	mov	r22, r5
    39e8:	70 e0       	ldi	r23, 0x00	; 0
    39ea:	02 c0       	rjmp	.+4      	; 0x39f0 <vfprintf+0x154>
    39ec:	6f ef       	ldi	r22, 0xFF	; 255
    39ee:	7f ef       	ldi	r23, 0xFF	; 255
    39f0:	c5 01       	movw	r24, r10
    39f2:	2c 87       	std	Y+12, r18	; 0x0c
    39f4:	4c d1       	rcall	.+664    	; 0x3c8e <strnlen>
    39f6:	2c 01       	movw	r4, r24
    39f8:	83 01       	movw	r16, r6
    39fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    39fc:	2f 77       	andi	r18, 0x7F	; 127
    39fe:	22 2e       	mov	r2, r18
    3a00:	16 c0       	rjmp	.+44     	; 0x3a2e <vfprintf+0x192>
    3a02:	38 01       	movw	r6, r16
    3a04:	f2 e0       	ldi	r31, 0x02	; 2
    3a06:	6f 0e       	add	r6, r31
    3a08:	71 1c       	adc	r7, r1
    3a0a:	f8 01       	movw	r30, r16
    3a0c:	a0 80       	ld	r10, Z
    3a0e:	b1 80       	ldd	r11, Z+1	; 0x01
    3a10:	26 ff       	sbrs	r18, 6
    3a12:	03 c0       	rjmp	.+6      	; 0x3a1a <vfprintf+0x17e>
    3a14:	65 2d       	mov	r22, r5
    3a16:	70 e0       	ldi	r23, 0x00	; 0
    3a18:	02 c0       	rjmp	.+4      	; 0x3a1e <vfprintf+0x182>
    3a1a:	6f ef       	ldi	r22, 0xFF	; 255
    3a1c:	7f ef       	ldi	r23, 0xFF	; 255
    3a1e:	c5 01       	movw	r24, r10
    3a20:	2c 87       	std	Y+12, r18	; 0x0c
    3a22:	2a d1       	rcall	.+596    	; 0x3c78 <strnlen_P>
    3a24:	2c 01       	movw	r4, r24
    3a26:	2c 85       	ldd	r18, Y+12	; 0x0c
    3a28:	20 68       	ori	r18, 0x80	; 128
    3a2a:	22 2e       	mov	r2, r18
    3a2c:	83 01       	movw	r16, r6
    3a2e:	23 fc       	sbrc	r2, 3
    3a30:	19 c0       	rjmp	.+50     	; 0x3a64 <vfprintf+0x1c8>
    3a32:	83 2d       	mov	r24, r3
    3a34:	90 e0       	ldi	r25, 0x00	; 0
    3a36:	48 16       	cp	r4, r24
    3a38:	59 06       	cpc	r5, r25
    3a3a:	a0 f4       	brcc	.+40     	; 0x3a64 <vfprintf+0x1c8>
    3a3c:	b7 01       	movw	r22, r14
    3a3e:	80 e2       	ldi	r24, 0x20	; 32
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	30 d1       	rcall	.+608    	; 0x3ca4 <fputc>
    3a44:	3a 94       	dec	r3
    3a46:	f5 cf       	rjmp	.-22     	; 0x3a32 <vfprintf+0x196>
    3a48:	f5 01       	movw	r30, r10
    3a4a:	27 fc       	sbrc	r2, 7
    3a4c:	85 91       	lpm	r24, Z+
    3a4e:	27 fe       	sbrs	r2, 7
    3a50:	81 91       	ld	r24, Z+
    3a52:	5f 01       	movw	r10, r30
    3a54:	b7 01       	movw	r22, r14
    3a56:	90 e0       	ldi	r25, 0x00	; 0
    3a58:	25 d1       	rcall	.+586    	; 0x3ca4 <fputc>
    3a5a:	31 10       	cpse	r3, r1
    3a5c:	3a 94       	dec	r3
    3a5e:	f1 e0       	ldi	r31, 0x01	; 1
    3a60:	4f 1a       	sub	r4, r31
    3a62:	51 08       	sbc	r5, r1
    3a64:	41 14       	cp	r4, r1
    3a66:	51 04       	cpc	r5, r1
    3a68:	79 f7       	brne	.-34     	; 0x3a48 <vfprintf+0x1ac>
    3a6a:	de c0       	rjmp	.+444    	; 0x3c28 <vfprintf+0x38c>
    3a6c:	84 36       	cpi	r24, 0x64	; 100
    3a6e:	11 f0       	breq	.+4      	; 0x3a74 <vfprintf+0x1d8>
    3a70:	89 36       	cpi	r24, 0x69	; 105
    3a72:	31 f5       	brne	.+76     	; 0x3ac0 <vfprintf+0x224>
    3a74:	f8 01       	movw	r30, r16
    3a76:	27 ff       	sbrs	r18, 7
    3a78:	07 c0       	rjmp	.+14     	; 0x3a88 <vfprintf+0x1ec>
    3a7a:	60 81       	ld	r22, Z
    3a7c:	71 81       	ldd	r23, Z+1	; 0x01
    3a7e:	82 81       	ldd	r24, Z+2	; 0x02
    3a80:	93 81       	ldd	r25, Z+3	; 0x03
    3a82:	0c 5f       	subi	r16, 0xFC	; 252
    3a84:	1f 4f       	sbci	r17, 0xFF	; 255
    3a86:	08 c0       	rjmp	.+16     	; 0x3a98 <vfprintf+0x1fc>
    3a88:	60 81       	ld	r22, Z
    3a8a:	71 81       	ldd	r23, Z+1	; 0x01
    3a8c:	88 27       	eor	r24, r24
    3a8e:	77 fd       	sbrc	r23, 7
    3a90:	80 95       	com	r24
    3a92:	98 2f       	mov	r25, r24
    3a94:	0e 5f       	subi	r16, 0xFE	; 254
    3a96:	1f 4f       	sbci	r17, 0xFF	; 255
    3a98:	2f 76       	andi	r18, 0x6F	; 111
    3a9a:	b2 2e       	mov	r11, r18
    3a9c:	97 ff       	sbrs	r25, 7
    3a9e:	09 c0       	rjmp	.+18     	; 0x3ab2 <vfprintf+0x216>
    3aa0:	90 95       	com	r25
    3aa2:	80 95       	com	r24
    3aa4:	70 95       	com	r23
    3aa6:	61 95       	neg	r22
    3aa8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aaa:	8f 4f       	sbci	r24, 0xFF	; 255
    3aac:	9f 4f       	sbci	r25, 0xFF	; 255
    3aae:	20 68       	ori	r18, 0x80	; 128
    3ab0:	b2 2e       	mov	r11, r18
    3ab2:	2a e0       	ldi	r18, 0x0A	; 10
    3ab4:	30 e0       	ldi	r19, 0x00	; 0
    3ab6:	a4 01       	movw	r20, r8
    3ab8:	27 d1       	rcall	.+590    	; 0x3d08 <__ultoa_invert>
    3aba:	a8 2e       	mov	r10, r24
    3abc:	a8 18       	sub	r10, r8
    3abe:	43 c0       	rjmp	.+134    	; 0x3b46 <vfprintf+0x2aa>
    3ac0:	85 37       	cpi	r24, 0x75	; 117
    3ac2:	29 f4       	brne	.+10     	; 0x3ace <vfprintf+0x232>
    3ac4:	2f 7e       	andi	r18, 0xEF	; 239
    3ac6:	b2 2e       	mov	r11, r18
    3ac8:	2a e0       	ldi	r18, 0x0A	; 10
    3aca:	30 e0       	ldi	r19, 0x00	; 0
    3acc:	25 c0       	rjmp	.+74     	; 0x3b18 <vfprintf+0x27c>
    3ace:	f2 2f       	mov	r31, r18
    3ad0:	f9 7f       	andi	r31, 0xF9	; 249
    3ad2:	bf 2e       	mov	r11, r31
    3ad4:	8f 36       	cpi	r24, 0x6F	; 111
    3ad6:	c1 f0       	breq	.+48     	; 0x3b08 <vfprintf+0x26c>
    3ad8:	18 f4       	brcc	.+6      	; 0x3ae0 <vfprintf+0x244>
    3ada:	88 35       	cpi	r24, 0x58	; 88
    3adc:	79 f0       	breq	.+30     	; 0x3afc <vfprintf+0x260>
    3ade:	ad c0       	rjmp	.+346    	; 0x3c3a <vfprintf+0x39e>
    3ae0:	80 37       	cpi	r24, 0x70	; 112
    3ae2:	19 f0       	breq	.+6      	; 0x3aea <vfprintf+0x24e>
    3ae4:	88 37       	cpi	r24, 0x78	; 120
    3ae6:	21 f0       	breq	.+8      	; 0x3af0 <vfprintf+0x254>
    3ae8:	a8 c0       	rjmp	.+336    	; 0x3c3a <vfprintf+0x39e>
    3aea:	2f 2f       	mov	r18, r31
    3aec:	20 61       	ori	r18, 0x10	; 16
    3aee:	b2 2e       	mov	r11, r18
    3af0:	b4 fe       	sbrs	r11, 4
    3af2:	0d c0       	rjmp	.+26     	; 0x3b0e <vfprintf+0x272>
    3af4:	8b 2d       	mov	r24, r11
    3af6:	84 60       	ori	r24, 0x04	; 4
    3af8:	b8 2e       	mov	r11, r24
    3afa:	09 c0       	rjmp	.+18     	; 0x3b0e <vfprintf+0x272>
    3afc:	24 ff       	sbrs	r18, 4
    3afe:	0a c0       	rjmp	.+20     	; 0x3b14 <vfprintf+0x278>
    3b00:	9f 2f       	mov	r25, r31
    3b02:	96 60       	ori	r25, 0x06	; 6
    3b04:	b9 2e       	mov	r11, r25
    3b06:	06 c0       	rjmp	.+12     	; 0x3b14 <vfprintf+0x278>
    3b08:	28 e0       	ldi	r18, 0x08	; 8
    3b0a:	30 e0       	ldi	r19, 0x00	; 0
    3b0c:	05 c0       	rjmp	.+10     	; 0x3b18 <vfprintf+0x27c>
    3b0e:	20 e1       	ldi	r18, 0x10	; 16
    3b10:	30 e0       	ldi	r19, 0x00	; 0
    3b12:	02 c0       	rjmp	.+4      	; 0x3b18 <vfprintf+0x27c>
    3b14:	20 e1       	ldi	r18, 0x10	; 16
    3b16:	32 e0       	ldi	r19, 0x02	; 2
    3b18:	f8 01       	movw	r30, r16
    3b1a:	b7 fe       	sbrs	r11, 7
    3b1c:	07 c0       	rjmp	.+14     	; 0x3b2c <vfprintf+0x290>
    3b1e:	60 81       	ld	r22, Z
    3b20:	71 81       	ldd	r23, Z+1	; 0x01
    3b22:	82 81       	ldd	r24, Z+2	; 0x02
    3b24:	93 81       	ldd	r25, Z+3	; 0x03
    3b26:	0c 5f       	subi	r16, 0xFC	; 252
    3b28:	1f 4f       	sbci	r17, 0xFF	; 255
    3b2a:	06 c0       	rjmp	.+12     	; 0x3b38 <vfprintf+0x29c>
    3b2c:	60 81       	ld	r22, Z
    3b2e:	71 81       	ldd	r23, Z+1	; 0x01
    3b30:	80 e0       	ldi	r24, 0x00	; 0
    3b32:	90 e0       	ldi	r25, 0x00	; 0
    3b34:	0e 5f       	subi	r16, 0xFE	; 254
    3b36:	1f 4f       	sbci	r17, 0xFF	; 255
    3b38:	a4 01       	movw	r20, r8
    3b3a:	e6 d0       	rcall	.+460    	; 0x3d08 <__ultoa_invert>
    3b3c:	a8 2e       	mov	r10, r24
    3b3e:	a8 18       	sub	r10, r8
    3b40:	fb 2d       	mov	r31, r11
    3b42:	ff 77       	andi	r31, 0x7F	; 127
    3b44:	bf 2e       	mov	r11, r31
    3b46:	b6 fe       	sbrs	r11, 6
    3b48:	0b c0       	rjmp	.+22     	; 0x3b60 <vfprintf+0x2c4>
    3b4a:	2b 2d       	mov	r18, r11
    3b4c:	2e 7f       	andi	r18, 0xFE	; 254
    3b4e:	a5 14       	cp	r10, r5
    3b50:	50 f4       	brcc	.+20     	; 0x3b66 <vfprintf+0x2ca>
    3b52:	b4 fe       	sbrs	r11, 4
    3b54:	0a c0       	rjmp	.+20     	; 0x3b6a <vfprintf+0x2ce>
    3b56:	b2 fc       	sbrc	r11, 2
    3b58:	08 c0       	rjmp	.+16     	; 0x3b6a <vfprintf+0x2ce>
    3b5a:	2b 2d       	mov	r18, r11
    3b5c:	2e 7e       	andi	r18, 0xEE	; 238
    3b5e:	05 c0       	rjmp	.+10     	; 0x3b6a <vfprintf+0x2ce>
    3b60:	7a 2c       	mov	r7, r10
    3b62:	2b 2d       	mov	r18, r11
    3b64:	03 c0       	rjmp	.+6      	; 0x3b6c <vfprintf+0x2d0>
    3b66:	7a 2c       	mov	r7, r10
    3b68:	01 c0       	rjmp	.+2      	; 0x3b6c <vfprintf+0x2d0>
    3b6a:	75 2c       	mov	r7, r5
    3b6c:	24 ff       	sbrs	r18, 4
    3b6e:	0d c0       	rjmp	.+26     	; 0x3b8a <vfprintf+0x2ee>
    3b70:	fe 01       	movw	r30, r28
    3b72:	ea 0d       	add	r30, r10
    3b74:	f1 1d       	adc	r31, r1
    3b76:	80 81       	ld	r24, Z
    3b78:	80 33       	cpi	r24, 0x30	; 48
    3b7a:	11 f4       	brne	.+4      	; 0x3b80 <vfprintf+0x2e4>
    3b7c:	29 7e       	andi	r18, 0xE9	; 233
    3b7e:	09 c0       	rjmp	.+18     	; 0x3b92 <vfprintf+0x2f6>
    3b80:	22 ff       	sbrs	r18, 2
    3b82:	06 c0       	rjmp	.+12     	; 0x3b90 <vfprintf+0x2f4>
    3b84:	73 94       	inc	r7
    3b86:	73 94       	inc	r7
    3b88:	04 c0       	rjmp	.+8      	; 0x3b92 <vfprintf+0x2f6>
    3b8a:	82 2f       	mov	r24, r18
    3b8c:	86 78       	andi	r24, 0x86	; 134
    3b8e:	09 f0       	breq	.+2      	; 0x3b92 <vfprintf+0x2f6>
    3b90:	73 94       	inc	r7
    3b92:	23 fd       	sbrc	r18, 3
    3b94:	12 c0       	rjmp	.+36     	; 0x3bba <vfprintf+0x31e>
    3b96:	20 ff       	sbrs	r18, 0
    3b98:	06 c0       	rjmp	.+12     	; 0x3ba6 <vfprintf+0x30a>
    3b9a:	5a 2c       	mov	r5, r10
    3b9c:	73 14       	cp	r7, r3
    3b9e:	18 f4       	brcc	.+6      	; 0x3ba6 <vfprintf+0x30a>
    3ba0:	53 0c       	add	r5, r3
    3ba2:	57 18       	sub	r5, r7
    3ba4:	73 2c       	mov	r7, r3
    3ba6:	73 14       	cp	r7, r3
    3ba8:	60 f4       	brcc	.+24     	; 0x3bc2 <vfprintf+0x326>
    3baa:	b7 01       	movw	r22, r14
    3bac:	80 e2       	ldi	r24, 0x20	; 32
    3bae:	90 e0       	ldi	r25, 0x00	; 0
    3bb0:	2c 87       	std	Y+12, r18	; 0x0c
    3bb2:	78 d0       	rcall	.+240    	; 0x3ca4 <fputc>
    3bb4:	73 94       	inc	r7
    3bb6:	2c 85       	ldd	r18, Y+12	; 0x0c
    3bb8:	f6 cf       	rjmp	.-20     	; 0x3ba6 <vfprintf+0x30a>
    3bba:	73 14       	cp	r7, r3
    3bbc:	10 f4       	brcc	.+4      	; 0x3bc2 <vfprintf+0x326>
    3bbe:	37 18       	sub	r3, r7
    3bc0:	01 c0       	rjmp	.+2      	; 0x3bc4 <vfprintf+0x328>
    3bc2:	31 2c       	mov	r3, r1
    3bc4:	24 ff       	sbrs	r18, 4
    3bc6:	11 c0       	rjmp	.+34     	; 0x3bea <vfprintf+0x34e>
    3bc8:	b7 01       	movw	r22, r14
    3bca:	80 e3       	ldi	r24, 0x30	; 48
    3bcc:	90 e0       	ldi	r25, 0x00	; 0
    3bce:	2c 87       	std	Y+12, r18	; 0x0c
    3bd0:	69 d0       	rcall	.+210    	; 0x3ca4 <fputc>
    3bd2:	2c 85       	ldd	r18, Y+12	; 0x0c
    3bd4:	22 ff       	sbrs	r18, 2
    3bd6:	16 c0       	rjmp	.+44     	; 0x3c04 <vfprintf+0x368>
    3bd8:	21 ff       	sbrs	r18, 1
    3bda:	03 c0       	rjmp	.+6      	; 0x3be2 <vfprintf+0x346>
    3bdc:	88 e5       	ldi	r24, 0x58	; 88
    3bde:	90 e0       	ldi	r25, 0x00	; 0
    3be0:	02 c0       	rjmp	.+4      	; 0x3be6 <vfprintf+0x34a>
    3be2:	88 e7       	ldi	r24, 0x78	; 120
    3be4:	90 e0       	ldi	r25, 0x00	; 0
    3be6:	b7 01       	movw	r22, r14
    3be8:	0c c0       	rjmp	.+24     	; 0x3c02 <vfprintf+0x366>
    3bea:	82 2f       	mov	r24, r18
    3bec:	86 78       	andi	r24, 0x86	; 134
    3bee:	51 f0       	breq	.+20     	; 0x3c04 <vfprintf+0x368>
    3bf0:	21 fd       	sbrc	r18, 1
    3bf2:	02 c0       	rjmp	.+4      	; 0x3bf8 <vfprintf+0x35c>
    3bf4:	80 e2       	ldi	r24, 0x20	; 32
    3bf6:	01 c0       	rjmp	.+2      	; 0x3bfa <vfprintf+0x35e>
    3bf8:	8b e2       	ldi	r24, 0x2B	; 43
    3bfa:	27 fd       	sbrc	r18, 7
    3bfc:	8d e2       	ldi	r24, 0x2D	; 45
    3bfe:	b7 01       	movw	r22, r14
    3c00:	90 e0       	ldi	r25, 0x00	; 0
    3c02:	50 d0       	rcall	.+160    	; 0x3ca4 <fputc>
    3c04:	a5 14       	cp	r10, r5
    3c06:	30 f4       	brcc	.+12     	; 0x3c14 <vfprintf+0x378>
    3c08:	b7 01       	movw	r22, r14
    3c0a:	80 e3       	ldi	r24, 0x30	; 48
    3c0c:	90 e0       	ldi	r25, 0x00	; 0
    3c0e:	4a d0       	rcall	.+148    	; 0x3ca4 <fputc>
    3c10:	5a 94       	dec	r5
    3c12:	f8 cf       	rjmp	.-16     	; 0x3c04 <vfprintf+0x368>
    3c14:	aa 94       	dec	r10
    3c16:	f4 01       	movw	r30, r8
    3c18:	ea 0d       	add	r30, r10
    3c1a:	f1 1d       	adc	r31, r1
    3c1c:	80 81       	ld	r24, Z
    3c1e:	b7 01       	movw	r22, r14
    3c20:	90 e0       	ldi	r25, 0x00	; 0
    3c22:	40 d0       	rcall	.+128    	; 0x3ca4 <fputc>
    3c24:	a1 10       	cpse	r10, r1
    3c26:	f6 cf       	rjmp	.-20     	; 0x3c14 <vfprintf+0x378>
    3c28:	33 20       	and	r3, r3
    3c2a:	09 f4       	brne	.+2      	; 0x3c2e <vfprintf+0x392>
    3c2c:	5d ce       	rjmp	.-838    	; 0x38e8 <vfprintf+0x4c>
    3c2e:	b7 01       	movw	r22, r14
    3c30:	80 e2       	ldi	r24, 0x20	; 32
    3c32:	90 e0       	ldi	r25, 0x00	; 0
    3c34:	37 d0       	rcall	.+110    	; 0x3ca4 <fputc>
    3c36:	3a 94       	dec	r3
    3c38:	f7 cf       	rjmp	.-18     	; 0x3c28 <vfprintf+0x38c>
    3c3a:	f7 01       	movw	r30, r14
    3c3c:	86 81       	ldd	r24, Z+6	; 0x06
    3c3e:	97 81       	ldd	r25, Z+7	; 0x07
    3c40:	02 c0       	rjmp	.+4      	; 0x3c46 <vfprintf+0x3aa>
    3c42:	8f ef       	ldi	r24, 0xFF	; 255
    3c44:	9f ef       	ldi	r25, 0xFF	; 255
    3c46:	2c 96       	adiw	r28, 0x0c	; 12
    3c48:	0f b6       	in	r0, 0x3f	; 63
    3c4a:	f8 94       	cli
    3c4c:	de bf       	out	0x3e, r29	; 62
    3c4e:	0f be       	out	0x3f, r0	; 63
    3c50:	cd bf       	out	0x3d, r28	; 61
    3c52:	df 91       	pop	r29
    3c54:	cf 91       	pop	r28
    3c56:	1f 91       	pop	r17
    3c58:	0f 91       	pop	r16
    3c5a:	ff 90       	pop	r15
    3c5c:	ef 90       	pop	r14
    3c5e:	df 90       	pop	r13
    3c60:	cf 90       	pop	r12
    3c62:	bf 90       	pop	r11
    3c64:	af 90       	pop	r10
    3c66:	9f 90       	pop	r9
    3c68:	8f 90       	pop	r8
    3c6a:	7f 90       	pop	r7
    3c6c:	6f 90       	pop	r6
    3c6e:	5f 90       	pop	r5
    3c70:	4f 90       	pop	r4
    3c72:	3f 90       	pop	r3
    3c74:	2f 90       	pop	r2
    3c76:	08 95       	ret

00003c78 <strnlen_P>:
    3c78:	fc 01       	movw	r30, r24
    3c7a:	05 90       	lpm	r0, Z+
    3c7c:	61 50       	subi	r22, 0x01	; 1
    3c7e:	70 40       	sbci	r23, 0x00	; 0
    3c80:	01 10       	cpse	r0, r1
    3c82:	d8 f7       	brcc	.-10     	; 0x3c7a <strnlen_P+0x2>
    3c84:	80 95       	com	r24
    3c86:	90 95       	com	r25
    3c88:	8e 0f       	add	r24, r30
    3c8a:	9f 1f       	adc	r25, r31
    3c8c:	08 95       	ret

00003c8e <strnlen>:
    3c8e:	fc 01       	movw	r30, r24
    3c90:	61 50       	subi	r22, 0x01	; 1
    3c92:	70 40       	sbci	r23, 0x00	; 0
    3c94:	01 90       	ld	r0, Z+
    3c96:	01 10       	cpse	r0, r1
    3c98:	d8 f7       	brcc	.-10     	; 0x3c90 <strnlen+0x2>
    3c9a:	80 95       	com	r24
    3c9c:	90 95       	com	r25
    3c9e:	8e 0f       	add	r24, r30
    3ca0:	9f 1f       	adc	r25, r31
    3ca2:	08 95       	ret

00003ca4 <fputc>:
    3ca4:	0f 93       	push	r16
    3ca6:	1f 93       	push	r17
    3ca8:	cf 93       	push	r28
    3caa:	df 93       	push	r29
    3cac:	18 2f       	mov	r17, r24
    3cae:	09 2f       	mov	r16, r25
    3cb0:	eb 01       	movw	r28, r22
    3cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb4:	81 fd       	sbrc	r24, 1
    3cb6:	03 c0       	rjmp	.+6      	; 0x3cbe <fputc+0x1a>
    3cb8:	8f ef       	ldi	r24, 0xFF	; 255
    3cba:	9f ef       	ldi	r25, 0xFF	; 255
    3cbc:	20 c0       	rjmp	.+64     	; 0x3cfe <fputc+0x5a>
    3cbe:	82 ff       	sbrs	r24, 2
    3cc0:	10 c0       	rjmp	.+32     	; 0x3ce2 <fputc+0x3e>
    3cc2:	4e 81       	ldd	r20, Y+6	; 0x06
    3cc4:	5f 81       	ldd	r21, Y+7	; 0x07
    3cc6:	2c 81       	ldd	r18, Y+4	; 0x04
    3cc8:	3d 81       	ldd	r19, Y+5	; 0x05
    3cca:	42 17       	cp	r20, r18
    3ccc:	53 07       	cpc	r21, r19
    3cce:	7c f4       	brge	.+30     	; 0x3cee <fputc+0x4a>
    3cd0:	e8 81       	ld	r30, Y
    3cd2:	f9 81       	ldd	r31, Y+1	; 0x01
    3cd4:	9f 01       	movw	r18, r30
    3cd6:	2f 5f       	subi	r18, 0xFF	; 255
    3cd8:	3f 4f       	sbci	r19, 0xFF	; 255
    3cda:	39 83       	std	Y+1, r19	; 0x01
    3cdc:	28 83       	st	Y, r18
    3cde:	10 83       	st	Z, r17
    3ce0:	06 c0       	rjmp	.+12     	; 0x3cee <fputc+0x4a>
    3ce2:	e8 85       	ldd	r30, Y+8	; 0x08
    3ce4:	f9 85       	ldd	r31, Y+9	; 0x09
    3ce6:	81 2f       	mov	r24, r17
    3ce8:	19 95       	eicall
    3cea:	89 2b       	or	r24, r25
    3cec:	29 f7       	brne	.-54     	; 0x3cb8 <fputc+0x14>
    3cee:	2e 81       	ldd	r18, Y+6	; 0x06
    3cf0:	3f 81       	ldd	r19, Y+7	; 0x07
    3cf2:	2f 5f       	subi	r18, 0xFF	; 255
    3cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    3cf6:	3f 83       	std	Y+7, r19	; 0x07
    3cf8:	2e 83       	std	Y+6, r18	; 0x06
    3cfa:	81 2f       	mov	r24, r17
    3cfc:	90 2f       	mov	r25, r16
    3cfe:	df 91       	pop	r29
    3d00:	cf 91       	pop	r28
    3d02:	1f 91       	pop	r17
    3d04:	0f 91       	pop	r16
    3d06:	08 95       	ret

00003d08 <__ultoa_invert>:
    3d08:	fa 01       	movw	r30, r20
    3d0a:	aa 27       	eor	r26, r26
    3d0c:	28 30       	cpi	r18, 0x08	; 8
    3d0e:	51 f1       	breq	.+84     	; 0x3d64 <__ultoa_invert+0x5c>
    3d10:	20 31       	cpi	r18, 0x10	; 16
    3d12:	81 f1       	breq	.+96     	; 0x3d74 <__ultoa_invert+0x6c>
    3d14:	e8 94       	clt
    3d16:	6f 93       	push	r22
    3d18:	6e 7f       	andi	r22, 0xFE	; 254
    3d1a:	6e 5f       	subi	r22, 0xFE	; 254
    3d1c:	7f 4f       	sbci	r23, 0xFF	; 255
    3d1e:	8f 4f       	sbci	r24, 0xFF	; 255
    3d20:	9f 4f       	sbci	r25, 0xFF	; 255
    3d22:	af 4f       	sbci	r26, 0xFF	; 255
    3d24:	b1 e0       	ldi	r27, 0x01	; 1
    3d26:	3e d0       	rcall	.+124    	; 0x3da4 <__ultoa_invert+0x9c>
    3d28:	b4 e0       	ldi	r27, 0x04	; 4
    3d2a:	3c d0       	rcall	.+120    	; 0x3da4 <__ultoa_invert+0x9c>
    3d2c:	67 0f       	add	r22, r23
    3d2e:	78 1f       	adc	r23, r24
    3d30:	89 1f       	adc	r24, r25
    3d32:	9a 1f       	adc	r25, r26
    3d34:	a1 1d       	adc	r26, r1
    3d36:	68 0f       	add	r22, r24
    3d38:	79 1f       	adc	r23, r25
    3d3a:	8a 1f       	adc	r24, r26
    3d3c:	91 1d       	adc	r25, r1
    3d3e:	a1 1d       	adc	r26, r1
    3d40:	6a 0f       	add	r22, r26
    3d42:	71 1d       	adc	r23, r1
    3d44:	81 1d       	adc	r24, r1
    3d46:	91 1d       	adc	r25, r1
    3d48:	a1 1d       	adc	r26, r1
    3d4a:	20 d0       	rcall	.+64     	; 0x3d8c <__ultoa_invert+0x84>
    3d4c:	09 f4       	brne	.+2      	; 0x3d50 <__ultoa_invert+0x48>
    3d4e:	68 94       	set
    3d50:	3f 91       	pop	r19
    3d52:	2a e0       	ldi	r18, 0x0A	; 10
    3d54:	26 9f       	mul	r18, r22
    3d56:	11 24       	eor	r1, r1
    3d58:	30 19       	sub	r19, r0
    3d5a:	30 5d       	subi	r19, 0xD0	; 208
    3d5c:	31 93       	st	Z+, r19
    3d5e:	de f6       	brtc	.-74     	; 0x3d16 <__ultoa_invert+0xe>
    3d60:	cf 01       	movw	r24, r30
    3d62:	08 95       	ret
    3d64:	46 2f       	mov	r20, r22
    3d66:	47 70       	andi	r20, 0x07	; 7
    3d68:	40 5d       	subi	r20, 0xD0	; 208
    3d6a:	41 93       	st	Z+, r20
    3d6c:	b3 e0       	ldi	r27, 0x03	; 3
    3d6e:	0f d0       	rcall	.+30     	; 0x3d8e <__ultoa_invert+0x86>
    3d70:	c9 f7       	brne	.-14     	; 0x3d64 <__ultoa_invert+0x5c>
    3d72:	f6 cf       	rjmp	.-20     	; 0x3d60 <__ultoa_invert+0x58>
    3d74:	46 2f       	mov	r20, r22
    3d76:	4f 70       	andi	r20, 0x0F	; 15
    3d78:	40 5d       	subi	r20, 0xD0	; 208
    3d7a:	4a 33       	cpi	r20, 0x3A	; 58
    3d7c:	18 f0       	brcs	.+6      	; 0x3d84 <__ultoa_invert+0x7c>
    3d7e:	49 5d       	subi	r20, 0xD9	; 217
    3d80:	31 fd       	sbrc	r19, 1
    3d82:	40 52       	subi	r20, 0x20	; 32
    3d84:	41 93       	st	Z+, r20
    3d86:	02 d0       	rcall	.+4      	; 0x3d8c <__ultoa_invert+0x84>
    3d88:	a9 f7       	brne	.-22     	; 0x3d74 <__ultoa_invert+0x6c>
    3d8a:	ea cf       	rjmp	.-44     	; 0x3d60 <__ultoa_invert+0x58>
    3d8c:	b4 e0       	ldi	r27, 0x04	; 4
    3d8e:	a6 95       	lsr	r26
    3d90:	97 95       	ror	r25
    3d92:	87 95       	ror	r24
    3d94:	77 95       	ror	r23
    3d96:	67 95       	ror	r22
    3d98:	ba 95       	dec	r27
    3d9a:	c9 f7       	brne	.-14     	; 0x3d8e <__ultoa_invert+0x86>
    3d9c:	00 97       	sbiw	r24, 0x00	; 0
    3d9e:	61 05       	cpc	r22, r1
    3da0:	71 05       	cpc	r23, r1
    3da2:	08 95       	ret
    3da4:	9b 01       	movw	r18, r22
    3da6:	ac 01       	movw	r20, r24
    3da8:	0a 2e       	mov	r0, r26
    3daa:	06 94       	lsr	r0
    3dac:	57 95       	ror	r21
    3dae:	47 95       	ror	r20
    3db0:	37 95       	ror	r19
    3db2:	27 95       	ror	r18
    3db4:	ba 95       	dec	r27
    3db6:	c9 f7       	brne	.-14     	; 0x3daa <__ultoa_invert+0xa2>
    3db8:	62 0f       	add	r22, r18
    3dba:	73 1f       	adc	r23, r19
    3dbc:	84 1f       	adc	r24, r20
    3dbe:	95 1f       	adc	r25, r21
    3dc0:	a0 1d       	adc	r26, r0
    3dc2:	08 95       	ret

00003dc4 <_exit>:
    3dc4:	f8 94       	cli

00003dc6 <__stop_program>:
    3dc6:	ff cf       	rjmp	.-2      	; 0x3dc6 <__stop_program>
