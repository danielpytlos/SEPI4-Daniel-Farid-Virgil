
Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e2  00800200  00003ac4  00003b58  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003ac4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000162a  008002e2  008002e2  00003c3a  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003c3a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000005b0  00000000  00000000  00003c96  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000079e1  00000000  00000000  00004246  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001a39  00000000  00000000  0000bc27  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000040f7  00000000  00000000  0000d660  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000133c  00000000  00000000  00011758  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000208e  00000000  00000000  00012a94  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000649e  00000000  00000000  00014b22  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000608  00000000  00000000  0001afc0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	ce c0       	rjmp	.+412    	; 0x19e <__ctors_end>
       2:	00 00       	nop
       4:	e0 c3       	rjmp	.+1984   	; 0x7c6 <__vector_1>
       6:	00 00       	nop
       8:	eb c0       	rjmp	.+470    	; 0x1e0 <__bad_interrupt>
       a:	00 00       	nop
       c:	e9 c0       	rjmp	.+466    	; 0x1e0 <__bad_interrupt>
       e:	00 00       	nop
      10:	e7 c0       	rjmp	.+462    	; 0x1e0 <__bad_interrupt>
      12:	00 00       	nop
      14:	e5 c0       	rjmp	.+458    	; 0x1e0 <__bad_interrupt>
      16:	00 00       	nop
      18:	e3 c0       	rjmp	.+454    	; 0x1e0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	e1 c0       	rjmp	.+450    	; 0x1e0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	df c0       	rjmp	.+446    	; 0x1e0 <__bad_interrupt>
      22:	00 00       	nop
      24:	dd c0       	rjmp	.+442    	; 0x1e0 <__bad_interrupt>
      26:	00 00       	nop
      28:	db c0       	rjmp	.+438    	; 0x1e0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	d9 c0       	rjmp	.+434    	; 0x1e0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	d7 c0       	rjmp	.+430    	; 0x1e0 <__bad_interrupt>
      32:	00 00       	nop
      34:	fd c3       	rjmp	.+2042   	; 0x830 <__vector_13>
      36:	00 00       	nop
      38:	d3 c0       	rjmp	.+422    	; 0x1e0 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	d1 c0       	rjmp	.+418    	; 0x1e0 <__bad_interrupt>
      3e:	00 00       	nop
      40:	cf c0       	rjmp	.+414    	; 0x1e0 <__bad_interrupt>
      42:	00 00       	nop
      44:	cd c0       	rjmp	.+410    	; 0x1e0 <__bad_interrupt>
      46:	00 00       	nop
      48:	cb c0       	rjmp	.+406    	; 0x1e0 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	c9 c0       	rjmp	.+402    	; 0x1e0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	c7 c0       	rjmp	.+398    	; 0x1e0 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 aa 08 	jmp	0x1154	; 0x1154 <__vector_21>
      58:	c3 c0       	rjmp	.+390    	; 0x1e0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	c1 c0       	rjmp	.+386    	; 0x1e0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	0c 94 50 18 	jmp	0x30a0	; 0x30a0 <__vector_24>
      64:	0c 94 ec 15 	jmp	0x2bd8	; 0x2bd8 <__vector_25>
      68:	0c 94 2e 16 	jmp	0x2c5c	; 0x2c5c <__vector_26>
      6c:	b9 c0       	rjmp	.+370    	; 0x1e0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	b7 c0       	rjmp	.+366    	; 0x1e0 <__bad_interrupt>
      72:	00 00       	nop
      74:	b5 c0       	rjmp	.+362    	; 0x1e0 <__bad_interrupt>
      76:	00 00       	nop
      78:	b3 c0       	rjmp	.+358    	; 0x1e0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	b1 c0       	rjmp	.+354    	; 0x1e0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	af c0       	rjmp	.+350    	; 0x1e0 <__bad_interrupt>
      82:	00 00       	nop
      84:	ad c0       	rjmp	.+346    	; 0x1e0 <__bad_interrupt>
      86:	00 00       	nop
      88:	ab c0       	rjmp	.+342    	; 0x1e0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	a9 c0       	rjmp	.+338    	; 0x1e0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 7a 16 	jmp	0x2cf4	; 0x2cf4 <__vector_36>
      94:	0c 94 bc 16 	jmp	0x2d78	; 0x2d78 <__vector_37>
      98:	a3 c0       	rjmp	.+326    	; 0x1e0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	a1 c0       	rjmp	.+322    	; 0x1e0 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	9f c0       	rjmp	.+318    	; 0x1e0 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	9d c0       	rjmp	.+314    	; 0x1e0 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	9b c0       	rjmp	.+310    	; 0x1e0 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	99 c0       	rjmp	.+306    	; 0x1e0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	97 c0       	rjmp	.+302    	; 0x1e0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	95 c0       	rjmp	.+298    	; 0x1e0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	93 c0       	rjmp	.+294    	; 0x1e0 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	91 c0       	rjmp	.+290    	; 0x1e0 <__bad_interrupt>
      be:	00 00       	nop
      c0:	8f c0       	rjmp	.+286    	; 0x1e0 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	8d c0       	rjmp	.+282    	; 0x1e0 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	8b c0       	rjmp	.+278    	; 0x1e0 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	4e 12       	cpse	r4, r30
      ce:	4e 12       	cpse	r4, r30
      d0:	4e 12       	cpse	r4, r30
      d2:	86 12       	cpse	r8, r22
      d4:	75 12       	cpse	r7, r21
      d6:	83 12       	cpse	r8, r19
      d8:	4e 12       	cpse	r4, r30
      da:	4e 12       	cpse	r4, r30
      dc:	86 12       	cpse	r8, r22
      de:	75 12       	cpse	r7, r21
      e0:	dc 13       	cpse	r29, r28
      e2:	e4 13       	cpse	r30, r20
      e4:	ec 13       	cpse	r30, r28
      e6:	f4 13       	cpse	r31, r20
      e8:	fc 13       	cpse	r31, r28
      ea:	00 14       	cp	r0, r0
      ec:	5a 14       	cp	r5, r10
      ee:	5a 14       	cp	r5, r10
      f0:	5a 14       	cp	r5, r10
      f2:	5a 14       	cp	r5, r10
      f4:	5a 14       	cp	r5, r10
      f6:	42 14       	cp	r4, r2
      f8:	5a 14       	cp	r5, r10
      fa:	5a 14       	cp	r5, r10
      fc:	5a 14       	cp	r5, r10
      fe:	5a 14       	cp	r5, r10
     100:	5a 14       	cp	r5, r10
     102:	4e 14       	cp	r4, r14
     104:	5a 14       	cp	r5, r10
     106:	5a 14       	cp	r5, r10
     108:	5a 14       	cp	r5, r10
     10a:	5a 14       	cp	r5, r10
     10c:	5a 14       	cp	r5, r10
     10e:	5a 14       	cp	r5, r10
     110:	5a 14       	cp	r5, r10
     112:	5a 14       	cp	r5, r10
     114:	5a 14       	cp	r5, r10
     116:	5a 14       	cp	r5, r10
     118:	5a 14       	cp	r5, r10
     11a:	5a 14       	cp	r5, r10
     11c:	5a 14       	cp	r5, r10
     11e:	5a 14       	cp	r5, r10
     120:	d8 13       	cpse	r29, r24
     122:	e0 13       	cpse	r30, r16
     124:	e8 13       	cpse	r30, r24
     126:	f0 13       	cpse	r31, r16
     128:	f8 13       	cpse	r31, r24

0000012a <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     12a:	0f 2e       	mov	r0, r31
     12c:	fd eb       	ldi	r31, 0xBD	; 189
     12e:	ef 2e       	mov	r14, r31
     130:	fd e0       	ldi	r31, 0x0D	; 13
     132:	ff 2e       	mov	r15, r31
     134:	f0 2d       	mov	r31, r0
     136:	c5 e9       	ldi	r28, 0x95	; 149
     138:	dd e0       	ldi	r29, 0x0D	; 13
     13a:	27 c0       	rjmp	.+78     	; 0x18a <prvIdleTask+0x60>
     13c:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <vTaskSuspendAll>
     140:	18 81       	ld	r17, Y
     142:	0e 94 08 0e 	call	0x1c10	; 0x1c10 <xTaskResumeAll>
     146:	11 23       	and	r17, r17
     148:	01 f1       	breq	.+64     	; 0x18a <prvIdleTask+0x60>
     14a:	0f b6       	in	r0, 0x3f	; 63
     14c:	f8 94       	cli
     14e:	0f 92       	push	r0
     150:	e0 91 9a 0d 	lds	r30, 0x0D9A
     154:	f0 91 9b 0d 	lds	r31, 0x0D9B
     158:	06 81       	ldd	r16, Z+6	; 0x06
     15a:	17 81       	ldd	r17, Z+7	; 0x07
     15c:	c8 01       	movw	r24, r16
     15e:	02 96       	adiw	r24, 0x02	; 2
     160:	46 d6       	rcall	.+3212   	; 0xdee <uxListRemove>
     162:	80 91 93 0d 	lds	r24, 0x0D93
     166:	81 50       	subi	r24, 0x01	; 1
     168:	80 93 93 0d 	sts	0x0D93, r24
     16c:	80 91 94 0d 	lds	r24, 0x0D94
     170:	81 50       	subi	r24, 0x01	; 1
     172:	80 93 94 0d 	sts	0x0D94, r24
     176:	0f 90       	pop	r0
     178:	0f be       	out	0x3f, r0	; 63
     17a:	f8 01       	movw	r30, r16
     17c:	87 89       	ldd	r24, Z+23	; 0x17
     17e:	90 8d       	ldd	r25, Z+24	; 0x18
     180:	0e 94 df 08 	call	0x11be	; 0x11be <vPortFree>
     184:	c8 01       	movw	r24, r16
     186:	0e 94 df 08 	call	0x11be	; 0x11be <vPortFree>
     18a:	80 91 94 0d 	lds	r24, 0x0D94
     18e:	81 11       	cpse	r24, r1
     190:	d5 cf       	rjmp	.-86     	; 0x13c <prvIdleTask+0x12>
     192:	f7 01       	movw	r30, r14
     194:	80 81       	ld	r24, Z
     196:	82 30       	cpi	r24, 0x02	; 2
     198:	c0 f3       	brcs	.-16     	; 0x18a <prvIdleTask+0x60>
     19a:	07 d7       	rcall	.+3598   	; 0xfaa <vPortYield>
     19c:	f6 cf       	rjmp	.-20     	; 0x18a <prvIdleTask+0x60>

0000019e <__ctors_end>:
     19e:	11 24       	eor	r1, r1
     1a0:	1f be       	out	0x3f, r1	; 63
     1a2:	cf ef       	ldi	r28, 0xFF	; 255
     1a4:	d1 e2       	ldi	r29, 0x21	; 33
     1a6:	de bf       	out	0x3e, r29	; 62
     1a8:	cd bf       	out	0x3d, r28	; 61
     1aa:	00 e0       	ldi	r16, 0x00	; 0
     1ac:	0c bf       	out	0x3c, r16	; 60

000001ae <__do_copy_data>:
     1ae:	12 e0       	ldi	r17, 0x02	; 2
     1b0:	a0 e0       	ldi	r26, 0x00	; 0
     1b2:	b2 e0       	ldi	r27, 0x02	; 2
     1b4:	e4 ec       	ldi	r30, 0xC4	; 196
     1b6:	fa e3       	ldi	r31, 0x3A	; 58
     1b8:	00 e0       	ldi	r16, 0x00	; 0
     1ba:	0b bf       	out	0x3b, r16	; 59
     1bc:	02 c0       	rjmp	.+4      	; 0x1c2 <__do_copy_data+0x14>
     1be:	07 90       	elpm	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	a2 3e       	cpi	r26, 0xE2	; 226
     1c4:	b1 07       	cpc	r27, r17
     1c6:	d9 f7       	brne	.-10     	; 0x1be <__do_copy_data+0x10>

000001c8 <__do_clear_bss>:
     1c8:	29 e1       	ldi	r18, 0x19	; 25
     1ca:	a2 ee       	ldi	r26, 0xE2	; 226
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	01 c0       	rjmp	.+2      	; 0x1d2 <.do_clear_bss_start>

000001d0 <.do_clear_bss_loop>:
     1d0:	1d 92       	st	X+, r1

000001d2 <.do_clear_bss_start>:
     1d2:	ac 30       	cpi	r26, 0x0C	; 12
     1d4:	b2 07       	cpc	r27, r18
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <.do_clear_bss_loop>
     1d8:	0e 94 0f 15 	call	0x2a1e	; 0x2a1e <main>
     1dc:	0c 94 60 1d 	jmp	0x3ac0	; 0x3ac0 <_exit>

000001e0 <__bad_interrupt>:
     1e0:	0f cf       	rjmp	.-482    	; 0x0 <__vectors>

000001e2 <_bt_status_call_back>:
	uint8_t _sreg = SREG;
	cli();
	int16_t _tmp = _z_gyro;
	SREG = _sreg;
	return _tmp;
}
     1e2:	10 92 42 03 	sts	0x0342, r1
     1e6:	e0 91 40 03 	lds	r30, 0x0340
     1ea:	f0 91 41 03 	lds	r31, 0x0341
     1ee:	30 97       	sbiw	r30, 0x00	; 0
     1f0:	09 f0       	breq	.+2      	; 0x1f4 <_bt_status_call_back+0x12>
     1f2:	19 95       	eicall
     1f4:	08 95       	ret

000001f6 <_bt_call_back>:
     1f6:	cf 93       	push	r28
     1f8:	df 93       	push	r29
     1fa:	1f 92       	push	r1
     1fc:	1f 92       	push	r1
     1fe:	cd b7       	in	r28, 0x3d	; 61
     200:	de b7       	in	r29, 0x3e	; 62
     202:	6a 83       	std	Y+2, r22	; 0x02
     204:	80 91 42 03 	lds	r24, 0x0342
     208:	88 23       	and	r24, r24
     20a:	19 f0       	breq	.+6      	; 0x212 <_bt_call_back+0x1c>
     20c:	86 2f       	mov	r24, r22
     20e:	98 d4       	rcall	.+2352   	; 0xb40 <dialog_byte_received>
     210:	13 c0       	rjmp	.+38     	; 0x238 <_bt_call_back+0x42>
     212:	80 91 3e 03 	lds	r24, 0x033E
     216:	90 91 3f 03 	lds	r25, 0x033F
     21a:	00 97       	sbiw	r24, 0x00	; 0
     21c:	69 f0       	breq	.+26     	; 0x238 <_bt_call_back+0x42>
     21e:	19 82       	std	Y+1, r1	; 0x01
     220:	20 e0       	ldi	r18, 0x00	; 0
     222:	ae 01       	movw	r20, r28
     224:	4f 5f       	subi	r20, 0xFF	; 255
     226:	5f 4f       	sbci	r21, 0xFF	; 255
     228:	be 01       	movw	r22, r28
     22a:	6e 5f       	subi	r22, 0xFE	; 254
     22c:	7f 4f       	sbci	r23, 0xFF	; 255
     22e:	0e 94 98 0a 	call	0x1530	; 0x1530 <xQueueGenericSendFromISR>
     232:	89 81       	ldd	r24, Y+1	; 0x01
     234:	81 11       	cpse	r24, r1
     236:	b9 d6       	rcall	.+3442   	; 0xfaa <vPortYield>
     238:	0f 90       	pop	r0
     23a:	0f 90       	pop	r0
     23c:	df 91       	pop	r29
     23e:	cf 91       	pop	r28
     240:	08 95       	ret

00000242 <_mpu9250_read_reg>:
     242:	df 92       	push	r13
     244:	ef 92       	push	r14
     246:	ff 92       	push	r15
     248:	0f 93       	push	r16
     24a:	1f 93       	push	r17
     24c:	cf 93       	push	r28
     24e:	df 93       	push	r29
     250:	cd b7       	in	r28, 0x3d	; 61
     252:	de b7       	in	r29, 0x3e	; 62
     254:	d6 2e       	mov	r13, r22
     256:	ed b6       	in	r14, 0x3d	; 61
     258:	fe b6       	in	r15, 0x3e	; 62
     25a:	26 2f       	mov	r18, r22
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	2f 5f       	subi	r18, 0xFF	; 255
     260:	3f 4f       	sbci	r19, 0xFF	; 255
     262:	4d b7       	in	r20, 0x3d	; 61
     264:	5e b7       	in	r21, 0x3e	; 62
     266:	42 1b       	sub	r20, r18
     268:	53 0b       	sbc	r21, r19
     26a:	0f b6       	in	r0, 0x3f	; 63
     26c:	f8 94       	cli
     26e:	5e bf       	out	0x3e, r21	; 62
     270:	0f be       	out	0x3f, r0	; 63
     272:	4d bf       	out	0x3d, r20	; 61
     274:	0d b7       	in	r16, 0x3d	; 61
     276:	1e b7       	in	r17, 0x3e	; 62
     278:	0f 5f       	subi	r16, 0xFF	; 255
     27a:	1f 4f       	sbci	r17, 0xFF	; 255
     27c:	98 01       	movw	r18, r16
     27e:	80 68       	ori	r24, 0x80	; 128
     280:	ed b7       	in	r30, 0x3d	; 61
     282:	fe b7       	in	r31, 0x3e	; 62
     284:	81 83       	std	Z+1, r24	; 0x01
     286:	66 23       	and	r22, r22
     288:	41 f0       	breq	.+16     	; 0x29a <_mpu9250_read_reg+0x58>
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	f9 01       	movw	r30, r18
     28e:	e8 0f       	add	r30, r24
     290:	f1 1d       	adc	r31, r1
     292:	10 82       	st	Z, r1
     294:	8f 5f       	subi	r24, 0xFF	; 255
     296:	d8 16       	cp	r13, r24
     298:	c8 f7       	brcc	.-14     	; 0x28c <_mpu9250_read_reg+0x4a>
     29a:	8a e7       	ldi	r24, 0x7A	; 122
     29c:	93 e0       	ldi	r25, 0x03	; 3
     29e:	35 d3       	rcall	.+1642   	; 0x90a <buffer_clear>
     2a0:	41 e0       	ldi	r20, 0x01	; 1
     2a2:	4d 0d       	add	r20, r13
     2a4:	b8 01       	movw	r22, r16
     2a6:	80 91 a7 03 	lds	r24, 0x03A7
     2aa:	90 91 a8 03 	lds	r25, 0x03A8
     2ae:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <spi_send_string>
     2b2:	0f b6       	in	r0, 0x3f	; 63
     2b4:	f8 94       	cli
     2b6:	fe be       	out	0x3e, r15	; 62
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	ed be       	out	0x3d, r14	; 61
     2bc:	df 91       	pop	r29
     2be:	cf 91       	pop	r28
     2c0:	1f 91       	pop	r17
     2c2:	0f 91       	pop	r16
     2c4:	ff 90       	pop	r15
     2c6:	ef 90       	pop	r14
     2c8:	df 90       	pop	r13
     2ca:	08 95       	ret

000002cc <_send_bytes_to_bt>:
     2cc:	46 2f       	mov	r20, r22
     2ce:	bc 01       	movw	r22, r24
     2d0:	80 91 a5 03 	lds	r24, 0x03A5
     2d4:	90 91 a6 03 	lds	r25, 0x03A6
     2d8:	0c 94 ad 15 	jmp	0x2b5a	; 0x2b5a <serial_send_bytes>
     2dc:	08 95       	ret

000002de <_mpu9250_call_back>:
     2de:	1f 93       	push	r17
     2e0:	cf 93       	push	r28
     2e2:	df 93       	push	r29
     2e4:	00 d0       	rcall	.+0      	; 0x2e6 <_mpu9250_call_back+0x8>
     2e6:	1f 92       	push	r1
     2e8:	cd b7       	in	r28, 0x3d	; 61
     2ea:	de b7       	in	r29, 0x3e	; 62
     2ec:	80 91 e5 02 	lds	r24, 0x02E5
     2f0:	82 30       	cpi	r24, 0x02	; 2
     2f2:	c1 f1       	breq	.+112    	; 0x364 <_mpu9250_call_back+0x86>
     2f4:	28 f4       	brcc	.+10     	; 0x300 <_mpu9250_call_back+0x22>
     2f6:	88 23       	and	r24, r24
     2f8:	51 f0       	breq	.+20     	; 0x30e <_mpu9250_call_back+0x30>
     2fa:	81 30       	cpi	r24, 0x01	; 1
     2fc:	c9 f0       	breq	.+50     	; 0x330 <_mpu9250_call_back+0x52>
     2fe:	f1 c0       	rjmp	.+482    	; 0x4e2 <_mpu9250_call_back+0x204>
     300:	83 30       	cpi	r24, 0x03	; 3
     302:	09 f4       	brne	.+2      	; 0x306 <_mpu9250_call_back+0x28>
     304:	3f c0       	rjmp	.+126    	; 0x384 <_mpu9250_call_back+0xa6>
     306:	85 30       	cpi	r24, 0x05	; 5
     308:	09 f4       	brne	.+2      	; 0x30c <_mpu9250_call_back+0x2e>
     30a:	94 c0       	rjmp	.+296    	; 0x434 <_mpu9250_call_back+0x156>
     30c:	ea c0       	rjmp	.+468    	; 0x4e2 <_mpu9250_call_back+0x204>
     30e:	81 e0       	ldi	r24, 0x01	; 1
     310:	80 93 e5 02 	sts	0x02E5, r24
     314:	8c e1       	ldi	r24, 0x1C	; 28
     316:	8b 83       	std	Y+3, r24	; 0x03
     318:	1c 82       	std	Y+4, r1	; 0x04
     31a:	42 e0       	ldi	r20, 0x02	; 2
     31c:	be 01       	movw	r22, r28
     31e:	6d 5f       	subi	r22, 0xFD	; 253
     320:	7f 4f       	sbci	r23, 0xFF	; 255
     322:	80 91 a7 03 	lds	r24, 0x03A7
     326:	90 91 a8 03 	lds	r25, 0x03A8
     32a:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <spi_send_string>
     32e:	d9 c0       	rjmp	.+434    	; 0x4e2 <_mpu9250_call_back+0x204>
     330:	8a e7       	ldi	r24, 0x7A	; 122
     332:	93 e0       	ldi	r25, 0x03	; 3
     334:	e7 d2       	rcall	.+1486   	; 0x904 <buffer_no_of_items>
     336:	82 30       	cpi	r24, 0x02	; 2
     338:	09 f0       	breq	.+2      	; 0x33c <_mpu9250_call_back+0x5e>
     33a:	d3 c0       	rjmp	.+422    	; 0x4e2 <_mpu9250_call_back+0x204>
     33c:	80 93 e5 02 	sts	0x02E5, r24
     340:	8a e7       	ldi	r24, 0x7A	; 122
     342:	93 e0       	ldi	r25, 0x03	; 3
     344:	e2 d2       	rcall	.+1476   	; 0x90a <buffer_clear>
     346:	8b e1       	ldi	r24, 0x1B	; 27
     348:	8b 83       	std	Y+3, r24	; 0x03
     34a:	88 e0       	ldi	r24, 0x08	; 8
     34c:	8c 83       	std	Y+4, r24	; 0x04
     34e:	42 e0       	ldi	r20, 0x02	; 2
     350:	be 01       	movw	r22, r28
     352:	6d 5f       	subi	r22, 0xFD	; 253
     354:	7f 4f       	sbci	r23, 0xFF	; 255
     356:	80 91 a7 03 	lds	r24, 0x03A7
     35a:	90 91 a8 03 	lds	r25, 0x03A8
     35e:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <spi_send_string>
     362:	bf c0       	rjmp	.+382    	; 0x4e2 <_mpu9250_call_back+0x204>
     364:	8a e7       	ldi	r24, 0x7A	; 122
     366:	93 e0       	ldi	r25, 0x03	; 3
     368:	cd d2       	rcall	.+1434   	; 0x904 <buffer_no_of_items>
     36a:	82 30       	cpi	r24, 0x02	; 2
     36c:	09 f0       	breq	.+2      	; 0x370 <_mpu9250_call_back+0x92>
     36e:	b9 c0       	rjmp	.+370    	; 0x4e2 <_mpu9250_call_back+0x204>
     370:	83 e0       	ldi	r24, 0x03	; 3
     372:	80 93 e5 02 	sts	0x02E5, r24
     376:	8a e7       	ldi	r24, 0x7A	; 122
     378:	93 e0       	ldi	r25, 0x03	; 3
     37a:	c7 d2       	rcall	.+1422   	; 0x90a <buffer_clear>
     37c:	66 e0       	ldi	r22, 0x06	; 6
     37e:	8b e3       	ldi	r24, 0x3B	; 59
     380:	60 df       	rcall	.-320    	; 0x242 <_mpu9250_read_reg>
     382:	af c0       	rjmp	.+350    	; 0x4e2 <_mpu9250_call_back+0x204>
     384:	8a e7       	ldi	r24, 0x7A	; 122
     386:	93 e0       	ldi	r25, 0x03	; 3
     388:	bd d2       	rcall	.+1402   	; 0x904 <buffer_no_of_items>
     38a:	87 30       	cpi	r24, 0x07	; 7
     38c:	09 f0       	breq	.+2      	; 0x390 <_mpu9250_call_back+0xb2>
     38e:	a9 c0       	rjmp	.+338    	; 0x4e2 <_mpu9250_call_back+0x204>
     390:	1f b7       	in	r17, 0x3f	; 63
     392:	f8 94       	cli
     394:	be 01       	movw	r22, r28
     396:	6f 5f       	subi	r22, 0xFF	; 255
     398:	7f 4f       	sbci	r23, 0xFF	; 255
     39a:	8a e7       	ldi	r24, 0x7A	; 122
     39c:	93 e0       	ldi	r25, 0x03	; 3
     39e:	82 d2       	rcall	.+1284   	; 0x8a4 <buffer_get_item>
     3a0:	be 01       	movw	r22, r28
     3a2:	6e 5f       	subi	r22, 0xFE	; 254
     3a4:	7f 4f       	sbci	r23, 0xFF	; 255
     3a6:	8a e7       	ldi	r24, 0x7A	; 122
     3a8:	93 e0       	ldi	r25, 0x03	; 3
     3aa:	7c d2       	rcall	.+1272   	; 0x8a4 <buffer_get_item>
     3ac:	be 01       	movw	r22, r28
     3ae:	6f 5f       	subi	r22, 0xFF	; 255
     3b0:	7f 4f       	sbci	r23, 0xFF	; 255
     3b2:	8a e7       	ldi	r24, 0x7A	; 122
     3b4:	93 e0       	ldi	r25, 0x03	; 3
     3b6:	76 d2       	rcall	.+1260   	; 0x8a4 <buffer_get_item>
     3b8:	8a 81       	ldd	r24, Y+2	; 0x02
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	98 2f       	mov	r25, r24
     3be:	88 27       	eor	r24, r24
     3c0:	29 81       	ldd	r18, Y+1	; 0x01
     3c2:	82 2b       	or	r24, r18
     3c4:	90 93 4e 03 	sts	0x034E, r25
     3c8:	80 93 4d 03 	sts	0x034D, r24
     3cc:	be 01       	movw	r22, r28
     3ce:	6e 5f       	subi	r22, 0xFE	; 254
     3d0:	7f 4f       	sbci	r23, 0xFF	; 255
     3d2:	8a e7       	ldi	r24, 0x7A	; 122
     3d4:	93 e0       	ldi	r25, 0x03	; 3
     3d6:	66 d2       	rcall	.+1228   	; 0x8a4 <buffer_get_item>
     3d8:	be 01       	movw	r22, r28
     3da:	6f 5f       	subi	r22, 0xFF	; 255
     3dc:	7f 4f       	sbci	r23, 0xFF	; 255
     3de:	8a e7       	ldi	r24, 0x7A	; 122
     3e0:	93 e0       	ldi	r25, 0x03	; 3
     3e2:	60 d2       	rcall	.+1216   	; 0x8a4 <buffer_get_item>
     3e4:	8a 81       	ldd	r24, Y+2	; 0x02
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	98 2f       	mov	r25, r24
     3ea:	88 27       	eor	r24, r24
     3ec:	29 81       	ldd	r18, Y+1	; 0x01
     3ee:	82 2b       	or	r24, r18
     3f0:	90 93 4c 03 	sts	0x034C, r25
     3f4:	80 93 4b 03 	sts	0x034B, r24
     3f8:	be 01       	movw	r22, r28
     3fa:	6e 5f       	subi	r22, 0xFE	; 254
     3fc:	7f 4f       	sbci	r23, 0xFF	; 255
     3fe:	8a e7       	ldi	r24, 0x7A	; 122
     400:	93 e0       	ldi	r25, 0x03	; 3
     402:	50 d2       	rcall	.+1184   	; 0x8a4 <buffer_get_item>
     404:	be 01       	movw	r22, r28
     406:	6f 5f       	subi	r22, 0xFF	; 255
     408:	7f 4f       	sbci	r23, 0xFF	; 255
     40a:	8a e7       	ldi	r24, 0x7A	; 122
     40c:	93 e0       	ldi	r25, 0x03	; 3
     40e:	4a d2       	rcall	.+1172   	; 0x8a4 <buffer_get_item>
     410:	1f bf       	out	0x3f, r17	; 63
     412:	8a 81       	ldd	r24, Y+2	; 0x02
     414:	90 e0       	ldi	r25, 0x00	; 0
     416:	98 2f       	mov	r25, r24
     418:	88 27       	eor	r24, r24
     41a:	29 81       	ldd	r18, Y+1	; 0x01
     41c:	82 2b       	or	r24, r18
     41e:	90 93 4a 03 	sts	0x034A, r25
     422:	80 93 49 03 	sts	0x0349, r24
     426:	85 e0       	ldi	r24, 0x05	; 5
     428:	80 93 e5 02 	sts	0x02E5, r24
     42c:	66 e0       	ldi	r22, 0x06	; 6
     42e:	83 e4       	ldi	r24, 0x43	; 67
     430:	08 df       	rcall	.-496    	; 0x242 <_mpu9250_read_reg>
     432:	57 c0       	rjmp	.+174    	; 0x4e2 <_mpu9250_call_back+0x204>
     434:	8a e7       	ldi	r24, 0x7A	; 122
     436:	93 e0       	ldi	r25, 0x03	; 3
     438:	65 d2       	rcall	.+1226   	; 0x904 <buffer_no_of_items>
     43a:	87 30       	cpi	r24, 0x07	; 7
     43c:	09 f0       	breq	.+2      	; 0x440 <_mpu9250_call_back+0x162>
     43e:	51 c0       	rjmp	.+162    	; 0x4e2 <_mpu9250_call_back+0x204>
     440:	1f b7       	in	r17, 0x3f	; 63
     442:	f8 94       	cli
     444:	be 01       	movw	r22, r28
     446:	6f 5f       	subi	r22, 0xFF	; 255
     448:	7f 4f       	sbci	r23, 0xFF	; 255
     44a:	8a e7       	ldi	r24, 0x7A	; 122
     44c:	93 e0       	ldi	r25, 0x03	; 3
     44e:	2a d2       	rcall	.+1108   	; 0x8a4 <buffer_get_item>
     450:	be 01       	movw	r22, r28
     452:	6e 5f       	subi	r22, 0xFE	; 254
     454:	7f 4f       	sbci	r23, 0xFF	; 255
     456:	8a e7       	ldi	r24, 0x7A	; 122
     458:	93 e0       	ldi	r25, 0x03	; 3
     45a:	24 d2       	rcall	.+1096   	; 0x8a4 <buffer_get_item>
     45c:	be 01       	movw	r22, r28
     45e:	6f 5f       	subi	r22, 0xFF	; 255
     460:	7f 4f       	sbci	r23, 0xFF	; 255
     462:	8a e7       	ldi	r24, 0x7A	; 122
     464:	93 e0       	ldi	r25, 0x03	; 3
     466:	1e d2       	rcall	.+1084   	; 0x8a4 <buffer_get_item>
     468:	8a 81       	ldd	r24, Y+2	; 0x02
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	98 2f       	mov	r25, r24
     46e:	88 27       	eor	r24, r24
     470:	29 81       	ldd	r18, Y+1	; 0x01
     472:	82 2b       	or	r24, r18
     474:	90 93 48 03 	sts	0x0348, r25
     478:	80 93 47 03 	sts	0x0347, r24
     47c:	be 01       	movw	r22, r28
     47e:	6e 5f       	subi	r22, 0xFE	; 254
     480:	7f 4f       	sbci	r23, 0xFF	; 255
     482:	8a e7       	ldi	r24, 0x7A	; 122
     484:	93 e0       	ldi	r25, 0x03	; 3
     486:	0e d2       	rcall	.+1052   	; 0x8a4 <buffer_get_item>
     488:	be 01       	movw	r22, r28
     48a:	6f 5f       	subi	r22, 0xFF	; 255
     48c:	7f 4f       	sbci	r23, 0xFF	; 255
     48e:	8a e7       	ldi	r24, 0x7A	; 122
     490:	93 e0       	ldi	r25, 0x03	; 3
     492:	08 d2       	rcall	.+1040   	; 0x8a4 <buffer_get_item>
     494:	8a 81       	ldd	r24, Y+2	; 0x02
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	98 2f       	mov	r25, r24
     49a:	88 27       	eor	r24, r24
     49c:	29 81       	ldd	r18, Y+1	; 0x01
     49e:	82 2b       	or	r24, r18
     4a0:	90 93 46 03 	sts	0x0346, r25
     4a4:	80 93 45 03 	sts	0x0345, r24
     4a8:	be 01       	movw	r22, r28
     4aa:	6e 5f       	subi	r22, 0xFE	; 254
     4ac:	7f 4f       	sbci	r23, 0xFF	; 255
     4ae:	8a e7       	ldi	r24, 0x7A	; 122
     4b0:	93 e0       	ldi	r25, 0x03	; 3
     4b2:	f8 d1       	rcall	.+1008   	; 0x8a4 <buffer_get_item>
     4b4:	be 01       	movw	r22, r28
     4b6:	6f 5f       	subi	r22, 0xFF	; 255
     4b8:	7f 4f       	sbci	r23, 0xFF	; 255
     4ba:	8a e7       	ldi	r24, 0x7A	; 122
     4bc:	93 e0       	ldi	r25, 0x03	; 3
     4be:	f2 d1       	rcall	.+996    	; 0x8a4 <buffer_get_item>
     4c0:	1f bf       	out	0x3f, r17	; 63
     4c2:	8a 81       	ldd	r24, Y+2	; 0x02
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	98 2f       	mov	r25, r24
     4c8:	88 27       	eor	r24, r24
     4ca:	29 81       	ldd	r18, Y+1	; 0x01
     4cc:	82 2b       	or	r24, r18
     4ce:	90 93 44 03 	sts	0x0344, r25
     4d2:	80 93 43 03 	sts	0x0343, r24
     4d6:	83 e0       	ldi	r24, 0x03	; 3
     4d8:	80 93 e5 02 	sts	0x02E5, r24
     4dc:	66 e0       	ldi	r22, 0x06	; 6
     4de:	8b e3       	ldi	r24, 0x3B	; 59
     4e0:	b0 de       	rcall	.-672    	; 0x242 <_mpu9250_read_reg>
     4e2:	0f 90       	pop	r0
     4e4:	0f 90       	pop	r0
     4e6:	0f 90       	pop	r0
     4e8:	0f 90       	pop	r0
     4ea:	df 91       	pop	r29
     4ec:	cf 91       	pop	r28
     4ee:	1f 91       	pop	r17
     4f0:	08 95       	ret

000004f2 <set_horn>:
     4f2:	88 23       	and	r24, r24
     4f4:	11 f0       	breq	.+4      	; 0x4fa <set_horn+0x8>
     4f6:	43 9a       	sbi	0x08, 3	; 8
     4f8:	08 95       	ret
     4fa:	43 98       	cbi	0x08, 3	; 8
     4fc:	08 95       	ret

000004fe <set_head_light>:
     4fe:	88 23       	and	r24, r24
     500:	11 f0       	breq	.+4      	; 0x506 <set_head_light+0x8>
     502:	42 9a       	sbi	0x08, 2	; 8
     504:	08 95       	ret
     506:	42 98       	cbi	0x08, 2	; 8
     508:	08 95       	ret

0000050a <set_brake_light>:
     50a:	88 23       	and	r24, r24
     50c:	11 f0       	breq	.+4      	; 0x512 <set_brake_light+0x8>
     50e:	41 9a       	sbi	0x08, 1	; 8
     510:	08 95       	ret
     512:	41 98       	cbi	0x08, 1	; 8
     514:	08 95       	ret

00000516 <set_motor_speed>:
     516:	85 36       	cpi	r24, 0x65	; 101
     518:	08 f0       	brcs	.+2      	; 0x51c <set_motor_speed+0x6>
     51a:	84 e6       	ldi	r24, 0x64	; 100
     51c:	88 23       	and	r24, r24
     51e:	a9 f0       	breq	.+42     	; 0x54a <set_motor_speed+0x34>
     520:	28 2f       	mov	r18, r24
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	af e7       	ldi	r26, 0x7F	; 127
     526:	bc e0       	ldi	r27, 0x0C	; 12
     528:	0e 94 26 19 	call	0x324c	; 0x324c <__umulhisi3>
     52c:	24 e6       	ldi	r18, 0x64	; 100
     52e:	30 e0       	ldi	r19, 0x00	; 0
     530:	40 e0       	ldi	r20, 0x00	; 0
     532:	50 e0       	ldi	r21, 0x00	; 0
     534:	0e 94 04 19 	call	0x3208	; 0x3208 <__divmodsi4>
     538:	30 93 99 00 	sts	0x0099, r19
     53c:	20 93 98 00 	sts	0x0098, r18
     540:	30 93 9b 00 	sts	0x009B, r19
     544:	20 93 9a 00 	sts	0x009A, r18
     548:	08 95       	ret
     54a:	10 92 99 00 	sts	0x0099, r1
     54e:	10 92 98 00 	sts	0x0098, r1
     552:	10 92 9b 00 	sts	0x009B, r1
     556:	10 92 9a 00 	sts	0x009A, r1
     55a:	08 95       	ret

0000055c <init_main_board>:
     55c:	8f 92       	push	r8
     55e:	9f 92       	push	r9
     560:	af 92       	push	r10
     562:	bf 92       	push	r11
     564:	cf 92       	push	r12
     566:	df 92       	push	r13
     568:	ef 92       	push	r14
     56a:	0f 93       	push	r16
     56c:	1f 93       	push	r17
     56e:	3b 9a       	sbi	0x07, 3	; 7
     570:	3a 9a       	sbi	0x07, 2	; 7
     572:	39 9a       	sbi	0x07, 1	; 7
     574:	38 9a       	sbi	0x07, 0	; 7
     576:	e0 e9       	ldi	r30, 0x90	; 144
     578:	f0 e0       	ldi	r31, 0x00	; 0
     57a:	80 81       	ld	r24, Z
     57c:	82 60       	ori	r24, 0x02	; 2
     57e:	80 83       	st	Z, r24
     580:	a1 e9       	ldi	r26, 0x91	; 145
     582:	b0 e0       	ldi	r27, 0x00	; 0
     584:	8c 91       	ld	r24, X
     586:	88 61       	ori	r24, 0x18	; 24
     588:	8c 93       	st	X, r24
     58a:	8f e7       	ldi	r24, 0x7F	; 127
     58c:	9c e0       	ldi	r25, 0x0C	; 12
     58e:	90 93 99 00 	sts	0x0099, r25
     592:	80 93 98 00 	sts	0x0098, r24
     596:	20 81       	ld	r18, Z
     598:	20 6c       	ori	r18, 0xC0	; 192
     59a:	20 83       	st	Z, r18
     59c:	6b 9a       	sbi	0x0d, 3	; 13
     59e:	90 93 9b 00 	sts	0x009B, r25
     5a2:	80 93 9a 00 	sts	0x009A, r24
     5a6:	20 81       	ld	r18, Z
     5a8:	20 63       	ori	r18, 0x30	; 48
     5aa:	20 83       	st	Z, r18
     5ac:	6c 9a       	sbi	0x0d, 4	; 13
     5ae:	90 93 97 00 	sts	0x0097, r25
     5b2:	80 93 96 00 	sts	0x0096, r24
     5b6:	8c 91       	ld	r24, X
     5b8:	81 60       	ori	r24, 0x01	; 1
     5ba:	8c 93       	st	X, r24
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	ab df       	rcall	.-170    	; 0x516 <set_motor_speed>
     5c0:	e1 e8       	ldi	r30, 0x81	; 129
     5c2:	f0 e0       	ldi	r31, 0x00	; 0
     5c4:	80 81       	ld	r24, Z
     5c6:	86 60       	ori	r24, 0x06	; 6
     5c8:	80 83       	st	Z, r24
     5ca:	6a 98       	cbi	0x0d, 2	; 13
     5cc:	6d 9a       	sbi	0x0d, 5	; 13
     5ce:	75 98       	cbi	0x0e, 5	; 14
     5d0:	08 9a       	sbi	0x01, 0	; 1
     5d2:	10 98       	cbi	0x02, 0	; 2
     5d4:	09 9a       	sbi	0x01, 1	; 1
     5d6:	11 98       	cbi	0x02, 1	; 2
     5d8:	0a 9a       	sbi	0x01, 2	; 1
     5da:	12 98       	cbi	0x02, 2	; 2
     5dc:	e9 e6       	ldi	r30, 0x69	; 105
     5de:	f0 e0       	ldi	r31, 0x00	; 0
     5e0:	80 81       	ld	r24, Z
     5e2:	82 60       	ori	r24, 0x02	; 2
     5e4:	80 83       	st	Z, r24
     5e6:	e8 9a       	sbi	0x1d, 0	; 29
     5e8:	81 e1       	ldi	r24, 0x11	; 17
     5ea:	93 e0       	ldi	r25, 0x03	; 3
     5ec:	56 d1       	rcall	.+684    	; 0x89a <buffer_init>
     5ee:	86 ee       	ldi	r24, 0xE6	; 230
     5f0:	92 e0       	ldi	r25, 0x02	; 2
     5f2:	53 d1       	rcall	.+678    	; 0x89a <buffer_init>
     5f4:	0f 2e       	mov	r0, r31
     5f6:	fb ef       	ldi	r31, 0xFB	; 251
     5f8:	8f 2e       	mov	r8, r31
     5fa:	f0 e0       	ldi	r31, 0x00	; 0
     5fc:	9f 2e       	mov	r9, r31
     5fe:	f0 2d       	mov	r31, r0
     600:	0f 2e       	mov	r0, r31
     602:	f6 ee       	ldi	r31, 0xE6	; 230
     604:	af 2e       	mov	r10, r31
     606:	f2 e0       	ldi	r31, 0x02	; 2
     608:	bf 2e       	mov	r11, r31
     60a:	f0 2d       	mov	r31, r0
     60c:	0f 2e       	mov	r0, r31
     60e:	f1 e1       	ldi	r31, 0x11	; 17
     610:	cf 2e       	mov	r12, r31
     612:	f3 e0       	ldi	r31, 0x03	; 3
     614:	df 2e       	mov	r13, r31
     616:	f0 2d       	mov	r31, r0
     618:	e1 2c       	mov	r14, r1
     61a:	00 e0       	ldi	r16, 0x00	; 0
     61c:	23 e0       	ldi	r18, 0x03	; 3
     61e:	40 e8       	ldi	r20, 0x80	; 128
     620:	55 e2       	ldi	r21, 0x25	; 37
     622:	60 e0       	ldi	r22, 0x00	; 0
     624:	70 e0       	ldi	r23, 0x00	; 0
     626:	80 e0       	ldi	r24, 0x00	; 0
     628:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <serial_new_instance>
     62c:	90 93 a6 03 	sts	0x03A6, r25
     630:	80 93 a5 03 	sts	0x03A5, r24
     634:	8a e7       	ldi	r24, 0x7A	; 122
     636:	93 e0       	ldi	r25, 0x03	; 3
     638:	30 d1       	rcall	.+608    	; 0x89a <buffer_init>
     63a:	8f e4       	ldi	r24, 0x4F	; 79
     63c:	93 e0       	ldi	r25, 0x03	; 3
     63e:	2d d1       	rcall	.+602    	; 0x89a <buffer_init>
     640:	8f e6       	ldi	r24, 0x6F	; 111
     642:	91 e0       	ldi	r25, 0x01	; 1
     644:	9f 93       	push	r25
     646:	8f 93       	push	r24
     648:	0f 2e       	mov	r0, r31
     64a:	ff e4       	ldi	r31, 0x4F	; 79
     64c:	8f 2e       	mov	r8, r31
     64e:	f3 e0       	ldi	r31, 0x03	; 3
     650:	9f 2e       	mov	r9, r31
     652:	f0 2d       	mov	r31, r0
     654:	0f 2e       	mov	r0, r31
     656:	fa e7       	ldi	r31, 0x7A	; 122
     658:	af 2e       	mov	r10, r31
     65a:	f3 e0       	ldi	r31, 0x03	; 3
     65c:	bf 2e       	mov	r11, r31
     65e:	f0 2d       	mov	r31, r0
     660:	c1 2c       	mov	r12, r1
     662:	05 e2       	ldi	r16, 0x25	; 37
     664:	10 e0       	ldi	r17, 0x00	; 0
     666:	20 e0       	ldi	r18, 0x00	; 0
     668:	43 e0       	ldi	r20, 0x03	; 3
     66a:	63 e0       	ldi	r22, 0x03	; 3
     66c:	80 e1       	ldi	r24, 0x10	; 16
     66e:	0e 94 42 17 	call	0x2e84	; 0x2e84 <spi_new_instance>
     672:	90 93 a8 03 	sts	0x03A8, r25
     676:	80 93 a7 03 	sts	0x03A7, r24
     67a:	60 e0       	ldi	r22, 0x00	; 0
     67c:	80 e0       	ldi	r24, 0x00	; 0
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	2e de       	rcall	.-932    	; 0x2de <_mpu9250_call_back>
     682:	8b e9       	ldi	r24, 0x9B	; 155
     684:	80 93 b3 00 	sts	0x00B3, r24
     688:	e1 eb       	ldi	r30, 0xB1	; 177
     68a:	f0 e0       	ldi	r31, 0x00	; 0
     68c:	80 81       	ld	r24, Z
     68e:	82 60       	ori	r24, 0x02	; 2
     690:	80 83       	st	Z, r24
     692:	a0 e7       	ldi	r26, 0x70	; 112
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	8c 91       	ld	r24, X
     698:	82 60       	ori	r24, 0x02	; 2
     69a:	8c 93       	st	X, r24
     69c:	80 81       	ld	r24, Z
     69e:	85 60       	ori	r24, 0x05	; 5
     6a0:	80 83       	st	Z, r24
     6a2:	0f 90       	pop	r0
     6a4:	0f 90       	pop	r0
     6a6:	1f 91       	pop	r17
     6a8:	0f 91       	pop	r16
     6aa:	ef 90       	pop	r14
     6ac:	df 90       	pop	r13
     6ae:	cf 90       	pop	r12
     6b0:	bf 90       	pop	r11
     6b2:	af 90       	pop	r10
     6b4:	9f 90       	pop	r9
     6b6:	8f 90       	pop	r8
     6b8:	08 95       	ret

000006ba <set_brake>:
     6ba:	85 36       	cpi	r24, 0x65	; 101
     6bc:	08 f0       	brcs	.+2      	; 0x6c0 <set_brake+0x6>
     6be:	84 e6       	ldi	r24, 0x64	; 100
     6c0:	88 23       	and	r24, r24
     6c2:	a9 f0       	breq	.+42     	; 0x6ee <set_brake+0x34>
     6c4:	28 2f       	mov	r18, r24
     6c6:	30 e0       	ldi	r19, 0x00	; 0
     6c8:	af e7       	ldi	r26, 0x7F	; 127
     6ca:	bc e0       	ldi	r27, 0x0C	; 12
     6cc:	0e 94 26 19 	call	0x324c	; 0x324c <__umulhisi3>
     6d0:	24 e6       	ldi	r18, 0x64	; 100
     6d2:	30 e0       	ldi	r19, 0x00	; 0
     6d4:	40 e0       	ldi	r20, 0x00	; 0
     6d6:	50 e0       	ldi	r21, 0x00	; 0
     6d8:	0e 94 04 19 	call	0x3208	; 0x3208 <__divmodsi4>
     6dc:	30 93 99 00 	sts	0x0099, r19
     6e0:	20 93 98 00 	sts	0x0098, r18
     6e4:	10 92 9b 00 	sts	0x009B, r1
     6e8:	10 92 9a 00 	sts	0x009A, r1
     6ec:	08 95       	ret
     6ee:	10 92 99 00 	sts	0x0099, r1
     6f2:	10 92 98 00 	sts	0x0098, r1
     6f6:	10 92 9b 00 	sts	0x009B, r1
     6fa:	10 92 9a 00 	sts	0x009A, r1
     6fe:	08 95       	ret

00000700 <get_raw_x_accel>:
     700:	2f b7       	in	r18, 0x3f	; 63
     702:	f8 94       	cli
     704:	80 91 4d 03 	lds	r24, 0x034D
     708:	90 91 4e 03 	lds	r25, 0x034E
     70c:	2f bf       	out	0x3f, r18	; 63
     70e:	08 95       	ret

00000710 <get_raw_y_accel>:
     710:	2f b7       	in	r18, 0x3f	; 63
     712:	f8 94       	cli
     714:	80 91 4b 03 	lds	r24, 0x034B
     718:	90 91 4c 03 	lds	r25, 0x034C
     71c:	2f bf       	out	0x3f, r18	; 63
     71e:	08 95       	ret

00000720 <get_raw_x_rotation>:
     720:	2f b7       	in	r18, 0x3f	; 63
     722:	f8 94       	cli
     724:	80 91 47 03 	lds	r24, 0x0347
     728:	90 91 48 03 	lds	r25, 0x0348
     72c:	2f bf       	out	0x3f, r18	; 63
     72e:	08 95       	ret

00000730 <get_raw_y_rotation>:
     730:	2f b7       	in	r18, 0x3f	; 63
     732:	f8 94       	cli
     734:	80 91 45 03 	lds	r24, 0x0345
     738:	90 91 46 03 	lds	r25, 0x0346
     73c:	2f bf       	out	0x3f, r18	; 63
     73e:	08 95       	ret

00000740 <get_tacho_count>:

// ----------------------------------------------------------------------------------------------------------------------
uint16_t get_tacho_count() {
	static uint16_t _last_reading = 0;
	
	uint16_t _tmp = TACHO_TCNT_reg;
     740:	20 91 84 00 	lds	r18, 0x0084
     744:	30 91 85 00 	lds	r19, 0x0085
	uint16_t _tmp_last = _tmp;
	
	if (_tmp < _last_reading) {
     748:	80 91 e3 02 	lds	r24, 0x02E3
     74c:	90 91 e4 02 	lds	r25, 0x02E4
     750:	28 17       	cp	r18, r24
     752:	39 07       	cpc	r19, r25
     754:	30 f4       	brcc	.+12     	; 0x762 <get_tacho_count+0x22>
		_tmp = (UINT16_MAX - _last_reading + _tmp);
     756:	a9 01       	movw	r20, r18
     758:	48 1b       	sub	r20, r24
     75a:	59 0b       	sbc	r21, r25
     75c:	ca 01       	movw	r24, r20
     75e:	01 97       	sbiw	r24, 0x01	; 1
     760:	04 c0       	rjmp	.+8      	; 0x76a <get_tacho_count+0x2a>
		} else {
		_tmp = _tmp-_last_reading;
     762:	a9 01       	movw	r20, r18
     764:	48 1b       	sub	r20, r24
     766:	59 0b       	sbc	r21, r25
     768:	ca 01       	movw	r24, r20
	}
	_last_reading = _tmp_last;
     76a:	30 93 e4 02 	sts	0x02E4, r19
     76e:	20 93 e3 02 	sts	0x02E3, r18
	
	return _tmp;
}
     772:	08 95       	ret

00000774 <set_bt_reset>:

// ----------------------------------------------------------------------------------------------------------------------
void set_bt_reset(uint8_t state) {
	if (state) {
     774:	88 23       	and	r24, r24
     776:	11 f0       	breq	.+4      	; 0x77c <set_bt_reset+0x8>
		BT_RESET_PORT &= ~_BV(BT_RESET_PIN); // Set RESET low/active
     778:	10 98       	cbi	0x02, 0	; 2
     77a:	08 95       	ret
		} else {
		BT_RESET_PORT |= _BV(BT_RESET_PIN); // Set RESET high/in-active
     77c:	10 9a       	sbi	0x02, 0	; 2
     77e:	08 95       	ret

00000780 <bt_send_bytes>:
static void _send_bytes_to_bt(uint8_t *bytes, uint8_t len) {
	serial_send_bytes(_bt_serial_instance, bytes, len);
}

// ----------------------------------------------------------------------------------------------------------------------
uint8_t bt_send_bytes(uint8_t *bytes, uint8_t len) {
     780:	46 2f       	mov	r20, r22
	return serial_send_bytes(_bt_serial_instance, bytes, len);
     782:	bc 01       	movw	r22, r24
     784:	80 91 a5 03 	lds	r24, 0x03A5
     788:	90 91 a6 03 	lds	r25, 0x03A6
     78c:	0c 94 ad 15 	jmp	0x2b5a	; 0x2b5a <serial_send_bytes>
}
     790:	08 95       	ret

00000792 <init_bt_module>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void init_bt_module(void (*bt_status_call_back)(uint8_t result), QueueHandle_t RX_Que) {
	_xRxedCharsQ = RX_Que;
     792:	70 93 3f 03 	sts	0x033F, r23
     796:	60 93 3e 03 	sts	0x033E, r22
	_app_bt_status_call_back = bt_status_call_back;
     79a:	90 93 41 03 	sts	0x0341, r25
     79e:	80 93 40 03 	sts	0x0340, r24
	_bt_dialog_active = 1;
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	80 93 42 03 	sts	0x0342, r24
	dialog_start(_dialog_bt_init_seq, _send_bytes_to_bt, _bt_status_call_back);
     7a8:	41 ef       	ldi	r20, 0xF1	; 241
     7aa:	50 e0       	ldi	r21, 0x00	; 0
     7ac:	66 e6       	ldi	r22, 0x66	; 102
     7ae:	71 e0       	ldi	r23, 0x01	; 1
     7b0:	87 e0       	ldi	r24, 0x07	; 7
     7b2:	92 e0       	ldi	r25, 0x02	; 2
     7b4:	9d c1       	rjmp	.+826    	; 0xaf0 <dialog_start>
     7b6:	08 95       	ret

000007b8 <set_goal_line_semaphore>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void set_goal_line_semaphore(SemaphoreHandle_t goal_line_semaphore) {
	if (goal_line_semaphore) {
     7b8:	00 97       	sbiw	r24, 0x00	; 0
     7ba:	21 f0       	breq	.+8      	; 0x7c4 <set_goal_line_semaphore+0xc>
		_goal_line_semaphore = goal_line_semaphore;
     7bc:	90 93 3d 03 	sts	0x033D, r25
     7c0:	80 93 3c 03 	sts	0x033C, r24
     7c4:	08 95       	ret

000007c6 <__vector_1>:
	}
}

ISR(INT0_vect) {
     7c6:	1f 92       	push	r1
     7c8:	0f 92       	push	r0
     7ca:	0f b6       	in	r0, 0x3f	; 63
     7cc:	0f 92       	push	r0
     7ce:	11 24       	eor	r1, r1
     7d0:	0b b6       	in	r0, 0x3b	; 59
     7d2:	0f 92       	push	r0
     7d4:	2f 93       	push	r18
     7d6:	3f 93       	push	r19
     7d8:	4f 93       	push	r20
     7da:	5f 93       	push	r21
     7dc:	6f 93       	push	r22
     7de:	7f 93       	push	r23
     7e0:	8f 93       	push	r24
     7e2:	9f 93       	push	r25
     7e4:	af 93       	push	r26
     7e6:	bf 93       	push	r27
     7e8:	ef 93       	push	r30
     7ea:	ff 93       	push	r31
	static signed portBASE_TYPE _higher_priority_task_woken;
	if (_goal_line_semaphore) {
     7ec:	80 91 3c 03 	lds	r24, 0x033C
     7f0:	90 91 3d 03 	lds	r25, 0x033D
     7f4:	00 97       	sbiw	r24, 0x00	; 0
     7f6:	49 f0       	breq	.+18     	; 0x80a <__vector_1+0x44>
		_higher_priority_task_woken = pdFALSE;
     7f8:	10 92 e2 02 	sts	0x02E2, r1

		xSemaphoreGiveFromISR(_goal_line_semaphore, &_higher_priority_task_woken);
     7fc:	62 ee       	ldi	r22, 0xE2	; 226
     7fe:	72 e0       	ldi	r23, 0x02	; 2
     800:	c9 d6       	rcall	.+3474   	; 0x1594 <xQueueGiveFromISR>
		
		if (_higher_priority_task_woken != pdFALSE) {
     802:	80 91 e2 02 	lds	r24, 0x02E2
     806:	81 11       	cpse	r24, r1
			portYIELD();
     808:	d0 d3       	rcall	.+1952   	; 0xfaa <vPortYield>
		}
	}
}
     80a:	ff 91       	pop	r31
     80c:	ef 91       	pop	r30
     80e:	bf 91       	pop	r27
     810:	af 91       	pop	r26
     812:	9f 91       	pop	r25
     814:	8f 91       	pop	r24
     816:	7f 91       	pop	r23
     818:	6f 91       	pop	r22
     81a:	5f 91       	pop	r21
     81c:	4f 91       	pop	r20
     81e:	3f 91       	pop	r19
     820:	2f 91       	pop	r18
     822:	0f 90       	pop	r0
     824:	0b be       	out	0x3b, r0	; 59
     826:	0f 90       	pop	r0
     828:	0f be       	out	0x3f, r0	; 63
     82a:	0f 90       	pop	r0
     82c:	1f 90       	pop	r1
     82e:	18 95       	reti

00000830 <__vector_13>:
	#elif ((DIALOG_HANDLER_PRESCALER == 1024))
	DIALOG_HANDLER_TCCRB_reg |= _BV(DIALOG_HANDLER_CS0_bit) | _BV(DIALOG_HANDLER_CS2_bit); ;    // Prescaler 1024 and Start Timer
	#endif
}

ISR(TIMER2_COMPA_vect) {
     830:	1f 92       	push	r1
     832:	0f 92       	push	r0
     834:	0f b6       	in	r0, 0x3f	; 63
     836:	0f 92       	push	r0
     838:	11 24       	eor	r1, r1
     83a:	0b b6       	in	r0, 0x3b	; 59
     83c:	0f 92       	push	r0
     83e:	2f 93       	push	r18
     840:	3f 93       	push	r19
     842:	4f 93       	push	r20
     844:	5f 93       	push	r21
     846:	6f 93       	push	r22
     848:	7f 93       	push	r23
     84a:	8f 93       	push	r24
     84c:	9f 93       	push	r25
     84e:	af 93       	push	r26
     850:	bf 93       	push	r27
     852:	ef 93       	push	r30
     854:	ff 93       	push	r31
	static uint8_t _count = 10;
	if (_bt_dialog_active) {
     856:	80 91 42 03 	lds	r24, 0x0342
     85a:	88 23       	and	r24, r24
     85c:	59 f0       	breq	.+22     	; 0x874 <__vector_13+0x44>
		if (--_count == 0) {
     85e:	80 91 06 02 	lds	r24, 0x0206
     862:	81 50       	subi	r24, 0x01	; 1
     864:	19 f0       	breq	.+6      	; 0x86c <__vector_13+0x3c>
     866:	80 93 06 02 	sts	0x0206, r24
     86a:	04 c0       	rjmp	.+8      	; 0x874 <__vector_13+0x44>
			_count = 10;
     86c:	8a e0       	ldi	r24, 0x0A	; 10
     86e:	80 93 06 02 	sts	0x0206, r24
			dialog_tick();
     872:	4f d1       	rcall	.+670    	; 0xb12 <dialog_tick>
		}
	}
}
     874:	ff 91       	pop	r31
     876:	ef 91       	pop	r30
     878:	bf 91       	pop	r27
     87a:	af 91       	pop	r26
     87c:	9f 91       	pop	r25
     87e:	8f 91       	pop	r24
     880:	7f 91       	pop	r23
     882:	6f 91       	pop	r22
     884:	5f 91       	pop	r21
     886:	4f 91       	pop	r20
     888:	3f 91       	pop	r19
     88a:	2f 91       	pop	r18
     88c:	0f 90       	pop	r0
     88e:	0b be       	out	0x3b, r0	; 59
     890:	0f 90       	pop	r0
     892:	0f be       	out	0x3f, r0	; 63
     894:	0f 90       	pop	r0
     896:	1f 90       	pop	r1
     898:	18 95       	reti

0000089a <buffer_init>:
 @return true if buffer is empty.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_is_empty(buffer_struct_t *buffer) {
	return (buffer->no_in_buffer == 0);
}
     89a:	fc 01       	movw	r30, r24
     89c:	10 a6       	std	Z+40, r1	; 0x28
     89e:	11 a6       	std	Z+41, r1	; 0x29
     8a0:	12 a6       	std	Z+42, r1	; 0x2a
     8a2:	08 95       	ret

000008a4 <buffer_get_item>:
     8a4:	fc 01       	movw	r30, r24
     8a6:	82 a5       	ldd	r24, Z+42	; 0x2a
     8a8:	88 23       	and	r24, r24
     8aa:	a1 f0       	breq	.+40     	; 0x8d4 <buffer_get_item+0x30>
     8ac:	81 a5       	ldd	r24, Z+41	; 0x29
     8ae:	df 01       	movw	r26, r30
     8b0:	a8 0f       	add	r26, r24
     8b2:	b1 1d       	adc	r27, r1
     8b4:	8c 91       	ld	r24, X
     8b6:	db 01       	movw	r26, r22
     8b8:	8c 93       	st	X, r24
     8ba:	81 a5       	ldd	r24, Z+41	; 0x29
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	01 96       	adiw	r24, 0x01	; 1
     8c0:	68 e2       	ldi	r22, 0x28	; 40
     8c2:	70 e0       	ldi	r23, 0x00	; 0
     8c4:	0e 94 cf 18 	call	0x319e	; 0x319e <__divmodhi4>
     8c8:	81 a7       	std	Z+41, r24	; 0x29
     8ca:	82 a5       	ldd	r24, Z+42	; 0x2a
     8cc:	81 50       	subi	r24, 0x01	; 1
     8ce:	82 a7       	std	Z+42, r24	; 0x2a
     8d0:	80 e0       	ldi	r24, 0x00	; 0
     8d2:	08 95       	ret
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	08 95       	ret

000008d8 <buffer_put_item>:
     8d8:	fc 01       	movw	r30, r24
     8da:	22 a5       	ldd	r18, Z+42	; 0x2a
     8dc:	28 32       	cpi	r18, 0x28	; 40
     8de:	80 f4       	brcc	.+32     	; 0x900 <buffer_put_item+0x28>
     8e0:	80 a5       	ldd	r24, Z+40	; 0x28
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	df 01       	movw	r26, r30
     8e6:	a8 0f       	add	r26, r24
     8e8:	b9 1f       	adc	r27, r25
     8ea:	6c 93       	st	X, r22
     8ec:	01 96       	adiw	r24, 0x01	; 1
     8ee:	68 e2       	ldi	r22, 0x28	; 40
     8f0:	70 e0       	ldi	r23, 0x00	; 0
     8f2:	0e 94 cf 18 	call	0x319e	; 0x319e <__divmodhi4>
     8f6:	80 a7       	std	Z+40, r24	; 0x28
     8f8:	2f 5f       	subi	r18, 0xFF	; 255
     8fa:	22 a7       	std	Z+42, r18	; 0x2a
     8fc:	80 e0       	ldi	r24, 0x00	; 0
     8fe:	08 95       	ret
     900:	82 e0       	ldi	r24, 0x02	; 2
     902:	08 95       	ret

00000904 <buffer_no_of_items>:
 @return no of items in the buffer.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_no_of_items(buffer_struct_t *buffer) {
	return buffer->no_in_buffer;
}
     904:	fc 01       	movw	r30, r24
     906:	82 a5       	ldd	r24, Z+42	; 0x2a
     908:	08 95       	ret

0000090a <buffer_clear>:
 @ingroup buffer_function
 @brief Clear the content of the buffer.

 @param *buffer pointer to the buffer structure.
 **********************************************************************/
void buffer_clear(buffer_struct_t *buffer) {
     90a:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     90c:	10 a6       	std	Z+40, r1	; 0x28
	buffer->out_i = 0;
     90e:	11 a6       	std	Z+41, r1	; 0x29
	buffer->no_in_buffer = 0;
     910:	12 a6       	std	Z+42, r1	; 0x2a
     912:	08 95       	ret

00000914 <_dialog_prepare_for_next_byte>:

 When the function returns it has setup the state variable _dialog_await_state that will be used in dialog_char_received(), and the needed argument counters etc.
 */
static void _dialog_prepare_for_next_byte() {
  // esc char?
  if (*(_dialog_format.response_p) == '%') {
     914:	e0 91 b6 03 	lds	r30, 0x03B6
     918:	f0 91 b7 03 	lds	r31, 0x03B7
     91c:	80 81       	ld	r24, Z
     91e:	85 32       	cpi	r24, 0x25	; 37
     920:	09 f0       	breq	.+2      	; 0x924 <_dialog_prepare_for_next_byte+0x10>
     922:	85 c0       	rjmp	.+266    	; 0xa2e <_dialog_prepare_for_next_byte+0x11a>
    _dialog_format.response_p++;
     924:	cf 01       	movw	r24, r30
     926:	01 96       	adiw	r24, 0x01	; 1
     928:	90 93 b7 03 	sts	0x03B7, r25
     92c:	80 93 b6 03 	sts	0x03B6, r24

    if (*(_dialog_format.response_p) == '%') {
     930:	81 81       	ldd	r24, Z+1	; 0x01
     932:	85 32       	cpi	r24, 0x25	; 37
     934:	19 f4       	brne	.+6      	; 0x93c <_dialog_prepare_for_next_byte+0x28>
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
     936:	10 92 ad 03 	sts	0x03AD, r1
     93a:	08 95       	ret
    } else if (*_dialog_format.response_p == '*') {
     93c:	8a 32       	cpi	r24, 0x2A	; 42
     93e:	e1 f5       	brne	.+120    	; 0x9b8 <_dialog_prepare_for_next_byte+0xa4>
      // Max args: %*nnB
      _dialog_format.response_p++;
     940:	cf 01       	movw	r24, r30
     942:	02 96       	adiw	r24, 0x02	; 2
     944:	90 93 b7 03 	sts	0x03B7, r25
     948:	80 93 b6 03 	sts	0x03B6, r24
     94c:	33 96       	adiw	r30, 0x03	; 3
     94e:	20 e0       	ldi	r18, 0x00	; 0
     950:	dc 01       	movw	r26, r24
     952:	01 96       	adiw	r24, 0x01	; 1
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     954:	22 0f       	add	r18, r18
     956:	32 2f       	mov	r19, r18
     958:	33 0f       	add	r19, r19
     95a:	33 0f       	add	r19, r19
     95c:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     95e:	20 53       	subi	r18, 0x30	; 48
     960:	3c 91       	ld	r19, X
     962:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     964:	31 91       	ld	r19, Z+
     966:	32 34       	cpi	r19, 0x42	; 66
     968:	99 f7       	brne	.-26     	; 0x950 <_dialog_prepare_for_next_byte+0x3c>
     96a:	20 93 b8 03 	sts	0x03B8, r18
      _dialog_format.response_p++;
     96e:	12 96       	adiw	r26, 0x02	; 2
     970:	b0 93 b7 03 	sts	0x03B7, r27
     974:	a0 93 b6 03 	sts	0x03B6, r26
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     978:	80 91 ba 03 	lds	r24, 0x03BA
     97c:	90 91 bb 03 	lds	r25, 0x03BB
     980:	00 97       	sbiw	r24, 0x00	; 0
     982:	b1 f0       	breq	.+44     	; 0x9b0 <_dialog_prepare_for_next_byte+0x9c>
        _dialog_format.arg_index++;
     984:	e9 eb       	ldi	r30, 0xB9	; 185
     986:	f3 e0       	ldi	r31, 0x03	; 3
     988:	20 81       	ld	r18, Z
     98a:	2f 5f       	subi	r18, 0xFF	; 255
     98c:	20 83       	st	Z, r18
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     98e:	33 27       	eor	r19, r19
     990:	27 fd       	sbrc	r18, 7
     992:	30 95       	com	r19
     994:	f9 01       	movw	r30, r18
     996:	ee 0f       	add	r30, r30
     998:	ff 1f       	adc	r31, r31
     99a:	e2 0f       	add	r30, r18
     99c:	f3 1f       	adc	r31, r19
     99e:	e8 0f       	add	r30, r24
     9a0:	f9 1f       	adc	r31, r25
     9a2:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     9a4:	80 81       	ld	r24, Z
     9a6:	91 81       	ldd	r25, Z+1	; 0x01
     9a8:	90 93 bd 03 	sts	0x03BD, r25
     9ac:	80 93 bc 03 	sts	0x03BC, r24
      }
      _dialog_await_state = ARG_MAX_STATE;
     9b0:	82 e0       	ldi	r24, 0x02	; 2
     9b2:	80 93 ad 03 	sts	0x03AD, r24
     9b6:	08 95       	ret
     9b8:	80 91 b6 03 	lds	r24, 0x03B6
     9bc:	90 91 b7 03 	lds	r25, 0x03B7
     9c0:	dc 01       	movw	r26, r24
     9c2:	11 96       	adiw	r26, 0x01	; 1
    _dialog_format.response_p++;

    if (*(_dialog_format.response_p) == '%') {
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
    } else if (*_dialog_format.response_p == '*') {
     9c4:	20 e0       	ldi	r18, 0x00	; 0
     9c6:	fc 01       	movw	r30, r24
     9c8:	01 96       	adiw	r24, 0x01	; 1
    } else {
      // args: %nnB
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     9ca:	22 0f       	add	r18, r18
     9cc:	32 2f       	mov	r19, r18
     9ce:	33 0f       	add	r19, r19
     9d0:	33 0f       	add	r19, r19
     9d2:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     9d4:	20 53       	subi	r18, 0x30	; 48
     9d6:	30 81       	ld	r19, Z
     9d8:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     9da:	3d 91       	ld	r19, X+
     9dc:	32 34       	cpi	r19, 0x42	; 66
     9de:	99 f7       	brne	.-26     	; 0x9c6 <_dialog_prepare_for_next_byte+0xb2>
     9e0:	20 93 b8 03 	sts	0x03B8, r18
      _dialog_format.response_p++;
     9e4:	32 96       	adiw	r30, 0x02	; 2
     9e6:	f0 93 b7 03 	sts	0x03B7, r31
     9ea:	e0 93 b6 03 	sts	0x03B6, r30
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     9ee:	80 91 ba 03 	lds	r24, 0x03BA
     9f2:	90 91 bb 03 	lds	r25, 0x03BB
     9f6:	00 97       	sbiw	r24, 0x00	; 0
     9f8:	b1 f0       	breq	.+44     	; 0xa26 <_dialog_prepare_for_next_byte+0x112>
        _dialog_format.arg_index++;
     9fa:	a9 eb       	ldi	r26, 0xB9	; 185
     9fc:	b3 e0       	ldi	r27, 0x03	; 3
     9fe:	ec 91       	ld	r30, X
     a00:	ef 5f       	subi	r30, 0xFF	; 255
     a02:	ec 93       	st	X, r30
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     a04:	ff 27       	eor	r31, r31
     a06:	e7 fd       	sbrc	r30, 7
     a08:	f0 95       	com	r31
     a0a:	9f 01       	movw	r18, r30
     a0c:	22 0f       	add	r18, r18
     a0e:	33 1f       	adc	r19, r19
     a10:	e2 0f       	add	r30, r18
     a12:	f3 1f       	adc	r31, r19
     a14:	e8 0f       	add	r30, r24
     a16:	f9 1f       	adc	r31, r25
     a18:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     a1a:	80 81       	ld	r24, Z
     a1c:	91 81       	ldd	r25, Z+1	; 0x01
     a1e:	90 93 bd 03 	sts	0x03BD, r25
     a22:	80 93 bc 03 	sts	0x03BC, r24
      }
      _dialog_await_state = ARG_STATE;
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	80 93 ad 03 	sts	0x03AD, r24
     a2c:	08 95       	ret
    }
  } else {
    _dialog_await_state = NORMAL_STATE;
     a2e:	10 92 ad 03 	sts	0x03AD, r1
     a32:	08 95       	ret

00000a34 <_dialog_goto_state>:
 IF the new state is either DIALOG_OK_STOP or DIALOG_ERROR_STOP then the call_back function will be called.
 ELSE the new State will be setup.

 @param[in] new_state the new state to goto.
 */
static void _dialog_goto_state(const uint8_t new_state) {
     a34:	cf 93       	push	r28
     a36:	df 93       	push	r29
  _dialog_second_counter = 0;
     a38:	10 92 b1 03 	sts	0x03B1, r1
  _dialog_current_state = new_state;
     a3c:	80 93 b0 03 	sts	0x03B0, r24
  if (new_state == DIALOG_ERROR_STOP || new_state == DIALOG_OK_STOP) {
     a40:	92 e0       	ldi	r25, 0x02	; 2
     a42:	98 0f       	add	r25, r24
     a44:	92 30       	cpi	r25, 0x02	; 2
     a46:	30 f4       	brcc	.+12     	; 0xa54 <_dialog_goto_state+0x20>
    (*_dialog_pf_call_back)(new_state);
     a48:	e0 91 a9 03 	lds	r30, 0x03A9
     a4c:	f0 91 aa 03 	lds	r31, 0x03AA
     a50:	19 95       	eicall
     a52:	4b c0       	rjmp	.+150    	; 0xaea <_dialog_goto_state+0xb6>
  } else {
    // Send command if any
    if (_dialog_seq[new_state].command_length != 0) {
     a54:	9b e0       	ldi	r25, 0x0B	; 11
     a56:	89 9f       	mul	r24, r25
     a58:	e0 01       	movw	r28, r0
     a5a:	11 24       	eor	r1, r1
     a5c:	a0 91 ae 03 	lds	r26, 0x03AE
     a60:	b0 91 af 03 	lds	r27, 0x03AF
     a64:	ac 0f       	add	r26, r28
     a66:	bd 1f       	adc	r27, r29
     a68:	12 96       	adiw	r26, 0x02	; 2
     a6a:	6c 91       	ld	r22, X
     a6c:	12 97       	sbiw	r26, 0x02	; 2
     a6e:	66 23       	and	r22, r22
     a70:	39 f0       	breq	.+14     	; 0xa80 <_dialog_goto_state+0x4c>
      (*_dialog_pf_send)(_dialog_seq[new_state].command,
     a72:	e0 91 ab 03 	lds	r30, 0x03AB
     a76:	f0 91 ac 03 	lds	r31, 0x03AC
     a7a:	8d 91       	ld	r24, X+
     a7c:	9c 91       	ld	r25, X
     a7e:	19 95       	eicall
      _dialog_seq[new_state].command_length);
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
     a80:	80 91 ae 03 	lds	r24, 0x03AE
     a84:	90 91 af 03 	lds	r25, 0x03AF
     a88:	c8 0f       	add	r28, r24
     a8a:	d9 1f       	adc	r29, r25
     a8c:	2d 81       	ldd	r18, Y+5	; 0x05
     a8e:	22 23       	and	r18, r18
     a90:	51 f1       	breq	.+84     	; 0xae6 <_dialog_goto_state+0xb2>
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
                  _dialog_seq[new_state].responce_format;
     a92:	8b 81       	ldd	r24, Y+3	; 0x03
     a94:	9c 81       	ldd	r25, Y+4	; 0x04
 @param[in] response_format to be waited for..
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
     a96:	90 93 b3 03 	sts	0x03B3, r25
     a9a:	80 93 b2 03 	sts	0x03B2, r24
     a9e:	90 93 b7 03 	sts	0x03B7, r25
     aa2:	80 93 b6 03 	sts	0x03B6, r24
                  _dialog_seq[new_state].responce_format;
  _dialog_format.arg_buffers = _dialog_seq[new_state].arg_buffers;
     aa6:	e9 85       	ldd	r30, Y+9	; 0x09
     aa8:	fa 85       	ldd	r31, Y+10	; 0x0a
     aaa:	f0 93 bb 03 	sts	0x03BB, r31
     aae:	e0 93 ba 03 	sts	0x03BA, r30
  _dialog_format.arg_index = -1;
     ab2:	3f ef       	ldi	r19, 0xFF	; 255
     ab4:	30 93 b9 03 	sts	0x03B9, r19
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
     ab8:	30 97       	sbiw	r30, 0x00	; 0
     aba:	31 f0       	breq	.+12     	; 0xac8 <_dialog_goto_state+0x94>
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
     abc:	40 81       	ld	r20, Z
     abe:	51 81       	ldd	r21, Z+1	; 0x01
     ac0:	50 93 bd 03 	sts	0x03BD, r21
     ac4:	40 93 bc 03 	sts	0x03BC, r20
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
                  + _dialog_seq[new_state].responce_format_length - 1;
     ac8:	30 e0       	ldi	r19, 0x00	; 0
     aca:	21 50       	subi	r18, 0x01	; 1
     acc:	31 09       	sbc	r19, r1
     ace:	82 0f       	add	r24, r18
     ad0:	93 1f       	adc	r25, r19
  _dialog_format.arg_index = -1;
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
     ad2:	90 93 b5 03 	sts	0x03B5, r25
     ad6:	80 93 b4 03 	sts	0x03B4, r24
                  + _dialog_seq[new_state].responce_format_length - 1;
  _dialog_prepare_for_next_byte();
     ada:	1c df       	rcall	.-456    	; 0x914 <_dialog_prepare_for_next_byte>
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
      _dialog_await(new_state);
      _dialog_second_counter = _dialog_seq[new_state].max_response_time
     adc:	8e 81       	ldd	r24, Y+6	; 0x06
     ade:	8f 5f       	subi	r24, 0xFF	; 255
     ae0:	80 93 b1 03 	sts	0x03B1, r24
     ae4:	02 c0       	rjmp	.+4      	; 0xaea <_dialog_goto_state+0xb6>
                      + 1; // add one because of 1 sec jitter in second timer
    } else {
      _dialog_goto_state(_dialog_seq[new_state].ok_state);
     ae6:	8f 81       	ldd	r24, Y+7	; 0x07
     ae8:	a5 df       	rcall	.-182    	; 0xa34 <_dialog_goto_state>
    }
  }
}
     aea:	df 91       	pop	r29
     aec:	cf 91       	pop	r28
     aee:	08 95       	ret

00000af0 <dialog_start>:
 @endcode
 */
void dialog_start(dialog_seq_t *p_seq,
		void (*pf_send)(uint8_t *command, uint8_t command_length),
		void (*pf_call_back)(uint8_t result)) {
  _dialog_seq = p_seq;
     af0:	90 93 af 03 	sts	0x03AF, r25
     af4:	80 93 ae 03 	sts	0x03AE, r24
  _dialog_pf_send = pf_send;
     af8:	70 93 ac 03 	sts	0x03AC, r23
     afc:	60 93 ab 03 	sts	0x03AB, r22
  _dialog_pf_call_back = pf_call_back;
     b00:	50 93 aa 03 	sts	0x03AA, r21
     b04:	40 93 a9 03 	sts	0x03A9, r20
  _dialog_current_state = 0;
     b08:	10 92 b0 03 	sts	0x03B0, r1
  _dialog_goto_state(0);
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	92 cf       	rjmp	.-220    	; 0xa34 <_dialog_goto_state>
     b10:	08 95       	ret

00000b12 <dialog_tick>:
 @brief Housekeeping function that must be called every second when a dialog is active.

 If the maximum wait time is exceeded the the dialog will change to error state.
 */
void dialog_tick() {
  if (_dialog_second_counter) {
     b12:	80 91 b1 03 	lds	r24, 0x03B1
     b16:	88 23       	and	r24, r24
     b18:	91 f0       	breq	.+36     	; 0xb3e <dialog_tick+0x2c>
    if (--_dialog_second_counter == 0) {
     b1a:	81 50       	subi	r24, 0x01	; 1
     b1c:	80 93 b1 03 	sts	0x03B1, r24
     b20:	81 11       	cpse	r24, r1
     b22:	0d c0       	rjmp	.+26     	; 0xb3e <dialog_tick+0x2c>
      _dialog_goto_state(_dialog_seq[_dialog_current_state].error_state);
     b24:	80 91 b0 03 	lds	r24, 0x03B0
     b28:	e0 91 ae 03 	lds	r30, 0x03AE
     b2c:	f0 91 af 03 	lds	r31, 0x03AF
     b30:	9b e0       	ldi	r25, 0x0B	; 11
     b32:	89 9f       	mul	r24, r25
     b34:	e0 0d       	add	r30, r0
     b36:	f1 1d       	adc	r31, r1
     b38:	11 24       	eor	r1, r1
     b3a:	80 85       	ldd	r24, Z+8	; 0x08
     b3c:	7b cf       	rjmp	.-266    	; 0xa34 <_dialog_goto_state>
     b3e:	08 95       	ret

00000b40 <dialog_byte_received>:
If there are specified a pointer to an argument buffer in the current state of the dialog_seq, the received argument bytes will be stored in this buffer, else the argument values will be thrown away.

 When/If the expected response string is received the dialog state is changed to the current dialog states OK state.
 @param[in] byte received from device we are communication with.
 */
void dialog_byte_received(const uint8_t byte) {
     b40:	6f 92       	push	r6
     b42:	7f 92       	push	r7
     b44:	8f 92       	push	r8
     b46:	9f 92       	push	r9
     b48:	af 92       	push	r10
     b4a:	bf 92       	push	r11
     b4c:	cf 92       	push	r12
     b4e:	df 92       	push	r13
     b50:	ef 92       	push	r14
     b52:	ff 92       	push	r15
     b54:	0f 93       	push	r16
     b56:	1f 93       	push	r17
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	98 2e       	mov	r9, r24
  uint8_t _retry;
  
  switch (_dialog_await_state) {
     b5e:	80 91 ad 03 	lds	r24, 0x03AD
     b62:	81 30       	cpi	r24, 0x01	; 1
     b64:	09 f4       	brne	.+2      	; 0xb68 <dialog_byte_received+0x28>
     b66:	42 c0       	rjmp	.+132    	; 0xbec <dialog_byte_received+0xac>
     b68:	20 f0       	brcs	.+8      	; 0xb72 <dialog_byte_received+0x32>
     b6a:	82 30       	cpi	r24, 0x02	; 2
     b6c:	09 f4       	brne	.+2      	; 0xb70 <dialog_byte_received+0x30>
     b6e:	70 c0       	rjmp	.+224    	; 0xc50 <dialog_byte_received+0x110>
     b70:	af c0       	rjmp	.+350    	; 0xcd0 <dialog_byte_received+0x190>
     b72:	81 2c       	mov	r8, r1
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     b74:	c6 eb       	ldi	r28, 0xB6	; 182
     b76:	d3 e0       	ldi	r29, 0x03	; 3
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     b78:	0f 2e       	mov	r0, r31
     b7a:	f2 eb       	ldi	r31, 0xB2	; 178
     b7c:	cf 2e       	mov	r12, r31
     b7e:	f3 e0       	ldi	r31, 0x03	; 3
     b80:	df 2e       	mov	r13, r31
     b82:	f0 2d       	mov	r31, r0

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     b84:	0f 2e       	mov	r0, r31
     b86:	f9 eb       	ldi	r31, 0xB9	; 185
     b88:	ef 2e       	mov	r14, r31
     b8a:	f3 e0       	ldi	r31, 0x03	; 3
     b8c:	ff 2e       	mov	r15, r31
     b8e:	f0 2d       	mov	r31, r0
        if (_dialog_format.arg_buffers != 0) {
     b90:	0a eb       	ldi	r16, 0xBA	; 186
     b92:	13 e0       	ldi	r17, 0x03	; 3
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
        }

        if (!_retry) {
     b94:	77 24       	eor	r7, r7
     b96:	73 94       	inc	r7
     b98:	61 2c       	mov	r6, r1
        _dialog_format.response_p = _dialog_format.response;

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
        if (_dialog_format.arg_buffers != 0) {
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     b9a:	0f 2e       	mov	r0, r31
     b9c:	fc eb       	ldi	r31, 0xBC	; 188
     b9e:	af 2e       	mov	r10, r31
     ba0:	f3 e0       	ldi	r31, 0x03	; 3
     ba2:	bf 2e       	mov	r11, r31
     ba4:	f0 2d       	mov	r31, r0
  
  switch (_dialog_await_state) {
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     ba6:	e8 81       	ld	r30, Y
     ba8:	f9 81       	ldd	r31, Y+1	; 0x01
     baa:	9f 01       	movw	r18, r30
     bac:	2f 5f       	subi	r18, 0xFF	; 255
     bae:	3f 4f       	sbci	r19, 0xFF	; 255
     bb0:	39 83       	std	Y+1, r19	; 0x01
     bb2:	28 83       	st	Y, r18
     bb4:	80 81       	ld	r24, Z
     bb6:	89 15       	cp	r24, r9
     bb8:	a9 f0       	breq	.+42     	; 0xbe4 <dialog_byte_received+0xa4>
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     bba:	d6 01       	movw	r26, r12
     bbc:	8d 91       	ld	r24, X+
     bbe:	9c 91       	ld	r25, X
     bc0:	99 83       	std	Y+1, r25	; 0x01
     bc2:	88 83       	st	Y, r24

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     bc4:	f7 01       	movw	r30, r14
     bc6:	10 82       	st	Z, r1
        if (_dialog_format.arg_buffers != 0) {
     bc8:	d8 01       	movw	r26, r16
     bca:	ed 91       	ld	r30, X+
     bcc:	fc 91       	ld	r31, X
     bce:	30 97       	sbiw	r30, 0x00	; 0
     bd0:	29 f0       	breq	.+10     	; 0xbdc <dialog_byte_received+0x9c>
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     bd2:	80 81       	ld	r24, Z
     bd4:	91 81       	ldd	r25, Z+1	; 0x01
     bd6:	f5 01       	movw	r30, r10
     bd8:	91 83       	std	Z+1, r25	; 0x01
     bda:	80 83       	st	Z, r24
        }

        if (!_retry) {
     bdc:	87 2d       	mov	r24, r7
     bde:	81 10       	cpse	r8, r1
     be0:	86 2d       	mov	r24, r6
          _retry = 1;
     be2:	88 2e       	mov	r8, r24
        } else {
          _retry = 0;
        }
      }
      _dialog_prepare_for_next_byte();
     be4:	97 de       	rcall	.-722    	; 0x914 <_dialog_prepare_for_next_byte>
    } while (_retry);
     be6:	81 10       	cpse	r8, r1
     be8:	de cf       	rjmp	.-68     	; 0xba6 <dialog_byte_received+0x66>
     bea:	72 c0       	rjmp	.+228    	; 0xcd0 <dialog_byte_received+0x190>
    break;

  case ARG_STATE:
    // Test if buffer is specified
    if (_dialog_format.arg_buffers != 0) {
     bec:	20 91 ba 03 	lds	r18, 0x03BA
     bf0:	30 91 bb 03 	lds	r19, 0x03BB
     bf4:	21 15       	cp	r18, r1
     bf6:	31 05       	cpc	r19, r1
     bf8:	11 f1       	breq	.+68     	; 0xc3e <dialog_byte_received+0xfe>
      *_dialog_format.arg_buf_p++ = byte;
     bfa:	ac eb       	ldi	r26, 0xBC	; 188
     bfc:	b3 e0       	ldi	r27, 0x03	; 3
     bfe:	ed 91       	ld	r30, X+
     c00:	fc 91       	ld	r31, X
     c02:	11 97       	sbiw	r26, 0x01	; 1
     c04:	cf 01       	movw	r24, r30
     c06:	01 96       	adiw	r24, 0x01	; 1
     c08:	8d 93       	st	X+, r24
     c0a:	9c 93       	st	X, r25
     c0c:	90 82       	st	Z, r9
      // Update length of received argument in arg_buffers
      _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     c0e:	e0 91 b9 03 	lds	r30, 0x03B9
     c12:	ff 27       	eor	r31, r31
     c14:	e7 fd       	sbrc	r30, 7
     c16:	f0 95       	com	r31
     c18:	cf 01       	movw	r24, r30
     c1a:	88 0f       	add	r24, r24
     c1c:	99 1f       	adc	r25, r25
     c1e:	e8 0f       	add	r30, r24
     c20:	f9 1f       	adc	r31, r25
     c22:	e2 0f       	add	r30, r18
     c24:	f3 1f       	adc	r31, r19
     c26:	82 81       	ldd	r24, Z+2	; 0x02
     c28:	8f 5f       	subi	r24, 0xFF	; 255
     c2a:	82 83       	std	Z+2, r24	; 0x02

      // have we got all the bytes in the this argument
      if (--(_dialog_format.arg_cnt) == 0) {
     c2c:	e8 eb       	ldi	r30, 0xB8	; 184
     c2e:	f3 e0       	ldi	r31, 0x03	; 3
     c30:	80 81       	ld	r24, Z
     c32:	81 50       	subi	r24, 0x01	; 1
     c34:	80 83       	st	Z, r24
     c36:	81 11       	cpse	r24, r1
     c38:	4b c0       	rjmp	.+150    	; 0xcd0 <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     c3a:	6c de       	rcall	.-808    	; 0x914 <_dialog_prepare_for_next_byte>
     c3c:	49 c0       	rjmp	.+146    	; 0xcd0 <dialog_byte_received+0x190>
      }
    } else if (--(_dialog_format.arg_cnt) == 0) {
     c3e:	e8 eb       	ldi	r30, 0xB8	; 184
     c40:	f3 e0       	ldi	r31, 0x03	; 3
     c42:	80 81       	ld	r24, Z
     c44:	81 50       	subi	r24, 0x01	; 1
     c46:	80 83       	st	Z, r24
     c48:	81 11       	cpse	r24, r1
     c4a:	42 c0       	rjmp	.+132    	; 0xcd0 <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     c4c:	63 de       	rcall	.-826    	; 0x914 <_dialog_prepare_for_next_byte>
     c4e:	40 c0       	rjmp	.+128    	; 0xcd0 <dialog_byte_received+0x190>
    }
    break;

  case ARG_MAX_STATE:
    // Test if we still are receiving argument bytes
    if (byte != *_dialog_format.response_p) {
     c50:	e0 91 b6 03 	lds	r30, 0x03B6
     c54:	f0 91 b7 03 	lds	r31, 0x03B7
     c58:	80 81       	ld	r24, Z
     c5a:	89 15       	cp	r24, r9
     c5c:	51 f1       	breq	.+84     	; 0xcb2 <dialog_byte_received+0x172>
      // Test if buffer is specified
      if (_dialog_format.arg_buffers != 0) {
     c5e:	80 91 ba 03 	lds	r24, 0x03BA
     c62:	90 91 bb 03 	lds	r25, 0x03BB
     c66:	00 97       	sbiw	r24, 0x00	; 0
     c68:	09 f4       	brne	.+2      	; 0xc6c <dialog_byte_received+0x12c>
     c6a:	4e c0       	rjmp	.+156    	; 0xd08 <dialog_byte_received+0x1c8>
        *_dialog_format.arg_buf_p++ = byte;
     c6c:	ac eb       	ldi	r26, 0xBC	; 188
     c6e:	b3 e0       	ldi	r27, 0x03	; 3
     c70:	ed 91       	ld	r30, X+
     c72:	fc 91       	ld	r31, X
     c74:	11 97       	sbiw	r26, 0x01	; 1
     c76:	9f 01       	movw	r18, r30
     c78:	2f 5f       	subi	r18, 0xFF	; 255
     c7a:	3f 4f       	sbci	r19, 0xFF	; 255
     c7c:	2d 93       	st	X+, r18
     c7e:	3c 93       	st	X, r19
     c80:	90 82       	st	Z, r9
        // Update length of received argument in arg_buffers
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     c82:	20 91 b9 03 	lds	r18, 0x03B9
     c86:	33 27       	eor	r19, r19
     c88:	27 fd       	sbrc	r18, 7
     c8a:	30 95       	com	r19
     c8c:	f9 01       	movw	r30, r18
     c8e:	ee 0f       	add	r30, r30
     c90:	ff 1f       	adc	r31, r31
     c92:	e2 0f       	add	r30, r18
     c94:	f3 1f       	adc	r31, r19
     c96:	e8 0f       	add	r30, r24
     c98:	f9 1f       	adc	r31, r25
     c9a:	82 81       	ldd	r24, Z+2	; 0x02
     c9c:	8f 5f       	subi	r24, 0xFF	; 255
     c9e:	82 83       	std	Z+2, r24	; 0x02

        // Have we received the maximum number of bytes in argument?
        if (--(_dialog_format.arg_cnt) == 0) {
     ca0:	e8 eb       	ldi	r30, 0xB8	; 184
     ca2:	f3 e0       	ldi	r31, 0x03	; 3
     ca4:	80 81       	ld	r24, Z
     ca6:	81 50       	subi	r24, 0x01	; 1
     ca8:	80 83       	st	Z, r24
     caa:	81 11       	cpse	r24, r1
     cac:	11 c0       	rjmp	.+34     	; 0xcd0 <dialog_byte_received+0x190>
          _dialog_prepare_for_next_byte();
     cae:	32 de       	rcall	.-924    	; 0x914 <_dialog_prepare_for_next_byte>
     cb0:	0f c0       	rjmp	.+30     	; 0xcd0 <dialog_byte_received+0x190>
        }
      }
    } else if (--(_dialog_format.arg_cnt) == 0) { // or have we received the maximum allowed no of bytes in the argument?
     cb2:	a8 eb       	ldi	r26, 0xB8	; 184
     cb4:	b3 e0       	ldi	r27, 0x03	; 3
     cb6:	8c 91       	ld	r24, X
     cb8:	81 50       	subi	r24, 0x01	; 1
     cba:	8c 93       	st	X, r24
     cbc:	81 11       	cpse	r24, r1
     cbe:	02 c0       	rjmp	.+4      	; 0xcc4 <dialog_byte_received+0x184>
      _dialog_prepare_for_next_byte();
     cc0:	29 de       	rcall	.-942    	; 0x914 <_dialog_prepare_for_next_byte>
     cc2:	06 c0       	rjmp	.+12     	; 0xcd0 <dialog_byte_received+0x190>
    } else {
      // Next byte in normal response is received
      _dialog_format.response_p++;
     cc4:	31 96       	adiw	r30, 0x01	; 1
     cc6:	f0 93 b7 03 	sts	0x03B7, r31
     cca:	e0 93 b6 03 	sts	0x03B6, r30
      _dialog_prepare_for_next_byte();
     cce:	22 de       	rcall	.-956    	; 0x914 <_dialog_prepare_for_next_byte>
  default:
    break;
  }

  // Test if we are done - have received all bytes in this state of the dialog_seq
  if ((_dialog_await_state == NORMAL_STATE) && (_dialog_format.response_p > _dialog_format.last)) {
     cd0:	80 91 ad 03 	lds	r24, 0x03AD
     cd4:	81 11       	cpse	r24, r1
     cd6:	18 c0       	rjmp	.+48     	; 0xd08 <dialog_byte_received+0x1c8>
     cd8:	20 91 b6 03 	lds	r18, 0x03B6
     cdc:	30 91 b7 03 	lds	r19, 0x03B7
     ce0:	80 91 b4 03 	lds	r24, 0x03B4
     ce4:	90 91 b5 03 	lds	r25, 0x03B5
     ce8:	82 17       	cp	r24, r18
     cea:	93 07       	cpc	r25, r19
     cec:	68 f4       	brcc	.+26     	; 0xd08 <dialog_byte_received+0x1c8>
    // OK - goto OK state
    _dialog_goto_state(_dialog_seq[_dialog_current_state].ok_state);
     cee:	80 91 b0 03 	lds	r24, 0x03B0
     cf2:	e0 91 ae 03 	lds	r30, 0x03AE
     cf6:	f0 91 af 03 	lds	r31, 0x03AF
     cfa:	9b e0       	ldi	r25, 0x0B	; 11
     cfc:	89 9f       	mul	r24, r25
     cfe:	e0 0d       	add	r30, r0
     d00:	f1 1d       	adc	r31, r1
     d02:	11 24       	eor	r1, r1
     d04:	87 81       	ldd	r24, Z+7	; 0x07
     d06:	96 de       	rcall	.-724    	; 0xa34 <_dialog_goto_state>
  }
}
     d08:	df 91       	pop	r29
     d0a:	cf 91       	pop	r28
     d0c:	1f 91       	pop	r17
     d0e:	0f 91       	pop	r16
     d10:	ff 90       	pop	r15
     d12:	ef 90       	pop	r14
     d14:	df 90       	pop	r13
     d16:	cf 90       	pop	r12
     d18:	bf 90       	pop	r11
     d1a:	af 90       	pop	r10
     d1c:	9f 90       	pop	r9
     d1e:	8f 90       	pop	r8
     d20:	7f 90       	pop	r7
     d22:	6f 90       	pop	r6
     d24:	08 95       	ret

00000d26 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     d26:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d28:	03 96       	adiw	r24, 0x03	; 3
     d2a:	92 83       	std	Z+2, r25	; 0x02
     d2c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d2e:	2f ef       	ldi	r18, 0xFF	; 255
     d30:	3f ef       	ldi	r19, 0xFF	; 255
     d32:	34 83       	std	Z+4, r19	; 0x04
     d34:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d36:	96 83       	std	Z+6, r25	; 0x06
     d38:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d3a:	90 87       	std	Z+8, r25	; 0x08
     d3c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     d3e:	10 82       	st	Z, r1
     d40:	08 95       	ret

00000d42 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     d42:	fc 01       	movw	r30, r24
     d44:	11 86       	std	Z+9, r1	; 0x09
     d46:	10 86       	std	Z+8, r1	; 0x08
     d48:	08 95       	ret

00000d4a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     d4a:	cf 93       	push	r28
     d4c:	df 93       	push	r29
     d4e:	9c 01       	movw	r18, r24
     d50:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     d52:	dc 01       	movw	r26, r24
     d54:	11 96       	adiw	r26, 0x01	; 1
     d56:	cd 91       	ld	r28, X+
     d58:	dc 91       	ld	r29, X
     d5a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     d5c:	d3 83       	std	Z+3, r29	; 0x03
     d5e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     d60:	8c 81       	ldd	r24, Y+4	; 0x04
     d62:	9d 81       	ldd	r25, Y+5	; 0x05
     d64:	95 83       	std	Z+5, r25	; 0x05
     d66:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     d68:	8c 81       	ldd	r24, Y+4	; 0x04
     d6a:	9d 81       	ldd	r25, Y+5	; 0x05
     d6c:	dc 01       	movw	r26, r24
     d6e:	13 96       	adiw	r26, 0x03	; 3
     d70:	7c 93       	st	X, r23
     d72:	6e 93       	st	-X, r22
     d74:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     d76:	7d 83       	std	Y+5, r23	; 0x05
     d78:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d7a:	31 87       	std	Z+9, r19	; 0x09
     d7c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     d7e:	f9 01       	movw	r30, r18
     d80:	80 81       	ld	r24, Z
     d82:	8f 5f       	subi	r24, 0xFF	; 255
     d84:	80 83       	st	Z, r24
}
     d86:	df 91       	pop	r29
     d88:	cf 91       	pop	r28
     d8a:	08 95       	ret

00000d8c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     d92:	48 81       	ld	r20, Y
     d94:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d96:	4f 3f       	cpi	r20, 0xFF	; 255
     d98:	2f ef       	ldi	r18, 0xFF	; 255
     d9a:	52 07       	cpc	r21, r18
     d9c:	21 f4       	brne	.+8      	; 0xda6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d9e:	fc 01       	movw	r30, r24
     da0:	a7 81       	ldd	r26, Z+7	; 0x07
     da2:	b0 85       	ldd	r27, Z+8	; 0x08
     da4:	0d c0       	rjmp	.+26     	; 0xdc0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     da6:	dc 01       	movw	r26, r24
     da8:	13 96       	adiw	r26, 0x03	; 3
     daa:	12 96       	adiw	r26, 0x02	; 2
     dac:	ed 91       	ld	r30, X+
     dae:	fc 91       	ld	r31, X
     db0:	13 97       	sbiw	r26, 0x03	; 3
     db2:	20 81       	ld	r18, Z
     db4:	31 81       	ldd	r19, Z+1	; 0x01
     db6:	42 17       	cp	r20, r18
     db8:	53 07       	cpc	r21, r19
     dba:	10 f0       	brcs	.+4      	; 0xdc0 <vListInsert+0x34>
     dbc:	df 01       	movw	r26, r30
     dbe:	f5 cf       	rjmp	.-22     	; 0xdaa <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     dc0:	12 96       	adiw	r26, 0x02	; 2
     dc2:	ed 91       	ld	r30, X+
     dc4:	fc 91       	ld	r31, X
     dc6:	13 97       	sbiw	r26, 0x03	; 3
     dc8:	fb 83       	std	Y+3, r31	; 0x03
     dca:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     dcc:	d5 83       	std	Z+5, r29	; 0x05
     dce:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     dd0:	bd 83       	std	Y+5, r27	; 0x05
     dd2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     dd4:	13 96       	adiw	r26, 0x03	; 3
     dd6:	dc 93       	st	X, r29
     dd8:	ce 93       	st	-X, r28
     dda:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     ddc:	99 87       	std	Y+9, r25	; 0x09
     dde:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     de0:	fc 01       	movw	r30, r24
     de2:	20 81       	ld	r18, Z
     de4:	2f 5f       	subi	r18, 0xFF	; 255
     de6:	20 83       	st	Z, r18
}
     de8:	df 91       	pop	r29
     dea:	cf 91       	pop	r28
     dec:	08 95       	ret

00000dee <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     dee:	cf 93       	push	r28
     df0:	df 93       	push	r29
     df2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     df4:	a0 85       	ldd	r26, Z+8	; 0x08
     df6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     df8:	c2 81       	ldd	r28, Z+2	; 0x02
     dfa:	d3 81       	ldd	r29, Z+3	; 0x03
     dfc:	84 81       	ldd	r24, Z+4	; 0x04
     dfe:	95 81       	ldd	r25, Z+5	; 0x05
     e00:	9d 83       	std	Y+5, r25	; 0x05
     e02:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e04:	c4 81       	ldd	r28, Z+4	; 0x04
     e06:	d5 81       	ldd	r29, Z+5	; 0x05
     e08:	82 81       	ldd	r24, Z+2	; 0x02
     e0a:	93 81       	ldd	r25, Z+3	; 0x03
     e0c:	9b 83       	std	Y+3, r25	; 0x03
     e0e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e10:	11 96       	adiw	r26, 0x01	; 1
     e12:	cd 91       	ld	r28, X+
     e14:	dc 91       	ld	r29, X
     e16:	12 97       	sbiw	r26, 0x02	; 2
     e18:	ce 17       	cp	r28, r30
     e1a:	df 07       	cpc	r29, r31
     e1c:	31 f4       	brne	.+12     	; 0xe2a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e1e:	8c 81       	ldd	r24, Y+4	; 0x04
     e20:	9d 81       	ldd	r25, Y+5	; 0x05
     e22:	12 96       	adiw	r26, 0x02	; 2
     e24:	9c 93       	st	X, r25
     e26:	8e 93       	st	-X, r24
     e28:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     e2a:	11 86       	std	Z+9, r1	; 0x09
     e2c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     e2e:	8c 91       	ld	r24, X
     e30:	81 50       	subi	r24, 0x01	; 1
     e32:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     e34:	df 91       	pop	r29
     e36:	cf 91       	pop	r28
     e38:	08 95       	ret

00000e3a <pxPortInitialiseStack>:
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */

#if defined( portUSE_TIMER0 )
   /* Setup clock source and compare match behaviour. Assuming 328p*/
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     e3a:	31 e1       	ldi	r19, 0x11	; 17
     e3c:	fc 01       	movw	r30, r24
     e3e:	30 83       	st	Z, r19
     e40:	31 97       	sbiw	r30, 0x01	; 1
     e42:	22 e2       	ldi	r18, 0x22	; 34
     e44:	20 83       	st	Z, r18
     e46:	31 97       	sbiw	r30, 0x01	; 1
     e48:	a3 e3       	ldi	r26, 0x33	; 51
     e4a:	a0 83       	st	Z, r26
     e4c:	31 97       	sbiw	r30, 0x01	; 1
     e4e:	60 83       	st	Z, r22
     e50:	31 97       	sbiw	r30, 0x01	; 1
     e52:	70 83       	st	Z, r23
     e54:	31 97       	sbiw	r30, 0x01	; 1
     e56:	10 82       	st	Z, r1
     e58:	31 97       	sbiw	r30, 0x01	; 1
     e5a:	10 82       	st	Z, r1
     e5c:	31 97       	sbiw	r30, 0x01	; 1
     e5e:	60 e8       	ldi	r22, 0x80	; 128
     e60:	60 83       	st	Z, r22
     e62:	31 97       	sbiw	r30, 0x01	; 1
     e64:	10 82       	st	Z, r1
     e66:	31 97       	sbiw	r30, 0x01	; 1
     e68:	10 82       	st	Z, r1
     e6a:	31 97       	sbiw	r30, 0x01	; 1
     e6c:	10 82       	st	Z, r1
     e6e:	31 97       	sbiw	r30, 0x01	; 1
     e70:	62 e0       	ldi	r22, 0x02	; 2
     e72:	60 83       	st	Z, r22
     e74:	31 97       	sbiw	r30, 0x01	; 1
     e76:	63 e0       	ldi	r22, 0x03	; 3
     e78:	60 83       	st	Z, r22
     e7a:	31 97       	sbiw	r30, 0x01	; 1
     e7c:	64 e0       	ldi	r22, 0x04	; 4
     e7e:	60 83       	st	Z, r22
     e80:	31 97       	sbiw	r30, 0x01	; 1
     e82:	65 e0       	ldi	r22, 0x05	; 5
     e84:	60 83       	st	Z, r22
     e86:	31 97       	sbiw	r30, 0x01	; 1
     e88:	66 e0       	ldi	r22, 0x06	; 6
     e8a:	60 83       	st	Z, r22
     e8c:	31 97       	sbiw	r30, 0x01	; 1
     e8e:	67 e0       	ldi	r22, 0x07	; 7
     e90:	60 83       	st	Z, r22
     e92:	31 97       	sbiw	r30, 0x01	; 1
     e94:	68 e0       	ldi	r22, 0x08	; 8
     e96:	60 83       	st	Z, r22
     e98:	31 97       	sbiw	r30, 0x01	; 1
     e9a:	69 e0       	ldi	r22, 0x09	; 9
     e9c:	60 83       	st	Z, r22
     e9e:	31 97       	sbiw	r30, 0x01	; 1
     ea0:	60 e1       	ldi	r22, 0x10	; 16
     ea2:	60 83       	st	Z, r22
     ea4:	31 97       	sbiw	r30, 0x01	; 1
     ea6:	30 83       	st	Z, r19
     ea8:	31 97       	sbiw	r30, 0x01	; 1
     eaa:	32 e1       	ldi	r19, 0x12	; 18
     eac:	30 83       	st	Z, r19
     eae:	31 97       	sbiw	r30, 0x01	; 1
     eb0:	33 e1       	ldi	r19, 0x13	; 19
     eb2:	30 83       	st	Z, r19
     eb4:	31 97       	sbiw	r30, 0x01	; 1
     eb6:	34 e1       	ldi	r19, 0x14	; 20
     eb8:	30 83       	st	Z, r19
     eba:	31 97       	sbiw	r30, 0x01	; 1
     ebc:	35 e1       	ldi	r19, 0x15	; 21
     ebe:	30 83       	st	Z, r19
     ec0:	31 97       	sbiw	r30, 0x01	; 1
     ec2:	36 e1       	ldi	r19, 0x16	; 22
     ec4:	30 83       	st	Z, r19
     ec6:	31 97       	sbiw	r30, 0x01	; 1
     ec8:	37 e1       	ldi	r19, 0x17	; 23
     eca:	30 83       	st	Z, r19
     ecc:	31 97       	sbiw	r30, 0x01	; 1
     ece:	38 e1       	ldi	r19, 0x18	; 24
     ed0:	30 83       	st	Z, r19
     ed2:	31 97       	sbiw	r30, 0x01	; 1
     ed4:	39 e1       	ldi	r19, 0x19	; 25
     ed6:	30 83       	st	Z, r19
     ed8:	31 97       	sbiw	r30, 0x01	; 1
     eda:	30 e2       	ldi	r19, 0x20	; 32
     edc:	30 83       	st	Z, r19
     ede:	31 97       	sbiw	r30, 0x01	; 1
     ee0:	31 e2       	ldi	r19, 0x21	; 33
     ee2:	30 83       	st	Z, r19
     ee4:	31 97       	sbiw	r30, 0x01	; 1
     ee6:	20 83       	st	Z, r18
     ee8:	31 97       	sbiw	r30, 0x01	; 1
     eea:	23 e2       	ldi	r18, 0x23	; 35
     eec:	20 83       	st	Z, r18
     eee:	31 97       	sbiw	r30, 0x01	; 1
     ef0:	40 83       	st	Z, r20
     ef2:	31 97       	sbiw	r30, 0x01	; 1
     ef4:	50 83       	st	Z, r21
     ef6:	31 97       	sbiw	r30, 0x01	; 1
     ef8:	26 e2       	ldi	r18, 0x26	; 38
     efa:	20 83       	st	Z, r18
     efc:	31 97       	sbiw	r30, 0x01	; 1
     efe:	27 e2       	ldi	r18, 0x27	; 39
     f00:	20 83       	st	Z, r18
     f02:	31 97       	sbiw	r30, 0x01	; 1
     f04:	28 e2       	ldi	r18, 0x28	; 40
     f06:	20 83       	st	Z, r18
     f08:	31 97       	sbiw	r30, 0x01	; 1
     f0a:	29 e2       	ldi	r18, 0x29	; 41
     f0c:	20 83       	st	Z, r18
     f0e:	31 97       	sbiw	r30, 0x01	; 1
     f10:	20 e3       	ldi	r18, 0x30	; 48
     f12:	20 83       	st	Z, r18
     f14:	31 97       	sbiw	r30, 0x01	; 1
     f16:	21 e3       	ldi	r18, 0x31	; 49
     f18:	20 83       	st	Z, r18
     f1a:	89 97       	sbiw	r24, 0x29	; 41
     f1c:	08 95       	ret

00000f1e <xPortStartScheduler>:
     f1e:	88 ee       	ldi	r24, 0xE8	; 232
     f20:	93 e0       	ldi	r25, 0x03	; 3
     f22:	90 93 c1 03 	sts	0x03C1, r25
     f26:	80 93 c0 03 	sts	0x03C0, r24
     f2a:	90 93 bf 03 	sts	0x03BF, r25
     f2e:	80 93 be 03 	sts	0x03BE, r24
     f32:	89 ef       	ldi	r24, 0xF9	; 249
     f34:	87 bd       	out	0x27, r24	; 39
     f36:	82 e0       	ldi	r24, 0x02	; 2
     f38:	84 bd       	out	0x24, r24	; 36
     f3a:	83 e0       	ldi	r24, 0x03	; 3
     f3c:	85 bd       	out	0x25, r24	; 37
     f3e:	ee e6       	ldi	r30, 0x6E	; 110
     f40:	f0 e0       	ldi	r31, 0x00	; 0
     f42:	80 81       	ld	r24, Z
     f44:	82 60       	ori	r24, 0x02	; 2
     f46:	80 83       	st	Z, r24
     f48:	a0 91 e1 0d 	lds	r26, 0x0DE1
     f4c:	b0 91 e2 0d 	lds	r27, 0x0DE2
     f50:	cd 91       	ld	r28, X+
     f52:	cd bf       	out	0x3d, r28	; 61
     f54:	dd 91       	ld	r29, X+
     f56:	de bf       	out	0x3e, r29	; 62
     f58:	ff 91       	pop	r31
     f5a:	ef 91       	pop	r30
     f5c:	df 91       	pop	r29
     f5e:	cf 91       	pop	r28
     f60:	bf 91       	pop	r27
     f62:	af 91       	pop	r26
     f64:	9f 91       	pop	r25
     f66:	8f 91       	pop	r24
     f68:	7f 91       	pop	r23
     f6a:	6f 91       	pop	r22
     f6c:	5f 91       	pop	r21
     f6e:	4f 91       	pop	r20
     f70:	3f 91       	pop	r19
     f72:	2f 91       	pop	r18
     f74:	1f 91       	pop	r17
     f76:	0f 91       	pop	r16
     f78:	ff 90       	pop	r15
     f7a:	ef 90       	pop	r14
     f7c:	df 90       	pop	r13
     f7e:	cf 90       	pop	r12
     f80:	bf 90       	pop	r11
     f82:	af 90       	pop	r10
     f84:	9f 90       	pop	r9
     f86:	8f 90       	pop	r8
     f88:	7f 90       	pop	r7
     f8a:	6f 90       	pop	r6
     f8c:	5f 90       	pop	r5
     f8e:	4f 90       	pop	r4
     f90:	3f 90       	pop	r3
     f92:	2f 90       	pop	r2
     f94:	1f 90       	pop	r1
     f96:	0f 90       	pop	r0
     f98:	0c be       	out	0x3c, r0	; 60
     f9a:	0f 90       	pop	r0
     f9c:	0b be       	out	0x3b, r0	; 59
     f9e:	0f 90       	pop	r0
     fa0:	0f be       	out	0x3f, r0	; 63
     fa2:	0f 90       	pop	r0
     fa4:	08 95       	ret
     fa6:	81 e0       	ldi	r24, 0x01	; 1
     fa8:	08 95       	ret

00000faa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     faa:	0f 92       	push	r0
     fac:	0f b6       	in	r0, 0x3f	; 63
     fae:	f8 94       	cli
     fb0:	0f 92       	push	r0
     fb2:	0b b6       	in	r0, 0x3b	; 59
     fb4:	0f 92       	push	r0
     fb6:	0c b6       	in	r0, 0x3c	; 60
     fb8:	0f 92       	push	r0
     fba:	1f 92       	push	r1
     fbc:	11 24       	eor	r1, r1
     fbe:	2f 92       	push	r2
     fc0:	3f 92       	push	r3
     fc2:	4f 92       	push	r4
     fc4:	5f 92       	push	r5
     fc6:	6f 92       	push	r6
     fc8:	7f 92       	push	r7
     fca:	8f 92       	push	r8
     fcc:	9f 92       	push	r9
     fce:	af 92       	push	r10
     fd0:	bf 92       	push	r11
     fd2:	cf 92       	push	r12
     fd4:	df 92       	push	r13
     fd6:	ef 92       	push	r14
     fd8:	ff 92       	push	r15
     fda:	0f 93       	push	r16
     fdc:	1f 93       	push	r17
     fde:	2f 93       	push	r18
     fe0:	3f 93       	push	r19
     fe2:	4f 93       	push	r20
     fe4:	5f 93       	push	r21
     fe6:	6f 93       	push	r22
     fe8:	7f 93       	push	r23
     fea:	8f 93       	push	r24
     fec:	9f 93       	push	r25
     fee:	af 93       	push	r26
     ff0:	bf 93       	push	r27
     ff2:	cf 93       	push	r28
     ff4:	df 93       	push	r29
     ff6:	ef 93       	push	r30
     ff8:	ff 93       	push	r31
     ffa:	a0 91 e1 0d 	lds	r26, 0x0DE1
     ffe:	b0 91 e2 0d 	lds	r27, 0x0DE2
    1002:	0d b6       	in	r0, 0x3d	; 61
    1004:	0d 92       	st	X+, r0
    1006:	0e b6       	in	r0, 0x3e	; 62
    1008:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    100a:	9b d6       	rcall	.+3382   	; 0x1d42 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    100c:	a0 91 e1 0d 	lds	r26, 0x0DE1
    1010:	b0 91 e2 0d 	lds	r27, 0x0DE2
    1014:	cd 91       	ld	r28, X+
    1016:	cd bf       	out	0x3d, r28	; 61
    1018:	dd 91       	ld	r29, X+
    101a:	de bf       	out	0x3e, r29	; 62
    101c:	ff 91       	pop	r31
    101e:	ef 91       	pop	r30
    1020:	df 91       	pop	r29
    1022:	cf 91       	pop	r28
    1024:	bf 91       	pop	r27
    1026:	af 91       	pop	r26
    1028:	9f 91       	pop	r25
    102a:	8f 91       	pop	r24
    102c:	7f 91       	pop	r23
    102e:	6f 91       	pop	r22
    1030:	5f 91       	pop	r21
    1032:	4f 91       	pop	r20
    1034:	3f 91       	pop	r19
    1036:	2f 91       	pop	r18
    1038:	1f 91       	pop	r17
    103a:	0f 91       	pop	r16
    103c:	ff 90       	pop	r15
    103e:	ef 90       	pop	r14
    1040:	df 90       	pop	r13
    1042:	cf 90       	pop	r12
    1044:	bf 90       	pop	r11
    1046:	af 90       	pop	r10
    1048:	9f 90       	pop	r9
    104a:	8f 90       	pop	r8
    104c:	7f 90       	pop	r7
    104e:	6f 90       	pop	r6
    1050:	5f 90       	pop	r5
    1052:	4f 90       	pop	r4
    1054:	3f 90       	pop	r3
    1056:	2f 90       	pop	r2
    1058:	1f 90       	pop	r1
    105a:	0f 90       	pop	r0
    105c:	0c be       	out	0x3c, r0	; 60
    105e:	0f 90       	pop	r0
    1060:	0b be       	out	0x3b, r0	; 59
    1062:	0f 90       	pop	r0
    1064:	0f be       	out	0x3f, r0	; 63
    1066:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1068:	08 95       	ret

0000106a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    106a:	0f 92       	push	r0
    106c:	0f b6       	in	r0, 0x3f	; 63
    106e:	f8 94       	cli
    1070:	0f 92       	push	r0
    1072:	0b b6       	in	r0, 0x3b	; 59
    1074:	0f 92       	push	r0
    1076:	0c b6       	in	r0, 0x3c	; 60
    1078:	0f 92       	push	r0
    107a:	1f 92       	push	r1
    107c:	11 24       	eor	r1, r1
    107e:	2f 92       	push	r2
    1080:	3f 92       	push	r3
    1082:	4f 92       	push	r4
    1084:	5f 92       	push	r5
    1086:	6f 92       	push	r6
    1088:	7f 92       	push	r7
    108a:	8f 92       	push	r8
    108c:	9f 92       	push	r9
    108e:	af 92       	push	r10
    1090:	bf 92       	push	r11
    1092:	cf 92       	push	r12
    1094:	df 92       	push	r13
    1096:	ef 92       	push	r14
    1098:	ff 92       	push	r15
    109a:	0f 93       	push	r16
    109c:	1f 93       	push	r17
    109e:	2f 93       	push	r18
    10a0:	3f 93       	push	r19
    10a2:	4f 93       	push	r20
    10a4:	5f 93       	push	r21
    10a6:	6f 93       	push	r22
    10a8:	7f 93       	push	r23
    10aa:	8f 93       	push	r24
    10ac:	9f 93       	push	r25
    10ae:	af 93       	push	r26
    10b0:	bf 93       	push	r27
    10b2:	cf 93       	push	r28
    10b4:	df 93       	push	r29
    10b6:	ef 93       	push	r30
    10b8:	ff 93       	push	r31
    10ba:	a0 91 e1 0d 	lds	r26, 0x0DE1
    10be:	b0 91 e2 0d 	lds	r27, 0x0DE2
    10c2:	0d b6       	in	r0, 0x3d	; 61
    10c4:	0d 92       	st	X+, r0
    10c6:	0e b6       	in	r0, 0x3e	; 62
    10c8:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
    10ca:	80 91 be 03 	lds	r24, 0x03BE
    10ce:	90 91 bf 03 	lds	r25, 0x03BF
    10d2:	01 97       	sbiw	r24, 0x01	; 1
    10d4:	90 93 bf 03 	sts	0x03BF, r25
    10d8:	80 93 be 03 	sts	0x03BE, r24
    10dc:	89 2b       	or	r24, r25
    10de:	41 f4       	brne	.+16     	; 0x10f0 <vPortYieldFromTick+0x86>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
    10e0:	80 91 c0 03 	lds	r24, 0x03C0
    10e4:	90 91 c1 03 	lds	r25, 0x03C1
    10e8:	90 93 bf 03 	sts	0x03BF, r25
    10ec:	80 93 be 03 	sts	0x03BE, r24
	}

	if( xTaskIncrementTick() != pdFALSE )
    10f0:	d4 d4       	rcall	.+2472   	; 0x1a9a <xTaskIncrementTick>
    10f2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    10f4:	26 d6       	rcall	.+3148   	; 0x1d42 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    10f6:	a0 91 e1 0d 	lds	r26, 0x0DE1
    10fa:	b0 91 e2 0d 	lds	r27, 0x0DE2
    10fe:	cd 91       	ld	r28, X+
    1100:	cd bf       	out	0x3d, r28	; 61
    1102:	dd 91       	ld	r29, X+
    1104:	de bf       	out	0x3e, r29	; 62
    1106:	ff 91       	pop	r31
    1108:	ef 91       	pop	r30
    110a:	df 91       	pop	r29
    110c:	cf 91       	pop	r28
    110e:	bf 91       	pop	r27
    1110:	af 91       	pop	r26
    1112:	9f 91       	pop	r25
    1114:	8f 91       	pop	r24
    1116:	7f 91       	pop	r23
    1118:	6f 91       	pop	r22
    111a:	5f 91       	pop	r21
    111c:	4f 91       	pop	r20
    111e:	3f 91       	pop	r19
    1120:	2f 91       	pop	r18
    1122:	1f 91       	pop	r17
    1124:	0f 91       	pop	r16
    1126:	ff 90       	pop	r15
    1128:	ef 90       	pop	r14
    112a:	df 90       	pop	r13
    112c:	cf 90       	pop	r12
    112e:	bf 90       	pop	r11
    1130:	af 90       	pop	r10
    1132:	9f 90       	pop	r9
    1134:	8f 90       	pop	r8
    1136:	7f 90       	pop	r7
    1138:	6f 90       	pop	r6
    113a:	5f 90       	pop	r5
    113c:	4f 90       	pop	r4
    113e:	3f 90       	pop	r3
    1140:	2f 90       	pop	r2
    1142:	1f 90       	pop	r1
    1144:	0f 90       	pop	r0
    1146:	0c be       	out	0x3c, r0	; 60
    1148:	0f 90       	pop	r0
    114a:	0b be       	out	0x3b, r0	; 59
    114c:	0f 90       	pop	r0
    114e:	0f be       	out	0x3f, r0	; 63
    1150:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1152:	08 95       	ret

00001154 <__vector_21>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
    1154:	8a df       	rcall	.-236    	; 0x106a <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1156:	18 95       	reti

00001158 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1158:	cf 93       	push	r28
    115a:	df 93       	push	r29
    115c:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    115e:	8d d4       	rcall	.+2330   	; 0x1a7a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1160:	80 91 c2 03 	lds	r24, 0x03C2
    1164:	90 91 c3 03 	lds	r25, 0x03C3
    1168:	89 2b       	or	r24, r25
    116a:	31 f4       	brne	.+12     	; 0x1178 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    116c:	87 ec       	ldi	r24, 0xC7	; 199
    116e:	93 e0       	ldi	r25, 0x03	; 3
    1170:	90 93 c3 03 	sts	0x03C3, r25
    1174:	80 93 c2 03 	sts	0x03C2, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1178:	40 91 c4 03 	lds	r20, 0x03C4
    117c:	50 91 c5 03 	lds	r21, 0x03C5
    1180:	9e 01       	movw	r18, r28
    1182:	24 0f       	add	r18, r20
    1184:	35 1f       	adc	r19, r21
    1186:	23 3c       	cpi	r18, 0xC3	; 195
    1188:	89 e0       	ldi	r24, 0x09	; 9
    118a:	38 07       	cpc	r19, r24
    118c:	70 f4       	brcc	.+28     	; 0x11aa <pvPortMalloc+0x52>
    118e:	42 17       	cp	r20, r18
    1190:	53 07       	cpc	r21, r19
    1192:	70 f4       	brcc	.+28     	; 0x11b0 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1194:	c0 91 c2 03 	lds	r28, 0x03C2
    1198:	d0 91 c3 03 	lds	r29, 0x03C3
    119c:	c4 0f       	add	r28, r20
    119e:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    11a0:	30 93 c5 03 	sts	0x03C5, r19
    11a4:	20 93 c4 03 	sts	0x03C4, r18
    11a8:	05 c0       	rjmp	.+10     	; 0x11b4 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    11aa:	c0 e0       	ldi	r28, 0x00	; 0
    11ac:	d0 e0       	ldi	r29, 0x00	; 0
    11ae:	02 c0       	rjmp	.+4      	; 0x11b4 <pvPortMalloc+0x5c>
    11b0:	c0 e0       	ldi	r28, 0x00	; 0
    11b2:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    11b4:	2d d5       	rcall	.+2650   	; 0x1c10 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    11b6:	ce 01       	movw	r24, r28
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	08 95       	ret

000011be <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    11be:	08 95       	ret

000011c0 <prvCopyDataToQueue>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    11c0:	1f 93       	push	r17
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	ec 01       	movw	r28, r24
    11c8:	14 2f       	mov	r17, r20
    11ca:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11cc:	81 11       	cpse	r24, r1
    11ce:	0b c0       	rjmp	.+22     	; 0x11e6 <prvCopyDataToQueue+0x26>
    11d0:	88 81       	ld	r24, Y
    11d2:	99 81       	ldd	r25, Y+1	; 0x01
    11d4:	89 2b       	or	r24, r25
    11d6:	09 f0       	breq	.+2      	; 0x11da <prvCopyDataToQueue+0x1a>
    11d8:	46 c0       	rjmp	.+140    	; 0x1266 <prvCopyDataToQueue+0xa6>
    11da:	8a 81       	ldd	r24, Y+2	; 0x02
    11dc:	9b 81       	ldd	r25, Y+3	; 0x03
    11de:	56 d7       	rcall	.+3756   	; 0x208c <xTaskPriorityDisinherit>
    11e0:	1b 82       	std	Y+3, r1	; 0x03
    11e2:	1a 82       	std	Y+2, r1	; 0x02
    11e4:	47 c0       	rjmp	.+142    	; 0x1274 <prvCopyDataToQueue+0xb4>
    11e6:	41 11       	cpse	r20, r1
    11e8:	18 c0       	rjmp	.+48     	; 0x121a <prvCopyDataToQueue+0x5a>
    11ea:	48 2f       	mov	r20, r24
    11ec:	50 e0       	ldi	r21, 0x00	; 0
    11ee:	8c 81       	ldd	r24, Y+4	; 0x04
    11f0:	9d 81       	ldd	r25, Y+5	; 0x05
    11f2:	0e 94 8d 1a 	call	0x351a	; 0x351a <memcpy>
    11f6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11f8:	8c 81       	ldd	r24, Y+4	; 0x04
    11fa:	9d 81       	ldd	r25, Y+5	; 0x05
    11fc:	82 0f       	add	r24, r18
    11fe:	91 1d       	adc	r25, r1
    1200:	9d 83       	std	Y+5, r25	; 0x05
    1202:	8c 83       	std	Y+4, r24	; 0x04
    1204:	2a 81       	ldd	r18, Y+2	; 0x02
    1206:	3b 81       	ldd	r19, Y+3	; 0x03
    1208:	82 17       	cp	r24, r18
    120a:	93 07       	cpc	r25, r19
    120c:	70 f1       	brcs	.+92     	; 0x126a <prvCopyDataToQueue+0xaa>
    120e:	88 81       	ld	r24, Y
    1210:	99 81       	ldd	r25, Y+1	; 0x01
    1212:	9d 83       	std	Y+5, r25	; 0x05
    1214:	8c 83       	std	Y+4, r24	; 0x04
    1216:	80 e0       	ldi	r24, 0x00	; 0
    1218:	2d c0       	rjmp	.+90     	; 0x1274 <prvCopyDataToQueue+0xb4>
    121a:	48 2f       	mov	r20, r24
    121c:	50 e0       	ldi	r21, 0x00	; 0
    121e:	8e 81       	ldd	r24, Y+6	; 0x06
    1220:	9f 81       	ldd	r25, Y+7	; 0x07
    1222:	0e 94 8d 1a 	call	0x351a	; 0x351a <memcpy>
    1226:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1228:	30 e0       	ldi	r19, 0x00	; 0
    122a:	31 95       	neg	r19
    122c:	21 95       	neg	r18
    122e:	31 09       	sbc	r19, r1
    1230:	8e 81       	ldd	r24, Y+6	; 0x06
    1232:	9f 81       	ldd	r25, Y+7	; 0x07
    1234:	82 0f       	add	r24, r18
    1236:	93 1f       	adc	r25, r19
    1238:	9f 83       	std	Y+7, r25	; 0x07
    123a:	8e 83       	std	Y+6, r24	; 0x06
    123c:	68 81       	ld	r22, Y
    123e:	79 81       	ldd	r23, Y+1	; 0x01
    1240:	86 17       	cp	r24, r22
    1242:	97 07       	cpc	r25, r23
    1244:	30 f4       	brcc	.+12     	; 0x1252 <prvCopyDataToQueue+0x92>
    1246:	8a 81       	ldd	r24, Y+2	; 0x02
    1248:	9b 81       	ldd	r25, Y+3	; 0x03
    124a:	28 0f       	add	r18, r24
    124c:	39 1f       	adc	r19, r25
    124e:	3f 83       	std	Y+7, r19	; 0x07
    1250:	2e 83       	std	Y+6, r18	; 0x06
    1252:	12 30       	cpi	r17, 0x02	; 2
    1254:	61 f4       	brne	.+24     	; 0x126e <prvCopyDataToQueue+0xae>
    1256:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1258:	88 23       	and	r24, r24
    125a:	59 f0       	breq	.+22     	; 0x1272 <prvCopyDataToQueue+0xb2>
    125c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    125e:	81 50       	subi	r24, 0x01	; 1
    1260:	8a 8f       	std	Y+26, r24	; 0x1a
    1262:	80 e0       	ldi	r24, 0x00	; 0
    1264:	07 c0       	rjmp	.+14     	; 0x1274 <prvCopyDataToQueue+0xb4>
    1266:	80 e0       	ldi	r24, 0x00	; 0
    1268:	05 c0       	rjmp	.+10     	; 0x1274 <prvCopyDataToQueue+0xb4>
    126a:	80 e0       	ldi	r24, 0x00	; 0
    126c:	03 c0       	rjmp	.+6      	; 0x1274 <prvCopyDataToQueue+0xb4>
    126e:	80 e0       	ldi	r24, 0x00	; 0
    1270:	01 c0       	rjmp	.+2      	; 0x1274 <prvCopyDataToQueue+0xb4>
    1272:	80 e0       	ldi	r24, 0x00	; 0
    1274:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1276:	9f 5f       	subi	r25, 0xFF	; 255
    1278:	9a 8f       	std	Y+26, r25	; 0x1a
    127a:	df 91       	pop	r29
    127c:	cf 91       	pop	r28
    127e:	1f 91       	pop	r17
    1280:	08 95       	ret

00001282 <prvCopyDataFromQueue>:
    1282:	fc 01       	movw	r30, r24
    1284:	cb 01       	movw	r24, r22
    1286:	44 8d       	ldd	r20, Z+28	; 0x1c
    1288:	44 23       	and	r20, r20
    128a:	a1 f0       	breq	.+40     	; 0x12b4 <prvCopyDataFromQueue+0x32>
    128c:	50 e0       	ldi	r21, 0x00	; 0
    128e:	26 81       	ldd	r18, Z+6	; 0x06
    1290:	37 81       	ldd	r19, Z+7	; 0x07
    1292:	24 0f       	add	r18, r20
    1294:	35 1f       	adc	r19, r21
    1296:	37 83       	std	Z+7, r19	; 0x07
    1298:	26 83       	std	Z+6, r18	; 0x06
    129a:	62 81       	ldd	r22, Z+2	; 0x02
    129c:	73 81       	ldd	r23, Z+3	; 0x03
    129e:	26 17       	cp	r18, r22
    12a0:	37 07       	cpc	r19, r23
    12a2:	20 f0       	brcs	.+8      	; 0x12ac <prvCopyDataFromQueue+0x2a>
    12a4:	20 81       	ld	r18, Z
    12a6:	31 81       	ldd	r19, Z+1	; 0x01
    12a8:	37 83       	std	Z+7, r19	; 0x07
    12aa:	26 83       	std	Z+6, r18	; 0x06
    12ac:	66 81       	ldd	r22, Z+6	; 0x06
    12ae:	77 81       	ldd	r23, Z+7	; 0x07
    12b0:	0c 94 8d 1a 	jmp	0x351a	; 0x351a <memcpy>
    12b4:	08 95       	ret

000012b6 <prvUnlockQueue>:
    12b6:	0f 93       	push	r16
    12b8:	1f 93       	push	r17
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	ec 01       	movw	r28, r24
    12c0:	0f b6       	in	r0, 0x3f	; 63
    12c2:	f8 94       	cli
    12c4:	0f 92       	push	r0
    12c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12c8:	18 16       	cp	r1, r24
    12ca:	a4 f4       	brge	.+40     	; 0x12f4 <prvUnlockQueue+0x3e>
    12cc:	89 89       	ldd	r24, Y+17	; 0x11
    12ce:	88 23       	and	r24, r24
    12d0:	89 f0       	breq	.+34     	; 0x12f4 <prvUnlockQueue+0x3e>
    12d2:	8e 01       	movw	r16, r28
    12d4:	0f 5e       	subi	r16, 0xEF	; 239
    12d6:	1f 4f       	sbci	r17, 0xFF	; 255
    12d8:	03 c0       	rjmp	.+6      	; 0x12e0 <prvUnlockQueue+0x2a>
    12da:	89 89       	ldd	r24, Y+17	; 0x11
    12dc:	88 23       	and	r24, r24
    12de:	51 f0       	breq	.+20     	; 0x12f4 <prvUnlockQueue+0x3e>
    12e0:	c8 01       	movw	r24, r16
    12e2:	df d5       	rcall	.+3006   	; 0x1ea2 <xTaskRemoveFromEventList>
    12e4:	81 11       	cpse	r24, r1
    12e6:	62 d6       	rcall	.+3268   	; 0x1fac <vTaskMissedYield>
    12e8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12ea:	81 50       	subi	r24, 0x01	; 1
    12ec:	8e 8f       	std	Y+30, r24	; 0x1e
    12ee:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12f0:	18 16       	cp	r1, r24
    12f2:	9c f3       	brlt	.-26     	; 0x12da <prvUnlockQueue+0x24>
    12f4:	8f ef       	ldi	r24, 0xFF	; 255
    12f6:	8e 8f       	std	Y+30, r24	; 0x1e
    12f8:	0f 90       	pop	r0
    12fa:	0f be       	out	0x3f, r0	; 63
    12fc:	0f b6       	in	r0, 0x3f	; 63
    12fe:	f8 94       	cli
    1300:	0f 92       	push	r0
    1302:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1304:	18 16       	cp	r1, r24
    1306:	a4 f4       	brge	.+40     	; 0x1330 <prvUnlockQueue+0x7a>
    1308:	88 85       	ldd	r24, Y+8	; 0x08
    130a:	88 23       	and	r24, r24
    130c:	89 f0       	breq	.+34     	; 0x1330 <prvUnlockQueue+0x7a>
    130e:	8e 01       	movw	r16, r28
    1310:	08 5f       	subi	r16, 0xF8	; 248
    1312:	1f 4f       	sbci	r17, 0xFF	; 255
    1314:	03 c0       	rjmp	.+6      	; 0x131c <prvUnlockQueue+0x66>
    1316:	88 85       	ldd	r24, Y+8	; 0x08
    1318:	88 23       	and	r24, r24
    131a:	51 f0       	breq	.+20     	; 0x1330 <prvUnlockQueue+0x7a>
    131c:	c8 01       	movw	r24, r16
    131e:	c1 d5       	rcall	.+2946   	; 0x1ea2 <xTaskRemoveFromEventList>
    1320:	81 11       	cpse	r24, r1
    1322:	44 d6       	rcall	.+3208   	; 0x1fac <vTaskMissedYield>
    1324:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1326:	81 50       	subi	r24, 0x01	; 1
    1328:	8d 8f       	std	Y+29, r24	; 0x1d
    132a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    132c:	18 16       	cp	r1, r24
    132e:	9c f3       	brlt	.-26     	; 0x1316 <prvUnlockQueue+0x60>
    1330:	8f ef       	ldi	r24, 0xFF	; 255
    1332:	8d 8f       	std	Y+29, r24	; 0x1d
    1334:	0f 90       	pop	r0
    1336:	0f be       	out	0x3f, r0	; 63
    1338:	df 91       	pop	r29
    133a:	cf 91       	pop	r28
    133c:	1f 91       	pop	r17
    133e:	0f 91       	pop	r16
    1340:	08 95       	ret

00001342 <xQueueGenericReset>:
    1342:	cf 93       	push	r28
    1344:	df 93       	push	r29
    1346:	ec 01       	movw	r28, r24
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	0f 92       	push	r0
    134e:	88 81       	ld	r24, Y
    1350:	99 81       	ldd	r25, Y+1	; 0x01
    1352:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1354:	30 e0       	ldi	r19, 0x00	; 0
    1356:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1358:	72 9f       	mul	r23, r18
    135a:	a0 01       	movw	r20, r0
    135c:	73 9f       	mul	r23, r19
    135e:	50 0d       	add	r21, r0
    1360:	11 24       	eor	r1, r1
    1362:	fc 01       	movw	r30, r24
    1364:	e4 0f       	add	r30, r20
    1366:	f5 1f       	adc	r31, r21
    1368:	fb 83       	std	Y+3, r31	; 0x03
    136a:	ea 83       	std	Y+2, r30	; 0x02
    136c:	1a 8e       	std	Y+26, r1	; 0x1a
    136e:	9d 83       	std	Y+5, r25	; 0x05
    1370:	8c 83       	std	Y+4, r24	; 0x04
    1372:	42 1b       	sub	r20, r18
    1374:	53 0b       	sbc	r21, r19
    1376:	84 0f       	add	r24, r20
    1378:	95 1f       	adc	r25, r21
    137a:	9f 83       	std	Y+7, r25	; 0x07
    137c:	8e 83       	std	Y+6, r24	; 0x06
    137e:	8f ef       	ldi	r24, 0xFF	; 255
    1380:	8d 8f       	std	Y+29, r24	; 0x1d
    1382:	8e 8f       	std	Y+30, r24	; 0x1e
    1384:	61 11       	cpse	r22, r1
    1386:	0a c0       	rjmp	.+20     	; 0x139c <xQueueGenericReset+0x5a>
    1388:	88 85       	ldd	r24, Y+8	; 0x08
    138a:	88 23       	and	r24, r24
    138c:	69 f0       	breq	.+26     	; 0x13a8 <xQueueGenericReset+0x66>
    138e:	ce 01       	movw	r24, r28
    1390:	08 96       	adiw	r24, 0x08	; 8
    1392:	87 d5       	rcall	.+2830   	; 0x1ea2 <xTaskRemoveFromEventList>
    1394:	81 30       	cpi	r24, 0x01	; 1
    1396:	41 f4       	brne	.+16     	; 0x13a8 <xQueueGenericReset+0x66>
    1398:	08 de       	rcall	.-1008   	; 0xfaa <vPortYield>
    139a:	06 c0       	rjmp	.+12     	; 0x13a8 <xQueueGenericReset+0x66>
    139c:	ce 01       	movw	r24, r28
    139e:	08 96       	adiw	r24, 0x08	; 8
    13a0:	c2 dc       	rcall	.-1660   	; 0xd26 <vListInitialise>
    13a2:	ce 01       	movw	r24, r28
    13a4:	41 96       	adiw	r24, 0x11	; 17
    13a6:	bf dc       	rcall	.-1666   	; 0xd26 <vListInitialise>
    13a8:	0f 90       	pop	r0
    13aa:	0f be       	out	0x3f, r0	; 63
    13ac:	81 e0       	ldi	r24, 0x01	; 1
    13ae:	df 91       	pop	r29
    13b0:	cf 91       	pop	r28
    13b2:	08 95       	ret

000013b4 <xQueueGenericCreate>:
    13b4:	0f 93       	push	r16
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
    13bc:	08 2f       	mov	r16, r24
    13be:	16 2f       	mov	r17, r22
    13c0:	66 23       	and	r22, r22
    13c2:	b9 f0       	breq	.+46     	; 0x13f2 <xQueueGenericCreate+0x3e>
    13c4:	86 9f       	mul	r24, r22
    13c6:	c0 01       	movw	r24, r0
    13c8:	11 24       	eor	r1, r1
    13ca:	80 96       	adiw	r24, 0x20	; 32
    13cc:	c5 de       	rcall	.-630    	; 0x1158 <pvPortMalloc>
    13ce:	ec 01       	movw	r28, r24
    13d0:	00 97       	sbiw	r24, 0x00	; 0
    13d2:	21 f4       	brne	.+8      	; 0x13dc <xQueueGenericCreate+0x28>
    13d4:	14 c0       	rjmp	.+40     	; 0x13fe <xQueueGenericCreate+0x4a>
    13d6:	d9 83       	std	Y+1, r29	; 0x01
    13d8:	c8 83       	st	Y, r28
    13da:	05 c0       	rjmp	.+10     	; 0x13e6 <xQueueGenericCreate+0x32>
    13dc:	9c 01       	movw	r18, r24
    13de:	21 5e       	subi	r18, 0xE1	; 225
    13e0:	3f 4f       	sbci	r19, 0xFF	; 255
    13e2:	39 83       	std	Y+1, r19	; 0x01
    13e4:	28 83       	st	Y, r18
    13e6:	0b 8f       	std	Y+27, r16	; 0x1b
    13e8:	1c 8f       	std	Y+28, r17	; 0x1c
    13ea:	61 e0       	ldi	r22, 0x01	; 1
    13ec:	ce 01       	movw	r24, r28
    13ee:	a9 df       	rcall	.-174    	; 0x1342 <xQueueGenericReset>
    13f0:	06 c0       	rjmp	.+12     	; 0x13fe <xQueueGenericCreate+0x4a>
    13f2:	8f e1       	ldi	r24, 0x1F	; 31
    13f4:	90 e0       	ldi	r25, 0x00	; 0
    13f6:	b0 de       	rcall	.-672    	; 0x1158 <pvPortMalloc>
    13f8:	ec 01       	movw	r28, r24
    13fa:	00 97       	sbiw	r24, 0x00	; 0
    13fc:	61 f7       	brne	.-40     	; 0x13d6 <xQueueGenericCreate+0x22>
    13fe:	ce 01       	movw	r24, r28
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	1f 91       	pop	r17
    1406:	0f 91       	pop	r16
    1408:	08 95       	ret

0000140a <xQueueGenericSend>:
    140a:	9f 92       	push	r9
    140c:	af 92       	push	r10
    140e:	bf 92       	push	r11
    1410:	cf 92       	push	r12
    1412:	df 92       	push	r13
    1414:	ef 92       	push	r14
    1416:	ff 92       	push	r15
    1418:	0f 93       	push	r16
    141a:	1f 93       	push	r17
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	00 d0       	rcall	.+0      	; 0x1422 <xQueueGenericSend+0x18>
    1422:	1f 92       	push	r1
    1424:	1f 92       	push	r1
    1426:	cd b7       	in	r28, 0x3d	; 61
    1428:	de b7       	in	r29, 0x3e	; 62
    142a:	8c 01       	movw	r16, r24
    142c:	6b 01       	movw	r12, r22
    142e:	5d 83       	std	Y+5, r21	; 0x05
    1430:	4c 83       	std	Y+4, r20	; 0x04
    1432:	a2 2e       	mov	r10, r18
    1434:	b1 2c       	mov	r11, r1
    1436:	99 24       	eor	r9, r9
    1438:	93 94       	inc	r9
    143a:	7c 01       	movw	r14, r24
    143c:	88 e0       	ldi	r24, 0x08	; 8
    143e:	e8 0e       	add	r14, r24
    1440:	f1 1c       	adc	r15, r1
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	f8 94       	cli
    1446:	0f 92       	push	r0
    1448:	f8 01       	movw	r30, r16
    144a:	92 8d       	ldd	r25, Z+26	; 0x1a
    144c:	83 8d       	ldd	r24, Z+27	; 0x1b
    144e:	98 17       	cp	r25, r24
    1450:	18 f0       	brcs	.+6      	; 0x1458 <xQueueGenericSend+0x4e>
    1452:	f2 e0       	ldi	r31, 0x02	; 2
    1454:	af 12       	cpse	r10, r31
    1456:	15 c0       	rjmp	.+42     	; 0x1482 <xQueueGenericSend+0x78>
    1458:	4a 2d       	mov	r20, r10
    145a:	b6 01       	movw	r22, r12
    145c:	c8 01       	movw	r24, r16
    145e:	b0 de       	rcall	.-672    	; 0x11c0 <prvCopyDataToQueue>
    1460:	f8 01       	movw	r30, r16
    1462:	91 89       	ldd	r25, Z+17	; 0x11
    1464:	99 23       	and	r25, r25
    1466:	39 f0       	breq	.+14     	; 0x1476 <xQueueGenericSend+0x6c>
    1468:	c8 01       	movw	r24, r16
    146a:	41 96       	adiw	r24, 0x11	; 17
    146c:	1a d5       	rcall	.+2612   	; 0x1ea2 <xTaskRemoveFromEventList>
    146e:	81 30       	cpi	r24, 0x01	; 1
    1470:	21 f4       	brne	.+8      	; 0x147a <xQueueGenericSend+0x70>
    1472:	9b dd       	rcall	.-1226   	; 0xfaa <vPortYield>
    1474:	02 c0       	rjmp	.+4      	; 0x147a <xQueueGenericSend+0x70>
    1476:	81 11       	cpse	r24, r1
    1478:	98 dd       	rcall	.-1232   	; 0xfaa <vPortYield>
    147a:	0f 90       	pop	r0
    147c:	0f be       	out	0x3f, r0	; 63
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	46 c0       	rjmp	.+140    	; 0x150e <xQueueGenericSend+0x104>
    1482:	ec 81       	ldd	r30, Y+4	; 0x04
    1484:	fd 81       	ldd	r31, Y+5	; 0x05
    1486:	ef 2b       	or	r30, r31
    1488:	21 f4       	brne	.+8      	; 0x1492 <xQueueGenericSend+0x88>
    148a:	0f 90       	pop	r0
    148c:	0f be       	out	0x3f, r0	; 63
    148e:	80 e0       	ldi	r24, 0x00	; 0
    1490:	3e c0       	rjmp	.+124    	; 0x150e <xQueueGenericSend+0x104>
    1492:	b1 10       	cpse	r11, r1
    1494:	04 c0       	rjmp	.+8      	; 0x149e <xQueueGenericSend+0x94>
    1496:	ce 01       	movw	r24, r28
    1498:	01 96       	adiw	r24, 0x01	; 1
    149a:	4b d5       	rcall	.+2710   	; 0x1f32 <vTaskSetTimeOutState>
    149c:	b9 2c       	mov	r11, r9
    149e:	0f 90       	pop	r0
    14a0:	0f be       	out	0x3f, r0	; 63
    14a2:	eb d2       	rcall	.+1494   	; 0x1a7a <vTaskSuspendAll>
    14a4:	0f b6       	in	r0, 0x3f	; 63
    14a6:	f8 94       	cli
    14a8:	0f 92       	push	r0
    14aa:	f8 01       	movw	r30, r16
    14ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    14ae:	8f 3f       	cpi	r24, 0xFF	; 255
    14b0:	09 f4       	brne	.+2      	; 0x14b4 <xQueueGenericSend+0xaa>
    14b2:	15 8e       	std	Z+29, r1	; 0x1d
    14b4:	f8 01       	movw	r30, r16
    14b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    14b8:	8f 3f       	cpi	r24, 0xFF	; 255
    14ba:	09 f4       	brne	.+2      	; 0x14be <xQueueGenericSend+0xb4>
    14bc:	16 8e       	std	Z+30, r1	; 0x1e
    14be:	0f 90       	pop	r0
    14c0:	0f be       	out	0x3f, r0	; 63
    14c2:	be 01       	movw	r22, r28
    14c4:	6c 5f       	subi	r22, 0xFC	; 252
    14c6:	7f 4f       	sbci	r23, 0xFF	; 255
    14c8:	ce 01       	movw	r24, r28
    14ca:	01 96       	adiw	r24, 0x01	; 1
    14cc:	3d d5       	rcall	.+2682   	; 0x1f48 <xTaskCheckForTimeOut>
    14ce:	81 11       	cpse	r24, r1
    14d0:	1a c0       	rjmp	.+52     	; 0x1506 <xQueueGenericSend+0xfc>
    14d2:	0f b6       	in	r0, 0x3f	; 63
    14d4:	f8 94       	cli
    14d6:	0f 92       	push	r0
    14d8:	f8 01       	movw	r30, r16
    14da:	92 8d       	ldd	r25, Z+26	; 0x1a
    14dc:	0f 90       	pop	r0
    14de:	0f be       	out	0x3f, r0	; 63
    14e0:	f8 01       	movw	r30, r16
    14e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    14e4:	98 13       	cpse	r25, r24
    14e6:	0b c0       	rjmp	.+22     	; 0x14fe <xQueueGenericSend+0xf4>
    14e8:	6c 81       	ldd	r22, Y+4	; 0x04
    14ea:	7d 81       	ldd	r23, Y+5	; 0x05
    14ec:	c7 01       	movw	r24, r14
    14ee:	a1 d4       	rcall	.+2370   	; 0x1e32 <vTaskPlaceOnEventList>
    14f0:	c8 01       	movw	r24, r16
    14f2:	e1 de       	rcall	.-574    	; 0x12b6 <prvUnlockQueue>
    14f4:	8d d3       	rcall	.+1818   	; 0x1c10 <xTaskResumeAll>
    14f6:	81 11       	cpse	r24, r1
    14f8:	a4 cf       	rjmp	.-184    	; 0x1442 <xQueueGenericSend+0x38>
    14fa:	57 dd       	rcall	.-1362   	; 0xfaa <vPortYield>
    14fc:	a2 cf       	rjmp	.-188    	; 0x1442 <xQueueGenericSend+0x38>
    14fe:	c8 01       	movw	r24, r16
    1500:	da de       	rcall	.-588    	; 0x12b6 <prvUnlockQueue>
    1502:	86 d3       	rcall	.+1804   	; 0x1c10 <xTaskResumeAll>
    1504:	9e cf       	rjmp	.-196    	; 0x1442 <xQueueGenericSend+0x38>
    1506:	c8 01       	movw	r24, r16
    1508:	d6 de       	rcall	.-596    	; 0x12b6 <prvUnlockQueue>
    150a:	82 d3       	rcall	.+1796   	; 0x1c10 <xTaskResumeAll>
    150c:	80 e0       	ldi	r24, 0x00	; 0
    150e:	0f 90       	pop	r0
    1510:	0f 90       	pop	r0
    1512:	0f 90       	pop	r0
    1514:	0f 90       	pop	r0
    1516:	0f 90       	pop	r0
    1518:	df 91       	pop	r29
    151a:	cf 91       	pop	r28
    151c:	1f 91       	pop	r17
    151e:	0f 91       	pop	r16
    1520:	ff 90       	pop	r15
    1522:	ef 90       	pop	r14
    1524:	df 90       	pop	r13
    1526:	cf 90       	pop	r12
    1528:	bf 90       	pop	r11
    152a:	af 90       	pop	r10
    152c:	9f 90       	pop	r9
    152e:	08 95       	ret

00001530 <xQueueGenericSendFromISR>:
    1530:	0f 93       	push	r16
    1532:	1f 93       	push	r17
    1534:	cf 93       	push	r28
    1536:	df 93       	push	r29
    1538:	ec 01       	movw	r28, r24
    153a:	8a 01       	movw	r16, r20
    153c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    153e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1540:	98 17       	cp	r25, r24
    1542:	10 f0       	brcs	.+4      	; 0x1548 <xQueueGenericSendFromISR+0x18>
    1544:	22 30       	cpi	r18, 0x02	; 2
    1546:	d1 f4       	brne	.+52     	; 0x157c <xQueueGenericSendFromISR+0x4c>
    1548:	42 2f       	mov	r20, r18
    154a:	ce 01       	movw	r24, r28
    154c:	39 de       	rcall	.-910    	; 0x11c0 <prvCopyDataToQueue>
    154e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1550:	8f 3f       	cpi	r24, 0xFF	; 255
    1552:	79 f4       	brne	.+30     	; 0x1572 <xQueueGenericSendFromISR+0x42>
    1554:	89 89       	ldd	r24, Y+17	; 0x11
    1556:	88 23       	and	r24, r24
    1558:	99 f0       	breq	.+38     	; 0x1580 <xQueueGenericSendFromISR+0x50>
    155a:	ce 01       	movw	r24, r28
    155c:	41 96       	adiw	r24, 0x11	; 17
    155e:	a1 d4       	rcall	.+2370   	; 0x1ea2 <xTaskRemoveFromEventList>
    1560:	88 23       	and	r24, r24
    1562:	81 f0       	breq	.+32     	; 0x1584 <xQueueGenericSendFromISR+0x54>
    1564:	01 15       	cp	r16, r1
    1566:	11 05       	cpc	r17, r1
    1568:	79 f0       	breq	.+30     	; 0x1588 <xQueueGenericSendFromISR+0x58>
    156a:	81 e0       	ldi	r24, 0x01	; 1
    156c:	f8 01       	movw	r30, r16
    156e:	80 83       	st	Z, r24
    1570:	0c c0       	rjmp	.+24     	; 0x158a <xQueueGenericSendFromISR+0x5a>
    1572:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1574:	8f 5f       	subi	r24, 0xFF	; 255
    1576:	8e 8f       	std	Y+30, r24	; 0x1e
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	07 c0       	rjmp	.+14     	; 0x158a <xQueueGenericSendFromISR+0x5a>
    157c:	80 e0       	ldi	r24, 0x00	; 0
    157e:	05 c0       	rjmp	.+10     	; 0x158a <xQueueGenericSendFromISR+0x5a>
    1580:	81 e0       	ldi	r24, 0x01	; 1
    1582:	03 c0       	rjmp	.+6      	; 0x158a <xQueueGenericSendFromISR+0x5a>
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	01 c0       	rjmp	.+2      	; 0x158a <xQueueGenericSendFromISR+0x5a>
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	df 91       	pop	r29
    158c:	cf 91       	pop	r28
    158e:	1f 91       	pop	r17
    1590:	0f 91       	pop	r16
    1592:	08 95       	ret

00001594 <xQueueGiveFromISR>:
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	fc 01       	movw	r30, r24
    159a:	eb 01       	movw	r28, r22
    159c:	92 8d       	ldd	r25, Z+26	; 0x1a
    159e:	83 8d       	ldd	r24, Z+27	; 0x1b
    15a0:	98 17       	cp	r25, r24
    15a2:	c0 f4       	brcc	.+48     	; 0x15d4 <xQueueGiveFromISR+0x40>
    15a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    15a6:	8f 5f       	subi	r24, 0xFF	; 255
    15a8:	82 8f       	std	Z+26, r24	; 0x1a
    15aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    15ac:	8f 3f       	cpi	r24, 0xFF	; 255
    15ae:	69 f4       	brne	.+26     	; 0x15ca <xQueueGiveFromISR+0x36>
    15b0:	81 89       	ldd	r24, Z+17	; 0x11
    15b2:	88 23       	and	r24, r24
    15b4:	89 f0       	breq	.+34     	; 0x15d8 <xQueueGiveFromISR+0x44>
    15b6:	cf 01       	movw	r24, r30
    15b8:	41 96       	adiw	r24, 0x11	; 17
    15ba:	73 d4       	rcall	.+2278   	; 0x1ea2 <xTaskRemoveFromEventList>
    15bc:	88 23       	and	r24, r24
    15be:	71 f0       	breq	.+28     	; 0x15dc <xQueueGiveFromISR+0x48>
    15c0:	20 97       	sbiw	r28, 0x00	; 0
    15c2:	71 f0       	breq	.+28     	; 0x15e0 <xQueueGiveFromISR+0x4c>
    15c4:	81 e0       	ldi	r24, 0x01	; 1
    15c6:	88 83       	st	Y, r24
    15c8:	0c c0       	rjmp	.+24     	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    15cc:	8f 5f       	subi	r24, 0xFF	; 255
    15ce:	86 8f       	std	Z+30, r24	; 0x1e
    15d0:	81 e0       	ldi	r24, 0x01	; 1
    15d2:	07 c0       	rjmp	.+14     	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	05 c0       	rjmp	.+10     	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15d8:	81 e0       	ldi	r24, 0x01	; 1
    15da:	03 c0       	rjmp	.+6      	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15dc:	81 e0       	ldi	r24, 0x01	; 1
    15de:	01 c0       	rjmp	.+2      	; 0x15e2 <xQueueGiveFromISR+0x4e>
    15e0:	81 e0       	ldi	r24, 0x01	; 1
    15e2:	df 91       	pop	r29
    15e4:	cf 91       	pop	r28
    15e6:	08 95       	ret

000015e8 <xQueueGenericReceive>:
    15e8:	9f 92       	push	r9
    15ea:	af 92       	push	r10
    15ec:	bf 92       	push	r11
    15ee:	cf 92       	push	r12
    15f0:	df 92       	push	r13
    15f2:	ef 92       	push	r14
    15f4:	ff 92       	push	r15
    15f6:	0f 93       	push	r16
    15f8:	1f 93       	push	r17
    15fa:	cf 93       	push	r28
    15fc:	df 93       	push	r29
    15fe:	00 d0       	rcall	.+0      	; 0x1600 <xQueueGenericReceive+0x18>
    1600:	1f 92       	push	r1
    1602:	1f 92       	push	r1
    1604:	cd b7       	in	r28, 0x3d	; 61
    1606:	de b7       	in	r29, 0x3e	; 62
    1608:	8c 01       	movw	r16, r24
    160a:	6b 01       	movw	r12, r22
    160c:	5d 83       	std	Y+5, r21	; 0x05
    160e:	4c 83       	std	Y+4, r20	; 0x04
    1610:	b2 2e       	mov	r11, r18
    1612:	a1 2c       	mov	r10, r1
    1614:	99 24       	eor	r9, r9
    1616:	93 94       	inc	r9
    1618:	7c 01       	movw	r14, r24
    161a:	81 e1       	ldi	r24, 0x11	; 17
    161c:	e8 0e       	add	r14, r24
    161e:	f1 1c       	adc	r15, r1
    1620:	0f b6       	in	r0, 0x3f	; 63
    1622:	f8 94       	cli
    1624:	0f 92       	push	r0
    1626:	f8 01       	movw	r30, r16
    1628:	82 8d       	ldd	r24, Z+26	; 0x1a
    162a:	88 23       	and	r24, r24
    162c:	69 f1       	breq	.+90     	; 0x1688 <xQueueGenericReceive+0xa0>
    162e:	e6 80       	ldd	r14, Z+6	; 0x06
    1630:	f7 80       	ldd	r15, Z+7	; 0x07
    1632:	b6 01       	movw	r22, r12
    1634:	c8 01       	movw	r24, r16
    1636:	25 de       	rcall	.-950    	; 0x1282 <prvCopyDataFromQueue>
    1638:	b1 10       	cpse	r11, r1
    163a:	17 c0       	rjmp	.+46     	; 0x166a <xQueueGenericReceive+0x82>
    163c:	f8 01       	movw	r30, r16
    163e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1640:	81 50       	subi	r24, 0x01	; 1
    1642:	82 8f       	std	Z+26, r24	; 0x1a
    1644:	80 81       	ld	r24, Z
    1646:	91 81       	ldd	r25, Z+1	; 0x01
    1648:	89 2b       	or	r24, r25
    164a:	21 f4       	brne	.+8      	; 0x1654 <xQueueGenericReceive+0x6c>
    164c:	5e d5       	rcall	.+2748   	; 0x210a <pvTaskIncrementMutexHeldCount>
    164e:	f8 01       	movw	r30, r16
    1650:	93 83       	std	Z+3, r25	; 0x03
    1652:	82 83       	std	Z+2, r24	; 0x02
    1654:	f8 01       	movw	r30, r16
    1656:	80 85       	ldd	r24, Z+8	; 0x08
    1658:	88 23       	and	r24, r24
    165a:	91 f0       	breq	.+36     	; 0x1680 <xQueueGenericReceive+0x98>
    165c:	c8 01       	movw	r24, r16
    165e:	08 96       	adiw	r24, 0x08	; 8
    1660:	20 d4       	rcall	.+2112   	; 0x1ea2 <xTaskRemoveFromEventList>
    1662:	81 30       	cpi	r24, 0x01	; 1
    1664:	69 f4       	brne	.+26     	; 0x1680 <xQueueGenericReceive+0x98>
    1666:	a1 dc       	rcall	.-1726   	; 0xfaa <vPortYield>
    1668:	0b c0       	rjmp	.+22     	; 0x1680 <xQueueGenericReceive+0x98>
    166a:	f8 01       	movw	r30, r16
    166c:	f7 82       	std	Z+7, r15	; 0x07
    166e:	e6 82       	std	Z+6, r14	; 0x06
    1670:	81 89       	ldd	r24, Z+17	; 0x11
    1672:	88 23       	and	r24, r24
    1674:	29 f0       	breq	.+10     	; 0x1680 <xQueueGenericReceive+0x98>
    1676:	c8 01       	movw	r24, r16
    1678:	41 96       	adiw	r24, 0x11	; 17
    167a:	13 d4       	rcall	.+2086   	; 0x1ea2 <xTaskRemoveFromEventList>
    167c:	81 11       	cpse	r24, r1
    167e:	95 dc       	rcall	.-1750   	; 0xfaa <vPortYield>
    1680:	0f 90       	pop	r0
    1682:	0f be       	out	0x3f, r0	; 63
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	52 c0       	rjmp	.+164    	; 0x172c <xQueueGenericReceive+0x144>
    1688:	4c 81       	ldd	r20, Y+4	; 0x04
    168a:	5d 81       	ldd	r21, Y+5	; 0x05
    168c:	45 2b       	or	r20, r21
    168e:	21 f4       	brne	.+8      	; 0x1698 <xQueueGenericReceive+0xb0>
    1690:	0f 90       	pop	r0
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	80 e0       	ldi	r24, 0x00	; 0
    1696:	4a c0       	rjmp	.+148    	; 0x172c <xQueueGenericReceive+0x144>
    1698:	a1 10       	cpse	r10, r1
    169a:	04 c0       	rjmp	.+8      	; 0x16a4 <xQueueGenericReceive+0xbc>
    169c:	ce 01       	movw	r24, r28
    169e:	01 96       	adiw	r24, 0x01	; 1
    16a0:	48 d4       	rcall	.+2192   	; 0x1f32 <vTaskSetTimeOutState>
    16a2:	a9 2c       	mov	r10, r9
    16a4:	0f 90       	pop	r0
    16a6:	0f be       	out	0x3f, r0	; 63
    16a8:	e8 d1       	rcall	.+976    	; 0x1a7a <vTaskSuspendAll>
    16aa:	0f b6       	in	r0, 0x3f	; 63
    16ac:	f8 94       	cli
    16ae:	0f 92       	push	r0
    16b0:	f8 01       	movw	r30, r16
    16b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    16b4:	8f 3f       	cpi	r24, 0xFF	; 255
    16b6:	09 f4       	brne	.+2      	; 0x16ba <xQueueGenericReceive+0xd2>
    16b8:	15 8e       	std	Z+29, r1	; 0x1d
    16ba:	f8 01       	movw	r30, r16
    16bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    16be:	8f 3f       	cpi	r24, 0xFF	; 255
    16c0:	09 f4       	brne	.+2      	; 0x16c4 <xQueueGenericReceive+0xdc>
    16c2:	16 8e       	std	Z+30, r1	; 0x1e
    16c4:	0f 90       	pop	r0
    16c6:	0f be       	out	0x3f, r0	; 63
    16c8:	be 01       	movw	r22, r28
    16ca:	6c 5f       	subi	r22, 0xFC	; 252
    16cc:	7f 4f       	sbci	r23, 0xFF	; 255
    16ce:	ce 01       	movw	r24, r28
    16d0:	01 96       	adiw	r24, 0x01	; 1
    16d2:	3a d4       	rcall	.+2164   	; 0x1f48 <xTaskCheckForTimeOut>
    16d4:	81 11       	cpse	r24, r1
    16d6:	26 c0       	rjmp	.+76     	; 0x1724 <xQueueGenericReceive+0x13c>
    16d8:	0f b6       	in	r0, 0x3f	; 63
    16da:	f8 94       	cli
    16dc:	0f 92       	push	r0
    16de:	f8 01       	movw	r30, r16
    16e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    16e2:	0f 90       	pop	r0
    16e4:	0f be       	out	0x3f, r0	; 63
    16e6:	81 11       	cpse	r24, r1
    16e8:	19 c0       	rjmp	.+50     	; 0x171c <xQueueGenericReceive+0x134>
    16ea:	f8 01       	movw	r30, r16
    16ec:	80 81       	ld	r24, Z
    16ee:	91 81       	ldd	r25, Z+1	; 0x01
    16f0:	89 2b       	or	r24, r25
    16f2:	49 f4       	brne	.+18     	; 0x1706 <xQueueGenericReceive+0x11e>
    16f4:	0f b6       	in	r0, 0x3f	; 63
    16f6:	f8 94       	cli
    16f8:	0f 92       	push	r0
    16fa:	f8 01       	movw	r30, r16
    16fc:	82 81       	ldd	r24, Z+2	; 0x02
    16fe:	93 81       	ldd	r25, Z+3	; 0x03
    1700:	67 d4       	rcall	.+2254   	; 0x1fd0 <vTaskPriorityInherit>
    1702:	0f 90       	pop	r0
    1704:	0f be       	out	0x3f, r0	; 63
    1706:	6c 81       	ldd	r22, Y+4	; 0x04
    1708:	7d 81       	ldd	r23, Y+5	; 0x05
    170a:	c7 01       	movw	r24, r14
    170c:	92 d3       	rcall	.+1828   	; 0x1e32 <vTaskPlaceOnEventList>
    170e:	c8 01       	movw	r24, r16
    1710:	d2 dd       	rcall	.-1116   	; 0x12b6 <prvUnlockQueue>
    1712:	7e d2       	rcall	.+1276   	; 0x1c10 <xTaskResumeAll>
    1714:	81 11       	cpse	r24, r1
    1716:	84 cf       	rjmp	.-248    	; 0x1620 <xQueueGenericReceive+0x38>
    1718:	48 dc       	rcall	.-1904   	; 0xfaa <vPortYield>
    171a:	82 cf       	rjmp	.-252    	; 0x1620 <xQueueGenericReceive+0x38>
    171c:	c8 01       	movw	r24, r16
    171e:	cb dd       	rcall	.-1130   	; 0x12b6 <prvUnlockQueue>
    1720:	77 d2       	rcall	.+1262   	; 0x1c10 <xTaskResumeAll>
    1722:	7e cf       	rjmp	.-260    	; 0x1620 <xQueueGenericReceive+0x38>
    1724:	c8 01       	movw	r24, r16
    1726:	c7 dd       	rcall	.-1138   	; 0x12b6 <prvUnlockQueue>
    1728:	73 d2       	rcall	.+1254   	; 0x1c10 <xTaskResumeAll>
    172a:	80 e0       	ldi	r24, 0x00	; 0
    172c:	0f 90       	pop	r0
    172e:	0f 90       	pop	r0
    1730:	0f 90       	pop	r0
    1732:	0f 90       	pop	r0
    1734:	0f 90       	pop	r0
    1736:	df 91       	pop	r29
    1738:	cf 91       	pop	r28
    173a:	1f 91       	pop	r17
    173c:	0f 91       	pop	r16
    173e:	ff 90       	pop	r15
    1740:	ef 90       	pop	r14
    1742:	df 90       	pop	r13
    1744:	cf 90       	pop	r12
    1746:	bf 90       	pop	r11
    1748:	af 90       	pop	r10
    174a:	9f 90       	pop	r9
    174c:	08 95       	ret

0000174e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
    174e:	cf 93       	push	r28
    1750:	df 93       	push	r29
    1752:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1754:	0f b6       	in	r0, 0x3f	; 63
    1756:	f8 94       	cli
    1758:	0f 92       	push	r0
    175a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    175c:	8f 3f       	cpi	r24, 0xFF	; 255
    175e:	09 f4       	brne	.+2      	; 0x1762 <vQueueWaitForMessageRestricted+0x14>
    1760:	1d 8e       	std	Y+29, r1	; 0x1d
    1762:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1764:	8f 3f       	cpi	r24, 0xFF	; 255
    1766:	09 f4       	brne	.+2      	; 0x176a <vQueueWaitForMessageRestricted+0x1c>
    1768:	1e 8e       	std	Y+30, r1	; 0x1e
    176a:	0f 90       	pop	r0
    176c:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    176e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1770:	81 11       	cpse	r24, r1
    1772:	03 c0       	rjmp	.+6      	; 0x177a <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1774:	ce 01       	movw	r24, r28
    1776:	41 96       	adiw	r24, 0x11	; 17
    1778:	78 d3       	rcall	.+1776   	; 0x1e6a <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    177a:	ce 01       	movw	r24, r28
    177c:	9c dd       	rcall	.-1224   	; 0x12b6 <prvUnlockQueue>
	}
    177e:	df 91       	pop	r29
    1780:	cf 91       	pop	r28
    1782:	08 95       	ret

00001784 <prvResetNextTaskUnblockTime>:
    1784:	e0 91 a9 0d 	lds	r30, 0x0DA9
    1788:	f0 91 aa 0d 	lds	r31, 0x0DAA
    178c:	80 81       	ld	r24, Z
    178e:	81 11       	cpse	r24, r1
    1790:	07 c0       	rjmp	.+14     	; 0x17a0 <prvResetNextTaskUnblockTime+0x1c>
    1792:	8f ef       	ldi	r24, 0xFF	; 255
    1794:	9f ef       	ldi	r25, 0xFF	; 255
    1796:	90 93 4a 02 	sts	0x024A, r25
    179a:	80 93 49 02 	sts	0x0249, r24
    179e:	08 95       	ret
    17a0:	e0 91 a9 0d 	lds	r30, 0x0DA9
    17a4:	f0 91 aa 0d 	lds	r31, 0x0DAA
    17a8:	05 80       	ldd	r0, Z+5	; 0x05
    17aa:	f6 81       	ldd	r31, Z+6	; 0x06
    17ac:	e0 2d       	mov	r30, r0
    17ae:	06 80       	ldd	r0, Z+6	; 0x06
    17b0:	f7 81       	ldd	r31, Z+7	; 0x07
    17b2:	e0 2d       	mov	r30, r0
    17b4:	82 81       	ldd	r24, Z+2	; 0x02
    17b6:	93 81       	ldd	r25, Z+3	; 0x03
    17b8:	90 93 4a 02 	sts	0x024A, r25
    17bc:	80 93 49 02 	sts	0x0249, r24
    17c0:	08 95       	ret

000017c2 <prvAddCurrentTaskToDelayedList>:
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	ec 01       	movw	r28, r24
    17c8:	e0 91 e1 0d 	lds	r30, 0x0DE1
    17cc:	f0 91 e2 0d 	lds	r31, 0x0DE2
    17d0:	93 83       	std	Z+3, r25	; 0x03
    17d2:	82 83       	std	Z+2, r24	; 0x02
    17d4:	80 91 91 0d 	lds	r24, 0x0D91
    17d8:	90 91 92 0d 	lds	r25, 0x0D92
    17dc:	c8 17       	cp	r28, r24
    17de:	d9 07       	cpc	r29, r25
    17e0:	60 f4       	brcc	.+24     	; 0x17fa <prvAddCurrentTaskToDelayedList+0x38>
    17e2:	60 91 e1 0d 	lds	r22, 0x0DE1
    17e6:	70 91 e2 0d 	lds	r23, 0x0DE2
    17ea:	80 91 a7 0d 	lds	r24, 0x0DA7
    17ee:	90 91 a8 0d 	lds	r25, 0x0DA8
    17f2:	6e 5f       	subi	r22, 0xFE	; 254
    17f4:	7f 4f       	sbci	r23, 0xFF	; 255
    17f6:	ca da       	rcall	.-2668   	; 0xd8c <vListInsert>
    17f8:	16 c0       	rjmp	.+44     	; 0x1826 <prvAddCurrentTaskToDelayedList+0x64>
    17fa:	60 91 e1 0d 	lds	r22, 0x0DE1
    17fe:	70 91 e2 0d 	lds	r23, 0x0DE2
    1802:	80 91 a9 0d 	lds	r24, 0x0DA9
    1806:	90 91 aa 0d 	lds	r25, 0x0DAA
    180a:	6e 5f       	subi	r22, 0xFE	; 254
    180c:	7f 4f       	sbci	r23, 0xFF	; 255
    180e:	be da       	rcall	.-2692   	; 0xd8c <vListInsert>
    1810:	80 91 49 02 	lds	r24, 0x0249
    1814:	90 91 4a 02 	lds	r25, 0x024A
    1818:	c8 17       	cp	r28, r24
    181a:	d9 07       	cpc	r29, r25
    181c:	20 f4       	brcc	.+8      	; 0x1826 <prvAddCurrentTaskToDelayedList+0x64>
    181e:	d0 93 4a 02 	sts	0x024A, r29
    1822:	c0 93 49 02 	sts	0x0249, r28
    1826:	df 91       	pop	r29
    1828:	cf 91       	pop	r28
    182a:	08 95       	ret

0000182c <xTaskGenericCreate>:
    182c:	4f 92       	push	r4
    182e:	5f 92       	push	r5
    1830:	6f 92       	push	r6
    1832:	7f 92       	push	r7
    1834:	8f 92       	push	r8
    1836:	9f 92       	push	r9
    1838:	af 92       	push	r10
    183a:	bf 92       	push	r11
    183c:	cf 92       	push	r12
    183e:	df 92       	push	r13
    1840:	ef 92       	push	r14
    1842:	ff 92       	push	r15
    1844:	0f 93       	push	r16
    1846:	1f 93       	push	r17
    1848:	cf 93       	push	r28
    184a:	df 93       	push	r29
    184c:	4c 01       	movw	r8, r24
    184e:	5b 01       	movw	r10, r22
    1850:	2a 01       	movw	r4, r20
    1852:	39 01       	movw	r6, r18
    1854:	c1 14       	cp	r12, r1
    1856:	d1 04       	cpc	r13, r1
    1858:	31 f4       	brne	.+12     	; 0x1866 <xTaskGenericCreate+0x3a>
    185a:	ca 01       	movw	r24, r20
    185c:	7d dc       	rcall	.-1798   	; 0x1158 <pvPortMalloc>
    185e:	6c 01       	movw	r12, r24
    1860:	00 97       	sbiw	r24, 0x00	; 0
    1862:	09 f4       	brne	.+2      	; 0x1866 <xTaskGenericCreate+0x3a>
    1864:	cc c0       	rjmp	.+408    	; 0x19fe <xTaskGenericCreate+0x1d2>
    1866:	88 e2       	ldi	r24, 0x28	; 40
    1868:	90 e0       	ldi	r25, 0x00	; 0
    186a:	76 dc       	rcall	.-1812   	; 0x1158 <pvPortMalloc>
    186c:	ec 01       	movw	r28, r24
    186e:	00 97       	sbiw	r24, 0x00	; 0
    1870:	71 f0       	breq	.+28     	; 0x188e <xTaskGenericCreate+0x62>
    1872:	d8 8e       	std	Y+24, r13	; 0x18
    1874:	cf 8a       	std	Y+23, r12	; 0x17
    1876:	81 e0       	ldi	r24, 0x01	; 1
    1878:	48 1a       	sub	r4, r24
    187a:	51 08       	sbc	r5, r1
    187c:	c4 0c       	add	r12, r4
    187e:	d5 1c       	adc	r13, r5
    1880:	d5 01       	movw	r26, r10
    1882:	8c 91       	ld	r24, X
    1884:	89 8f       	std	Y+25, r24	; 0x19
    1886:	8c 91       	ld	r24, X
    1888:	81 11       	cpse	r24, r1
    188a:	04 c0       	rjmp	.+8      	; 0x1894 <xTaskGenericCreate+0x68>
    188c:	14 c0       	rjmp	.+40     	; 0x18b6 <xTaskGenericCreate+0x8a>
    188e:	c6 01       	movw	r24, r12
    1890:	96 dc       	rcall	.-1748   	; 0x11be <vPortFree>
    1892:	b5 c0       	rjmp	.+362    	; 0x19fe <xTaskGenericCreate+0x1d2>
    1894:	ae 01       	movw	r20, r28
    1896:	46 5e       	subi	r20, 0xE6	; 230
    1898:	5f 4f       	sbci	r21, 0xFF	; 255
    189a:	f5 01       	movw	r30, r10
    189c:	31 96       	adiw	r30, 0x01	; 1
    189e:	27 e0       	ldi	r18, 0x07	; 7
    18a0:	cf 01       	movw	r24, r30
    18a2:	31 91       	ld	r19, Z+
    18a4:	da 01       	movw	r26, r20
    18a6:	3d 93       	st	X+, r19
    18a8:	ad 01       	movw	r20, r26
    18aa:	dc 01       	movw	r26, r24
    18ac:	8c 91       	ld	r24, X
    18ae:	88 23       	and	r24, r24
    18b0:	11 f0       	breq	.+4      	; 0x18b6 <xTaskGenericCreate+0x8a>
    18b2:	21 50       	subi	r18, 0x01	; 1
    18b4:	a9 f7       	brne	.-22     	; 0x18a0 <xTaskGenericCreate+0x74>
    18b6:	18 a2       	std	Y+32, r1	; 0x20
    18b8:	10 2f       	mov	r17, r16
    18ba:	04 30       	cpi	r16, 0x04	; 4
    18bc:	08 f0       	brcs	.+2      	; 0x18c0 <xTaskGenericCreate+0x94>
    18be:	13 e0       	ldi	r17, 0x03	; 3
    18c0:	1e 8b       	std	Y+22, r17	; 0x16
    18c2:	19 a3       	std	Y+33, r17	; 0x21
    18c4:	1a a2       	std	Y+34, r1	; 0x22
    18c6:	5e 01       	movw	r10, r28
    18c8:	b2 e0       	ldi	r27, 0x02	; 2
    18ca:	ab 0e       	add	r10, r27
    18cc:	b1 1c       	adc	r11, r1
    18ce:	c5 01       	movw	r24, r10
    18d0:	38 da       	rcall	.-2960   	; 0xd42 <vListInitialiseItem>
    18d2:	ce 01       	movw	r24, r28
    18d4:	0c 96       	adiw	r24, 0x0c	; 12
    18d6:	35 da       	rcall	.-2966   	; 0xd42 <vListInitialiseItem>
    18d8:	d9 87       	std	Y+9, r29	; 0x09
    18da:	c8 87       	std	Y+8, r28	; 0x08
    18dc:	84 e0       	ldi	r24, 0x04	; 4
    18de:	90 e0       	ldi	r25, 0x00	; 0
    18e0:	81 1b       	sub	r24, r17
    18e2:	91 09       	sbc	r25, r1
    18e4:	9d 87       	std	Y+13, r25	; 0x0d
    18e6:	8c 87       	std	Y+12, r24	; 0x0c
    18e8:	db 8b       	std	Y+19, r29	; 0x13
    18ea:	ca 8b       	std	Y+18, r28	; 0x12
    18ec:	1b a2       	std	Y+35, r1	; 0x23
    18ee:	1c a2       	std	Y+36, r1	; 0x24
    18f0:	1d a2       	std	Y+37, r1	; 0x25
    18f2:	1e a2       	std	Y+38, r1	; 0x26
    18f4:	1f a2       	std	Y+39, r1	; 0x27
    18f6:	a3 01       	movw	r20, r6
    18f8:	b4 01       	movw	r22, r8
    18fa:	c6 01       	movw	r24, r12
    18fc:	9e da       	rcall	.-2756   	; 0xe3a <pxPortInitialiseStack>
    18fe:	99 83       	std	Y+1, r25	; 0x01
    1900:	88 83       	st	Y, r24
    1902:	e1 14       	cp	r14, r1
    1904:	f1 04       	cpc	r15, r1
    1906:	19 f0       	breq	.+6      	; 0x190e <xTaskGenericCreate+0xe2>
    1908:	f7 01       	movw	r30, r14
    190a:	d1 83       	std	Z+1, r29	; 0x01
    190c:	c0 83       	st	Z, r28
    190e:	0f b6       	in	r0, 0x3f	; 63
    1910:	f8 94       	cli
    1912:	0f 92       	push	r0
    1914:	80 91 93 0d 	lds	r24, 0x0D93
    1918:	8f 5f       	subi	r24, 0xFF	; 255
    191a:	80 93 93 0d 	sts	0x0D93, r24
    191e:	80 91 e1 0d 	lds	r24, 0x0DE1
    1922:	90 91 e2 0d 	lds	r25, 0x0DE2
    1926:	89 2b       	or	r24, r25
    1928:	69 f5       	brne	.+90     	; 0x1984 <xTaskGenericCreate+0x158>
    192a:	d0 93 e2 0d 	sts	0x0DE2, r29
    192e:	c0 93 e1 0d 	sts	0x0DE1, r28
    1932:	80 91 93 0d 	lds	r24, 0x0D93
    1936:	81 30       	cpi	r24, 0x01	; 1
    1938:	a1 f5       	brne	.+104    	; 0x19a2 <xTaskGenericCreate+0x176>
    193a:	8d eb       	ldi	r24, 0xBD	; 189
    193c:	9d e0       	ldi	r25, 0x0D	; 13
    193e:	f3 d9       	rcall	.-3098   	; 0xd26 <vListInitialise>
    1940:	86 ec       	ldi	r24, 0xC6	; 198
    1942:	9d e0       	ldi	r25, 0x0D	; 13
    1944:	f0 d9       	rcall	.-3104   	; 0xd26 <vListInitialise>
    1946:	8f ec       	ldi	r24, 0xCF	; 207
    1948:	9d e0       	ldi	r25, 0x0D	; 13
    194a:	ed d9       	rcall	.-3110   	; 0xd26 <vListInitialise>
    194c:	88 ed       	ldi	r24, 0xD8	; 216
    194e:	9d e0       	ldi	r25, 0x0D	; 13
    1950:	ea d9       	rcall	.-3116   	; 0xd26 <vListInitialise>
    1952:	84 eb       	ldi	r24, 0xB4	; 180
    1954:	9d e0       	ldi	r25, 0x0D	; 13
    1956:	e7 d9       	rcall	.-3122   	; 0xd26 <vListInitialise>
    1958:	8b ea       	ldi	r24, 0xAB	; 171
    195a:	9d e0       	ldi	r25, 0x0D	; 13
    195c:	e4 d9       	rcall	.-3128   	; 0xd26 <vListInitialise>
    195e:	8e e9       	ldi	r24, 0x9E	; 158
    1960:	9d e0       	ldi	r25, 0x0D	; 13
    1962:	e1 d9       	rcall	.-3134   	; 0xd26 <vListInitialise>
    1964:	85 e9       	ldi	r24, 0x95	; 149
    1966:	9d e0       	ldi	r25, 0x0D	; 13
    1968:	de d9       	rcall	.-3140   	; 0xd26 <vListInitialise>
    196a:	84 eb       	ldi	r24, 0xB4	; 180
    196c:	9d e0       	ldi	r25, 0x0D	; 13
    196e:	90 93 aa 0d 	sts	0x0DAA, r25
    1972:	80 93 a9 0d 	sts	0x0DA9, r24
    1976:	8b ea       	ldi	r24, 0xAB	; 171
    1978:	9d e0       	ldi	r25, 0x0D	; 13
    197a:	90 93 a8 0d 	sts	0x0DA8, r25
    197e:	80 93 a7 0d 	sts	0x0DA7, r24
    1982:	0f c0       	rjmp	.+30     	; 0x19a2 <xTaskGenericCreate+0x176>
    1984:	80 91 8f 0d 	lds	r24, 0x0D8F
    1988:	81 11       	cpse	r24, r1
    198a:	0b c0       	rjmp	.+22     	; 0x19a2 <xTaskGenericCreate+0x176>
    198c:	e0 91 e1 0d 	lds	r30, 0x0DE1
    1990:	f0 91 e2 0d 	lds	r31, 0x0DE2
    1994:	86 89       	ldd	r24, Z+22	; 0x16
    1996:	08 17       	cp	r16, r24
    1998:	20 f0       	brcs	.+8      	; 0x19a2 <xTaskGenericCreate+0x176>
    199a:	d0 93 e2 0d 	sts	0x0DE2, r29
    199e:	c0 93 e1 0d 	sts	0x0DE1, r28
    19a2:	80 91 8b 0d 	lds	r24, 0x0D8B
    19a6:	8f 5f       	subi	r24, 0xFF	; 255
    19a8:	80 93 8b 0d 	sts	0x0D8B, r24
    19ac:	8e 89       	ldd	r24, Y+22	; 0x16
    19ae:	90 91 90 0d 	lds	r25, 0x0D90
    19b2:	98 17       	cp	r25, r24
    19b4:	10 f4       	brcc	.+4      	; 0x19ba <xTaskGenericCreate+0x18e>
    19b6:	80 93 90 0d 	sts	0x0D90, r24
    19ba:	90 e0       	ldi	r25, 0x00	; 0
    19bc:	9c 01       	movw	r18, r24
    19be:	22 0f       	add	r18, r18
    19c0:	33 1f       	adc	r19, r19
    19c2:	22 0f       	add	r18, r18
    19c4:	33 1f       	adc	r19, r19
    19c6:	22 0f       	add	r18, r18
    19c8:	33 1f       	adc	r19, r19
    19ca:	82 0f       	add	r24, r18
    19cc:	93 1f       	adc	r25, r19
    19ce:	b5 01       	movw	r22, r10
    19d0:	83 54       	subi	r24, 0x43	; 67
    19d2:	92 4f       	sbci	r25, 0xF2	; 242
    19d4:	ba d9       	rcall	.-3212   	; 0xd4a <vListInsertEnd>
    19d6:	0f 90       	pop	r0
    19d8:	0f be       	out	0x3f, r0	; 63
    19da:	80 91 8f 0d 	lds	r24, 0x0D8F
    19de:	88 23       	and	r24, r24
    19e0:	51 f0       	breq	.+20     	; 0x19f6 <xTaskGenericCreate+0x1ca>
    19e2:	e0 91 e1 0d 	lds	r30, 0x0DE1
    19e6:	f0 91 e2 0d 	lds	r31, 0x0DE2
    19ea:	86 89       	ldd	r24, Z+22	; 0x16
    19ec:	80 17       	cp	r24, r16
    19ee:	28 f4       	brcc	.+10     	; 0x19fa <xTaskGenericCreate+0x1ce>
    19f0:	dc da       	rcall	.-2632   	; 0xfaa <vPortYield>
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	05 c0       	rjmp	.+10     	; 0x1a00 <xTaskGenericCreate+0x1d4>
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	03 c0       	rjmp	.+6      	; 0x1a00 <xTaskGenericCreate+0x1d4>
    19fa:	81 e0       	ldi	r24, 0x01	; 1
    19fc:	01 c0       	rjmp	.+2      	; 0x1a00 <xTaskGenericCreate+0x1d4>
    19fe:	8f ef       	ldi	r24, 0xFF	; 255
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	1f 91       	pop	r17
    1a06:	0f 91       	pop	r16
    1a08:	ff 90       	pop	r15
    1a0a:	ef 90       	pop	r14
    1a0c:	df 90       	pop	r13
    1a0e:	cf 90       	pop	r12
    1a10:	bf 90       	pop	r11
    1a12:	af 90       	pop	r10
    1a14:	9f 90       	pop	r9
    1a16:	8f 90       	pop	r8
    1a18:	7f 90       	pop	r7
    1a1a:	6f 90       	pop	r6
    1a1c:	5f 90       	pop	r5
    1a1e:	4f 90       	pop	r4
    1a20:	08 95       	ret

00001a22 <vTaskStartScheduler>:
    1a22:	af 92       	push	r10
    1a24:	bf 92       	push	r11
    1a26:	cf 92       	push	r12
    1a28:	df 92       	push	r13
    1a2a:	ef 92       	push	r14
    1a2c:	ff 92       	push	r15
    1a2e:	0f 93       	push	r16
    1a30:	a1 2c       	mov	r10, r1
    1a32:	b1 2c       	mov	r11, r1
    1a34:	c1 2c       	mov	r12, r1
    1a36:	d1 2c       	mov	r13, r1
    1a38:	e1 2c       	mov	r14, r1
    1a3a:	f1 2c       	mov	r15, r1
    1a3c:	00 e0       	ldi	r16, 0x00	; 0
    1a3e:	20 e0       	ldi	r18, 0x00	; 0
    1a40:	30 e0       	ldi	r19, 0x00	; 0
    1a42:	49 eb       	ldi	r20, 0xB9	; 185
    1a44:	50 e0       	ldi	r21, 0x00	; 0
    1a46:	66 e8       	ldi	r22, 0x86	; 134
    1a48:	72 e0       	ldi	r23, 0x02	; 2
    1a4a:	85 e9       	ldi	r24, 0x95	; 149
    1a4c:	90 e0       	ldi	r25, 0x00	; 0
    1a4e:	ee de       	rcall	.-548    	; 0x182c <xTaskGenericCreate>
    1a50:	81 30       	cpi	r24, 0x01	; 1
    1a52:	59 f4       	brne	.+22     	; 0x1a6a <vTaskStartScheduler+0x48>
    1a54:	c3 d3       	rcall	.+1926   	; 0x21dc <xTimerCreateTimerTask>
    1a56:	81 30       	cpi	r24, 0x01	; 1
    1a58:	41 f4       	brne	.+16     	; 0x1a6a <vTaskStartScheduler+0x48>
    1a5a:	f8 94       	cli
    1a5c:	80 93 8f 0d 	sts	0x0D8F, r24
    1a60:	10 92 92 0d 	sts	0x0D92, r1
    1a64:	10 92 91 0d 	sts	0x0D91, r1
    1a68:	5a da       	rcall	.-2892   	; 0xf1e <xPortStartScheduler>
    1a6a:	0f 91       	pop	r16
    1a6c:	ff 90       	pop	r15
    1a6e:	ef 90       	pop	r14
    1a70:	df 90       	pop	r13
    1a72:	cf 90       	pop	r12
    1a74:	bf 90       	pop	r11
    1a76:	af 90       	pop	r10
    1a78:	08 95       	ret

00001a7a <vTaskSuspendAll>:
    1a7a:	80 91 8a 0d 	lds	r24, 0x0D8A
    1a7e:	8f 5f       	subi	r24, 0xFF	; 255
    1a80:	80 93 8a 0d 	sts	0x0D8A, r24
    1a84:	08 95       	ret

00001a86 <xTaskGetTickCount>:
    1a86:	0f b6       	in	r0, 0x3f	; 63
    1a88:	f8 94       	cli
    1a8a:	0f 92       	push	r0
    1a8c:	80 91 91 0d 	lds	r24, 0x0D91
    1a90:	90 91 92 0d 	lds	r25, 0x0D92
    1a94:	0f 90       	pop	r0
    1a96:	0f be       	out	0x3f, r0	; 63
    1a98:	08 95       	ret

00001a9a <xTaskIncrementTick>:
    1a9a:	cf 92       	push	r12
    1a9c:	df 92       	push	r13
    1a9e:	ef 92       	push	r14
    1aa0:	ff 92       	push	r15
    1aa2:	0f 93       	push	r16
    1aa4:	1f 93       	push	r17
    1aa6:	cf 93       	push	r28
    1aa8:	df 93       	push	r29
    1aaa:	80 91 8a 0d 	lds	r24, 0x0D8A
    1aae:	81 11       	cpse	r24, r1
    1ab0:	96 c0       	rjmp	.+300    	; 0x1bde <xTaskIncrementTick+0x144>
    1ab2:	80 91 91 0d 	lds	r24, 0x0D91
    1ab6:	90 91 92 0d 	lds	r25, 0x0D92
    1aba:	01 96       	adiw	r24, 0x01	; 1
    1abc:	90 93 92 0d 	sts	0x0D92, r25
    1ac0:	80 93 91 0d 	sts	0x0D91, r24
    1ac4:	e0 90 91 0d 	lds	r14, 0x0D91
    1ac8:	f0 90 92 0d 	lds	r15, 0x0D92
    1acc:	e1 14       	cp	r14, r1
    1ace:	f1 04       	cpc	r15, r1
    1ad0:	b1 f4       	brne	.+44     	; 0x1afe <xTaskIncrementTick+0x64>
    1ad2:	80 91 a9 0d 	lds	r24, 0x0DA9
    1ad6:	90 91 aa 0d 	lds	r25, 0x0DAA
    1ada:	20 91 a7 0d 	lds	r18, 0x0DA7
    1ade:	30 91 a8 0d 	lds	r19, 0x0DA8
    1ae2:	30 93 aa 0d 	sts	0x0DAA, r19
    1ae6:	20 93 a9 0d 	sts	0x0DA9, r18
    1aea:	90 93 a8 0d 	sts	0x0DA8, r25
    1aee:	80 93 a7 0d 	sts	0x0DA7, r24
    1af2:	80 91 8c 0d 	lds	r24, 0x0D8C
    1af6:	8f 5f       	subi	r24, 0xFF	; 255
    1af8:	80 93 8c 0d 	sts	0x0D8C, r24
    1afc:	43 de       	rcall	.-890    	; 0x1784 <prvResetNextTaskUnblockTime>
    1afe:	80 91 49 02 	lds	r24, 0x0249
    1b02:	90 91 4a 02 	lds	r25, 0x024A
    1b06:	e8 16       	cp	r14, r24
    1b08:	f9 06       	cpc	r15, r25
    1b0a:	08 f4       	brcc	.+2      	; 0x1b0e <xTaskIncrementTick+0x74>
    1b0c:	51 c0       	rjmp	.+162    	; 0x1bb0 <xTaskIncrementTick+0x116>
    1b0e:	d1 2c       	mov	r13, r1
    1b10:	cc 24       	eor	r12, r12
    1b12:	c3 94       	inc	r12
    1b14:	01 c0       	rjmp	.+2      	; 0x1b18 <xTaskIncrementTick+0x7e>
    1b16:	dc 2c       	mov	r13, r12
    1b18:	e0 91 a9 0d 	lds	r30, 0x0DA9
    1b1c:	f0 91 aa 0d 	lds	r31, 0x0DAA
    1b20:	80 81       	ld	r24, Z
    1b22:	81 11       	cpse	r24, r1
    1b24:	07 c0       	rjmp	.+14     	; 0x1b34 <xTaskIncrementTick+0x9a>
    1b26:	8f ef       	ldi	r24, 0xFF	; 255
    1b28:	9f ef       	ldi	r25, 0xFF	; 255
    1b2a:	90 93 4a 02 	sts	0x024A, r25
    1b2e:	80 93 49 02 	sts	0x0249, r24
    1b32:	3f c0       	rjmp	.+126    	; 0x1bb2 <xTaskIncrementTick+0x118>
    1b34:	e0 91 a9 0d 	lds	r30, 0x0DA9
    1b38:	f0 91 aa 0d 	lds	r31, 0x0DAA
    1b3c:	05 80       	ldd	r0, Z+5	; 0x05
    1b3e:	f6 81       	ldd	r31, Z+6	; 0x06
    1b40:	e0 2d       	mov	r30, r0
    1b42:	c6 81       	ldd	r28, Z+6	; 0x06
    1b44:	d7 81       	ldd	r29, Z+7	; 0x07
    1b46:	2a 81       	ldd	r18, Y+2	; 0x02
    1b48:	3b 81       	ldd	r19, Y+3	; 0x03
    1b4a:	e2 16       	cp	r14, r18
    1b4c:	f3 06       	cpc	r15, r19
    1b4e:	28 f4       	brcc	.+10     	; 0x1b5a <xTaskIncrementTick+0xc0>
    1b50:	30 93 4a 02 	sts	0x024A, r19
    1b54:	20 93 49 02 	sts	0x0249, r18
    1b58:	2c c0       	rjmp	.+88     	; 0x1bb2 <xTaskIncrementTick+0x118>
    1b5a:	8e 01       	movw	r16, r28
    1b5c:	0e 5f       	subi	r16, 0xFE	; 254
    1b5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b60:	c8 01       	movw	r24, r16
    1b62:	45 d9       	rcall	.-3446   	; 0xdee <uxListRemove>
    1b64:	8c 89       	ldd	r24, Y+20	; 0x14
    1b66:	9d 89       	ldd	r25, Y+21	; 0x15
    1b68:	89 2b       	or	r24, r25
    1b6a:	19 f0       	breq	.+6      	; 0x1b72 <xTaskIncrementTick+0xd8>
    1b6c:	ce 01       	movw	r24, r28
    1b6e:	0c 96       	adiw	r24, 0x0c	; 12
    1b70:	3e d9       	rcall	.-3460   	; 0xdee <uxListRemove>
    1b72:	2e 89       	ldd	r18, Y+22	; 0x16
    1b74:	80 91 90 0d 	lds	r24, 0x0D90
    1b78:	82 17       	cp	r24, r18
    1b7a:	10 f4       	brcc	.+4      	; 0x1b80 <xTaskIncrementTick+0xe6>
    1b7c:	20 93 90 0d 	sts	0x0D90, r18
    1b80:	30 e0       	ldi	r19, 0x00	; 0
    1b82:	c9 01       	movw	r24, r18
    1b84:	88 0f       	add	r24, r24
    1b86:	99 1f       	adc	r25, r25
    1b88:	88 0f       	add	r24, r24
    1b8a:	99 1f       	adc	r25, r25
    1b8c:	88 0f       	add	r24, r24
    1b8e:	99 1f       	adc	r25, r25
    1b90:	82 0f       	add	r24, r18
    1b92:	93 1f       	adc	r25, r19
    1b94:	b8 01       	movw	r22, r16
    1b96:	83 54       	subi	r24, 0x43	; 67
    1b98:	92 4f       	sbci	r25, 0xF2	; 242
    1b9a:	d7 d8       	rcall	.-3666   	; 0xd4a <vListInsertEnd>
    1b9c:	e0 91 e1 0d 	lds	r30, 0x0DE1
    1ba0:	f0 91 e2 0d 	lds	r31, 0x0DE2
    1ba4:	9e 89       	ldd	r25, Y+22	; 0x16
    1ba6:	86 89       	ldd	r24, Z+22	; 0x16
    1ba8:	98 17       	cp	r25, r24
    1baa:	08 f0       	brcs	.+2      	; 0x1bae <xTaskIncrementTick+0x114>
    1bac:	b4 cf       	rjmp	.-152    	; 0x1b16 <xTaskIncrementTick+0x7c>
    1bae:	b4 cf       	rjmp	.-152    	; 0x1b18 <xTaskIncrementTick+0x7e>
    1bb0:	d1 2c       	mov	r13, r1
    1bb2:	e0 91 e1 0d 	lds	r30, 0x0DE1
    1bb6:	f0 91 e2 0d 	lds	r31, 0x0DE2
    1bba:	86 89       	ldd	r24, Z+22	; 0x16
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	fc 01       	movw	r30, r24
    1bc0:	ee 0f       	add	r30, r30
    1bc2:	ff 1f       	adc	r31, r31
    1bc4:	ee 0f       	add	r30, r30
    1bc6:	ff 1f       	adc	r31, r31
    1bc8:	ee 0f       	add	r30, r30
    1bca:	ff 1f       	adc	r31, r31
    1bcc:	8e 0f       	add	r24, r30
    1bce:	9f 1f       	adc	r25, r31
    1bd0:	fc 01       	movw	r30, r24
    1bd2:	e3 54       	subi	r30, 0x43	; 67
    1bd4:	f2 4f       	sbci	r31, 0xF2	; 242
    1bd6:	80 81       	ld	r24, Z
    1bd8:	82 30       	cpi	r24, 0x02	; 2
    1bda:	40 f4       	brcc	.+16     	; 0x1bec <xTaskIncrementTick+0x152>
    1bdc:	09 c0       	rjmp	.+18     	; 0x1bf0 <xTaskIncrementTick+0x156>
    1bde:	80 91 8e 0d 	lds	r24, 0x0D8E
    1be2:	8f 5f       	subi	r24, 0xFF	; 255
    1be4:	80 93 8e 0d 	sts	0x0D8E, r24
    1be8:	d1 2c       	mov	r13, r1
    1bea:	02 c0       	rjmp	.+4      	; 0x1bf0 <xTaskIncrementTick+0x156>
    1bec:	dd 24       	eor	r13, r13
    1bee:	d3 94       	inc	r13
    1bf0:	80 91 8d 0d 	lds	r24, 0x0D8D
    1bf4:	88 23       	and	r24, r24
    1bf6:	11 f0       	breq	.+4      	; 0x1bfc <xTaskIncrementTick+0x162>
    1bf8:	dd 24       	eor	r13, r13
    1bfa:	d3 94       	inc	r13
    1bfc:	8d 2d       	mov	r24, r13
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	ff 90       	pop	r15
    1c08:	ef 90       	pop	r14
    1c0a:	df 90       	pop	r13
    1c0c:	cf 90       	pop	r12
    1c0e:	08 95       	ret

00001c10 <xTaskResumeAll>:
    1c10:	df 92       	push	r13
    1c12:	ef 92       	push	r14
    1c14:	ff 92       	push	r15
    1c16:	0f 93       	push	r16
    1c18:	1f 93       	push	r17
    1c1a:	cf 93       	push	r28
    1c1c:	df 93       	push	r29
    1c1e:	0f b6       	in	r0, 0x3f	; 63
    1c20:	f8 94       	cli
    1c22:	0f 92       	push	r0
    1c24:	80 91 8a 0d 	lds	r24, 0x0D8A
    1c28:	81 50       	subi	r24, 0x01	; 1
    1c2a:	80 93 8a 0d 	sts	0x0D8A, r24
    1c2e:	80 91 8a 0d 	lds	r24, 0x0D8A
    1c32:	81 11       	cpse	r24, r1
    1c34:	5c c0       	rjmp	.+184    	; 0x1cee <xTaskResumeAll+0xde>
    1c36:	80 91 93 0d 	lds	r24, 0x0D93
    1c3a:	88 23       	and	r24, r24
    1c3c:	09 f4       	brne	.+2      	; 0x1c40 <xTaskResumeAll+0x30>
    1c3e:	59 c0       	rjmp	.+178    	; 0x1cf2 <xTaskResumeAll+0xe2>
    1c40:	0f 2e       	mov	r0, r31
    1c42:	fe e9       	ldi	r31, 0x9E	; 158
    1c44:	ef 2e       	mov	r14, r31
    1c46:	fd e0       	ldi	r31, 0x0D	; 13
    1c48:	ff 2e       	mov	r15, r31
    1c4a:	f0 2d       	mov	r31, r0
    1c4c:	dd 24       	eor	r13, r13
    1c4e:	d3 94       	inc	r13
    1c50:	2d c0       	rjmp	.+90     	; 0x1cac <xTaskResumeAll+0x9c>
    1c52:	e0 91 a3 0d 	lds	r30, 0x0DA3
    1c56:	f0 91 a4 0d 	lds	r31, 0x0DA4
    1c5a:	c6 81       	ldd	r28, Z+6	; 0x06
    1c5c:	d7 81       	ldd	r29, Z+7	; 0x07
    1c5e:	ce 01       	movw	r24, r28
    1c60:	0c 96       	adiw	r24, 0x0c	; 12
    1c62:	c5 d8       	rcall	.-3702   	; 0xdee <uxListRemove>
    1c64:	8e 01       	movw	r16, r28
    1c66:	0e 5f       	subi	r16, 0xFE	; 254
    1c68:	1f 4f       	sbci	r17, 0xFF	; 255
    1c6a:	c8 01       	movw	r24, r16
    1c6c:	c0 d8       	rcall	.-3712   	; 0xdee <uxListRemove>
    1c6e:	8e 89       	ldd	r24, Y+22	; 0x16
    1c70:	90 91 90 0d 	lds	r25, 0x0D90
    1c74:	98 17       	cp	r25, r24
    1c76:	10 f4       	brcc	.+4      	; 0x1c7c <xTaskResumeAll+0x6c>
    1c78:	80 93 90 0d 	sts	0x0D90, r24
    1c7c:	90 e0       	ldi	r25, 0x00	; 0
    1c7e:	9c 01       	movw	r18, r24
    1c80:	22 0f       	add	r18, r18
    1c82:	33 1f       	adc	r19, r19
    1c84:	22 0f       	add	r18, r18
    1c86:	33 1f       	adc	r19, r19
    1c88:	22 0f       	add	r18, r18
    1c8a:	33 1f       	adc	r19, r19
    1c8c:	82 0f       	add	r24, r18
    1c8e:	93 1f       	adc	r25, r19
    1c90:	b8 01       	movw	r22, r16
    1c92:	83 54       	subi	r24, 0x43	; 67
    1c94:	92 4f       	sbci	r25, 0xF2	; 242
    1c96:	59 d8       	rcall	.-3918   	; 0xd4a <vListInsertEnd>
    1c98:	e0 91 e1 0d 	lds	r30, 0x0DE1
    1c9c:	f0 91 e2 0d 	lds	r31, 0x0DE2
    1ca0:	9e 89       	ldd	r25, Y+22	; 0x16
    1ca2:	86 89       	ldd	r24, Z+22	; 0x16
    1ca4:	98 17       	cp	r25, r24
    1ca6:	10 f0       	brcs	.+4      	; 0x1cac <xTaskResumeAll+0x9c>
    1ca8:	d0 92 8d 0d 	sts	0x0D8D, r13
    1cac:	f7 01       	movw	r30, r14
    1cae:	80 81       	ld	r24, Z
    1cb0:	81 11       	cpse	r24, r1
    1cb2:	cf cf       	rjmp	.-98     	; 0x1c52 <xTaskResumeAll+0x42>
    1cb4:	80 91 8e 0d 	lds	r24, 0x0D8E
    1cb8:	88 23       	and	r24, r24
    1cba:	91 f0       	breq	.+36     	; 0x1ce0 <xTaskResumeAll+0xd0>
    1cbc:	80 91 8e 0d 	lds	r24, 0x0D8E
    1cc0:	88 23       	and	r24, r24
    1cc2:	71 f0       	breq	.+28     	; 0x1ce0 <xTaskResumeAll+0xd0>
    1cc4:	c1 e0       	ldi	r28, 0x01	; 1
    1cc6:	e9 de       	rcall	.-558    	; 0x1a9a <xTaskIncrementTick>
    1cc8:	81 11       	cpse	r24, r1
    1cca:	c0 93 8d 0d 	sts	0x0D8D, r28
    1cce:	80 91 8e 0d 	lds	r24, 0x0D8E
    1cd2:	81 50       	subi	r24, 0x01	; 1
    1cd4:	80 93 8e 0d 	sts	0x0D8E, r24
    1cd8:	80 91 8e 0d 	lds	r24, 0x0D8E
    1cdc:	81 11       	cpse	r24, r1
    1cde:	f3 cf       	rjmp	.-26     	; 0x1cc6 <xTaskResumeAll+0xb6>
    1ce0:	80 91 8d 0d 	lds	r24, 0x0D8D
    1ce4:	81 30       	cpi	r24, 0x01	; 1
    1ce6:	39 f4       	brne	.+14     	; 0x1cf6 <xTaskResumeAll+0xe6>
    1ce8:	60 d9       	rcall	.-3392   	; 0xfaa <vPortYield>
    1cea:	81 e0       	ldi	r24, 0x01	; 1
    1cec:	05 c0       	rjmp	.+10     	; 0x1cf8 <xTaskResumeAll+0xe8>
    1cee:	80 e0       	ldi	r24, 0x00	; 0
    1cf0:	03 c0       	rjmp	.+6      	; 0x1cf8 <xTaskResumeAll+0xe8>
    1cf2:	80 e0       	ldi	r24, 0x00	; 0
    1cf4:	01 c0       	rjmp	.+2      	; 0x1cf8 <xTaskResumeAll+0xe8>
    1cf6:	80 e0       	ldi	r24, 0x00	; 0
    1cf8:	0f 90       	pop	r0
    1cfa:	0f be       	out	0x3f, r0	; 63
    1cfc:	df 91       	pop	r29
    1cfe:	cf 91       	pop	r28
    1d00:	1f 91       	pop	r17
    1d02:	0f 91       	pop	r16
    1d04:	ff 90       	pop	r15
    1d06:	ef 90       	pop	r14
    1d08:	df 90       	pop	r13
    1d0a:	08 95       	ret

00001d0c <vTaskDelay>:
    1d0c:	cf 93       	push	r28
    1d0e:	df 93       	push	r29
    1d10:	ec 01       	movw	r28, r24
    1d12:	00 97       	sbiw	r24, 0x00	; 0
    1d14:	91 f0       	breq	.+36     	; 0x1d3a <vTaskDelay+0x2e>
    1d16:	b1 de       	rcall	.-670    	; 0x1a7a <vTaskSuspendAll>
    1d18:	80 91 91 0d 	lds	r24, 0x0D91
    1d1c:	90 91 92 0d 	lds	r25, 0x0D92
    1d20:	c8 0f       	add	r28, r24
    1d22:	d9 1f       	adc	r29, r25
    1d24:	80 91 e1 0d 	lds	r24, 0x0DE1
    1d28:	90 91 e2 0d 	lds	r25, 0x0DE2
    1d2c:	02 96       	adiw	r24, 0x02	; 2
    1d2e:	5f d8       	rcall	.-3906   	; 0xdee <uxListRemove>
    1d30:	ce 01       	movw	r24, r28
    1d32:	47 dd       	rcall	.-1394   	; 0x17c2 <prvAddCurrentTaskToDelayedList>
    1d34:	6d df       	rcall	.-294    	; 0x1c10 <xTaskResumeAll>
    1d36:	81 11       	cpse	r24, r1
    1d38:	01 c0       	rjmp	.+2      	; 0x1d3c <vTaskDelay+0x30>
    1d3a:	37 d9       	rcall	.-3474   	; 0xfaa <vPortYield>
    1d3c:	df 91       	pop	r29
    1d3e:	cf 91       	pop	r28
    1d40:	08 95       	ret

00001d42 <vTaskSwitchContext>:
    1d42:	80 91 8a 0d 	lds	r24, 0x0D8A
    1d46:	88 23       	and	r24, r24
    1d48:	21 f0       	breq	.+8      	; 0x1d52 <vTaskSwitchContext+0x10>
    1d4a:	81 e0       	ldi	r24, 0x01	; 1
    1d4c:	80 93 8d 0d 	sts	0x0D8D, r24
    1d50:	08 95       	ret
    1d52:	10 92 8d 0d 	sts	0x0D8D, r1
    1d56:	a0 91 e1 0d 	lds	r26, 0x0DE1
    1d5a:	b0 91 e2 0d 	lds	r27, 0x0DE2
    1d5e:	e0 91 e1 0d 	lds	r30, 0x0DE1
    1d62:	f0 91 e2 0d 	lds	r31, 0x0DE2
    1d66:	2d 91       	ld	r18, X+
    1d68:	3c 91       	ld	r19, X
    1d6a:	87 89       	ldd	r24, Z+23	; 0x17
    1d6c:	90 8d       	ldd	r25, Z+24	; 0x18
    1d6e:	82 17       	cp	r24, r18
    1d70:	93 07       	cpc	r25, r19
    1d72:	58 f0       	brcs	.+22     	; 0x1d8a <vTaskSwitchContext+0x48>
    1d74:	60 91 e1 0d 	lds	r22, 0x0DE1
    1d78:	70 91 e2 0d 	lds	r23, 0x0DE2
    1d7c:	80 91 e1 0d 	lds	r24, 0x0DE1
    1d80:	90 91 e2 0d 	lds	r25, 0x0DE2
    1d84:	67 5e       	subi	r22, 0xE7	; 231
    1d86:	7f 4f       	sbci	r23, 0xFF	; 255
    1d88:	70 d6       	rcall	.+3296   	; 0x2a6a <vApplicationStackOverflowHook>
    1d8a:	80 91 90 0d 	lds	r24, 0x0D90
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	fc 01       	movw	r30, r24
    1d92:	ee 0f       	add	r30, r30
    1d94:	ff 1f       	adc	r31, r31
    1d96:	ee 0f       	add	r30, r30
    1d98:	ff 1f       	adc	r31, r31
    1d9a:	ee 0f       	add	r30, r30
    1d9c:	ff 1f       	adc	r31, r31
    1d9e:	8e 0f       	add	r24, r30
    1da0:	9f 1f       	adc	r25, r31
    1da2:	fc 01       	movw	r30, r24
    1da4:	e3 54       	subi	r30, 0x43	; 67
    1da6:	f2 4f       	sbci	r31, 0xF2	; 242
    1da8:	80 81       	ld	r24, Z
    1daa:	81 11       	cpse	r24, r1
    1dac:	17 c0       	rjmp	.+46     	; 0x1ddc <vTaskSwitchContext+0x9a>
    1dae:	80 91 90 0d 	lds	r24, 0x0D90
    1db2:	81 50       	subi	r24, 0x01	; 1
    1db4:	80 93 90 0d 	sts	0x0D90, r24
    1db8:	80 91 90 0d 	lds	r24, 0x0D90
    1dbc:	90 e0       	ldi	r25, 0x00	; 0
    1dbe:	fc 01       	movw	r30, r24
    1dc0:	ee 0f       	add	r30, r30
    1dc2:	ff 1f       	adc	r31, r31
    1dc4:	ee 0f       	add	r30, r30
    1dc6:	ff 1f       	adc	r31, r31
    1dc8:	ee 0f       	add	r30, r30
    1dca:	ff 1f       	adc	r31, r31
    1dcc:	8e 0f       	add	r24, r30
    1dce:	9f 1f       	adc	r25, r31
    1dd0:	fc 01       	movw	r30, r24
    1dd2:	e3 54       	subi	r30, 0x43	; 67
    1dd4:	f2 4f       	sbci	r31, 0xF2	; 242
    1dd6:	80 81       	ld	r24, Z
    1dd8:	88 23       	and	r24, r24
    1dda:	49 f3       	breq	.-46     	; 0x1dae <vTaskSwitchContext+0x6c>
    1ddc:	e0 91 90 0d 	lds	r30, 0x0D90
    1de0:	f0 e0       	ldi	r31, 0x00	; 0
    1de2:	cf 01       	movw	r24, r30
    1de4:	88 0f       	add	r24, r24
    1de6:	99 1f       	adc	r25, r25
    1de8:	88 0f       	add	r24, r24
    1dea:	99 1f       	adc	r25, r25
    1dec:	88 0f       	add	r24, r24
    1dee:	99 1f       	adc	r25, r25
    1df0:	e8 0f       	add	r30, r24
    1df2:	f9 1f       	adc	r31, r25
    1df4:	e3 54       	subi	r30, 0x43	; 67
    1df6:	f2 4f       	sbci	r31, 0xF2	; 242
    1df8:	a1 81       	ldd	r26, Z+1	; 0x01
    1dfa:	b2 81       	ldd	r27, Z+2	; 0x02
    1dfc:	12 96       	adiw	r26, 0x02	; 2
    1dfe:	0d 90       	ld	r0, X+
    1e00:	bc 91       	ld	r27, X
    1e02:	a0 2d       	mov	r26, r0
    1e04:	b2 83       	std	Z+2, r27	; 0x02
    1e06:	a1 83       	std	Z+1, r26	; 0x01
    1e08:	cf 01       	movw	r24, r30
    1e0a:	03 96       	adiw	r24, 0x03	; 3
    1e0c:	a8 17       	cp	r26, r24
    1e0e:	b9 07       	cpc	r27, r25
    1e10:	31 f4       	brne	.+12     	; 0x1e1e <vTaskSwitchContext+0xdc>
    1e12:	12 96       	adiw	r26, 0x02	; 2
    1e14:	8d 91       	ld	r24, X+
    1e16:	9c 91       	ld	r25, X
    1e18:	13 97       	sbiw	r26, 0x03	; 3
    1e1a:	92 83       	std	Z+2, r25	; 0x02
    1e1c:	81 83       	std	Z+1, r24	; 0x01
    1e1e:	01 80       	ldd	r0, Z+1	; 0x01
    1e20:	f2 81       	ldd	r31, Z+2	; 0x02
    1e22:	e0 2d       	mov	r30, r0
    1e24:	86 81       	ldd	r24, Z+6	; 0x06
    1e26:	97 81       	ldd	r25, Z+7	; 0x07
    1e28:	90 93 e2 0d 	sts	0x0DE2, r25
    1e2c:	80 93 e1 0d 	sts	0x0DE1, r24
    1e30:	08 95       	ret

00001e32 <vTaskPlaceOnEventList>:
    1e32:	cf 93       	push	r28
    1e34:	df 93       	push	r29
    1e36:	eb 01       	movw	r28, r22
    1e38:	60 91 e1 0d 	lds	r22, 0x0DE1
    1e3c:	70 91 e2 0d 	lds	r23, 0x0DE2
    1e40:	64 5f       	subi	r22, 0xF4	; 244
    1e42:	7f 4f       	sbci	r23, 0xFF	; 255
    1e44:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vListInsert>
    1e48:	80 91 e1 0d 	lds	r24, 0x0DE1
    1e4c:	90 91 e2 0d 	lds	r25, 0x0DE2
    1e50:	02 96       	adiw	r24, 0x02	; 2
    1e52:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
    1e56:	80 91 91 0d 	lds	r24, 0x0D91
    1e5a:	90 91 92 0d 	lds	r25, 0x0D92
    1e5e:	8c 0f       	add	r24, r28
    1e60:	9d 1f       	adc	r25, r29
    1e62:	af dc       	rcall	.-1698   	; 0x17c2 <prvAddCurrentTaskToDelayedList>
    1e64:	df 91       	pop	r29
    1e66:	cf 91       	pop	r28
    1e68:	08 95       	ret

00001e6a <vTaskPlaceOnEventListRestricted>:
    1e6a:	cf 93       	push	r28
    1e6c:	df 93       	push	r29
    1e6e:	eb 01       	movw	r28, r22
    1e70:	60 91 e1 0d 	lds	r22, 0x0DE1
    1e74:	70 91 e2 0d 	lds	r23, 0x0DE2
    1e78:	64 5f       	subi	r22, 0xF4	; 244
    1e7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7c:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vListInsertEnd>
    1e80:	80 91 e1 0d 	lds	r24, 0x0DE1
    1e84:	90 91 e2 0d 	lds	r25, 0x0DE2
    1e88:	02 96       	adiw	r24, 0x02	; 2
    1e8a:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
    1e8e:	80 91 91 0d 	lds	r24, 0x0D91
    1e92:	90 91 92 0d 	lds	r25, 0x0D92
    1e96:	8c 0f       	add	r24, r28
    1e98:	9d 1f       	adc	r25, r29
    1e9a:	93 dc       	rcall	.-1754   	; 0x17c2 <prvAddCurrentTaskToDelayedList>
    1e9c:	df 91       	pop	r29
    1e9e:	cf 91       	pop	r28
    1ea0:	08 95       	ret

00001ea2 <xTaskRemoveFromEventList>:
    1ea2:	0f 93       	push	r16
    1ea4:	1f 93       	push	r17
    1ea6:	cf 93       	push	r28
    1ea8:	df 93       	push	r29
    1eaa:	dc 01       	movw	r26, r24
    1eac:	15 96       	adiw	r26, 0x05	; 5
    1eae:	ed 91       	ld	r30, X+
    1eb0:	fc 91       	ld	r31, X
    1eb2:	16 97       	sbiw	r26, 0x06	; 6
    1eb4:	c6 81       	ldd	r28, Z+6	; 0x06
    1eb6:	d7 81       	ldd	r29, Z+7	; 0x07
    1eb8:	8e 01       	movw	r16, r28
    1eba:	04 5f       	subi	r16, 0xF4	; 244
    1ebc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ebe:	c8 01       	movw	r24, r16
    1ec0:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
    1ec4:	80 91 8a 0d 	lds	r24, 0x0D8A
    1ec8:	81 11       	cpse	r24, r1
    1eca:	1c c0       	rjmp	.+56     	; 0x1f04 <xTaskRemoveFromEventList+0x62>
    1ecc:	0a 50       	subi	r16, 0x0A	; 10
    1ece:	11 09       	sbc	r17, r1
    1ed0:	c8 01       	movw	r24, r16
    1ed2:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
    1ed6:	8e 89       	ldd	r24, Y+22	; 0x16
    1ed8:	90 91 90 0d 	lds	r25, 0x0D90
    1edc:	98 17       	cp	r25, r24
    1ede:	10 f4       	brcc	.+4      	; 0x1ee4 <xTaskRemoveFromEventList+0x42>
    1ee0:	80 93 90 0d 	sts	0x0D90, r24
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	9c 01       	movw	r18, r24
    1ee8:	22 0f       	add	r18, r18
    1eea:	33 1f       	adc	r19, r19
    1eec:	22 0f       	add	r18, r18
    1eee:	33 1f       	adc	r19, r19
    1ef0:	22 0f       	add	r18, r18
    1ef2:	33 1f       	adc	r19, r19
    1ef4:	82 0f       	add	r24, r18
    1ef6:	93 1f       	adc	r25, r19
    1ef8:	b8 01       	movw	r22, r16
    1efa:	83 54       	subi	r24, 0x43	; 67
    1efc:	92 4f       	sbci	r25, 0xF2	; 242
    1efe:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vListInsertEnd>
    1f02:	05 c0       	rjmp	.+10     	; 0x1f0e <xTaskRemoveFromEventList+0x6c>
    1f04:	b8 01       	movw	r22, r16
    1f06:	8e e9       	ldi	r24, 0x9E	; 158
    1f08:	9d e0       	ldi	r25, 0x0D	; 13
    1f0a:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vListInsertEnd>
    1f0e:	e0 91 e1 0d 	lds	r30, 0x0DE1
    1f12:	f0 91 e2 0d 	lds	r31, 0x0DE2
    1f16:	9e 89       	ldd	r25, Y+22	; 0x16
    1f18:	86 89       	ldd	r24, Z+22	; 0x16
    1f1a:	89 17       	cp	r24, r25
    1f1c:	20 f4       	brcc	.+8      	; 0x1f26 <xTaskRemoveFromEventList+0x84>
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	80 93 8d 0d 	sts	0x0D8D, r24
    1f24:	01 c0       	rjmp	.+2      	; 0x1f28 <xTaskRemoveFromEventList+0x86>
    1f26:	80 e0       	ldi	r24, 0x00	; 0
    1f28:	df 91       	pop	r29
    1f2a:	cf 91       	pop	r28
    1f2c:	1f 91       	pop	r17
    1f2e:	0f 91       	pop	r16
    1f30:	08 95       	ret

00001f32 <vTaskSetTimeOutState>:
    1f32:	20 91 8c 0d 	lds	r18, 0x0D8C
    1f36:	fc 01       	movw	r30, r24
    1f38:	20 83       	st	Z, r18
    1f3a:	20 91 91 0d 	lds	r18, 0x0D91
    1f3e:	30 91 92 0d 	lds	r19, 0x0D92
    1f42:	32 83       	std	Z+2, r19	; 0x02
    1f44:	21 83       	std	Z+1, r18	; 0x01
    1f46:	08 95       	ret

00001f48 <xTaskCheckForTimeOut>:
    1f48:	0f b6       	in	r0, 0x3f	; 63
    1f4a:	f8 94       	cli
    1f4c:	0f 92       	push	r0
    1f4e:	20 91 91 0d 	lds	r18, 0x0D91
    1f52:	30 91 92 0d 	lds	r19, 0x0D92
    1f56:	40 91 8c 0d 	lds	r20, 0x0D8C
    1f5a:	dc 01       	movw	r26, r24
    1f5c:	5c 91       	ld	r21, X
    1f5e:	54 17       	cp	r21, r20
    1f60:	39 f0       	breq	.+14     	; 0x1f70 <xTaskCheckForTimeOut+0x28>
    1f62:	11 96       	adiw	r26, 0x01	; 1
    1f64:	4d 91       	ld	r20, X+
    1f66:	5c 91       	ld	r21, X
    1f68:	12 97       	sbiw	r26, 0x02	; 2
    1f6a:	24 17       	cp	r18, r20
    1f6c:	35 07       	cpc	r19, r21
    1f6e:	c0 f4       	brcc	.+48     	; 0x1fa0 <xTaskCheckForTimeOut+0x58>
    1f70:	dc 01       	movw	r26, r24
    1f72:	11 96       	adiw	r26, 0x01	; 1
    1f74:	ed 91       	ld	r30, X+
    1f76:	fc 91       	ld	r31, X
    1f78:	12 97       	sbiw	r26, 0x02	; 2
    1f7a:	db 01       	movw	r26, r22
    1f7c:	4d 91       	ld	r20, X+
    1f7e:	5c 91       	ld	r21, X
    1f80:	d9 01       	movw	r26, r18
    1f82:	ae 1b       	sub	r26, r30
    1f84:	bf 0b       	sbc	r27, r31
    1f86:	a4 17       	cp	r26, r20
    1f88:	b5 07       	cpc	r27, r21
    1f8a:	60 f4       	brcc	.+24     	; 0x1fa4 <xTaskCheckForTimeOut+0x5c>
    1f8c:	e2 1b       	sub	r30, r18
    1f8e:	f3 0b       	sbc	r31, r19
    1f90:	4e 0f       	add	r20, r30
    1f92:	5f 1f       	adc	r21, r31
    1f94:	fb 01       	movw	r30, r22
    1f96:	51 83       	std	Z+1, r21	; 0x01
    1f98:	40 83       	st	Z, r20
    1f9a:	cb df       	rcall	.-106    	; 0x1f32 <vTaskSetTimeOutState>
    1f9c:	80 e0       	ldi	r24, 0x00	; 0
    1f9e:	03 c0       	rjmp	.+6      	; 0x1fa6 <xTaskCheckForTimeOut+0x5e>
    1fa0:	81 e0       	ldi	r24, 0x01	; 1
    1fa2:	01 c0       	rjmp	.+2      	; 0x1fa6 <xTaskCheckForTimeOut+0x5e>
    1fa4:	81 e0       	ldi	r24, 0x01	; 1
    1fa6:	0f 90       	pop	r0
    1fa8:	0f be       	out	0x3f, r0	; 63
    1faa:	08 95       	ret

00001fac <vTaskMissedYield>:
    1fac:	81 e0       	ldi	r24, 0x01	; 1
    1fae:	80 93 8d 0d 	sts	0x0D8D, r24
    1fb2:	08 95       	ret

00001fb4 <xTaskGetSchedulerState>:
    1fb4:	80 91 8f 0d 	lds	r24, 0x0D8F
    1fb8:	88 23       	and	r24, r24
    1fba:	31 f0       	breq	.+12     	; 0x1fc8 <xTaskGetSchedulerState+0x14>
    1fbc:	80 91 8a 0d 	lds	r24, 0x0D8A
    1fc0:	81 11       	cpse	r24, r1
    1fc2:	04 c0       	rjmp	.+8      	; 0x1fcc <xTaskGetSchedulerState+0x18>
    1fc4:	82 e0       	ldi	r24, 0x02	; 2
    1fc6:	08 95       	ret
    1fc8:	81 e0       	ldi	r24, 0x01	; 1
    1fca:	08 95       	ret
    1fcc:	80 e0       	ldi	r24, 0x00	; 0
    1fce:	08 95       	ret

00001fd0 <vTaskPriorityInherit>:
    1fd0:	0f 93       	push	r16
    1fd2:	1f 93       	push	r17
    1fd4:	cf 93       	push	r28
    1fd6:	df 93       	push	r29
    1fd8:	ec 01       	movw	r28, r24
    1fda:	00 97       	sbiw	r24, 0x00	; 0
    1fdc:	09 f4       	brne	.+2      	; 0x1fe0 <vTaskPriorityInherit+0x10>
    1fde:	51 c0       	rjmp	.+162    	; 0x2082 <vTaskPriorityInherit+0xb2>
    1fe0:	8e 89       	ldd	r24, Y+22	; 0x16
    1fe2:	e0 91 e1 0d 	lds	r30, 0x0DE1
    1fe6:	f0 91 e2 0d 	lds	r31, 0x0DE2
    1fea:	96 89       	ldd	r25, Z+22	; 0x16
    1fec:	89 17       	cp	r24, r25
    1fee:	08 f0       	brcs	.+2      	; 0x1ff2 <vTaskPriorityInherit+0x22>
    1ff0:	48 c0       	rjmp	.+144    	; 0x2082 <vTaskPriorityInherit+0xb2>
    1ff2:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ff4:	3d 85       	ldd	r19, Y+13	; 0x0d
    1ff6:	33 23       	and	r19, r19
    1ff8:	5c f0       	brlt	.+22     	; 0x2010 <vTaskPriorityInherit+0x40>
    1ffa:	e0 91 e1 0d 	lds	r30, 0x0DE1
    1ffe:	f0 91 e2 0d 	lds	r31, 0x0DE2
    2002:	96 89       	ldd	r25, Z+22	; 0x16
    2004:	24 e0       	ldi	r18, 0x04	; 4
    2006:	30 e0       	ldi	r19, 0x00	; 0
    2008:	29 1b       	sub	r18, r25
    200a:	31 09       	sbc	r19, r1
    200c:	3d 87       	std	Y+13, r19	; 0x0d
    200e:	2c 87       	std	Y+12, r18	; 0x0c
    2010:	90 e0       	ldi	r25, 0x00	; 0
    2012:	9c 01       	movw	r18, r24
    2014:	22 0f       	add	r18, r18
    2016:	33 1f       	adc	r19, r19
    2018:	22 0f       	add	r18, r18
    201a:	33 1f       	adc	r19, r19
    201c:	22 0f       	add	r18, r18
    201e:	33 1f       	adc	r19, r19
    2020:	82 0f       	add	r24, r18
    2022:	93 1f       	adc	r25, r19
    2024:	83 54       	subi	r24, 0x43	; 67
    2026:	92 4f       	sbci	r25, 0xF2	; 242
    2028:	2a 85       	ldd	r18, Y+10	; 0x0a
    202a:	3b 85       	ldd	r19, Y+11	; 0x0b
    202c:	28 17       	cp	r18, r24
    202e:	39 07       	cpc	r19, r25
    2030:	11 f5       	brne	.+68     	; 0x2076 <vTaskPriorityInherit+0xa6>
    2032:	8e 01       	movw	r16, r28
    2034:	0e 5f       	subi	r16, 0xFE	; 254
    2036:	1f 4f       	sbci	r17, 0xFF	; 255
    2038:	c8 01       	movw	r24, r16
    203a:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
    203e:	e0 91 e1 0d 	lds	r30, 0x0DE1
    2042:	f0 91 e2 0d 	lds	r31, 0x0DE2
    2046:	86 89       	ldd	r24, Z+22	; 0x16
    2048:	8e 8b       	std	Y+22, r24	; 0x16
    204a:	90 91 90 0d 	lds	r25, 0x0D90
    204e:	98 17       	cp	r25, r24
    2050:	10 f4       	brcc	.+4      	; 0x2056 <vTaskPriorityInherit+0x86>
    2052:	80 93 90 0d 	sts	0x0D90, r24
    2056:	90 e0       	ldi	r25, 0x00	; 0
    2058:	9c 01       	movw	r18, r24
    205a:	22 0f       	add	r18, r18
    205c:	33 1f       	adc	r19, r19
    205e:	22 0f       	add	r18, r18
    2060:	33 1f       	adc	r19, r19
    2062:	22 0f       	add	r18, r18
    2064:	33 1f       	adc	r19, r19
    2066:	82 0f       	add	r24, r18
    2068:	93 1f       	adc	r25, r19
    206a:	b8 01       	movw	r22, r16
    206c:	83 54       	subi	r24, 0x43	; 67
    206e:	92 4f       	sbci	r25, 0xF2	; 242
    2070:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vListInsertEnd>
    2074:	06 c0       	rjmp	.+12     	; 0x2082 <vTaskPriorityInherit+0xb2>
    2076:	e0 91 e1 0d 	lds	r30, 0x0DE1
    207a:	f0 91 e2 0d 	lds	r31, 0x0DE2
    207e:	86 89       	ldd	r24, Z+22	; 0x16
    2080:	8e 8b       	std	Y+22, r24	; 0x16
    2082:	df 91       	pop	r29
    2084:	cf 91       	pop	r28
    2086:	1f 91       	pop	r17
    2088:	0f 91       	pop	r16
    208a:	08 95       	ret

0000208c <xTaskPriorityDisinherit>:
    208c:	0f 93       	push	r16
    208e:	1f 93       	push	r17
    2090:	cf 93       	push	r28
    2092:	df 93       	push	r29
    2094:	ec 01       	movw	r28, r24
    2096:	00 97       	sbiw	r24, 0x00	; 0
    2098:	71 f1       	breq	.+92     	; 0x20f6 <xTaskPriorityDisinherit+0x6a>
    209a:	8a a1       	ldd	r24, Y+34	; 0x22
    209c:	81 50       	subi	r24, 0x01	; 1
    209e:	8a a3       	std	Y+34, r24	; 0x22
    20a0:	2e 89       	ldd	r18, Y+22	; 0x16
    20a2:	99 a1       	ldd	r25, Y+33	; 0x21
    20a4:	29 17       	cp	r18, r25
    20a6:	49 f1       	breq	.+82     	; 0x20fa <xTaskPriorityDisinherit+0x6e>
    20a8:	81 11       	cpse	r24, r1
    20aa:	29 c0       	rjmp	.+82     	; 0x20fe <xTaskPriorityDisinherit+0x72>
    20ac:	8e 01       	movw	r16, r28
    20ae:	0e 5f       	subi	r16, 0xFE	; 254
    20b0:	1f 4f       	sbci	r17, 0xFF	; 255
    20b2:	c8 01       	movw	r24, r16
    20b4:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
    20b8:	89 a1       	ldd	r24, Y+33	; 0x21
    20ba:	8e 8b       	std	Y+22, r24	; 0x16
    20bc:	24 e0       	ldi	r18, 0x04	; 4
    20be:	30 e0       	ldi	r19, 0x00	; 0
    20c0:	28 1b       	sub	r18, r24
    20c2:	31 09       	sbc	r19, r1
    20c4:	3d 87       	std	Y+13, r19	; 0x0d
    20c6:	2c 87       	std	Y+12, r18	; 0x0c
    20c8:	90 91 90 0d 	lds	r25, 0x0D90
    20cc:	98 17       	cp	r25, r24
    20ce:	10 f4       	brcc	.+4      	; 0x20d4 <xTaskPriorityDisinherit+0x48>
    20d0:	80 93 90 0d 	sts	0x0D90, r24
    20d4:	90 e0       	ldi	r25, 0x00	; 0
    20d6:	9c 01       	movw	r18, r24
    20d8:	22 0f       	add	r18, r18
    20da:	33 1f       	adc	r19, r19
    20dc:	22 0f       	add	r18, r18
    20de:	33 1f       	adc	r19, r19
    20e0:	22 0f       	add	r18, r18
    20e2:	33 1f       	adc	r19, r19
    20e4:	82 0f       	add	r24, r18
    20e6:	93 1f       	adc	r25, r19
    20e8:	b8 01       	movw	r22, r16
    20ea:	83 54       	subi	r24, 0x43	; 67
    20ec:	92 4f       	sbci	r25, 0xF2	; 242
    20ee:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vListInsertEnd>
    20f2:	81 e0       	ldi	r24, 0x01	; 1
    20f4:	05 c0       	rjmp	.+10     	; 0x2100 <xTaskPriorityDisinherit+0x74>
    20f6:	80 e0       	ldi	r24, 0x00	; 0
    20f8:	03 c0       	rjmp	.+6      	; 0x2100 <xTaskPriorityDisinherit+0x74>
    20fa:	80 e0       	ldi	r24, 0x00	; 0
    20fc:	01 c0       	rjmp	.+2      	; 0x2100 <xTaskPriorityDisinherit+0x74>
    20fe:	80 e0       	ldi	r24, 0x00	; 0
    2100:	df 91       	pop	r29
    2102:	cf 91       	pop	r28
    2104:	1f 91       	pop	r17
    2106:	0f 91       	pop	r16
    2108:	08 95       	ret

0000210a <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    210a:	80 91 e1 0d 	lds	r24, 0x0DE1
    210e:	90 91 e2 0d 	lds	r25, 0x0DE2
    2112:	89 2b       	or	r24, r25
    2114:	39 f0       	breq	.+14     	; 0x2124 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2116:	e0 91 e1 0d 	lds	r30, 0x0DE1
    211a:	f0 91 e2 0d 	lds	r31, 0x0DE2
    211e:	82 a1       	ldd	r24, Z+34	; 0x22
    2120:	8f 5f       	subi	r24, 0xFF	; 255
    2122:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2124:	80 91 e1 0d 	lds	r24, 0x0DE1
    2128:	90 91 e2 0d 	lds	r25, 0x0DE2
	}
    212c:	08 95       	ret

0000212e <prvInsertTimerInActiveList>:

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    212e:	fc 01       	movw	r30, r24
    2130:	73 83       	std	Z+3, r23	; 0x03
    2132:	62 83       	std	Z+2, r22	; 0x02
    2134:	91 87       	std	Z+9, r25	; 0x09
    2136:	80 87       	std	Z+8, r24	; 0x08
    2138:	46 17       	cp	r20, r22
    213a:	57 07       	cpc	r21, r23
    213c:	90 f0       	brcs	.+36     	; 0x2162 <prvInsertTimerInActiveList+0x34>
    213e:	42 1b       	sub	r20, r18
    2140:	53 0b       	sbc	r21, r19
    2142:	84 85       	ldd	r24, Z+12	; 0x0c
    2144:	95 85       	ldd	r25, Z+13	; 0x0d
    2146:	48 17       	cp	r20, r24
    2148:	59 07       	cpc	r21, r25
    214a:	e0 f4       	brcc	.+56     	; 0x2184 <prvInsertTimerInActiveList+0x56>
    214c:	bf 01       	movw	r22, r30
    214e:	6e 5f       	subi	r22, 0xFE	; 254
    2150:	7f 4f       	sbci	r23, 0xFF	; 255
    2152:	80 91 e7 0d 	lds	r24, 0x0DE7
    2156:	90 91 e8 0d 	lds	r25, 0x0DE8
    215a:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vListInsert>
    215e:	80 e0       	ldi	r24, 0x00	; 0
    2160:	08 95       	ret
    2162:	42 17       	cp	r20, r18
    2164:	53 07       	cpc	r21, r19
    2166:	18 f4       	brcc	.+6      	; 0x216e <prvInsertTimerInActiveList+0x40>
    2168:	62 17       	cp	r22, r18
    216a:	73 07       	cpc	r23, r19
    216c:	68 f4       	brcc	.+26     	; 0x2188 <prvInsertTimerInActiveList+0x5a>
    216e:	bf 01       	movw	r22, r30
    2170:	6e 5f       	subi	r22, 0xFE	; 254
    2172:	7f 4f       	sbci	r23, 0xFF	; 255
    2174:	80 91 e9 0d 	lds	r24, 0x0DE9
    2178:	90 91 ea 0d 	lds	r25, 0x0DEA
    217c:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vListInsert>
    2180:	80 e0       	ldi	r24, 0x00	; 0
    2182:	08 95       	ret
    2184:	81 e0       	ldi	r24, 0x01	; 1
    2186:	08 95       	ret
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	08 95       	ret

0000218c <prvCheckForValidListAndQueue>:
    218c:	0f b6       	in	r0, 0x3f	; 63
    218e:	f8 94       	cli
    2190:	0f 92       	push	r0
    2192:	80 91 e5 0d 	lds	r24, 0x0DE5
    2196:	90 91 e6 0d 	lds	r25, 0x0DE6
    219a:	89 2b       	or	r24, r25
    219c:	e1 f4       	brne	.+56     	; 0x21d6 <prvCheckForValidListAndQueue+0x4a>
    219e:	84 ef       	ldi	r24, 0xF4	; 244
    21a0:	9d e0       	ldi	r25, 0x0D	; 13
    21a2:	0e 94 93 06 	call	0xd26	; 0xd26 <vListInitialise>
    21a6:	8b ee       	ldi	r24, 0xEB	; 235
    21a8:	9d e0       	ldi	r25, 0x0D	; 13
    21aa:	0e 94 93 06 	call	0xd26	; 0xd26 <vListInitialise>
    21ae:	84 ef       	ldi	r24, 0xF4	; 244
    21b0:	9d e0       	ldi	r25, 0x0D	; 13
    21b2:	90 93 ea 0d 	sts	0x0DEA, r25
    21b6:	80 93 e9 0d 	sts	0x0DE9, r24
    21ba:	8b ee       	ldi	r24, 0xEB	; 235
    21bc:	9d e0       	ldi	r25, 0x0D	; 13
    21be:	90 93 e8 0d 	sts	0x0DE8, r25
    21c2:	80 93 e7 0d 	sts	0x0DE7, r24
    21c6:	40 e0       	ldi	r20, 0x00	; 0
    21c8:	65 e0       	ldi	r22, 0x05	; 5
    21ca:	8a e0       	ldi	r24, 0x0A	; 10
    21cc:	f3 d8       	rcall	.-3610   	; 0x13b4 <xQueueGenericCreate>
    21ce:	90 93 e6 0d 	sts	0x0DE6, r25
    21d2:	80 93 e5 0d 	sts	0x0DE5, r24
    21d6:	0f 90       	pop	r0
    21d8:	0f be       	out	0x3f, r0	; 63
    21da:	08 95       	ret

000021dc <xTimerCreateTimerTask>:
    21dc:	af 92       	push	r10
    21de:	bf 92       	push	r11
    21e0:	cf 92       	push	r12
    21e2:	df 92       	push	r13
    21e4:	ef 92       	push	r14
    21e6:	ff 92       	push	r15
    21e8:	0f 93       	push	r16
    21ea:	d0 df       	rcall	.-96     	; 0x218c <prvCheckForValidListAndQueue>
    21ec:	80 91 e5 0d 	lds	r24, 0x0DE5
    21f0:	90 91 e6 0d 	lds	r25, 0x0DE6
    21f4:	89 2b       	or	r24, r25
    21f6:	89 f0       	breq	.+34     	; 0x221a <__stack+0x1b>
    21f8:	a1 2c       	mov	r10, r1
    21fa:	b1 2c       	mov	r11, r1
    21fc:	c1 2c       	mov	r12, r1
    21fe:	d1 2c       	mov	r13, r1
    2200:	e1 2c       	mov	r14, r1
    2202:	f1 2c       	mov	r15, r1
    2204:	05 e0       	ldi	r16, 0x05	; 5
    2206:	20 e0       	ldi	r18, 0x00	; 0
    2208:	30 e0       	ldi	r19, 0x00	; 0
    220a:	49 eb       	ldi	r20, 0xB9	; 185
    220c:	50 e0       	ldi	r21, 0x00	; 0
    220e:	6b e8       	ldi	r22, 0x8B	; 139
    2210:	72 e0       	ldi	r23, 0x02	; 2
    2212:	88 ec       	ldi	r24, 0xC8	; 200
    2214:	91 e1       	ldi	r25, 0x11	; 17
    2216:	0a db       	rcall	.-2540   	; 0x182c <xTaskGenericCreate>
    2218:	01 c0       	rjmp	.+2      	; 0x221c <__stack+0x1d>
    221a:	80 e0       	ldi	r24, 0x00	; 0
    221c:	0f 91       	pop	r16
    221e:	ff 90       	pop	r15
    2220:	ef 90       	pop	r14
    2222:	df 90       	pop	r13
    2224:	cf 90       	pop	r12
    2226:	bf 90       	pop	r11
    2228:	af 90       	pop	r10
    222a:	08 95       	ret

0000222c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    222c:	0f 93       	push	r16
    222e:	1f 93       	push	r17
    2230:	cf 93       	push	r28
    2232:	df 93       	push	r29
    2234:	00 d0       	rcall	.+0      	; 0x2236 <xTimerGenericCommand+0xa>
    2236:	1f 92       	push	r1
    2238:	1f 92       	push	r1
    223a:	cd b7       	in	r28, 0x3d	; 61
    223c:	de b7       	in	r29, 0x3e	; 62
    223e:	d9 01       	movw	r26, r18
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2240:	e0 91 e5 0d 	lds	r30, 0x0DE5
    2244:	f0 91 e6 0d 	lds	r31, 0x0DE6
    2248:	30 97       	sbiw	r30, 0x00	; 0
    224a:	49 f1       	breq	.+82     	; 0x229e <xTimerGenericCommand+0x72>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    224c:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    224e:	5b 83       	std	Y+3, r21	; 0x03
    2250:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2252:	9d 83       	std	Y+5, r25	; 0x05
    2254:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2256:	66 30       	cpi	r22, 0x06	; 6
    2258:	d4 f4       	brge	.+52     	; 0x228e <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    225a:	ac de       	rcall	.-680    	; 0x1fb4 <xTaskGetSchedulerState>
    225c:	82 30       	cpi	r24, 0x02	; 2
    225e:	59 f4       	brne	.+22     	; 0x2276 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2260:	20 e0       	ldi	r18, 0x00	; 0
    2262:	a8 01       	movw	r20, r16
    2264:	be 01       	movw	r22, r28
    2266:	6f 5f       	subi	r22, 0xFF	; 255
    2268:	7f 4f       	sbci	r23, 0xFF	; 255
    226a:	80 91 e5 0d 	lds	r24, 0x0DE5
    226e:	90 91 e6 0d 	lds	r25, 0x0DE6
    2272:	cb d8       	rcall	.-3690   	; 0x140a <xQueueGenericSend>
    2274:	15 c0       	rjmp	.+42     	; 0x22a0 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2276:	20 e0       	ldi	r18, 0x00	; 0
    2278:	40 e0       	ldi	r20, 0x00	; 0
    227a:	50 e0       	ldi	r21, 0x00	; 0
    227c:	be 01       	movw	r22, r28
    227e:	6f 5f       	subi	r22, 0xFF	; 255
    2280:	7f 4f       	sbci	r23, 0xFF	; 255
    2282:	80 91 e5 0d 	lds	r24, 0x0DE5
    2286:	90 91 e6 0d 	lds	r25, 0x0DE6
    228a:	bf d8       	rcall	.-3714   	; 0x140a <xQueueGenericSend>
    228c:	09 c0       	rjmp	.+18     	; 0x22a0 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    228e:	20 e0       	ldi	r18, 0x00	; 0
    2290:	ad 01       	movw	r20, r26
    2292:	be 01       	movw	r22, r28
    2294:	6f 5f       	subi	r22, 0xFF	; 255
    2296:	7f 4f       	sbci	r23, 0xFF	; 255
    2298:	cf 01       	movw	r24, r30
    229a:	4a d9       	rcall	.-3436   	; 0x1530 <xQueueGenericSendFromISR>
    229c:	01 c0       	rjmp	.+2      	; 0x22a0 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    229e:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    22a0:	0f 90       	pop	r0
    22a2:	0f 90       	pop	r0
    22a4:	0f 90       	pop	r0
    22a6:	0f 90       	pop	r0
    22a8:	0f 90       	pop	r0
    22aa:	df 91       	pop	r29
    22ac:	cf 91       	pop	r28
    22ae:	1f 91       	pop	r17
    22b0:	0f 91       	pop	r16
    22b2:	08 95       	ret

000022b4 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    22b4:	af 92       	push	r10
    22b6:	bf 92       	push	r11
    22b8:	cf 92       	push	r12
    22ba:	df 92       	push	r13
    22bc:	ef 92       	push	r14
    22be:	ff 92       	push	r15
    22c0:	0f 93       	push	r16
    22c2:	1f 93       	push	r17
    22c4:	cf 93       	push	r28
    22c6:	df 93       	push	r29
    22c8:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    22ca:	dd db       	rcall	.-2118   	; 0x1a86 <xTaskGetTickCount>
    22cc:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    22ce:	80 91 e3 0d 	lds	r24, 0x0DE3
    22d2:	90 91 e4 0d 	lds	r25, 0x0DE4
    22d6:	e8 16       	cp	r14, r24
    22d8:	f9 06       	cpc	r15, r25
    22da:	08 f0       	brcs	.+2      	; 0x22de <prvSampleTimeNow+0x2a>
    22dc:	47 c0       	rjmp	.+142    	; 0x236c <prvSampleTimeNow+0xb8>
    22de:	2f c0       	rjmp	.+94     	; 0x233e <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    22e0:	05 80       	ldd	r0, Z+5	; 0x05
    22e2:	f6 81       	ldd	r31, Z+6	; 0x06
    22e4:	e0 2d       	mov	r30, r0
    22e6:	a0 80       	ld	r10, Z
    22e8:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    22ea:	c6 81       	ldd	r28, Z+6	; 0x06
    22ec:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    22ee:	8e 01       	movw	r16, r28
    22f0:	0e 5f       	subi	r16, 0xFE	; 254
    22f2:	1f 4f       	sbci	r17, 0xFF	; 255
    22f4:	c8 01       	movw	r24, r16
    22f6:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    22fa:	e9 89       	ldd	r30, Y+17	; 0x11
    22fc:	fa 89       	ldd	r31, Y+18	; 0x12
    22fe:	ce 01       	movw	r24, r28
    2300:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2302:	8e 85       	ldd	r24, Y+14	; 0x0e
    2304:	81 30       	cpi	r24, 0x01	; 1
    2306:	d9 f4       	brne	.+54     	; 0x233e <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2308:	8c 85       	ldd	r24, Y+12	; 0x0c
    230a:	9d 85       	ldd	r25, Y+13	; 0x0d
    230c:	8a 0d       	add	r24, r10
    230e:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2310:	a8 16       	cp	r10, r24
    2312:	b9 06       	cpc	r11, r25
    2314:	60 f4       	brcc	.+24     	; 0x232e <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2316:	9b 83       	std	Y+3, r25	; 0x03
    2318:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    231a:	d9 87       	std	Y+9, r29	; 0x09
    231c:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    231e:	b8 01       	movw	r22, r16
    2320:	80 91 e9 0d 	lds	r24, 0x0DE9
    2324:	90 91 ea 0d 	lds	r25, 0x0DEA
    2328:	0e 94 c6 06 	call	0xd8c	; 0xd8c <vListInsert>
    232c:	08 c0       	rjmp	.+16     	; 0x233e <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    232e:	00 e0       	ldi	r16, 0x00	; 0
    2330:	10 e0       	ldi	r17, 0x00	; 0
    2332:	20 e0       	ldi	r18, 0x00	; 0
    2334:	30 e0       	ldi	r19, 0x00	; 0
    2336:	a5 01       	movw	r20, r10
    2338:	60 e0       	ldi	r22, 0x00	; 0
    233a:	ce 01       	movw	r24, r28
    233c:	77 df       	rcall	.-274    	; 0x222c <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    233e:	e0 91 e9 0d 	lds	r30, 0x0DE9
    2342:	f0 91 ea 0d 	lds	r31, 0x0DEA
    2346:	80 81       	ld	r24, Z
    2348:	81 11       	cpse	r24, r1
    234a:	ca cf       	rjmp	.-108    	; 0x22e0 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    234c:	80 91 e7 0d 	lds	r24, 0x0DE7
    2350:	90 91 e8 0d 	lds	r25, 0x0DE8
    2354:	90 93 ea 0d 	sts	0x0DEA, r25
    2358:	80 93 e9 0d 	sts	0x0DE9, r24
	pxOverflowTimerList = pxTemp;
    235c:	f0 93 e8 0d 	sts	0x0DE8, r31
    2360:	e0 93 e7 0d 	sts	0x0DE7, r30
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2364:	81 e0       	ldi	r24, 0x01	; 1
    2366:	f6 01       	movw	r30, r12
    2368:	80 83       	st	Z, r24
    236a:	02 c0       	rjmp	.+4      	; 0x2370 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    236c:	f6 01       	movw	r30, r12
    236e:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    2370:	f0 92 e4 0d 	sts	0x0DE4, r15
    2374:	e0 92 e3 0d 	sts	0x0DE3, r14

	return xTimeNow;
}
    2378:	c7 01       	movw	r24, r14
    237a:	df 91       	pop	r29
    237c:	cf 91       	pop	r28
    237e:	1f 91       	pop	r17
    2380:	0f 91       	pop	r16
    2382:	ff 90       	pop	r15
    2384:	ef 90       	pop	r14
    2386:	df 90       	pop	r13
    2388:	cf 90       	pop	r12
    238a:	bf 90       	pop	r11
    238c:	af 90       	pop	r10
    238e:	08 95       	ret

00002390 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	00 d0       	rcall	.+0      	; 0x2396 <prvTimerTask+0x6>
    2396:	00 d0       	rcall	.+0      	; 0x2398 <prvTimerTask+0x8>
    2398:	cd b7       	in	r28, 0x3d	; 61
    239a:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    239c:	ce 01       	movw	r24, r28
    239e:	01 96       	adiw	r24, 0x01	; 1
    23a0:	6c 01       	movw	r12, r24
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    23a2:	81 2c       	mov	r8, r1
    23a4:	91 2c       	mov	r9, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    23a6:	68 2e       	mov	r6, r24
    23a8:	7d 2c       	mov	r7, r13
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    23aa:	e0 91 e9 0d 	lds	r30, 0x0DE9
    23ae:	f0 91 ea 0d 	lds	r31, 0x0DEA
	if( *pxListWasEmpty == pdFALSE )
    23b2:	80 81       	ld	r24, Z
    23b4:	88 23       	and	r24, r24
    23b6:	09 f4       	brne	.+2      	; 0x23ba <prvTimerTask+0x2a>
    23b8:	b6 c0       	rjmp	.+364    	; 0x2526 <prvTimerTask+0x196>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    23ba:	05 80       	ldd	r0, Z+5	; 0x05
    23bc:	f6 81       	ldd	r31, Z+6	; 0x06
    23be:	e0 2d       	mov	r30, r0
    23c0:	e0 80       	ld	r14, Z
    23c2:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    23c4:	5a db       	rcall	.-2380   	; 0x1a7a <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    23c6:	c6 01       	movw	r24, r12
    23c8:	75 df       	rcall	.-278    	; 0x22b4 <prvSampleTimeNow>
    23ca:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    23cc:	89 81       	ldd	r24, Y+1	; 0x01
    23ce:	81 11       	cpse	r24, r1
    23d0:	43 c0       	rjmp	.+134    	; 0x2458 <prvTimerTask+0xc8>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    23d2:	0e 15       	cp	r16, r14
    23d4:	1f 05       	cpc	r17, r15
    23d6:	90 f1       	brcs	.+100    	; 0x243c <prvTimerTask+0xac>
			{
				( void ) xTaskResumeAll();
    23d8:	1b dc       	rcall	.-1994   	; 0x1c10 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    23da:	e0 91 e9 0d 	lds	r30, 0x0DE9
    23de:	f0 91 ea 0d 	lds	r31, 0x0DEA
    23e2:	05 80       	ldd	r0, Z+5	; 0x05
    23e4:	f6 81       	ldd	r31, Z+6	; 0x06
    23e6:	e0 2d       	mov	r30, r0
    23e8:	a6 80       	ldd	r10, Z+6	; 0x06
    23ea:	b7 80       	ldd	r11, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    23ec:	c5 01       	movw	r24, r10
    23ee:	02 96       	adiw	r24, 0x02	; 2
    23f0:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    23f4:	d5 01       	movw	r26, r10
    23f6:	1e 96       	adiw	r26, 0x0e	; 14
    23f8:	8c 91       	ld	r24, X
    23fa:	1e 97       	sbiw	r26, 0x0e	; 14
    23fc:	81 30       	cpi	r24, 0x01	; 1
    23fe:	a1 f4       	brne	.+40     	; 0x2428 <prvTimerTask+0x98>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2400:	1c 96       	adiw	r26, 0x0c	; 12
    2402:	6d 91       	ld	r22, X+
    2404:	7c 91       	ld	r23, X
    2406:	1d 97       	sbiw	r26, 0x0d	; 13
    2408:	6e 0d       	add	r22, r14
    240a:	7f 1d       	adc	r23, r15
    240c:	97 01       	movw	r18, r14
    240e:	a8 01       	movw	r20, r16
    2410:	c5 01       	movw	r24, r10
    2412:	8d de       	rcall	.-742    	; 0x212e <prvInsertTimerInActiveList>
    2414:	81 30       	cpi	r24, 0x01	; 1
    2416:	41 f4       	brne	.+16     	; 0x2428 <prvTimerTask+0x98>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2418:	08 2d       	mov	r16, r8
    241a:	19 2d       	mov	r17, r9
    241c:	28 2d       	mov	r18, r8
    241e:	39 2d       	mov	r19, r9
    2420:	a7 01       	movw	r20, r14
    2422:	60 e0       	ldi	r22, 0x00	; 0
    2424:	c5 01       	movw	r24, r10
    2426:	02 df       	rcall	.-508    	; 0x222c <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2428:	d5 01       	movw	r26, r10
    242a:	51 96       	adiw	r26, 0x11	; 17
    242c:	ed 91       	ld	r30, X+
    242e:	fc 91       	ld	r31, X
    2430:	52 97       	sbiw	r26, 0x12	; 18
    2432:	c5 01       	movw	r24, r10
    2434:	19 95       	eicall
    2436:	6a c0       	rjmp	.+212    	; 0x250c <prvTimerTask+0x17c>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2438:	e8 2c       	mov	r14, r8
    243a:	f9 2c       	mov	r15, r9
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    243c:	b7 01       	movw	r22, r14
    243e:	60 1b       	sub	r22, r16
    2440:	71 0b       	sbc	r23, r17
    2442:	80 91 e5 0d 	lds	r24, 0x0DE5
    2446:	90 91 e6 0d 	lds	r25, 0x0DE6
    244a:	81 d9       	rcall	.-3326   	; 0x174e <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    244c:	e1 db       	rcall	.-2110   	; 0x1c10 <xTaskResumeAll>
    244e:	81 11       	cpse	r24, r1
    2450:	5d c0       	rjmp	.+186    	; 0x250c <prvTimerTask+0x17c>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2452:	0e 94 d5 07 	call	0xfaa	; 0xfaa <vPortYield>
    2456:	5a c0       	rjmp	.+180    	; 0x250c <prvTimerTask+0x17c>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2458:	db db       	rcall	.-2122   	; 0x1c10 <xTaskResumeAll>
    245a:	58 c0       	rjmp	.+176    	; 0x250c <prvTimerTask+0x17c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    245c:	89 81       	ldd	r24, Y+1	; 0x01
    245e:	88 23       	and	r24, r24
    2460:	0c f4       	brge	.+2      	; 0x2464 <prvTimerTask+0xd4>
    2462:	54 c0       	rjmp	.+168    	; 0x250c <prvTimerTask+0x17c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2464:	ec 80       	ldd	r14, Y+4	; 0x04
    2466:	fd 80       	ldd	r15, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2468:	f7 01       	movw	r30, r14
    246a:	82 85       	ldd	r24, Z+10	; 0x0a
    246c:	93 85       	ldd	r25, Z+11	; 0x0b
    246e:	89 2b       	or	r24, r25
    2470:	21 f0       	breq	.+8      	; 0x247a <prvTimerTask+0xea>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2472:	c7 01       	movw	r24, r14
    2474:	02 96       	adiw	r24, 0x02	; 2
    2476:	0e 94 f7 06 	call	0xdee	; 0xdee <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    247a:	ce 01       	movw	r24, r28
    247c:	06 96       	adiw	r24, 0x06	; 6
    247e:	1a df       	rcall	.-460    	; 0x22b4 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    2480:	09 81       	ldd	r16, Y+1	; 0x01
    2482:	11 27       	eor	r17, r17
    2484:	07 fd       	sbrc	r16, 7
    2486:	10 95       	com	r17
    2488:	21 2f       	mov	r18, r17
    248a:	31 2f       	mov	r19, r17
    248c:	0a 30       	cpi	r16, 0x0A	; 10
    248e:	11 05       	cpc	r17, r1
    2490:	08 f0       	brcs	.+2      	; 0x2494 <prvTimerTask+0x104>
    2492:	3c c0       	rjmp	.+120    	; 0x250c <prvTimerTask+0x17c>
    2494:	f8 01       	movw	r30, r16
    2496:	ea 59       	subi	r30, 0x9A	; 154
    2498:	ff 4f       	sbci	r31, 0xFF	; 255
    249a:	d2 c6       	rjmp	.+3492   	; 0x3240 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    249c:	2a 81       	ldd	r18, Y+2	; 0x02
    249e:	3b 81       	ldd	r19, Y+3	; 0x03
    24a0:	d7 01       	movw	r26, r14
    24a2:	1c 96       	adiw	r26, 0x0c	; 12
    24a4:	6d 91       	ld	r22, X+
    24a6:	7c 91       	ld	r23, X
    24a8:	1d 97       	sbiw	r26, 0x0d	; 13
    24aa:	62 0f       	add	r22, r18
    24ac:	73 1f       	adc	r23, r19
    24ae:	ac 01       	movw	r20, r24
    24b0:	c7 01       	movw	r24, r14
    24b2:	3d de       	rcall	.-902    	; 0x212e <prvInsertTimerInActiveList>
    24b4:	81 30       	cpi	r24, 0x01	; 1
    24b6:	51 f5       	brne	.+84     	; 0x250c <prvTimerTask+0x17c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    24b8:	d7 01       	movw	r26, r14
    24ba:	51 96       	adiw	r26, 0x11	; 17
    24bc:	ed 91       	ld	r30, X+
    24be:	fc 91       	ld	r31, X
    24c0:	52 97       	sbiw	r26, 0x12	; 18
    24c2:	c7 01       	movw	r24, r14
    24c4:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    24c6:	f7 01       	movw	r30, r14
    24c8:	86 85       	ldd	r24, Z+14	; 0x0e
    24ca:	81 30       	cpi	r24, 0x01	; 1
    24cc:	f9 f4       	brne	.+62     	; 0x250c <prvTimerTask+0x17c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    24ce:	44 85       	ldd	r20, Z+12	; 0x0c
    24d0:	55 85       	ldd	r21, Z+13	; 0x0d
    24d2:	8a 81       	ldd	r24, Y+2	; 0x02
    24d4:	9b 81       	ldd	r25, Y+3	; 0x03
    24d6:	48 0f       	add	r20, r24
    24d8:	59 1f       	adc	r21, r25
    24da:	08 2d       	mov	r16, r8
    24dc:	19 2d       	mov	r17, r9
    24de:	28 2d       	mov	r18, r8
    24e0:	39 2d       	mov	r19, r9
    24e2:	60 e0       	ldi	r22, 0x00	; 0
    24e4:	c7 01       	movw	r24, r14
    24e6:	a2 de       	rcall	.-700    	; 0x222c <xTimerGenericCommand>
    24e8:	11 c0       	rjmp	.+34     	; 0x250c <prvTimerTask+0x17c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    24ea:	6a 81       	ldd	r22, Y+2	; 0x02
    24ec:	7b 81       	ldd	r23, Y+3	; 0x03
    24ee:	d7 01       	movw	r26, r14
    24f0:	1d 96       	adiw	r26, 0x0d	; 13
    24f2:	7c 93       	st	X, r23
    24f4:	6e 93       	st	-X, r22
    24f6:	1c 97       	sbiw	r26, 0x0c	; 12
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    24f8:	68 0f       	add	r22, r24
    24fa:	79 1f       	adc	r23, r25
    24fc:	9c 01       	movw	r18, r24
    24fe:	ac 01       	movw	r20, r24
    2500:	c7 01       	movw	r24, r14
    2502:	15 de       	rcall	.-982    	; 0x212e <prvInsertTimerInActiveList>
    2504:	03 c0       	rjmp	.+6      	; 0x250c <prvTimerTask+0x17c>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    2506:	c7 01       	movw	r24, r14
    2508:	0e 94 df 08 	call	0x11be	; 0x11be <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    250c:	20 e0       	ldi	r18, 0x00	; 0
    250e:	48 2d       	mov	r20, r8
    2510:	59 2d       	mov	r21, r9
    2512:	66 2d       	mov	r22, r6
    2514:	77 2d       	mov	r23, r7
    2516:	80 91 e5 0d 	lds	r24, 0x0DE5
    251a:	90 91 e6 0d 	lds	r25, 0x0DE6
    251e:	64 d8       	rcall	.-3896   	; 0x15e8 <xQueueGenericReceive>
    2520:	81 11       	cpse	r24, r1
    2522:	9c cf       	rjmp	.-200    	; 0x245c <prvTimerTask+0xcc>
    2524:	42 cf       	rjmp	.-380    	; 0x23aa <prvTimerTask+0x1a>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2526:	a9 da       	rcall	.-2734   	; 0x1a7a <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2528:	c6 01       	movw	r24, r12
    252a:	c4 de       	rcall	.-632    	; 0x22b4 <prvSampleTimeNow>
    252c:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    252e:	89 81       	ldd	r24, Y+1	; 0x01
    2530:	88 23       	and	r24, r24
    2532:	09 f4       	brne	.+2      	; 0x2536 <prvTimerTask+0x1a6>
    2534:	81 cf       	rjmp	.-254    	; 0x2438 <prvTimerTask+0xa8>
    2536:	90 cf       	rjmp	.-224    	; 0x2458 <prvTimerTask+0xc8>

00002538 <bt_status_call_back>:
		bt_initialised = 1;
		} else if (status == DIALOG_ERROR_STOP) {
		// What to do??
	}
}
void vTimerCallback( TimerHandle_t pxTimer ){
    2538:	8f 3f       	cpi	r24, 0xFF	; 255
    253a:	19 f4       	brne	.+6      	; 0x2542 <bt_status_call_back+0xa>
    253c:	81 e0       	ldi	r24, 0x01	; 1
    253e:	80 93 7b 13 	sts	0x137B, r24
    2542:	08 95       	ret

00002544 <vPlannedTrack>:
    2544:	20 e0       	ldi	r18, 0x00	; 0
    2546:	4f ef       	ldi	r20, 0xFF	; 255
    2548:	5f ef       	ldi	r21, 0xFF	; 255
    254a:	60 e0       	ldi	r22, 0x00	; 0
    254c:	70 e0       	ldi	r23, 0x00	; 0
    254e:	80 91 fa 18 	lds	r24, 0x18FA
    2552:	90 91 fb 18 	lds	r25, 0x18FB
    2556:	48 d8       	rcall	.-3952   	; 0x15e8 <xQueueGenericReceive>
    2558:	88 23       	and	r24, r24
    255a:	a1 f3       	breq	.-24     	; 0x2544 <vPlannedTrack>
    255c:	0e 94 a0 03 	call	0x740	; 0x740 <get_tacho_count>
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	0e 94 7f 02 	call	0x4fe	; 0x4fe <set_head_light>
    2566:	0e 94 a0 03 	call	0x740	; 0x740 <get_tacho_count>
    256a:	ec 01       	movw	r28, r24
    256c:	cc 3d       	cpi	r28, 0xDC	; 220
    256e:	85 e0       	ldi	r24, 0x05	; 5
    2570:	d8 07       	cpc	r29, r24
    2572:	08 f0       	brcs	.+2      	; 0x2576 <vPlannedTrack+0x32>
    2574:	45 c0       	rjmp	.+138    	; 0x2600 <vPlannedTrack+0xbc>
    2576:	00 e0       	ldi	r16, 0x00	; 0
    2578:	10 e0       	ldi	r17, 0x00	; 0
    257a:	f8 01       	movw	r30, r16
    257c:	ee 0f       	add	r30, r30
    257e:	ff 1f       	adc	r31, r31
    2580:	e2 58       	subi	r30, 0x82	; 130
    2582:	fc 4e       	sbci	r31, 0xEC	; 236
    2584:	80 81       	ld	r24, Z
    2586:	91 81       	ldd	r25, Z+1	; 0x01
    2588:	c8 17       	cp	r28, r24
    258a:	d9 07       	cpc	r29, r25
    258c:	80 f1       	brcs	.+96     	; 0x25ee <vPlannedTrack+0xaa>
    258e:	78 01       	movw	r14, r16
    2590:	8f ef       	ldi	r24, 0xFF	; 255
    2592:	e8 1a       	sub	r14, r24
    2594:	f8 0a       	sbc	r15, r24
    2596:	f7 01       	movw	r30, r14
    2598:	ee 0f       	add	r30, r30
    259a:	ff 1f       	adc	r31, r31
    259c:	e2 58       	subi	r30, 0x82	; 130
    259e:	fc 4e       	sbci	r31, 0xEC	; 236
    25a0:	80 81       	ld	r24, Z
    25a2:	91 81       	ldd	r25, Z+1	; 0x01
    25a4:	85 36       	cpi	r24, 0x65	; 101
    25a6:	91 05       	cpc	r25, r1
    25a8:	60 f4       	brcc	.+24     	; 0x25c2 <vPlannedTrack+0x7e>
    25aa:	80 e0       	ldi	r24, 0x00	; 0
    25ac:	0e 94 85 02 	call	0x50a	; 0x50a <set_brake_light>
    25b0:	f7 01       	movw	r30, r14
    25b2:	ee 0f       	add	r30, r30
    25b4:	ff 1f       	adc	r31, r31
    25b6:	e2 58       	subi	r30, 0x82	; 130
    25b8:	fc 4e       	sbci	r31, 0xEC	; 236
    25ba:	80 81       	ld	r24, Z
    25bc:	0e 94 8b 02 	call	0x516	; 0x516 <set_motor_speed>
    25c0:	09 c0       	rjmp	.+18     	; 0x25d4 <vPlannedTrack+0x90>
    25c2:	84 56       	subi	r24, 0x64	; 100
    25c4:	0e 94 5d 03 	call	0x6ba	; 0x6ba <set_brake>
    25c8:	81 e0       	ldi	r24, 0x01	; 1
    25ca:	0e 94 85 02 	call	0x50a	; 0x50a <set_brake_light>
    25ce:	80 e0       	ldi	r24, 0x00	; 0
    25d0:	0e 94 8b 02 	call	0x516	; 0x516 <set_motor_speed>
    25d4:	f7 01       	movw	r30, r14
    25d6:	ee 0f       	add	r30, r30
    25d8:	ff 1f       	adc	r31, r31
    25da:	e2 58       	subi	r30, 0x82	; 130
    25dc:	fc 4e       	sbci	r31, 0xEC	; 236
    25de:	80 81       	ld	r24, Z
    25e0:	91 81       	ldd	r25, Z+1	; 0x01
    25e2:	90 93 7d 13 	sts	0x137D, r25
    25e6:	80 93 7c 13 	sts	0x137C, r24
    25ea:	0e 5f       	subi	r16, 0xFE	; 254
    25ec:	1f 4f       	sbci	r17, 0xFF	; 255
    25ee:	0e 94 a0 03 	call	0x740	; 0x740 <get_tacho_count>
    25f2:	c8 0f       	add	r28, r24
    25f4:	d9 1f       	adc	r29, r25
    25f6:	cc 3d       	cpi	r28, 0xDC	; 220
    25f8:	85 e0       	ldi	r24, 0x05	; 5
    25fa:	d8 07       	cpc	r29, r24
    25fc:	08 f4       	brcc	.+2      	; 0x2600 <vPlannedTrack+0xbc>
    25fe:	bd cf       	rjmp	.-134    	; 0x257a <vPlannedTrack+0x36>
    2600:	80 e0       	ldi	r24, 0x00	; 0
    2602:	0e 94 85 02 	call	0x50a	; 0x50a <set_brake_light>
    2606:	80 e0       	ldi	r24, 0x00	; 0
    2608:	0e 94 7f 02 	call	0x4fe	; 0x4fe <set_head_light>
    260c:	80 e0       	ldi	r24, 0x00	; 0
    260e:	0e 94 8b 02 	call	0x516	; 0x516 <set_motor_speed>
    2612:	98 cf       	rjmp	.-208    	; 0x2544 <vPlannedTrack>

00002614 <vjustATask>:
    2614:	20 e0       	ldi	r18, 0x00	; 0
    2616:	4f ef       	ldi	r20, 0xFF	; 255
    2618:	5f ef       	ldi	r21, 0xFF	; 255
    261a:	60 e0       	ldi	r22, 0x00	; 0
    261c:	70 e0       	ldi	r23, 0x00	; 0
    261e:	80 91 fc 18 	lds	r24, 0x18FC
    2622:	90 91 fd 18 	lds	r25, 0x18FD
    2626:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <xQueueGenericReceive>
    262a:	88 23       	and	r24, r24
    262c:	99 f3       	breq	.-26     	; 0x2614 <vjustATask>
    262e:	81 e0       	ldi	r24, 0x01	; 1
    2630:	0e 94 79 02 	call	0x4f2	; 0x4f2 <set_horn>
    2634:	82 e3       	ldi	r24, 0x32	; 50
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	69 db       	rcall	.-2350   	; 0x1d0c <vTaskDelay>
    263a:	80 e0       	ldi	r24, 0x00	; 0
    263c:	0e 94 79 02 	call	0x4f2	; 0x4f2 <set_horn>
    2640:	e9 cf       	rjmp	.-46     	; 0x2614 <vjustATask>

00002642 <vLearnTrack>:
    2642:	cf 93       	push	r28
    2644:	df 93       	push	r29
    2646:	cd b7       	in	r28, 0x3d	; 61
    2648:	de b7       	in	r29, 0x3e	; 62
    264a:	a8 97       	sbiw	r28, 0x28	; 40
    264c:	0f b6       	in	r0, 0x3f	; 63
    264e:	f8 94       	cli
    2650:	de bf       	out	0x3e, r29	; 62
    2652:	0f be       	out	0x3f, r0	; 63
    2654:	cd bf       	out	0x3d, r28	; 61
    2656:	0f 2e       	mov	r0, r31
    2658:	f5 e7       	ldi	r31, 0x75	; 117
    265a:	af 2e       	mov	r10, r31
    265c:	f3 e1       	ldi	r31, 0x13	; 19
    265e:	bf 2e       	mov	r11, r31
    2660:	f0 2d       	mov	r31, r0
    2662:	0f 2e       	mov	r0, r31
    2664:	fd ef       	ldi	r31, 0xFD	; 253
    2666:	8f 2e       	mov	r8, r31
    2668:	fd e0       	ldi	r31, 0x0D	; 13
    266a:	9f 2e       	mov	r9, r31
    266c:	f0 2d       	mov	r31, r0
    266e:	0f 2e       	mov	r0, r31
    2670:	f1 e2       	ldi	r31, 0x21	; 33
    2672:	6f 2e       	mov	r6, r31
    2674:	71 2c       	mov	r7, r1
    2676:	f0 2d       	mov	r31, r0
    2678:	ce 01       	movw	r24, r28
    267a:	01 96       	adiw	r24, 0x01	; 1
    267c:	7c 01       	movw	r14, r24
    267e:	0f 2e       	mov	r0, r31
    2680:	f3 e9       	ldi	r31, 0x93	; 147
    2682:	cf 2e       	mov	r12, r31
    2684:	f2 e0       	ldi	r31, 0x02	; 2
    2686:	df 2e       	mov	r13, r31
    2688:	f0 2d       	mov	r31, r0
    268a:	20 e0       	ldi	r18, 0x00	; 0
    268c:	4f ef       	ldi	r20, 0xFF	; 255
    268e:	5f ef       	ldi	r21, 0xFF	; 255
    2690:	60 e0       	ldi	r22, 0x00	; 0
    2692:	70 e0       	ldi	r23, 0x00	; 0
    2694:	80 91 f8 18 	lds	r24, 0x18F8
    2698:	90 91 f9 18 	lds	r25, 0x18F9
    269c:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <xQueueGenericReceive>
    26a0:	88 23       	and	r24, r24
    26a2:	99 f3       	breq	.-26     	; 0x268a <vLearnTrack+0x48>
    26a4:	8b e2       	ldi	r24, 0x2B	; 43
    26a6:	0e 94 8b 02 	call	0x516	; 0x516 <set_motor_speed>
    26aa:	84 01       	movw	r16, r8
    26ac:	0e 94 88 03 	call	0x710	; 0x710 <get_raw_y_accel>
    26b0:	f8 01       	movw	r30, r16
    26b2:	91 83       	std	Z+1, r25	; 0x01
    26b4:	80 83       	st	Z, r24
    26b6:	0e 94 a0 03 	call	0x740	; 0x740 <get_tacho_count>
    26ba:	f8 01       	movw	r30, r16
    26bc:	93 83       	std	Z+3, r25	; 0x03
    26be:	82 83       	std	Z+2, r24	; 0x02
    26c0:	82 e3       	ldi	r24, 0x32	; 50
    26c2:	90 e0       	ldi	r25, 0x00	; 0
    26c4:	23 db       	rcall	.-2490   	; 0x1d0c <vTaskDelay>
    26c6:	0c 5f       	subi	r16, 0xFC	; 252
    26c8:	1f 4f       	sbci	r17, 0xFF	; 255
    26ca:	0a 15       	cp	r16, r10
    26cc:	1b 05       	cpc	r17, r11
    26ce:	71 f7       	brne	.-36     	; 0x26ac <vLearnTrack+0x6a>
    26d0:	80 e0       	ldi	r24, 0x00	; 0
    26d2:	0e 94 8b 02 	call	0x516	; 0x516 <set_motor_speed>
    26d6:	7a 82       	std	Y+2, r7	; 0x02
    26d8:	69 82       	std	Y+1, r6	; 0x01
    26da:	f7 01       	movw	r30, r14
    26dc:	01 90       	ld	r0, Z+
    26de:	00 20       	and	r0, r0
    26e0:	e9 f7       	brne	.-6      	; 0x26dc <vLearnTrack+0x9a>
    26e2:	31 97       	sbiw	r30, 0x01	; 1
    26e4:	bf 01       	movw	r22, r30
    26e6:	6e 19       	sub	r22, r14
    26e8:	7f 09       	sbc	r23, r15
    26ea:	c7 01       	movw	r24, r14
    26ec:	0e 94 c0 03 	call	0x780	; 0x780 <bt_send_bytes>
    26f0:	8c e2       	ldi	r24, 0x2C	; 44
    26f2:	91 e0       	ldi	r25, 0x01	; 1
    26f4:	0b db       	rcall	.-2538   	; 0x1d0c <vTaskDelay>
    26f6:	81 e0       	ldi	r24, 0x01	; 1
    26f8:	0e 94 85 02 	call	0x50a	; 0x50a <set_brake_light>
    26fc:	84 01       	movw	r16, r8
    26fe:	f8 01       	movw	r30, r16
    2700:	50 80       	ld	r5, Z
    2702:	41 80       	ldd	r4, Z+1	; 0x01
    2704:	32 80       	ldd	r3, Z+2	; 0x02
    2706:	23 80       	ldd	r2, Z+3	; 0x03
    2708:	80 ea       	ldi	r24, 0xA0	; 160
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	ff da       	rcall	.-2562   	; 0x1d0c <vTaskDelay>
    270e:	2f 92       	push	r2
    2710:	3f 92       	push	r3
    2712:	1f 92       	push	r1
    2714:	1f 92       	push	r1
    2716:	1f 92       	push	r1
    2718:	1f 92       	push	r1
    271a:	80 91 07 19 	lds	r24, 0x1907
    271e:	8f 93       	push	r24
    2720:	80 91 06 19 	lds	r24, 0x1906
    2724:	8f 93       	push	r24
    2726:	4f 92       	push	r4
    2728:	5f 92       	push	r5
    272a:	1f 92       	push	r1
    272c:	1f 92       	push	r1
    272e:	df 92       	push	r13
    2730:	cf 92       	push	r12
    2732:	ff 92       	push	r15
    2734:	ef 92       	push	r14
    2736:	02 d7       	rcall	.+3588   	; 0x353c <sprintf>
    2738:	f7 01       	movw	r30, r14
    273a:	01 90       	ld	r0, Z+
    273c:	00 20       	and	r0, r0
    273e:	e9 f7       	brne	.-6      	; 0x273a <vLearnTrack+0xf8>
    2740:	31 97       	sbiw	r30, 0x01	; 1
    2742:	bf 01       	movw	r22, r30
    2744:	6e 19       	sub	r22, r14
    2746:	7f 09       	sbc	r23, r15
    2748:	c7 01       	movw	r24, r14
    274a:	0e 94 c0 03 	call	0x780	; 0x780 <bt_send_bytes>
    274e:	0c 5f       	subi	r16, 0xFC	; 252
    2750:	1f 4f       	sbci	r17, 0xFF	; 255
    2752:	0f b6       	in	r0, 0x3f	; 63
    2754:	f8 94       	cli
    2756:	de bf       	out	0x3e, r29	; 62
    2758:	0f be       	out	0x3f, r0	; 63
    275a:	cd bf       	out	0x3d, r28	; 61
    275c:	0a 15       	cp	r16, r10
    275e:	1b 05       	cpc	r17, r11
    2760:	71 f6       	brne	.-100    	; 0x26fe <vLearnTrack+0xbc>
    2762:	80 e0       	ldi	r24, 0x00	; 0
    2764:	0e 94 85 02 	call	0x50a	; 0x50a <set_brake_light>
    2768:	90 cf       	rjmp	.-224    	; 0x268a <vLearnTrack+0x48>

0000276a <bt_com_call_back>:
	//xSemaphoreGive(xSemaphore);
}

void bt_com_call_back(uint8_t byte) {
    276a:	af 92       	push	r10
    276c:	bf 92       	push	r11
    276e:	cf 92       	push	r12
    2770:	df 92       	push	r13
    2772:	ef 92       	push	r14
    2774:	ff 92       	push	r15
    2776:	0f 93       	push	r16
    2778:	1f 93       	push	r17
    277a:	cf 93       	push	r28
    277c:	df 93       	push	r29
    277e:	cd b7       	in	r28, 0x3d	; 61
    2780:	de b7       	in	r29, 0x3e	; 62
    2782:	a8 97       	sbiw	r28, 0x28	; 40
    2784:	0f b6       	in	r0, 0x3f	; 63
    2786:	f8 94       	cli
    2788:	de bf       	out	0x3e, r29	; 62
    278a:	0f be       	out	0x3f, r0	; 63
    278c:	cd bf       	out	0x3d, r28	; 61
	char buf[40];
	
	if (bt_initialised) {
    278e:	90 91 7b 13 	lds	r25, 0x137B
    2792:	99 23       	and	r25, r25
    2794:	09 f4       	brne	.+2      	; 0x2798 <bt_com_call_back+0x2e>
    2796:	b0 c0       	rjmp	.+352    	; 0x28f8 <bt_com_call_back+0x18e>
		switch (byte) {
    2798:	48 2f       	mov	r20, r24
    279a:	50 e0       	ldi	r21, 0x00	; 0
    279c:	fa 01       	movw	r30, r20
    279e:	e1 54       	subi	r30, 0x41	; 65
    27a0:	f1 09       	sbc	r31, r1
    27a2:	e5 32       	cpi	r30, 0x25	; 37
    27a4:	f1 05       	cpc	r31, r1
    27a6:	08 f0       	brcs	.+2      	; 0x27aa <bt_com_call_back+0x40>
    27a8:	85 c0       	rjmp	.+266    	; 0x28b4 <bt_com_call_back+0x14a>
    27aa:	e0 59       	subi	r30, 0x90	; 144
    27ac:	ff 4f       	sbci	r31, 0xFF	; 255
    27ae:	48 c5       	rjmp	.+2704   	; 0x3240 <__tablejump2__>
			case 'a': {
				set_head_light(0);
    27b0:	80 e0       	ldi	r24, 0x00	; 0
    27b2:	0e 94 7f 02 	call	0x4fe	; 0x4fe <set_head_light>
				break;
    27b6:	a0 c0       	rjmp	.+320    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'A': {
				set_head_light(1);
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	0e 94 7f 02 	call	0x4fe	; 0x4fe <set_head_light>
				break;
    27be:	9c c0       	rjmp	.+312    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'b': {
				set_brake_light(0);
    27c0:	80 e0       	ldi	r24, 0x00	; 0
    27c2:	0e 94 85 02 	call	0x50a	; 0x50a <set_brake_light>
				break;
    27c6:	98 c0       	rjmp	.+304    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'B': {
				set_brake_light(1);
    27c8:	81 e0       	ldi	r24, 0x01	; 1
    27ca:	0e 94 85 02 	call	0x50a	; 0x50a <set_brake_light>
				break;
    27ce:	94 c0       	rjmp	.+296    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'c': {
				set_horn(0);
    27d0:	80 e0       	ldi	r24, 0x00	; 0
    27d2:	0e 94 79 02 	call	0x4f2	; 0x4f2 <set_horn>
				break;
    27d6:	90 c0       	rjmp	.+288    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'C': {
				set_horn(1);
    27d8:	81 e0       	ldi	r24, 0x01	; 1
    27da:	0e 94 79 02 	call	0x4f2	; 0x4f2 <set_horn>
				break;
    27de:	8c c0       	rjmp	.+280    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'd': {
				set_motor_speed(0);
    27e0:	80 e0       	ldi	r24, 0x00	; 0
    27e2:	0e 94 8b 02 	call	0x516	; 0x516 <set_motor_speed>
				break;
    27e6:	88 c0       	rjmp	.+272    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'D': {
				set_motor_speed(65);
    27e8:	81 e4       	ldi	r24, 0x41	; 65
    27ea:	0e 94 8b 02 	call	0x516	; 0x516 <set_motor_speed>
				break;
    27ee:	84 c0       	rjmp	.+264    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'e': {
				set_brake(0);
    27f0:	80 e0       	ldi	r24, 0x00	; 0
    27f2:	0e 94 5d 03 	call	0x6ba	; 0x6ba <set_brake>
				break;
    27f6:	80 c0       	rjmp	.+256    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'E': {
				set_brake(100);
    27f8:	84 e6       	ldi	r24, 0x64	; 100
    27fa:	0e 94 5d 03 	call	0x6ba	; 0x6ba <set_brake>
				break;
    27fe:	7c c0       	rjmp	.+248    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'F': {
				uint16_t raw_x = get_raw_x_accel();
    2800:	0e 94 80 03 	call	0x700	; 0x700 <get_raw_x_accel>
    2804:	18 2f       	mov	r17, r24
    2806:	09 2f       	mov	r16, r25
				uint16_t raw_y = get_raw_y_accel();
    2808:	0e 94 88 03 	call	0x710	; 0x710 <get_raw_y_accel>
    280c:	f8 2e       	mov	r15, r24
    280e:	e9 2e       	mov	r14, r25
				tick = xTaskGetTickCount();
    2810:	3a d9       	rcall	.-3468   	; 0x1a86 <xTaskGetTickCount>
    2812:	90 93 07 19 	sts	0x1907, r25
    2816:	80 93 06 19 	sts	0x1906, r24
				//uint16_t raw_z = get_raw_z_accel();
				uint16_t raw_rx = get_raw_x_rotation();
    281a:	0e 94 90 03 	call	0x720	; 0x720 <get_raw_x_rotation>
    281e:	d8 2e       	mov	r13, r24
    2820:	c9 2e       	mov	r12, r25
				uint16_t raw_ry = get_raw_y_rotation();
    2822:	0e 94 98 03 	call	0x730	; 0x730 <get_raw_y_rotation>
    2826:	b8 2e       	mov	r11, r24
    2828:	a9 2e       	mov	r10, r25
				uint16_t tacho = get_tacho_count();
    282a:	0e 94 a0 03 	call	0x740	; 0x740 <get_tacho_count>
				sprintf(buf, "x%4dy%4dz%4dr%4dq%4dt%4d", raw_x, raw_y, tick, raw_rx, raw_ry, tacho);
    282e:	9f 93       	push	r25
    2830:	8f 93       	push	r24
    2832:	af 92       	push	r10
    2834:	bf 92       	push	r11
    2836:	cf 92       	push	r12
    2838:	df 92       	push	r13
    283a:	80 91 07 19 	lds	r24, 0x1907
    283e:	8f 93       	push	r24
    2840:	80 91 06 19 	lds	r24, 0x1906
    2844:	8f 93       	push	r24
    2846:	ef 92       	push	r14
    2848:	ff 92       	push	r15
    284a:	0f 93       	push	r16
    284c:	1f 93       	push	r17
    284e:	83 e9       	ldi	r24, 0x93	; 147
    2850:	92 e0       	ldi	r25, 0x02	; 2
    2852:	9f 93       	push	r25
    2854:	8f 93       	push	r24
    2856:	8e 01       	movw	r16, r28
    2858:	0f 5f       	subi	r16, 0xFF	; 255
    285a:	1f 4f       	sbci	r17, 0xFF	; 255
    285c:	1f 93       	push	r17
    285e:	0f 93       	push	r16
    2860:	6d d6       	rcall	.+3290   	; 0x353c <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    2862:	f8 01       	movw	r30, r16
    2864:	01 90       	ld	r0, Z+
    2866:	00 20       	and	r0, r0
    2868:	e9 f7       	brne	.-6      	; 0x2864 <bt_com_call_back+0xfa>
    286a:	31 97       	sbiw	r30, 0x01	; 1
    286c:	bf 01       	movw	r22, r30
    286e:	60 1b       	sub	r22, r16
    2870:	71 0b       	sbc	r23, r17
    2872:	c8 01       	movw	r24, r16
    2874:	0e 94 c0 03 	call	0x780	; 0x780 <bt_send_bytes>
				break;
    2878:	0f b6       	in	r0, 0x3f	; 63
    287a:	f8 94       	cli
    287c:	de bf       	out	0x3e, r29	; 62
    287e:	0f be       	out	0x3f, r0	; 63
    2880:	cd bf       	out	0x3d, r28	; 61
    2882:	3a c0       	rjmp	.+116    	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'L': {
				xSemaphoreGive(learn_semaphore);
    2884:	20 e0       	ldi	r18, 0x00	; 0
    2886:	40 e0       	ldi	r20, 0x00	; 0
    2888:	50 e0       	ldi	r21, 0x00	; 0
    288a:	60 e0       	ldi	r22, 0x00	; 0
    288c:	70 e0       	ldi	r23, 0x00	; 0
    288e:	80 91 f8 18 	lds	r24, 0x18F8
    2892:	90 91 f9 18 	lds	r25, 0x18F9
    2896:	0e 94 05 0a 	call	0x140a	; 0x140a <xQueueGenericSend>
				//vLearnTrack(NULL);
				break;
    289a:	2e c0       	rjmp	.+92     	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			case 'R': {
				xSemaphoreGive(race_semaphore);
    289c:	20 e0       	ldi	r18, 0x00	; 0
    289e:	40 e0       	ldi	r20, 0x00	; 0
    28a0:	50 e0       	ldi	r21, 0x00	; 0
    28a2:	60 e0       	ldi	r22, 0x00	; 0
    28a4:	70 e0       	ldi	r23, 0x00	; 0
    28a6:	80 91 fa 18 	lds	r24, 0x18FA
    28aa:	90 91 fb 18 	lds	r25, 0x18FB
    28ae:	0e 94 05 0a 	call	0x140a	; 0x140a <xQueueGenericSend>
				//xSemaphoreTake(race_semaphore,portMAX_DELAY);
				//vPlannedTrack(NULL);
				break;
    28b2:	22 c0       	rjmp	.+68     	; 0x28f8 <bt_com_call_back+0x18e>
			}
			
			default:
				sendValue[charCount] = byte;
    28b4:	90 91 7a 13 	lds	r25, 0x137A
    28b8:	e9 2f       	mov	r30, r25
    28ba:	f0 e0       	ldi	r31, 0x00	; 0
    28bc:	eb 58       	subi	r30, 0x8B	; 139
    28be:	fc 4e       	sbci	r31, 0xEC	; 236
    28c0:	80 83       	st	Z, r24
				charCount++;
    28c2:	9f 5f       	subi	r25, 0xFF	; 255
    28c4:	90 93 7a 13 	sts	0x137A, r25
				if(byte == 33) {
    28c8:	81 32       	cpi	r24, 0x21	; 33
    28ca:	b1 f4       	brne	.+44     	; 0x28f8 <bt_com_call_back+0x18e>
					accData[nextVal] = atoi(sendValue);
    28cc:	00 91 7c 13 	lds	r16, 0x137C
    28d0:	10 91 7d 13 	lds	r17, 0x137D
    28d4:	85 e7       	ldi	r24, 0x75	; 117
    28d6:	93 e1       	ldi	r25, 0x13	; 19
    28d8:	03 d6       	rcall	.+3078   	; 0x34e0 <atoi>
    28da:	f8 01       	movw	r30, r16
    28dc:	ee 0f       	add	r30, r30
    28de:	ff 1f       	adc	r31, r31
    28e0:	e2 58       	subi	r30, 0x82	; 130
    28e2:	fc 4e       	sbci	r31, 0xEC	; 236
    28e4:	91 83       	std	Z+1, r25	; 0x01
    28e6:	80 83       	st	Z, r24
					nextVal++;
    28e8:	0f 5f       	subi	r16, 0xFF	; 255
    28ea:	1f 4f       	sbci	r17, 0xFF	; 255
    28ec:	10 93 7d 13 	sts	0x137D, r17
    28f0:	00 93 7c 13 	sts	0x137C, r16
					charCount=0;
    28f4:	10 92 7a 13 	sts	0x137A, r1
				}
				break;
		}
	}
}
    28f8:	a8 96       	adiw	r28, 0x28	; 40
    28fa:	0f b6       	in	r0, 0x3f	; 63
    28fc:	f8 94       	cli
    28fe:	de bf       	out	0x3e, r29	; 62
    2900:	0f be       	out	0x3f, r0	; 63
    2902:	cd bf       	out	0x3d, r28	; 61
    2904:	df 91       	pop	r29
    2906:	cf 91       	pop	r28
    2908:	1f 91       	pop	r17
    290a:	0f 91       	pop	r16
    290c:	ff 90       	pop	r15
    290e:	ef 90       	pop	r14
    2910:	df 90       	pop	r13
    2912:	cf 90       	pop	r12
    2914:	bf 90       	pop	r11
    2916:	af 90       	pop	r10
    2918:	08 95       	ret

0000291a <vstartupTask>:
			set_horn(0);
		}
	}
}

static void vstartupTask( void *pvParameters ) {
    291a:	cf 93       	push	r28
    291c:	df 93       	push	r29
    291e:	1f 92       	push	r1
    2920:	cd b7       	in	r28, 0x3d	; 61
    2922:	de b7       	in	r29, 0x3e	; 62
	/* The parameters are not used. */
	( void ) pvParameters;
	
	goal_line_semaphore = xSemaphoreCreateBinary();
    2924:	43 e0       	ldi	r20, 0x03	; 3
    2926:	60 e0       	ldi	r22, 0x00	; 0
    2928:	81 e0       	ldi	r24, 0x01	; 1
    292a:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xQueueGenericCreate>
    292e:	90 93 fd 18 	sts	0x18FD, r25
    2932:	80 93 fc 18 	sts	0x18FC, r24
	race_semaphore = xSemaphoreCreateBinary();
    2936:	43 e0       	ldi	r20, 0x03	; 3
    2938:	60 e0       	ldi	r22, 0x00	; 0
    293a:	81 e0       	ldi	r24, 0x01	; 1
    293c:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xQueueGenericCreate>
    2940:	90 93 fb 18 	sts	0x18FB, r25
    2944:	80 93 fa 18 	sts	0x18FA, r24
	learn_semaphore = xSemaphoreCreateBinary();
    2948:	43 e0       	ldi	r20, 0x03	; 3
    294a:	60 e0       	ldi	r22, 0x00	; 0
    294c:	81 e0       	ldi	r24, 0x01	; 1
    294e:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xQueueGenericCreate>
    2952:	90 93 f9 18 	sts	0x18F9, r25
    2956:	80 93 f8 18 	sts	0x18F8, r24
	_xBT_received_chars_queue = xQueueCreate( _BT_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
    295a:	40 e0       	ldi	r20, 0x00	; 0
    295c:	61 e0       	ldi	r22, 0x01	; 1
    295e:	8e e1       	ldi	r24, 0x1E	; 30
    2960:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xQueueGenericCreate>
    2964:	90 93 f7 18 	sts	0x18F7, r25
    2968:	80 93 f6 18 	sts	0x18F6, r24
	
	if( goal_line_semaphore == NULL ) {
    296c:	80 91 fc 18 	lds	r24, 0x18FC
    2970:	90 91 fd 18 	lds	r25, 0x18FD
    2974:	00 97       	sbiw	r24, 0x00	; 0
    2976:	11 f0       	breq	.+4      	; 0x297c <vstartupTask+0x62>
		/* There was insufficient OpenRTOS heap available for the semaphore to
		be created successfully. */
		} else {
		set_goal_line_semaphore(goal_line_semaphore);
    2978:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <set_goal_line_semaphore>
	}
	
	// Initialize Bluetooth Module
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    297c:	88 ee       	ldi	r24, 0xE8	; 232
    297e:	93 e0       	ldi	r25, 0x03	; 3
    2980:	c5 d9       	rcall	.-3190   	; 0x1d0c <vTaskDelay>
	set_bt_reset(0);  // Disable reset line of Blue tooth module
    2982:	80 e0       	ldi	r24, 0x00	; 0
    2984:	0e 94 ba 03 	call	0x774	; 0x774 <set_bt_reset>
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    2988:	88 ee       	ldi	r24, 0xE8	; 232
    298a:	93 e0       	ldi	r25, 0x03	; 3
    298c:	bf d9       	rcall	.-3202   	; 0x1d0c <vTaskDelay>
	init_bt_module(bt_status_call_back, _xBT_received_chars_queue);
    298e:	60 91 f6 18 	lds	r22, 0x18F6
    2992:	70 91 f7 18 	lds	r23, 0x18F7
    2996:	8c e9       	ldi	r24, 0x9C	; 156
    2998:	92 e1       	ldi	r25, 0x12	; 18
    299a:	0e 94 c9 03 	call	0x792	; 0x792 <init_bt_module>
	
	xTaskCreate( vjustATask, "JustATask", configMINIMAL_STACK_SIZE, NULL, just_a_task_TASK_PRIORITY, NULL );
    299e:	a1 2c       	mov	r10, r1
    29a0:	b1 2c       	mov	r11, r1
    29a2:	c1 2c       	mov	r12, r1
    29a4:	d1 2c       	mov	r13, r1
    29a6:	e1 2c       	mov	r14, r1
    29a8:	f1 2c       	mov	r15, r1
    29aa:	02 e0       	ldi	r16, 0x02	; 2
    29ac:	20 e0       	ldi	r18, 0x00	; 0
    29ae:	30 e0       	ldi	r19, 0x00	; 0
    29b0:	49 eb       	ldi	r20, 0xB9	; 185
    29b2:	50 e0       	ldi	r21, 0x00	; 0
    29b4:	6c ea       	ldi	r22, 0xAC	; 172
    29b6:	72 e0       	ldi	r23, 0x02	; 2
    29b8:	8a e0       	ldi	r24, 0x0A	; 10
    29ba:	93 e1       	ldi	r25, 0x13	; 19
    29bc:	0e 94 16 0c 	call	0x182c	; 0x182c <xTaskGenericCreate>
	xTaskCreate( vLearnTrack, "LearnTrack", configMINIMAL_STACK_SIZE, NULL, learn_TASK_PRIORITY, NULL);
    29c0:	01 e0       	ldi	r16, 0x01	; 1
    29c2:	20 e0       	ldi	r18, 0x00	; 0
    29c4:	30 e0       	ldi	r19, 0x00	; 0
    29c6:	49 eb       	ldi	r20, 0xB9	; 185
    29c8:	50 e0       	ldi	r21, 0x00	; 0
    29ca:	66 eb       	ldi	r22, 0xB6	; 182
    29cc:	72 e0       	ldi	r23, 0x02	; 2
    29ce:	81 e2       	ldi	r24, 0x21	; 33
    29d0:	93 e1       	ldi	r25, 0x13	; 19
    29d2:	0e 94 16 0c 	call	0x182c	; 0x182c <xTaskGenericCreate>
	xTaskCreate( vPlannedTrack, "PlannedTrack", configMINIMAL_STACK_SIZE, NULL, planned_track_TASK_PRIORITY, NULL );
    29d6:	20 e0       	ldi	r18, 0x00	; 0
    29d8:	30 e0       	ldi	r19, 0x00	; 0
    29da:	49 eb       	ldi	r20, 0xB9	; 185
    29dc:	50 e0       	ldi	r21, 0x00	; 0
    29de:	61 ec       	ldi	r22, 0xC1	; 193
    29e0:	72 e0       	ldi	r23, 0x02	; 2
    29e2:	82 ea       	ldi	r24, 0xA2	; 162
    29e4:	92 e1       	ldi	r25, 0x12	; 18
    29e6:	0e 94 16 0c 	call	0x182c	; 0x182c <xTaskGenericCreate>
	
	
	uint8_t _byte;
	for( ;; ) {
		xSemaphoreTake(learn_semaphore,1000);
    29ea:	20 e0       	ldi	r18, 0x00	; 0
    29ec:	48 ee       	ldi	r20, 0xE8	; 232
    29ee:	53 e0       	ldi	r21, 0x03	; 3
    29f0:	60 e0       	ldi	r22, 0x00	; 0
    29f2:	70 e0       	ldi	r23, 0x00	; 0
    29f4:	80 91 f8 18 	lds	r24, 0x18F8
    29f8:	90 91 f9 18 	lds	r25, 0x18F9
    29fc:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <xQueueGenericReceive>
		xQueueReceive( _xBT_received_chars_queue, &_byte, portMAX_DELAY );
    2a00:	20 e0       	ldi	r18, 0x00	; 0
    2a02:	4f ef       	ldi	r20, 0xFF	; 255
    2a04:	5f ef       	ldi	r21, 0xFF	; 255
    2a06:	be 01       	movw	r22, r28
    2a08:	6f 5f       	subi	r22, 0xFF	; 255
    2a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a0c:	80 91 f6 18 	lds	r24, 0x18F6
    2a10:	90 91 f7 18 	lds	r25, 0x18F7
    2a14:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <xQueueGenericReceive>
		bt_com_call_back(_byte);
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	a7 de       	rcall	.-690    	; 0x276a <bt_com_call_back>
    2a1c:	e6 cf       	rjmp	.-52     	; 0x29ea <vstartupTask+0xd0>

00002a1e <main>:
	}
}

int main(void)
{
    2a1e:	af 92       	push	r10
    2a20:	bf 92       	push	r11
    2a22:	cf 92       	push	r12
    2a24:	df 92       	push	r13
    2a26:	ef 92       	push	r14
    2a28:	ff 92       	push	r15
    2a2a:	0f 93       	push	r16
	init_main_board();
    2a2c:	0e 94 ae 02 	call	0x55c	; 0x55c <init_main_board>
	xTaskCreate( vstartupTask, "StartupTask", configMINIMAL_STACK_SIZE, NULL, startup_TASK_PRIORITY, NULL );
    2a30:	a1 2c       	mov	r10, r1
    2a32:	b1 2c       	mov	r11, r1
    2a34:	c1 2c       	mov	r12, r1
    2a36:	d1 2c       	mov	r13, r1
    2a38:	e1 2c       	mov	r14, r1
    2a3a:	f1 2c       	mov	r15, r1
    2a3c:	00 e0       	ldi	r16, 0x00	; 0
    2a3e:	20 e0       	ldi	r18, 0x00	; 0
    2a40:	30 e0       	ldi	r19, 0x00	; 0
    2a42:	49 eb       	ldi	r20, 0xB9	; 185
    2a44:	50 e0       	ldi	r21, 0x00	; 0
    2a46:	6e ec       	ldi	r22, 0xCE	; 206
    2a48:	72 e0       	ldi	r23, 0x02	; 2
    2a4a:	8d e8       	ldi	r24, 0x8D	; 141
    2a4c:	94 e1       	ldi	r25, 0x14	; 20
    2a4e:	0e 94 16 0c 	call	0x182c	; 0x182c <xTaskGenericCreate>
	vTaskStartScheduler();
    2a52:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <vTaskStartScheduler>
}
    2a56:	80 e0       	ldi	r24, 0x00	; 0
    2a58:	90 e0       	ldi	r25, 0x00	; 0
    2a5a:	0f 91       	pop	r16
    2a5c:	ff 90       	pop	r15
    2a5e:	ef 90       	pop	r14
    2a60:	df 90       	pop	r13
    2a62:	cf 90       	pop	r12
    2a64:	bf 90       	pop	r11
    2a66:	af 90       	pop	r10
    2a68:	08 95       	ret

00002a6a <vApplicationStackOverflowHook>:


// Called is TASK Stack overflows
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
    2a6a:	08 95       	ret

00002a6c <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
    2a6c:	4f 92       	push	r4
    2a6e:	5f 92       	push	r5
    2a70:	6f 92       	push	r6
    2a72:	7f 92       	push	r7
    2a74:	8f 92       	push	r8
    2a76:	9f 92       	push	r9
    2a78:	af 92       	push	r10
    2a7a:	bf 92       	push	r11
    2a7c:	cf 92       	push	r12
    2a7e:	df 92       	push	r13
    2a80:	ff 92       	push	r15
    2a82:	0f 93       	push	r16
    2a84:	1f 93       	push	r17
    2a86:	cf 93       	push	r28
    2a88:	df 93       	push	r29
    2a8a:	cd b7       	in	r28, 0x3d	; 61
    2a8c:	de b7       	in	r29, 0x3e	; 62
    2a8e:	f8 2e       	mov	r15, r24
    2a90:	2a 01       	movw	r4, r20
    2a92:	3b 01       	movw	r6, r22
    2a94:	88 e0       	ldi	r24, 0x08	; 8
    2a96:	90 e0       	ldi	r25, 0x00	; 0
    2a98:	fc d3       	rcall	.+2040   	; 0x3292 <malloc>
    2a9a:	8c 01       	movw	r16, r24
    2a9c:	8f 2d       	mov	r24, r15
    2a9e:	90 e0       	ldi	r25, 0x00	; 0
    2aa0:	88 0f       	add	r24, r24
    2aa2:	99 1f       	adc	r25, r25
    2aa4:	fc 01       	movw	r30, r24
    2aa6:	e2 50       	subi	r30, 0x02	; 2
    2aa8:	f7 4e       	sbci	r31, 0xE7	; 231
    2aaa:	11 83       	std	Z+1, r17	; 0x01
    2aac:	00 83       	st	Z, r16
    2aae:	fc 01       	movw	r30, r24
    2ab0:	e5 5b       	subi	r30, 0xB5	; 181
    2ab2:	fd 4f       	sbci	r31, 0xFD	; 253
    2ab4:	80 81       	ld	r24, Z
    2ab6:	91 81       	ldd	r25, Z+1	; 0x01
    2ab8:	d8 01       	movw	r26, r16
    2aba:	11 96       	adiw	r26, 0x01	; 1
    2abc:	9c 93       	st	X, r25
    2abe:	8e 93       	st	-X, r24
    2ac0:	13 96       	adiw	r26, 0x03	; 3
    2ac2:	bc 92       	st	X, r11
    2ac4:	ae 92       	st	-X, r10
    2ac6:	12 97       	sbiw	r26, 0x02	; 2
    2ac8:	15 96       	adiw	r26, 0x05	; 5
    2aca:	dc 92       	st	X, r13
    2acc:	ce 92       	st	-X, r12
    2ace:	14 97       	sbiw	r26, 0x04	; 4
    2ad0:	17 96       	adiw	r26, 0x07	; 7
    2ad2:	9c 92       	st	X, r9
    2ad4:	8e 92       	st	-X, r8
    2ad6:	16 97       	sbiw	r26, 0x06	; 6
    2ad8:	ff b6       	in	r15, 0x3f	; 63
    2ada:	f8 94       	cli
    2adc:	d8 01       	movw	r26, r16
    2ade:	ed 91       	ld	r30, X+
    2ae0:	fc 91       	ld	r31, X
    2ae2:	11 97       	sbiw	r26, 0x01	; 1
    2ae4:	36 97       	sbiw	r30, 0x06	; 6
    2ae6:	80 81       	ld	r24, Z
    2ae8:	82 60       	ori	r24, 0x02	; 2
    2aea:	80 83       	st	Z, r24
    2aec:	cd 90       	ld	r12, X+
    2aee:	dc 90       	ld	r13, X
    2af0:	44 0c       	add	r4, r4
    2af2:	55 1c       	adc	r5, r5
    2af4:	66 1c       	adc	r6, r6
    2af6:	77 1c       	adc	r7, r7
    2af8:	44 0c       	add	r4, r4
    2afa:	55 1c       	adc	r5, r5
    2afc:	66 1c       	adc	r6, r6
    2afe:	77 1c       	adc	r7, r7
    2b00:	a3 01       	movw	r20, r6
    2b02:	92 01       	movw	r18, r4
    2b04:	22 0f       	add	r18, r18
    2b06:	33 1f       	adc	r19, r19
    2b08:	44 1f       	adc	r20, r20
    2b0a:	55 1f       	adc	r21, r21
    2b0c:	60 e0       	ldi	r22, 0x00	; 0
    2b0e:	74 e2       	ldi	r23, 0x24	; 36
    2b10:	84 ef       	ldi	r24, 0xF4	; 244
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	57 d3       	rcall	.+1710   	; 0x31c4 <__udivmodsi4>
    2b16:	21 50       	subi	r18, 0x01	; 1
    2b18:	f6 01       	movw	r30, r12
    2b1a:	32 97       	sbiw	r30, 0x02	; 2
    2b1c:	20 83       	st	Z, r18
    2b1e:	d8 01       	movw	r26, r16
    2b20:	ed 91       	ld	r30, X+
    2b22:	fc 91       	ld	r31, X
    2b24:	11 97       	sbiw	r26, 0x01	; 1
    2b26:	35 97       	sbiw	r30, 0x05	; 5
    2b28:	88 e9       	ldi	r24, 0x98	; 152
    2b2a:	80 83       	st	Z, r24
    2b2c:	ed 91       	ld	r30, X+
    2b2e:	fc 91       	ld	r31, X
    2b30:	34 97       	sbiw	r30, 0x04	; 4
    2b32:	86 e0       	ldi	r24, 0x06	; 6
    2b34:	80 83       	st	Z, r24
    2b36:	ff be       	out	0x3f, r15	; 63
    2b38:	c8 01       	movw	r24, r16
    2b3a:	df 91       	pop	r29
    2b3c:	cf 91       	pop	r28
    2b3e:	1f 91       	pop	r17
    2b40:	0f 91       	pop	r16
    2b42:	ff 90       	pop	r15
    2b44:	df 90       	pop	r13
    2b46:	cf 90       	pop	r12
    2b48:	bf 90       	pop	r11
    2b4a:	af 90       	pop	r10
    2b4c:	9f 90       	pop	r9
    2b4e:	8f 90       	pop	r8
    2b50:	7f 90       	pop	r7
    2b52:	6f 90       	pop	r6
    2b54:	5f 90       	pop	r5
    2b56:	4f 90       	pop	r4
    2b58:	08 95       	ret

00002b5a <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
    2b5a:	ef 92       	push	r14
    2b5c:	ff 92       	push	r15
    2b5e:	0f 93       	push	r16
    2b60:	1f 93       	push	r17
    2b62:	cf 93       	push	r28
    2b64:	df 93       	push	r29
    2b66:	8c 01       	movw	r16, r24
    2b68:	e4 2e       	mov	r14, r20
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    2b6a:	dc 01       	movw	r26, r24
    2b6c:	12 96       	adiw	r26, 0x02	; 2
    2b6e:	ed 91       	ld	r30, X+
    2b70:	fc 91       	ld	r31, X
    2b72:	13 97       	sbiw	r26, 0x03	; 3
    2b74:	30 97       	sbiw	r30, 0x00	; 0
    2b76:	69 f0       	breq	.+26     	; 0x2b92 <serial_send_bytes+0x38>
    2b78:	24 2f       	mov	r18, r20
    2b7a:	30 e0       	ldi	r19, 0x00	; 0
    2b7c:	42 a5       	ldd	r20, Z+42	; 0x2a
    2b7e:	88 e2       	ldi	r24, 0x28	; 40
    2b80:	90 e0       	ldi	r25, 0x00	; 0
    2b82:	84 1b       	sub	r24, r20
    2b84:	91 09       	sbc	r25, r1
    2b86:	82 17       	cp	r24, r18
    2b88:	93 07       	cpc	r25, r19
    2b8a:	e4 f0       	brlt	.+56     	; 0x2bc4 <serial_send_bytes+0x6a>
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2b8c:	e1 10       	cpse	r14, r1
    2b8e:	05 c0       	rjmp	.+10     	; 0x2b9a <serial_send_bytes+0x40>
    2b90:	10 c0       	rjmp	.+32     	; 0x2bb2 <serial_send_bytes+0x58>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    2b92:	b1 e0       	ldi	r27, 0x01	; 1
    2b94:	b4 17       	cp	r27, r20
    2b96:	c0 f0       	brcs	.+48     	; 0x2bc8 <serial_send_bytes+0x6e>
    2b98:	f9 cf       	rjmp	.-14     	; 0x2b8c <serial_send_bytes+0x32>
    2b9a:	c6 2f       	mov	r28, r22
    2b9c:	d7 2f       	mov	r29, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2b9e:	f1 2c       	mov	r15, r1
		buffer_put_item(handle->_tx_buf, buf[i]);
    2ba0:	69 91       	ld	r22, Y+
    2ba2:	f8 01       	movw	r30, r16
    2ba4:	82 81       	ldd	r24, Z+2	; 0x02
    2ba6:	93 81       	ldd	r25, Z+3	; 0x03
    2ba8:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2bac:	f3 94       	inc	r15
    2bae:	fe 10       	cpse	r15, r14
    2bb0:	f7 cf       	rjmp	.-18     	; 0x2ba0 <serial_send_bytes+0x46>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
    2bb2:	d8 01       	movw	r26, r16
    2bb4:	ed 91       	ld	r30, X+
    2bb6:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
    2bb8:	35 97       	sbiw	r30, 0x05	; 5
    2bba:	80 81       	ld	r24, Z
    2bbc:	80 62       	ori	r24, 0x20	; 32
    2bbe:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
    2bc0:	80 e0       	ldi	r24, 0x00	; 0
    2bc2:	03 c0       	rjmp	.+6      	; 0x2bca <serial_send_bytes+0x70>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
    2bc4:	82 e0       	ldi	r24, 0x02	; 2
    2bc6:	01 c0       	rjmp	.+2      	; 0x2bca <serial_send_bytes+0x70>
    2bc8:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
    2bca:	df 91       	pop	r29
    2bcc:	cf 91       	pop	r28
    2bce:	1f 91       	pop	r17
    2bd0:	0f 91       	pop	r16
    2bd2:	ff 90       	pop	r15
    2bd4:	ef 90       	pop	r14
    2bd6:	08 95       	ret

00002bd8 <__vector_25>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    2bd8:	1f 92       	push	r1
    2bda:	0f 92       	push	r0
    2bdc:	0f b6       	in	r0, 0x3f	; 63
    2bde:	0f 92       	push	r0
    2be0:	11 24       	eor	r1, r1
    2be2:	0b b6       	in	r0, 0x3b	; 59
    2be4:	0f 92       	push	r0
    2be6:	2f 93       	push	r18
    2be8:	3f 93       	push	r19
    2bea:	4f 93       	push	r20
    2bec:	5f 93       	push	r21
    2bee:	6f 93       	push	r22
    2bf0:	7f 93       	push	r23
    2bf2:	8f 93       	push	r24
    2bf4:	9f 93       	push	r25
    2bf6:	af 93       	push	r26
    2bf8:	bf 93       	push	r27
    2bfa:	cf 93       	push	r28
    2bfc:	ef 93       	push	r30
    2bfe:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    2c00:	e0 91 fe 18 	lds	r30, 0x18FE
    2c04:	f0 91 ff 18 	lds	r31, 0x18FF
    2c08:	30 97       	sbiw	r30, 0x00	; 0
    2c0a:	a1 f0       	breq	.+40     	; 0x2c34 <__vector_25+0x5c>
		item = UDR0;
    2c0c:	c0 91 c6 00 	lds	r28, 0x00C6
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
    2c10:	6c 2f       	mov	r22, r28
    2c12:	84 81       	ldd	r24, Z+4	; 0x04
    2c14:	95 81       	ldd	r25, Z+5	; 0x05
    2c16:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
    2c1a:	80 91 fe 18 	lds	r24, 0x18FE
    2c1e:	90 91 ff 18 	lds	r25, 0x18FF
    2c22:	dc 01       	movw	r26, r24
    2c24:	16 96       	adiw	r26, 0x06	; 6
    2c26:	ed 91       	ld	r30, X+
    2c28:	fc 91       	ld	r31, X
    2c2a:	17 97       	sbiw	r26, 0x07	; 7
    2c2c:	30 97       	sbiw	r30, 0x00	; 0
    2c2e:	11 f0       	breq	.+4      	; 0x2c34 <__vector_25+0x5c>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
    2c30:	6c 2f       	mov	r22, r28
    2c32:	19 95       	eicall
		}
	}
}
    2c34:	ff 91       	pop	r31
    2c36:	ef 91       	pop	r30
    2c38:	cf 91       	pop	r28
    2c3a:	bf 91       	pop	r27
    2c3c:	af 91       	pop	r26
    2c3e:	9f 91       	pop	r25
    2c40:	8f 91       	pop	r24
    2c42:	7f 91       	pop	r23
    2c44:	6f 91       	pop	r22
    2c46:	5f 91       	pop	r21
    2c48:	4f 91       	pop	r20
    2c4a:	3f 91       	pop	r19
    2c4c:	2f 91       	pop	r18
    2c4e:	0f 90       	pop	r0
    2c50:	0b be       	out	0x3b, r0	; 59
    2c52:	0f 90       	pop	r0
    2c54:	0f be       	out	0x3f, r0	; 63
    2c56:	0f 90       	pop	r0
    2c58:	1f 90       	pop	r1
    2c5a:	18 95       	reti

00002c5c <__vector_26>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
    2c5c:	1f 92       	push	r1
    2c5e:	0f 92       	push	r0
    2c60:	0f b6       	in	r0, 0x3f	; 63
    2c62:	0f 92       	push	r0
    2c64:	11 24       	eor	r1, r1
    2c66:	0b b6       	in	r0, 0x3b	; 59
    2c68:	0f 92       	push	r0
    2c6a:	2f 93       	push	r18
    2c6c:	3f 93       	push	r19
    2c6e:	4f 93       	push	r20
    2c70:	5f 93       	push	r21
    2c72:	6f 93       	push	r22
    2c74:	7f 93       	push	r23
    2c76:	8f 93       	push	r24
    2c78:	9f 93       	push	r25
    2c7a:	af 93       	push	r26
    2c7c:	bf 93       	push	r27
    2c7e:	ef 93       	push	r30
    2c80:	ff 93       	push	r31
    2c82:	cf 93       	push	r28
    2c84:	df 93       	push	r29
    2c86:	1f 92       	push	r1
    2c88:	cd b7       	in	r28, 0x3d	; 61
    2c8a:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    2c8c:	e0 91 fe 18 	lds	r30, 0x18FE
    2c90:	f0 91 ff 18 	lds	r31, 0x18FF
    2c94:	30 97       	sbiw	r30, 0x00	; 0
    2c96:	99 f0       	breq	.+38     	; 0x2cbe <__vector_26+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
    2c98:	be 01       	movw	r22, r28
    2c9a:	6f 5f       	subi	r22, 0xFF	; 255
    2c9c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c9e:	82 81       	ldd	r24, Z+2	; 0x02
    2ca0:	93 81       	ldd	r25, Z+3	; 0x03
    2ca2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <buffer_get_item>
    2ca6:	81 11       	cpse	r24, r1
    2ca8:	04 c0       	rjmp	.+8      	; 0x2cb2 <__vector_26+0x56>
			UDR0 = item;
    2caa:	89 81       	ldd	r24, Y+1	; 0x01
    2cac:	80 93 c6 00 	sts	0x00C6, r24
    2cb0:	0b c0       	rjmp	.+22     	; 0x2cc8 <__vector_26+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
    2cb2:	e1 ec       	ldi	r30, 0xC1	; 193
    2cb4:	f0 e0       	ldi	r31, 0x00	; 0
    2cb6:	80 81       	ld	r24, Z
    2cb8:	8f 7d       	andi	r24, 0xDF	; 223
    2cba:	80 83       	st	Z, r24
    2cbc:	05 c0       	rjmp	.+10     	; 0x2cc8 <__vector_26+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    2cbe:	e1 ec       	ldi	r30, 0xC1	; 193
    2cc0:	f0 e0       	ldi	r31, 0x00	; 0
    2cc2:	80 81       	ld	r24, Z
    2cc4:	8f 7d       	andi	r24, 0xDF	; 223
    2cc6:	80 83       	st	Z, r24
	}
}
    2cc8:	0f 90       	pop	r0
    2cca:	df 91       	pop	r29
    2ccc:	cf 91       	pop	r28
    2cce:	ff 91       	pop	r31
    2cd0:	ef 91       	pop	r30
    2cd2:	bf 91       	pop	r27
    2cd4:	af 91       	pop	r26
    2cd6:	9f 91       	pop	r25
    2cd8:	8f 91       	pop	r24
    2cda:	7f 91       	pop	r23
    2cdc:	6f 91       	pop	r22
    2cde:	5f 91       	pop	r21
    2ce0:	4f 91       	pop	r20
    2ce2:	3f 91       	pop	r19
    2ce4:	2f 91       	pop	r18
    2ce6:	0f 90       	pop	r0
    2ce8:	0b be       	out	0x3b, r0	; 59
    2cea:	0f 90       	pop	r0
    2cec:	0f be       	out	0x3f, r0	; 63
    2cee:	0f 90       	pop	r0
    2cf0:	1f 90       	pop	r1
    2cf2:	18 95       	reti

00002cf4 <__vector_36>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    2cf4:	1f 92       	push	r1
    2cf6:	0f 92       	push	r0
    2cf8:	0f b6       	in	r0, 0x3f	; 63
    2cfa:	0f 92       	push	r0
    2cfc:	11 24       	eor	r1, r1
    2cfe:	0b b6       	in	r0, 0x3b	; 59
    2d00:	0f 92       	push	r0
    2d02:	2f 93       	push	r18
    2d04:	3f 93       	push	r19
    2d06:	4f 93       	push	r20
    2d08:	5f 93       	push	r21
    2d0a:	6f 93       	push	r22
    2d0c:	7f 93       	push	r23
    2d0e:	8f 93       	push	r24
    2d10:	9f 93       	push	r25
    2d12:	af 93       	push	r26
    2d14:	bf 93       	push	r27
    2d16:	cf 93       	push	r28
    2d18:	ef 93       	push	r30
    2d1a:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    2d1c:	e0 91 00 19 	lds	r30, 0x1900
    2d20:	f0 91 01 19 	lds	r31, 0x1901
    2d24:	30 97       	sbiw	r30, 0x00	; 0
    2d26:	a1 f0       	breq	.+40     	; 0x2d50 <__vector_36+0x5c>
		item = UDR1;
    2d28:	c0 91 ce 00 	lds	r28, 0x00CE
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    2d2c:	6c 2f       	mov	r22, r28
    2d2e:	84 81       	ldd	r24, Z+4	; 0x04
    2d30:	95 81       	ldd	r25, Z+5	; 0x05
    2d32:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    2d36:	80 91 00 19 	lds	r24, 0x1900
    2d3a:	90 91 01 19 	lds	r25, 0x1901
    2d3e:	dc 01       	movw	r26, r24
    2d40:	16 96       	adiw	r26, 0x06	; 6
    2d42:	ed 91       	ld	r30, X+
    2d44:	fc 91       	ld	r31, X
    2d46:	17 97       	sbiw	r26, 0x07	; 7
    2d48:	30 97       	sbiw	r30, 0x00	; 0
    2d4a:	11 f0       	breq	.+4      	; 0x2d50 <__vector_36+0x5c>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    2d4c:	6c 2f       	mov	r22, r28
    2d4e:	19 95       	eicall
		}
	}
}
    2d50:	ff 91       	pop	r31
    2d52:	ef 91       	pop	r30
    2d54:	cf 91       	pop	r28
    2d56:	bf 91       	pop	r27
    2d58:	af 91       	pop	r26
    2d5a:	9f 91       	pop	r25
    2d5c:	8f 91       	pop	r24
    2d5e:	7f 91       	pop	r23
    2d60:	6f 91       	pop	r22
    2d62:	5f 91       	pop	r21
    2d64:	4f 91       	pop	r20
    2d66:	3f 91       	pop	r19
    2d68:	2f 91       	pop	r18
    2d6a:	0f 90       	pop	r0
    2d6c:	0b be       	out	0x3b, r0	; 59
    2d6e:	0f 90       	pop	r0
    2d70:	0f be       	out	0x3f, r0	; 63
    2d72:	0f 90       	pop	r0
    2d74:	1f 90       	pop	r1
    2d76:	18 95       	reti

00002d78 <__vector_37>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    2d78:	1f 92       	push	r1
    2d7a:	0f 92       	push	r0
    2d7c:	0f b6       	in	r0, 0x3f	; 63
    2d7e:	0f 92       	push	r0
    2d80:	11 24       	eor	r1, r1
    2d82:	0b b6       	in	r0, 0x3b	; 59
    2d84:	0f 92       	push	r0
    2d86:	2f 93       	push	r18
    2d88:	3f 93       	push	r19
    2d8a:	4f 93       	push	r20
    2d8c:	5f 93       	push	r21
    2d8e:	6f 93       	push	r22
    2d90:	7f 93       	push	r23
    2d92:	8f 93       	push	r24
    2d94:	9f 93       	push	r25
    2d96:	af 93       	push	r26
    2d98:	bf 93       	push	r27
    2d9a:	ef 93       	push	r30
    2d9c:	ff 93       	push	r31
    2d9e:	cf 93       	push	r28
    2da0:	df 93       	push	r29
    2da2:	1f 92       	push	r1
    2da4:	cd b7       	in	r28, 0x3d	; 61
    2da6:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    2da8:	e0 91 00 19 	lds	r30, 0x1900
    2dac:	f0 91 01 19 	lds	r31, 0x1901
    2db0:	30 97       	sbiw	r30, 0x00	; 0
    2db2:	99 f0       	breq	.+38     	; 0x2dda <__vector_37+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    2db4:	be 01       	movw	r22, r28
    2db6:	6f 5f       	subi	r22, 0xFF	; 255
    2db8:	7f 4f       	sbci	r23, 0xFF	; 255
    2dba:	82 81       	ldd	r24, Z+2	; 0x02
    2dbc:	93 81       	ldd	r25, Z+3	; 0x03
    2dbe:	0e 94 52 04 	call	0x8a4	; 0x8a4 <buffer_get_item>
    2dc2:	81 11       	cpse	r24, r1
    2dc4:	04 c0       	rjmp	.+8      	; 0x2dce <__vector_37+0x56>
			UDR1 = item;
    2dc6:	89 81       	ldd	r24, Y+1	; 0x01
    2dc8:	80 93 ce 00 	sts	0x00CE, r24
    2dcc:	0b c0       	rjmp	.+22     	; 0x2de4 <__vector_37+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    2dce:	e9 ec       	ldi	r30, 0xC9	; 201
    2dd0:	f0 e0       	ldi	r31, 0x00	; 0
    2dd2:	80 81       	ld	r24, Z
    2dd4:	8f 7d       	andi	r24, 0xDF	; 223
    2dd6:	80 83       	st	Z, r24
    2dd8:	05 c0       	rjmp	.+10     	; 0x2de4 <__vector_37+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    2dda:	e9 ec       	ldi	r30, 0xC9	; 201
    2ddc:	f0 e0       	ldi	r31, 0x00	; 0
    2dde:	80 81       	ld	r24, Z
    2de0:	8f 7d       	andi	r24, 0xDF	; 223
    2de2:	80 83       	st	Z, r24
	}
}
    2de4:	0f 90       	pop	r0
    2de6:	df 91       	pop	r29
    2de8:	cf 91       	pop	r28
    2dea:	ff 91       	pop	r31
    2dec:	ef 91       	pop	r30
    2dee:	bf 91       	pop	r27
    2df0:	af 91       	pop	r26
    2df2:	9f 91       	pop	r25
    2df4:	8f 91       	pop	r24
    2df6:	7f 91       	pop	r23
    2df8:	6f 91       	pop	r22
    2dfa:	5f 91       	pop	r21
    2dfc:	4f 91       	pop	r20
    2dfe:	3f 91       	pop	r19
    2e00:	2f 91       	pop	r18
    2e02:	0f 90       	pop	r0
    2e04:	0b be       	out	0x3b, r0	; 59
    2e06:	0f 90       	pop	r0
    2e08:	0f be       	out	0x3f, r0	; 63
    2e0a:	0f 90       	pop	r0
    2e0c:	1f 90       	pop	r1
    2e0e:	18 95       	reti

00002e10 <_select_instance>:
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    2e10:	e0 91 03 19 	lds	r30, 0x1903
    2e14:	f0 91 04 19 	lds	r31, 0x1904
    2e18:	30 97       	sbiw	r30, 0x00	; 0
    2e1a:	01 f1       	breq	.+64     	; 0x2e5c <_select_instance+0x4c>
    2e1c:	23 81       	ldd	r18, Z+3	; 0x03
    2e1e:	21 30       	cpi	r18, 0x01	; 1
    2e20:	79 f4       	brne	.+30     	; 0x2e40 <_select_instance+0x30>
    2e22:	a0 81       	ld	r26, Z
    2e24:	b1 81       	ldd	r27, Z+1	; 0x01
    2e26:	4c 91       	ld	r20, X
    2e28:	21 e0       	ldi	r18, 0x01	; 1
    2e2a:	30 e0       	ldi	r19, 0x00	; 0
    2e2c:	02 80       	ldd	r0, Z+2	; 0x02
    2e2e:	02 c0       	rjmp	.+4      	; 0x2e34 <_select_instance+0x24>
    2e30:	22 0f       	add	r18, r18
    2e32:	33 1f       	adc	r19, r19
    2e34:	0a 94       	dec	r0
    2e36:	e2 f7       	brpl	.-8      	; 0x2e30 <_select_instance+0x20>
    2e38:	20 95       	com	r18
    2e3a:	24 23       	and	r18, r20
    2e3c:	2c 93       	st	X, r18
    2e3e:	0e c0       	rjmp	.+28     	; 0x2e5c <_select_instance+0x4c>
    2e40:	a0 81       	ld	r26, Z
    2e42:	b1 81       	ldd	r27, Z+1	; 0x01
    2e44:	6c 91       	ld	r22, X
    2e46:	41 e0       	ldi	r20, 0x01	; 1
    2e48:	50 e0       	ldi	r21, 0x00	; 0
    2e4a:	9a 01       	movw	r18, r20
    2e4c:	02 80       	ldd	r0, Z+2	; 0x02
    2e4e:	02 c0       	rjmp	.+4      	; 0x2e54 <_select_instance+0x44>
    2e50:	22 0f       	add	r18, r18
    2e52:	33 1f       	adc	r19, r19
    2e54:	0a 94       	dec	r0
    2e56:	e2 f7       	brpl	.-8      	; 0x2e50 <_select_instance+0x40>
    2e58:	26 2b       	or	r18, r22
    2e5a:	2c 93       	st	X, r18
    2e5c:	90 93 04 19 	sts	0x1904, r25
    2e60:	80 93 03 19 	sts	0x1903, r24
    2e64:	00 97       	sbiw	r24, 0x00	; 0
    2e66:	69 f0       	breq	.+26     	; 0x2e82 <_select_instance+0x72>
    2e68:	10 92 05 19 	sts	0x1905, r1
    2e6c:	2c b5       	in	r18, 0x2c	; 44
    2e6e:	2f 73       	andi	r18, 0x3F	; 63
    2e70:	2c bd       	out	0x2c, r18	; 44
    2e72:	fc 01       	movw	r30, r24
    2e74:	24 81       	ldd	r18, Z+4	; 0x04
    2e76:	2c bd       	out	0x2c, r18	; 44
    2e78:	85 81       	ldd	r24, Z+5	; 0x05
    2e7a:	8d bd       	out	0x2d, r24	; 45
    2e7c:	8c b5       	in	r24, 0x2c	; 44
    2e7e:	80 64       	ori	r24, 0x40	; 64
    2e80:	8c bd       	out	0x2c, r24	; 44
    2e82:	08 95       	ret

00002e84 <spi_new_instance>:
    2e84:	6f 92       	push	r6
    2e86:	7f 92       	push	r7
    2e88:	8f 92       	push	r8
    2e8a:	9f 92       	push	r9
    2e8c:	af 92       	push	r10
    2e8e:	bf 92       	push	r11
    2e90:	cf 92       	push	r12
    2e92:	df 92       	push	r13
    2e94:	ef 92       	push	r14
    2e96:	ff 92       	push	r15
    2e98:	0f 93       	push	r16
    2e9a:	1f 93       	push	r17
    2e9c:	cf 93       	push	r28
    2e9e:	df 93       	push	r29
    2ea0:	cd b7       	in	r28, 0x3d	; 61
    2ea2:	de b7       	in	r29, 0x3e	; 62
    2ea4:	d8 2e       	mov	r13, r24
    2ea6:	f6 2e       	mov	r15, r22
    2ea8:	64 2e       	mov	r6, r20
    2eaa:	72 2e       	mov	r7, r18
    2eac:	80 91 02 19 	lds	r24, 0x1902
    2eb0:	81 11       	cpse	r24, r1
    2eb2:	06 c0       	rjmp	.+12     	; 0x2ec0 <spi_new_instance+0x3c>
    2eb4:	84 b1       	in	r24, 0x04	; 4
    2eb6:	87 60       	ori	r24, 0x07	; 7
    2eb8:	84 b9       	out	0x04, r24	; 4
    2eba:	81 e0       	ldi	r24, 0x01	; 1
    2ebc:	80 93 02 19 	sts	0x1902, r24
    2ec0:	8c e0       	ldi	r24, 0x0C	; 12
    2ec2:	90 e0       	ldi	r25, 0x00	; 0
    2ec4:	e6 d1       	rcall	.+972    	; 0x3292 <malloc>
    2ec6:	fc 01       	movw	r30, r24
    2ec8:	00 83       	st	Z, r16
    2eca:	11 83       	std	Z+1, r17	; 0x01
    2ecc:	e2 82       	std	Z+2, r14	; 0x02
    2ece:	a0 2f       	mov	r26, r16
    2ed0:	b1 2f       	mov	r27, r17
    2ed2:	4e 91       	ld	r20, -X
    2ed4:	21 e0       	ldi	r18, 0x01	; 1
    2ed6:	30 e0       	ldi	r19, 0x00	; 0
    2ed8:	c9 01       	movw	r24, r18
    2eda:	02 c0       	rjmp	.+4      	; 0x2ee0 <spi_new_instance+0x5c>
    2edc:	88 0f       	add	r24, r24
    2ede:	99 1f       	adc	r25, r25
    2ee0:	ea 94       	dec	r14
    2ee2:	e2 f7       	brpl	.-8      	; 0x2edc <spi_new_instance+0x58>
    2ee4:	84 2b       	or	r24, r20
    2ee6:	8c 93       	st	X, r24
    2ee8:	c3 82       	std	Z+3, r12	; 0x03
    2eea:	66 0c       	add	r6, r6
    2eec:	66 0c       	add	r6, r6
    2eee:	76 28       	or	r7, r6
    2ef0:	af 2d       	mov	r26, r15
    2ef2:	bb 27       	eor	r27, r27
    2ef4:	a7 fd       	sbrc	r26, 7
    2ef6:	b0 95       	com	r27
    2ef8:	a6 52       	subi	r26, 0x26	; 38
    2efa:	bd 4f       	sbci	r27, 0xFD	; 253
    2efc:	6c 90       	ld	r6, X
    2efe:	d6 28       	or	r13, r6
    2f00:	d7 28       	or	r13, r7
    2f02:	d4 82       	std	Z+4, r13	; 0x04
    2f04:	83 e0       	ldi	r24, 0x03	; 3
    2f06:	8f 15       	cp	r24, r15
    2f08:	14 f4       	brge	.+4      	; 0x2f0e <spi_new_instance+0x8a>
    2f0a:	81 e0       	ldi	r24, 0x01	; 1
    2f0c:	85 83       	std	Z+5, r24	; 0x05
    2f0e:	97 82       	std	Z+7, r9	; 0x07
    2f10:	86 82       	std	Z+6, r8	; 0x06
    2f12:	b1 86       	std	Z+9, r11	; 0x09
    2f14:	a0 86       	std	Z+8, r10	; 0x08
    2f16:	8a 89       	ldd	r24, Y+18	; 0x12
    2f18:	9b 89       	ldd	r25, Y+19	; 0x13
    2f1a:	93 87       	std	Z+11, r25	; 0x0b
    2f1c:	82 87       	std	Z+10, r24	; 0x0a
    2f1e:	6f b7       	in	r22, 0x3f	; 63
    2f20:	f8 94       	cli
    2f22:	80 91 03 19 	lds	r24, 0x1903
    2f26:	90 91 04 19 	lds	r25, 0x1904
    2f2a:	f0 93 04 19 	sts	0x1904, r31
    2f2e:	e0 93 03 19 	sts	0x1903, r30
    2f32:	23 81       	ldd	r18, Z+3	; 0x03
    2f34:	21 30       	cpi	r18, 0x01	; 1
    2f36:	81 f4       	brne	.+32     	; 0x2f58 <spi_new_instance+0xd4>
    2f38:	a0 81       	ld	r26, Z
    2f3a:	b1 81       	ldd	r27, Z+1	; 0x01
    2f3c:	7c 91       	ld	r23, X
    2f3e:	41 e0       	ldi	r20, 0x01	; 1
    2f40:	50 e0       	ldi	r21, 0x00	; 0
    2f42:	9a 01       	movw	r18, r20
    2f44:	02 80       	ldd	r0, Z+2	; 0x02
    2f46:	02 c0       	rjmp	.+4      	; 0x2f4c <spi_new_instance+0xc8>
    2f48:	22 0f       	add	r18, r18
    2f4a:	33 1f       	adc	r19, r19
    2f4c:	0a 94       	dec	r0
    2f4e:	e2 f7       	brpl	.-8      	; 0x2f48 <spi_new_instance+0xc4>
    2f50:	20 95       	com	r18
    2f52:	27 23       	and	r18, r23
    2f54:	2c 93       	st	X, r18
    2f56:	0e c0       	rjmp	.+28     	; 0x2f74 <spi_new_instance+0xf0>
    2f58:	a0 81       	ld	r26, Z
    2f5a:	b1 81       	ldd	r27, Z+1	; 0x01
    2f5c:	7c 91       	ld	r23, X
    2f5e:	41 e0       	ldi	r20, 0x01	; 1
    2f60:	50 e0       	ldi	r21, 0x00	; 0
    2f62:	9a 01       	movw	r18, r20
    2f64:	02 80       	ldd	r0, Z+2	; 0x02
    2f66:	02 c0       	rjmp	.+4      	; 0x2f6c <spi_new_instance+0xe8>
    2f68:	22 0f       	add	r18, r18
    2f6a:	33 1f       	adc	r19, r19
    2f6c:	0a 94       	dec	r0
    2f6e:	e2 f7       	brpl	.-8      	; 0x2f68 <spi_new_instance+0xe4>
    2f70:	27 2b       	or	r18, r23
    2f72:	2c 93       	st	X, r18
    2f74:	90 93 04 19 	sts	0x1904, r25
    2f78:	80 93 03 19 	sts	0x1903, r24
    2f7c:	6f bf       	out	0x3f, r22	; 63
    2f7e:	cf 01       	movw	r24, r30
    2f80:	df 91       	pop	r29
    2f82:	cf 91       	pop	r28
    2f84:	1f 91       	pop	r17
    2f86:	0f 91       	pop	r16
    2f88:	ff 90       	pop	r15
    2f8a:	ef 90       	pop	r14
    2f8c:	df 90       	pop	r13
    2f8e:	cf 90       	pop	r12
    2f90:	bf 90       	pop	r11
    2f92:	af 90       	pop	r10
    2f94:	9f 90       	pop	r9
    2f96:	8f 90       	pop	r8
    2f98:	7f 90       	pop	r7
    2f9a:	6f 90       	pop	r6
    2f9c:	08 95       	ret

00002f9e <spi_send_string>:
SPI_ILLEGAL_INSTANCE: instance is null.
@param spi to send to.
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
    2f9e:	df 92       	push	r13
    2fa0:	ef 92       	push	r14
    2fa2:	ff 92       	push	r15
    2fa4:	0f 93       	push	r16
    2fa6:	1f 93       	push	r17
    2fa8:	cf 93       	push	r28
    2faa:	df 93       	push	r29
    2fac:	ec 01       	movw	r28, r24
    2fae:	8b 01       	movw	r16, r22
    2fb0:	f4 2e       	mov	r15, r20
	if (spi == 0) {
    2fb2:	00 97       	sbiw	r24, 0x00	; 0
    2fb4:	09 f4       	brne	.+2      	; 0x2fb8 <spi_send_string+0x1a>
    2fb6:	6b c0       	rjmp	.+214    	; 0x308e <spi_send_string+0xf0>
		return SPI_ILLEGAL_INSTANCE;
	}

	// Select correct instance
	if (_this != spi ) {
    2fb8:	80 91 03 19 	lds	r24, 0x1903
    2fbc:	90 91 04 19 	lds	r25, 0x1904
    2fc0:	8c 17       	cp	r24, r28
    2fc2:	9d 07       	cpc	r25, r29
    2fc4:	11 f0       	breq	.+4      	; 0x2fca <spi_send_string+0x2c>
		_select_instance(spi);
    2fc6:	ce 01       	movw	r24, r28
    2fc8:	23 df       	rcall	.-442    	; 0x2e10 <_select_instance>
	uint8_t tmp = 0;

	// Critical section
	{
		// disable interrupt
		uint8_t c_sreg = SREG;
    2fca:	ef b6       	in	r14, 0x3f	; 63
		cli();
    2fcc:	f8 94       	cli

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
    2fce:	ee 81       	ldd	r30, Y+6	; 0x06
    2fd0:	ff 81       	ldd	r31, Y+7	; 0x07
    2fd2:	30 97       	sbiw	r30, 0x00	; 0
    2fd4:	61 f0       	breq	.+24     	; 0x2fee <spi_send_string+0x50>
    2fd6:	2f 2d       	mov	r18, r15
    2fd8:	30 e0       	ldi	r19, 0x00	; 0
    2fda:	42 a5       	ldd	r20, Z+42	; 0x2a
    2fdc:	88 e2       	ldi	r24, 0x28	; 40
    2fde:	90 e0       	ldi	r25, 0x00	; 0
    2fe0:	84 1b       	sub	r24, r20
    2fe2:	91 09       	sbc	r25, r1
    2fe4:	82 17       	cp	r24, r18
    2fe6:	93 07       	cpc	r25, r19
    2fe8:	0c f4       	brge	.+2      	; 0x2fec <spi_send_string+0x4e>
    2fea:	48 c0       	rjmp	.+144    	; 0x307c <spi_send_string+0xde>
    2fec:	04 c0       	rjmp	.+8      	; 0x2ff6 <spi_send_string+0x58>
    2fee:	81 e0       	ldi	r24, 0x01	; 1
    2ff0:	8f 15       	cp	r24, r15
    2ff2:	08 f4       	brcc	.+2      	; 0x2ff6 <spi_send_string+0x58>
    2ff4:	45 c0       	rjmp	.+138    	; 0x3080 <spi_send_string+0xe2>
			result = SPI_NO_ROOM_IN_TX_BUFFER;
			} else {
			// If SPI in idle send the first byte
			if (!_spi_active) {
    2ff6:	80 91 05 19 	lds	r24, 0x1905
    2ffa:	81 11       	cpse	r24, r1
    2ffc:	30 c0       	rjmp	.+96     	; 0x305e <spi_send_string+0xc0>
				_spi_active = 1;
    2ffe:	81 e0       	ldi	r24, 0x01	; 1
    3000:	80 93 05 19 	sts	0x1905, r24
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    3004:	e0 91 03 19 	lds	r30, 0x1903
    3008:	f0 91 04 19 	lds	r31, 0x1904
    300c:	83 81       	ldd	r24, Z+3	; 0x03
    300e:	81 30       	cpi	r24, 0x01	; 1
    3010:	79 f4       	brne	.+30     	; 0x3030 <spi_send_string+0x92>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    3012:	a0 81       	ld	r26, Z
    3014:	b1 81       	ldd	r27, Z+1	; 0x01
    3016:	4c 91       	ld	r20, X
    3018:	21 e0       	ldi	r18, 0x01	; 1
    301a:	30 e0       	ldi	r19, 0x00	; 0
    301c:	c9 01       	movw	r24, r18
    301e:	02 80       	ldd	r0, Z+2	; 0x02
    3020:	02 c0       	rjmp	.+4      	; 0x3026 <spi_send_string+0x88>
    3022:	88 0f       	add	r24, r24
    3024:	99 1f       	adc	r25, r25
    3026:	0a 94       	dec	r0
    3028:	e2 f7       	brpl	.-8      	; 0x3022 <spi_send_string+0x84>
    302a:	84 2b       	or	r24, r20
    302c:	8c 93       	st	X, r24
    302e:	0e c0       	rjmp	.+28     	; 0x304c <spi_send_string+0xae>
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
		}
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    3030:	a0 81       	ld	r26, Z
    3032:	b1 81       	ldd	r27, Z+1	; 0x01
    3034:	2c 91       	ld	r18, X
    3036:	81 e0       	ldi	r24, 0x01	; 1
    3038:	90 e0       	ldi	r25, 0x00	; 0
    303a:	02 80       	ldd	r0, Z+2	; 0x02
    303c:	02 c0       	rjmp	.+4      	; 0x3042 <spi_send_string+0xa4>
    303e:	88 0f       	add	r24, r24
    3040:	99 1f       	adc	r25, r25
    3042:	0a 94       	dec	r0
    3044:	e2 f7       	brpl	.-8      	; 0x303e <spi_send_string+0xa0>
    3046:	80 95       	com	r24
    3048:	82 23       	and	r24, r18
    304a:	8c 93       	st	X, r24
			// If SPI in idle send the first byte
			if (!_spi_active) {
				_spi_active = 1;
				_set_cs(CS_ACTIVE);
				// Enable SPI interrupt
				SPCR |= _BV(SPIE);
    304c:	8c b5       	in	r24, 0x2c	; 44
    304e:	80 68       	ori	r24, 0x80	; 128
    3050:	8c bd       	out	0x2c, r24	; 44
				// Send first byte
				SPDR =buf[0];
    3052:	f8 01       	movw	r30, r16
    3054:	80 81       	ld	r24, Z
    3056:	8e bd       	out	0x2e, r24	; 46

				tmp = 1;
    3058:	dd 24       	eor	r13, r13
    305a:	d3 94       	inc	r13
    305c:	01 c0       	rjmp	.+2      	; 0x3060 <spi_send_string+0xc2>
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
	uint8_t tmp = 0;
    305e:	d1 2c       	mov	r13, r1
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    3060:	df 14       	cp	r13, r15
    3062:	80 f4       	brcc	.+32     	; 0x3084 <spi_send_string+0xe6>
				buffer_put_item(spi->_tx_buf, buf[i]);
    3064:	f8 01       	movw	r30, r16
    3066:	ed 0d       	add	r30, r13
    3068:	f1 1d       	adc	r31, r1
    306a:	60 81       	ld	r22, Z
    306c:	8e 81       	ldd	r24, Y+6	; 0x06
    306e:	9f 81       	ldd	r25, Y+7	; 0x07
    3070:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <buffer_put_item>
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    3074:	d3 94       	inc	r13
    3076:	df 14       	cp	r13, r15
    3078:	a8 f3       	brcs	.-22     	; 0x3064 <spi_send_string+0xc6>
    307a:	06 c0       	rjmp	.+12     	; 0x3088 <spi_send_string+0xea>
		uint8_t c_sreg = SREG;
		cli();

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
			result = SPI_NO_ROOM_IN_TX_BUFFER;
    307c:	81 e0       	ldi	r24, 0x01	; 1
    307e:	05 c0       	rjmp	.+10     	; 0x308a <spi_send_string+0xec>
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	03 c0       	rjmp	.+6      	; 0x308a <spi_send_string+0xec>
	// Select correct instance
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
    3084:	80 e0       	ldi	r24, 0x00	; 0
    3086:	01 c0       	rjmp	.+2      	; 0x308a <spi_send_string+0xec>
    3088:	80 e0       	ldi	r24, 0x00	; 0
				buffer_put_item(spi->_tx_buf, buf[i]);
			}
		}

		// restore interrupt state
		SREG = c_sreg;
    308a:	ef be       	out	0x3f, r14	; 63
	}

	return result;
    308c:	01 c0       	rjmp	.+2      	; 0x3090 <spi_send_string+0xf2>
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
	if (spi == 0) {
		return SPI_ILLEGAL_INSTANCE;
    308e:	83 e0       	ldi	r24, 0x03	; 3
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    3090:	df 91       	pop	r29
    3092:	cf 91       	pop	r28
    3094:	1f 91       	pop	r17
    3096:	0f 91       	pop	r16
    3098:	ff 90       	pop	r15
    309a:	ef 90       	pop	r14
    309c:	df 90       	pop	r13
    309e:	08 95       	ret

000030a0 <__vector_24>:

/* ======================================================================================================================= */
/**
@todo Documentation
*/
ISR(SPI_STC_vect) {
    30a0:	1f 92       	push	r1
    30a2:	0f 92       	push	r0
    30a4:	0f b6       	in	r0, 0x3f	; 63
    30a6:	0f 92       	push	r0
    30a8:	11 24       	eor	r1, r1
    30aa:	0b b6       	in	r0, 0x3b	; 59
    30ac:	0f 92       	push	r0
    30ae:	2f 93       	push	r18
    30b0:	3f 93       	push	r19
    30b2:	4f 93       	push	r20
    30b4:	5f 93       	push	r21
    30b6:	6f 93       	push	r22
    30b8:	7f 93       	push	r23
    30ba:	8f 93       	push	r24
    30bc:	9f 93       	push	r25
    30be:	af 93       	push	r26
    30c0:	bf 93       	push	r27
    30c2:	ef 93       	push	r30
    30c4:	ff 93       	push	r31
    30c6:	cf 93       	push	r28
    30c8:	df 93       	push	r29
    30ca:	1f 92       	push	r1
    30cc:	cd b7       	in	r28, 0x3d	; 61
    30ce:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	#if SPI_USE_BUFFER == 1
	// store received byte if receive buffer available

	if (_this->_rx_buf != 0){
    30d0:	e0 91 03 19 	lds	r30, 0x1903
    30d4:	f0 91 04 19 	lds	r31, 0x1904
    30d8:	80 85       	ldd	r24, Z+8	; 0x08
    30da:	91 85       	ldd	r25, Z+9	; 0x09
    30dc:	00 97       	sbiw	r24, 0x00	; 0
    30de:	19 f0       	breq	.+6      	; 0x30e6 <__vector_24+0x46>
		buffer_put_item(_this->_rx_buf, SPDR);
    30e0:	6e b5       	in	r22, 0x2e	; 46
    30e2:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <buffer_put_item>
	}
	// more bytes to send?
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
    30e6:	e0 91 03 19 	lds	r30, 0x1903
    30ea:	f0 91 04 19 	lds	r31, 0x1904
    30ee:	be 01       	movw	r22, r28
    30f0:	6f 5f       	subi	r22, 0xFF	; 255
    30f2:	7f 4f       	sbci	r23, 0xFF	; 255
    30f4:	86 81       	ldd	r24, Z+6	; 0x06
    30f6:	97 81       	ldd	r25, Z+7	; 0x07
    30f8:	0e 94 52 04 	call	0x8a4	; 0x8a4 <buffer_get_item>
    30fc:	81 11       	cpse	r24, r1
    30fe:	03 c0       	rjmp	.+6      	; 0x3106 <__vector_24+0x66>
		_spi_send_byte(item);
    3100:	89 81       	ldd	r24, Y+1	; 0x01
// Indexed by SPI_CLOCK_DIVIDER_xx defines
static const uint8_t _prescaler_mask [] = {0b00,0b01,0b10,0b11,0b00,0b01,0b10};

// Send a byte to the SPI-bus
static inline void _spi_send_byte(uint8_t byte) {
	SPDR = byte;
    3102:	8e bd       	out	0x2e, r24	; 46
    3104:	29 c0       	rjmp	.+82     	; 0x3158 <__vector_24+0xb8>
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
		_spi_send_byte(item);
		} else {
		// No
		// Disable SPI interrupt
		SPCR &= ~_BV(SPIE);
    3106:	8c b5       	in	r24, 0x2c	; 44
    3108:	8f 77       	andi	r24, 0x7F	; 127
    310a:	8c bd       	out	0x2c, r24	; 44
		_spi_active = 0;
    310c:	10 92 05 19 	sts	0x1905, r1
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    3110:	e0 91 03 19 	lds	r30, 0x1903
    3114:	f0 91 04 19 	lds	r31, 0x1904
    3118:	83 81       	ldd	r24, Z+3	; 0x03
    311a:	81 30       	cpi	r24, 0x01	; 1
    311c:	79 f4       	brne	.+30     	; 0x313c <__vector_24+0x9c>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    311e:	a0 81       	ld	r26, Z
    3120:	b1 81       	ldd	r27, Z+1	; 0x01
    3122:	2c 91       	ld	r18, X
    3124:	81 e0       	ldi	r24, 0x01	; 1
    3126:	90 e0       	ldi	r25, 0x00	; 0
    3128:	02 80       	ldd	r0, Z+2	; 0x02
    312a:	02 c0       	rjmp	.+4      	; 0x3130 <__vector_24+0x90>
    312c:	88 0f       	add	r24, r24
    312e:	99 1f       	adc	r25, r25
    3130:	0a 94       	dec	r0
    3132:	e2 f7       	brpl	.-8      	; 0x312c <__vector_24+0x8c>
    3134:	80 95       	com	r24
    3136:	82 23       	and	r24, r18
    3138:	8c 93       	st	X, r24
    313a:	0e c0       	rjmp	.+28     	; 0x3158 <__vector_24+0xb8>
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);

			} else {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    313c:	a0 81       	ld	r26, Z
    313e:	b1 81       	ldd	r27, Z+1	; 0x01
    3140:	4c 91       	ld	r20, X
    3142:	21 e0       	ldi	r18, 0x01	; 1
    3144:	30 e0       	ldi	r19, 0x00	; 0
    3146:	c9 01       	movw	r24, r18
    3148:	02 80       	ldd	r0, Z+2	; 0x02
    314a:	02 c0       	rjmp	.+4      	; 0x3150 <__vector_24+0xb0>
    314c:	88 0f       	add	r24, r24
    314e:	99 1f       	adc	r25, r25
    3150:	0a 94       	dec	r0
    3152:	e2 f7       	brpl	.-8      	; 0x314c <__vector_24+0xac>
    3154:	84 2b       	or	r24, r20
    3156:	8c 93       	st	X, r24
	_spi_active = 0;
	_set_cs(CS_INACTIVE);
	#endif

	// If handler defined - call it with instance and received byte.
	if (_this->_call_back)
    3158:	80 91 03 19 	lds	r24, 0x1903
    315c:	90 91 04 19 	lds	r25, 0x1904
    3160:	dc 01       	movw	r26, r24
    3162:	1a 96       	adiw	r26, 0x0a	; 10
    3164:	ed 91       	ld	r30, X+
    3166:	fc 91       	ld	r31, X
    3168:	1b 97       	sbiw	r26, 0x0b	; 11
    316a:	30 97       	sbiw	r30, 0x00	; 0
    316c:	11 f0       	breq	.+4      	; 0x3172 <__vector_24+0xd2>
	{
		_this->_call_back(_this, item);
    316e:	69 81       	ldd	r22, Y+1	; 0x01
    3170:	19 95       	eicall
	}
    3172:	0f 90       	pop	r0
    3174:	df 91       	pop	r29
    3176:	cf 91       	pop	r28
    3178:	ff 91       	pop	r31
    317a:	ef 91       	pop	r30
    317c:	bf 91       	pop	r27
    317e:	af 91       	pop	r26
    3180:	9f 91       	pop	r25
    3182:	8f 91       	pop	r24
    3184:	7f 91       	pop	r23
    3186:	6f 91       	pop	r22
    3188:	5f 91       	pop	r21
    318a:	4f 91       	pop	r20
    318c:	3f 91       	pop	r19
    318e:	2f 91       	pop	r18
    3190:	0f 90       	pop	r0
    3192:	0b be       	out	0x3b, r0	; 59
    3194:	0f 90       	pop	r0
    3196:	0f be       	out	0x3f, r0	; 63
    3198:	0f 90       	pop	r0
    319a:	1f 90       	pop	r1
    319c:	18 95       	reti

0000319e <__divmodhi4>:
    319e:	97 fb       	bst	r25, 7
    31a0:	07 2e       	mov	r0, r23
    31a2:	16 f4       	brtc	.+4      	; 0x31a8 <__divmodhi4+0xa>
    31a4:	00 94       	com	r0
    31a6:	06 d0       	rcall	.+12     	; 0x31b4 <__divmodhi4_neg1>
    31a8:	77 fd       	sbrc	r23, 7
    31aa:	08 d0       	rcall	.+16     	; 0x31bc <__divmodhi4_neg2>
    31ac:	5e d0       	rcall	.+188    	; 0x326a <__udivmodhi4>
    31ae:	07 fc       	sbrc	r0, 7
    31b0:	05 d0       	rcall	.+10     	; 0x31bc <__divmodhi4_neg2>
    31b2:	3e f4       	brtc	.+14     	; 0x31c2 <__divmodhi4_exit>

000031b4 <__divmodhi4_neg1>:
    31b4:	90 95       	com	r25
    31b6:	81 95       	neg	r24
    31b8:	9f 4f       	sbci	r25, 0xFF	; 255
    31ba:	08 95       	ret

000031bc <__divmodhi4_neg2>:
    31bc:	70 95       	com	r23
    31be:	61 95       	neg	r22
    31c0:	7f 4f       	sbci	r23, 0xFF	; 255

000031c2 <__divmodhi4_exit>:
    31c2:	08 95       	ret

000031c4 <__udivmodsi4>:
    31c4:	a1 e2       	ldi	r26, 0x21	; 33
    31c6:	1a 2e       	mov	r1, r26
    31c8:	aa 1b       	sub	r26, r26
    31ca:	bb 1b       	sub	r27, r27
    31cc:	fd 01       	movw	r30, r26
    31ce:	0d c0       	rjmp	.+26     	; 0x31ea <__udivmodsi4_ep>

000031d0 <__udivmodsi4_loop>:
    31d0:	aa 1f       	adc	r26, r26
    31d2:	bb 1f       	adc	r27, r27
    31d4:	ee 1f       	adc	r30, r30
    31d6:	ff 1f       	adc	r31, r31
    31d8:	a2 17       	cp	r26, r18
    31da:	b3 07       	cpc	r27, r19
    31dc:	e4 07       	cpc	r30, r20
    31de:	f5 07       	cpc	r31, r21
    31e0:	20 f0       	brcs	.+8      	; 0x31ea <__udivmodsi4_ep>
    31e2:	a2 1b       	sub	r26, r18
    31e4:	b3 0b       	sbc	r27, r19
    31e6:	e4 0b       	sbc	r30, r20
    31e8:	f5 0b       	sbc	r31, r21

000031ea <__udivmodsi4_ep>:
    31ea:	66 1f       	adc	r22, r22
    31ec:	77 1f       	adc	r23, r23
    31ee:	88 1f       	adc	r24, r24
    31f0:	99 1f       	adc	r25, r25
    31f2:	1a 94       	dec	r1
    31f4:	69 f7       	brne	.-38     	; 0x31d0 <__udivmodsi4_loop>
    31f6:	60 95       	com	r22
    31f8:	70 95       	com	r23
    31fa:	80 95       	com	r24
    31fc:	90 95       	com	r25
    31fe:	9b 01       	movw	r18, r22
    3200:	ac 01       	movw	r20, r24
    3202:	bd 01       	movw	r22, r26
    3204:	cf 01       	movw	r24, r30
    3206:	08 95       	ret

00003208 <__divmodsi4>:
    3208:	05 2e       	mov	r0, r21
    320a:	97 fb       	bst	r25, 7
    320c:	16 f4       	brtc	.+4      	; 0x3212 <__divmodsi4+0xa>
    320e:	00 94       	com	r0
    3210:	0f d0       	rcall	.+30     	; 0x3230 <__negsi2>
    3212:	57 fd       	sbrc	r21, 7
    3214:	05 d0       	rcall	.+10     	; 0x3220 <__divmodsi4_neg2>
    3216:	d6 df       	rcall	.-84     	; 0x31c4 <__udivmodsi4>
    3218:	07 fc       	sbrc	r0, 7
    321a:	02 d0       	rcall	.+4      	; 0x3220 <__divmodsi4_neg2>
    321c:	46 f4       	brtc	.+16     	; 0x322e <__divmodsi4_exit>
    321e:	08 c0       	rjmp	.+16     	; 0x3230 <__negsi2>

00003220 <__divmodsi4_neg2>:
    3220:	50 95       	com	r21
    3222:	40 95       	com	r20
    3224:	30 95       	com	r19
    3226:	21 95       	neg	r18
    3228:	3f 4f       	sbci	r19, 0xFF	; 255
    322a:	4f 4f       	sbci	r20, 0xFF	; 255
    322c:	5f 4f       	sbci	r21, 0xFF	; 255

0000322e <__divmodsi4_exit>:
    322e:	08 95       	ret

00003230 <__negsi2>:
    3230:	90 95       	com	r25
    3232:	80 95       	com	r24
    3234:	70 95       	com	r23
    3236:	61 95       	neg	r22
    3238:	7f 4f       	sbci	r23, 0xFF	; 255
    323a:	8f 4f       	sbci	r24, 0xFF	; 255
    323c:	9f 4f       	sbci	r25, 0xFF	; 255
    323e:	08 95       	ret

00003240 <__tablejump2__>:
    3240:	ee 0f       	add	r30, r30
    3242:	ff 1f       	adc	r31, r31

00003244 <__tablejump__>:
    3244:	05 90       	lpm	r0, Z+
    3246:	f4 91       	lpm	r31, Z
    3248:	e0 2d       	mov	r30, r0
    324a:	19 94       	eijmp

0000324c <__umulhisi3>:
    324c:	a2 9f       	mul	r26, r18
    324e:	b0 01       	movw	r22, r0
    3250:	b3 9f       	mul	r27, r19
    3252:	c0 01       	movw	r24, r0
    3254:	a3 9f       	mul	r26, r19
    3256:	70 0d       	add	r23, r0
    3258:	81 1d       	adc	r24, r1
    325a:	11 24       	eor	r1, r1
    325c:	91 1d       	adc	r25, r1
    325e:	b2 9f       	mul	r27, r18
    3260:	70 0d       	add	r23, r0
    3262:	81 1d       	adc	r24, r1
    3264:	11 24       	eor	r1, r1
    3266:	91 1d       	adc	r25, r1
    3268:	08 95       	ret

0000326a <__udivmodhi4>:
    326a:	aa 1b       	sub	r26, r26
    326c:	bb 1b       	sub	r27, r27
    326e:	51 e1       	ldi	r21, 0x11	; 17
    3270:	07 c0       	rjmp	.+14     	; 0x3280 <__udivmodhi4_ep>

00003272 <__udivmodhi4_loop>:
    3272:	aa 1f       	adc	r26, r26
    3274:	bb 1f       	adc	r27, r27
    3276:	a6 17       	cp	r26, r22
    3278:	b7 07       	cpc	r27, r23
    327a:	10 f0       	brcs	.+4      	; 0x3280 <__udivmodhi4_ep>
    327c:	a6 1b       	sub	r26, r22
    327e:	b7 0b       	sbc	r27, r23

00003280 <__udivmodhi4_ep>:
    3280:	88 1f       	adc	r24, r24
    3282:	99 1f       	adc	r25, r25
    3284:	5a 95       	dec	r21
    3286:	a9 f7       	brne	.-22     	; 0x3272 <__udivmodhi4_loop>
    3288:	80 95       	com	r24
    328a:	90 95       	com	r25
    328c:	bc 01       	movw	r22, r24
    328e:	cd 01       	movw	r24, r26
    3290:	08 95       	ret

00003292 <malloc>:
    3292:	cf 93       	push	r28
    3294:	df 93       	push	r29
    3296:	82 30       	cpi	r24, 0x02	; 2
    3298:	91 05       	cpc	r25, r1
    329a:	10 f4       	brcc	.+4      	; 0x32a0 <malloc+0xe>
    329c:	82 e0       	ldi	r24, 0x02	; 2
    329e:	90 e0       	ldi	r25, 0x00	; 0
    32a0:	e0 91 0a 19 	lds	r30, 0x190A
    32a4:	f0 91 0b 19 	lds	r31, 0x190B
    32a8:	20 e0       	ldi	r18, 0x00	; 0
    32aa:	30 e0       	ldi	r19, 0x00	; 0
    32ac:	a0 e0       	ldi	r26, 0x00	; 0
    32ae:	b0 e0       	ldi	r27, 0x00	; 0
    32b0:	30 97       	sbiw	r30, 0x00	; 0
    32b2:	39 f1       	breq	.+78     	; 0x3302 <malloc+0x70>
    32b4:	40 81       	ld	r20, Z
    32b6:	51 81       	ldd	r21, Z+1	; 0x01
    32b8:	48 17       	cp	r20, r24
    32ba:	59 07       	cpc	r21, r25
    32bc:	b8 f0       	brcs	.+46     	; 0x32ec <malloc+0x5a>
    32be:	48 17       	cp	r20, r24
    32c0:	59 07       	cpc	r21, r25
    32c2:	71 f4       	brne	.+28     	; 0x32e0 <malloc+0x4e>
    32c4:	82 81       	ldd	r24, Z+2	; 0x02
    32c6:	93 81       	ldd	r25, Z+3	; 0x03
    32c8:	10 97       	sbiw	r26, 0x00	; 0
    32ca:	29 f0       	breq	.+10     	; 0x32d6 <malloc+0x44>
    32cc:	13 96       	adiw	r26, 0x03	; 3
    32ce:	9c 93       	st	X, r25
    32d0:	8e 93       	st	-X, r24
    32d2:	12 97       	sbiw	r26, 0x02	; 2
    32d4:	2c c0       	rjmp	.+88     	; 0x332e <malloc+0x9c>
    32d6:	90 93 0b 19 	sts	0x190B, r25
    32da:	80 93 0a 19 	sts	0x190A, r24
    32de:	27 c0       	rjmp	.+78     	; 0x332e <malloc+0x9c>
    32e0:	21 15       	cp	r18, r1
    32e2:	31 05       	cpc	r19, r1
    32e4:	31 f0       	breq	.+12     	; 0x32f2 <malloc+0x60>
    32e6:	42 17       	cp	r20, r18
    32e8:	53 07       	cpc	r21, r19
    32ea:	18 f0       	brcs	.+6      	; 0x32f2 <malloc+0x60>
    32ec:	a9 01       	movw	r20, r18
    32ee:	db 01       	movw	r26, r22
    32f0:	01 c0       	rjmp	.+2      	; 0x32f4 <malloc+0x62>
    32f2:	ef 01       	movw	r28, r30
    32f4:	9a 01       	movw	r18, r20
    32f6:	bd 01       	movw	r22, r26
    32f8:	df 01       	movw	r26, r30
    32fa:	02 80       	ldd	r0, Z+2	; 0x02
    32fc:	f3 81       	ldd	r31, Z+3	; 0x03
    32fe:	e0 2d       	mov	r30, r0
    3300:	d7 cf       	rjmp	.-82     	; 0x32b0 <malloc+0x1e>
    3302:	21 15       	cp	r18, r1
    3304:	31 05       	cpc	r19, r1
    3306:	f9 f0       	breq	.+62     	; 0x3346 <malloc+0xb4>
    3308:	28 1b       	sub	r18, r24
    330a:	39 0b       	sbc	r19, r25
    330c:	24 30       	cpi	r18, 0x04	; 4
    330e:	31 05       	cpc	r19, r1
    3310:	80 f4       	brcc	.+32     	; 0x3332 <malloc+0xa0>
    3312:	8a 81       	ldd	r24, Y+2	; 0x02
    3314:	9b 81       	ldd	r25, Y+3	; 0x03
    3316:	61 15       	cp	r22, r1
    3318:	71 05       	cpc	r23, r1
    331a:	21 f0       	breq	.+8      	; 0x3324 <malloc+0x92>
    331c:	fb 01       	movw	r30, r22
    331e:	93 83       	std	Z+3, r25	; 0x03
    3320:	82 83       	std	Z+2, r24	; 0x02
    3322:	04 c0       	rjmp	.+8      	; 0x332c <malloc+0x9a>
    3324:	90 93 0b 19 	sts	0x190B, r25
    3328:	80 93 0a 19 	sts	0x190A, r24
    332c:	fe 01       	movw	r30, r28
    332e:	32 96       	adiw	r30, 0x02	; 2
    3330:	44 c0       	rjmp	.+136    	; 0x33ba <malloc+0x128>
    3332:	fe 01       	movw	r30, r28
    3334:	e2 0f       	add	r30, r18
    3336:	f3 1f       	adc	r31, r19
    3338:	81 93       	st	Z+, r24
    333a:	91 93       	st	Z+, r25
    333c:	22 50       	subi	r18, 0x02	; 2
    333e:	31 09       	sbc	r19, r1
    3340:	39 83       	std	Y+1, r19	; 0x01
    3342:	28 83       	st	Y, r18
    3344:	3a c0       	rjmp	.+116    	; 0x33ba <malloc+0x128>
    3346:	20 91 08 19 	lds	r18, 0x1908
    334a:	30 91 09 19 	lds	r19, 0x1909
    334e:	23 2b       	or	r18, r19
    3350:	41 f4       	brne	.+16     	; 0x3362 <malloc+0xd0>
    3352:	20 91 02 02 	lds	r18, 0x0202
    3356:	30 91 03 02 	lds	r19, 0x0203
    335a:	30 93 09 19 	sts	0x1909, r19
    335e:	20 93 08 19 	sts	0x1908, r18
    3362:	20 91 00 02 	lds	r18, 0x0200
    3366:	30 91 01 02 	lds	r19, 0x0201
    336a:	21 15       	cp	r18, r1
    336c:	31 05       	cpc	r19, r1
    336e:	41 f4       	brne	.+16     	; 0x3380 <malloc+0xee>
    3370:	2d b7       	in	r18, 0x3d	; 61
    3372:	3e b7       	in	r19, 0x3e	; 62
    3374:	40 91 04 02 	lds	r20, 0x0204
    3378:	50 91 05 02 	lds	r21, 0x0205
    337c:	24 1b       	sub	r18, r20
    337e:	35 0b       	sbc	r19, r21
    3380:	e0 91 08 19 	lds	r30, 0x1908
    3384:	f0 91 09 19 	lds	r31, 0x1909
    3388:	e2 17       	cp	r30, r18
    338a:	f3 07       	cpc	r31, r19
    338c:	a0 f4       	brcc	.+40     	; 0x33b6 <malloc+0x124>
    338e:	2e 1b       	sub	r18, r30
    3390:	3f 0b       	sbc	r19, r31
    3392:	28 17       	cp	r18, r24
    3394:	39 07       	cpc	r19, r25
    3396:	78 f0       	brcs	.+30     	; 0x33b6 <malloc+0x124>
    3398:	ac 01       	movw	r20, r24
    339a:	4e 5f       	subi	r20, 0xFE	; 254
    339c:	5f 4f       	sbci	r21, 0xFF	; 255
    339e:	24 17       	cp	r18, r20
    33a0:	35 07       	cpc	r19, r21
    33a2:	48 f0       	brcs	.+18     	; 0x33b6 <malloc+0x124>
    33a4:	4e 0f       	add	r20, r30
    33a6:	5f 1f       	adc	r21, r31
    33a8:	50 93 09 19 	sts	0x1909, r21
    33ac:	40 93 08 19 	sts	0x1908, r20
    33b0:	81 93       	st	Z+, r24
    33b2:	91 93       	st	Z+, r25
    33b4:	02 c0       	rjmp	.+4      	; 0x33ba <malloc+0x128>
    33b6:	e0 e0       	ldi	r30, 0x00	; 0
    33b8:	f0 e0       	ldi	r31, 0x00	; 0
    33ba:	cf 01       	movw	r24, r30
    33bc:	df 91       	pop	r29
    33be:	cf 91       	pop	r28
    33c0:	08 95       	ret

000033c2 <free>:
    33c2:	cf 93       	push	r28
    33c4:	df 93       	push	r29
    33c6:	00 97       	sbiw	r24, 0x00	; 0
    33c8:	09 f4       	brne	.+2      	; 0x33cc <free+0xa>
    33ca:	87 c0       	rjmp	.+270    	; 0x34da <free+0x118>
    33cc:	fc 01       	movw	r30, r24
    33ce:	32 97       	sbiw	r30, 0x02	; 2
    33d0:	13 82       	std	Z+3, r1	; 0x03
    33d2:	12 82       	std	Z+2, r1	; 0x02
    33d4:	c0 91 0a 19 	lds	r28, 0x190A
    33d8:	d0 91 0b 19 	lds	r29, 0x190B
    33dc:	20 97       	sbiw	r28, 0x00	; 0
    33de:	81 f4       	brne	.+32     	; 0x3400 <free+0x3e>
    33e0:	20 81       	ld	r18, Z
    33e2:	31 81       	ldd	r19, Z+1	; 0x01
    33e4:	28 0f       	add	r18, r24
    33e6:	39 1f       	adc	r19, r25
    33e8:	80 91 08 19 	lds	r24, 0x1908
    33ec:	90 91 09 19 	lds	r25, 0x1909
    33f0:	82 17       	cp	r24, r18
    33f2:	93 07       	cpc	r25, r19
    33f4:	79 f5       	brne	.+94     	; 0x3454 <free+0x92>
    33f6:	f0 93 09 19 	sts	0x1909, r31
    33fa:	e0 93 08 19 	sts	0x1908, r30
    33fe:	6d c0       	rjmp	.+218    	; 0x34da <free+0x118>
    3400:	de 01       	movw	r26, r28
    3402:	20 e0       	ldi	r18, 0x00	; 0
    3404:	30 e0       	ldi	r19, 0x00	; 0
    3406:	ae 17       	cp	r26, r30
    3408:	bf 07       	cpc	r27, r31
    340a:	50 f4       	brcc	.+20     	; 0x3420 <free+0x5e>
    340c:	12 96       	adiw	r26, 0x02	; 2
    340e:	4d 91       	ld	r20, X+
    3410:	5c 91       	ld	r21, X
    3412:	13 97       	sbiw	r26, 0x03	; 3
    3414:	9d 01       	movw	r18, r26
    3416:	41 15       	cp	r20, r1
    3418:	51 05       	cpc	r21, r1
    341a:	09 f1       	breq	.+66     	; 0x345e <free+0x9c>
    341c:	da 01       	movw	r26, r20
    341e:	f3 cf       	rjmp	.-26     	; 0x3406 <free+0x44>
    3420:	b3 83       	std	Z+3, r27	; 0x03
    3422:	a2 83       	std	Z+2, r26	; 0x02
    3424:	40 81       	ld	r20, Z
    3426:	51 81       	ldd	r21, Z+1	; 0x01
    3428:	84 0f       	add	r24, r20
    342a:	95 1f       	adc	r25, r21
    342c:	8a 17       	cp	r24, r26
    342e:	9b 07       	cpc	r25, r27
    3430:	71 f4       	brne	.+28     	; 0x344e <free+0x8c>
    3432:	8d 91       	ld	r24, X+
    3434:	9c 91       	ld	r25, X
    3436:	11 97       	sbiw	r26, 0x01	; 1
    3438:	84 0f       	add	r24, r20
    343a:	95 1f       	adc	r25, r21
    343c:	02 96       	adiw	r24, 0x02	; 2
    343e:	91 83       	std	Z+1, r25	; 0x01
    3440:	80 83       	st	Z, r24
    3442:	12 96       	adiw	r26, 0x02	; 2
    3444:	8d 91       	ld	r24, X+
    3446:	9c 91       	ld	r25, X
    3448:	13 97       	sbiw	r26, 0x03	; 3
    344a:	93 83       	std	Z+3, r25	; 0x03
    344c:	82 83       	std	Z+2, r24	; 0x02
    344e:	21 15       	cp	r18, r1
    3450:	31 05       	cpc	r19, r1
    3452:	29 f4       	brne	.+10     	; 0x345e <free+0x9c>
    3454:	f0 93 0b 19 	sts	0x190B, r31
    3458:	e0 93 0a 19 	sts	0x190A, r30
    345c:	3e c0       	rjmp	.+124    	; 0x34da <free+0x118>
    345e:	d9 01       	movw	r26, r18
    3460:	13 96       	adiw	r26, 0x03	; 3
    3462:	fc 93       	st	X, r31
    3464:	ee 93       	st	-X, r30
    3466:	12 97       	sbiw	r26, 0x02	; 2
    3468:	4d 91       	ld	r20, X+
    346a:	5d 91       	ld	r21, X+
    346c:	a4 0f       	add	r26, r20
    346e:	b5 1f       	adc	r27, r21
    3470:	ea 17       	cp	r30, r26
    3472:	fb 07       	cpc	r31, r27
    3474:	79 f4       	brne	.+30     	; 0x3494 <free+0xd2>
    3476:	80 81       	ld	r24, Z
    3478:	91 81       	ldd	r25, Z+1	; 0x01
    347a:	84 0f       	add	r24, r20
    347c:	95 1f       	adc	r25, r21
    347e:	02 96       	adiw	r24, 0x02	; 2
    3480:	d9 01       	movw	r26, r18
    3482:	11 96       	adiw	r26, 0x01	; 1
    3484:	9c 93       	st	X, r25
    3486:	8e 93       	st	-X, r24
    3488:	82 81       	ldd	r24, Z+2	; 0x02
    348a:	93 81       	ldd	r25, Z+3	; 0x03
    348c:	13 96       	adiw	r26, 0x03	; 3
    348e:	9c 93       	st	X, r25
    3490:	8e 93       	st	-X, r24
    3492:	12 97       	sbiw	r26, 0x02	; 2
    3494:	e0 e0       	ldi	r30, 0x00	; 0
    3496:	f0 e0       	ldi	r31, 0x00	; 0
    3498:	8a 81       	ldd	r24, Y+2	; 0x02
    349a:	9b 81       	ldd	r25, Y+3	; 0x03
    349c:	00 97       	sbiw	r24, 0x00	; 0
    349e:	19 f0       	breq	.+6      	; 0x34a6 <free+0xe4>
    34a0:	fe 01       	movw	r30, r28
    34a2:	ec 01       	movw	r28, r24
    34a4:	f9 cf       	rjmp	.-14     	; 0x3498 <free+0xd6>
    34a6:	ce 01       	movw	r24, r28
    34a8:	02 96       	adiw	r24, 0x02	; 2
    34aa:	28 81       	ld	r18, Y
    34ac:	39 81       	ldd	r19, Y+1	; 0x01
    34ae:	82 0f       	add	r24, r18
    34b0:	93 1f       	adc	r25, r19
    34b2:	20 91 08 19 	lds	r18, 0x1908
    34b6:	30 91 09 19 	lds	r19, 0x1909
    34ba:	28 17       	cp	r18, r24
    34bc:	39 07       	cpc	r19, r25
    34be:	69 f4       	brne	.+26     	; 0x34da <free+0x118>
    34c0:	30 97       	sbiw	r30, 0x00	; 0
    34c2:	29 f4       	brne	.+10     	; 0x34ce <free+0x10c>
    34c4:	10 92 0b 19 	sts	0x190B, r1
    34c8:	10 92 0a 19 	sts	0x190A, r1
    34cc:	02 c0       	rjmp	.+4      	; 0x34d2 <free+0x110>
    34ce:	13 82       	std	Z+3, r1	; 0x03
    34d0:	12 82       	std	Z+2, r1	; 0x02
    34d2:	d0 93 09 19 	sts	0x1909, r29
    34d6:	c0 93 08 19 	sts	0x1908, r28
    34da:	df 91       	pop	r29
    34dc:	cf 91       	pop	r28
    34de:	08 95       	ret

000034e0 <atoi>:
    34e0:	fc 01       	movw	r30, r24
    34e2:	88 27       	eor	r24, r24
    34e4:	99 27       	eor	r25, r25
    34e6:	e8 94       	clt
    34e8:	21 91       	ld	r18, Z+
    34ea:	20 32       	cpi	r18, 0x20	; 32
    34ec:	e9 f3       	breq	.-6      	; 0x34e8 <atoi+0x8>
    34ee:	29 30       	cpi	r18, 0x09	; 9
    34f0:	10 f0       	brcs	.+4      	; 0x34f6 <atoi+0x16>
    34f2:	2e 30       	cpi	r18, 0x0E	; 14
    34f4:	c8 f3       	brcs	.-14     	; 0x34e8 <atoi+0x8>
    34f6:	2b 32       	cpi	r18, 0x2B	; 43
    34f8:	39 f0       	breq	.+14     	; 0x3508 <atoi+0x28>
    34fa:	2d 32       	cpi	r18, 0x2D	; 45
    34fc:	31 f4       	brne	.+12     	; 0x350a <atoi+0x2a>
    34fe:	68 94       	set
    3500:	03 c0       	rjmp	.+6      	; 0x3508 <atoi+0x28>
    3502:	14 d0       	rcall	.+40     	; 0x352c <__mulhi_const_10>
    3504:	82 0f       	add	r24, r18
    3506:	91 1d       	adc	r25, r1
    3508:	21 91       	ld	r18, Z+
    350a:	20 53       	subi	r18, 0x30	; 48
    350c:	2a 30       	cpi	r18, 0x0A	; 10
    350e:	c8 f3       	brcs	.-14     	; 0x3502 <atoi+0x22>
    3510:	1e f4       	brtc	.+6      	; 0x3518 <atoi+0x38>
    3512:	90 95       	com	r25
    3514:	81 95       	neg	r24
    3516:	9f 4f       	sbci	r25, 0xFF	; 255
    3518:	08 95       	ret

0000351a <memcpy>:
    351a:	fb 01       	movw	r30, r22
    351c:	dc 01       	movw	r26, r24
    351e:	02 c0       	rjmp	.+4      	; 0x3524 <memcpy+0xa>
    3520:	01 90       	ld	r0, Z+
    3522:	0d 92       	st	X+, r0
    3524:	41 50       	subi	r20, 0x01	; 1
    3526:	50 40       	sbci	r21, 0x00	; 0
    3528:	d8 f7       	brcc	.-10     	; 0x3520 <memcpy+0x6>
    352a:	08 95       	ret

0000352c <__mulhi_const_10>:
    352c:	7a e0       	ldi	r23, 0x0A	; 10
    352e:	97 9f       	mul	r25, r23
    3530:	90 2d       	mov	r25, r0
    3532:	87 9f       	mul	r24, r23
    3534:	80 2d       	mov	r24, r0
    3536:	91 0d       	add	r25, r1
    3538:	11 24       	eor	r1, r1
    353a:	08 95       	ret

0000353c <sprintf>:
    353c:	0f 93       	push	r16
    353e:	1f 93       	push	r17
    3540:	cf 93       	push	r28
    3542:	df 93       	push	r29
    3544:	cd b7       	in	r28, 0x3d	; 61
    3546:	de b7       	in	r29, 0x3e	; 62
    3548:	2e 97       	sbiw	r28, 0x0e	; 14
    354a:	0f b6       	in	r0, 0x3f	; 63
    354c:	f8 94       	cli
    354e:	de bf       	out	0x3e, r29	; 62
    3550:	0f be       	out	0x3f, r0	; 63
    3552:	cd bf       	out	0x3d, r28	; 61
    3554:	0e 89       	ldd	r16, Y+22	; 0x16
    3556:	1f 89       	ldd	r17, Y+23	; 0x17
    3558:	86 e0       	ldi	r24, 0x06	; 6
    355a:	8c 83       	std	Y+4, r24	; 0x04
    355c:	1a 83       	std	Y+2, r17	; 0x02
    355e:	09 83       	std	Y+1, r16	; 0x01
    3560:	8f ef       	ldi	r24, 0xFF	; 255
    3562:	9f e7       	ldi	r25, 0x7F	; 127
    3564:	9e 83       	std	Y+6, r25	; 0x06
    3566:	8d 83       	std	Y+5, r24	; 0x05
    3568:	ae 01       	movw	r20, r28
    356a:	46 5e       	subi	r20, 0xE6	; 230
    356c:	5f 4f       	sbci	r21, 0xFF	; 255
    356e:	68 8d       	ldd	r22, Y+24	; 0x18
    3570:	79 8d       	ldd	r23, Y+25	; 0x19
    3572:	ce 01       	movw	r24, r28
    3574:	01 96       	adiw	r24, 0x01	; 1
    3576:	10 d0       	rcall	.+32     	; 0x3598 <vfprintf>
    3578:	ef 81       	ldd	r30, Y+7	; 0x07
    357a:	f8 85       	ldd	r31, Y+8	; 0x08
    357c:	e0 0f       	add	r30, r16
    357e:	f1 1f       	adc	r31, r17
    3580:	10 82       	st	Z, r1
    3582:	2e 96       	adiw	r28, 0x0e	; 14
    3584:	0f b6       	in	r0, 0x3f	; 63
    3586:	f8 94       	cli
    3588:	de bf       	out	0x3e, r29	; 62
    358a:	0f be       	out	0x3f, r0	; 63
    358c:	cd bf       	out	0x3d, r28	; 61
    358e:	df 91       	pop	r29
    3590:	cf 91       	pop	r28
    3592:	1f 91       	pop	r17
    3594:	0f 91       	pop	r16
    3596:	08 95       	ret

00003598 <vfprintf>:
    3598:	2f 92       	push	r2
    359a:	3f 92       	push	r3
    359c:	4f 92       	push	r4
    359e:	5f 92       	push	r5
    35a0:	6f 92       	push	r6
    35a2:	7f 92       	push	r7
    35a4:	8f 92       	push	r8
    35a6:	9f 92       	push	r9
    35a8:	af 92       	push	r10
    35aa:	bf 92       	push	r11
    35ac:	cf 92       	push	r12
    35ae:	df 92       	push	r13
    35b0:	ef 92       	push	r14
    35b2:	ff 92       	push	r15
    35b4:	0f 93       	push	r16
    35b6:	1f 93       	push	r17
    35b8:	cf 93       	push	r28
    35ba:	df 93       	push	r29
    35bc:	cd b7       	in	r28, 0x3d	; 61
    35be:	de b7       	in	r29, 0x3e	; 62
    35c0:	2c 97       	sbiw	r28, 0x0c	; 12
    35c2:	0f b6       	in	r0, 0x3f	; 63
    35c4:	f8 94       	cli
    35c6:	de bf       	out	0x3e, r29	; 62
    35c8:	0f be       	out	0x3f, r0	; 63
    35ca:	cd bf       	out	0x3d, r28	; 61
    35cc:	7c 01       	movw	r14, r24
    35ce:	6b 01       	movw	r12, r22
    35d0:	8a 01       	movw	r16, r20
    35d2:	fc 01       	movw	r30, r24
    35d4:	17 82       	std	Z+7, r1	; 0x07
    35d6:	16 82       	std	Z+6, r1	; 0x06
    35d8:	83 81       	ldd	r24, Z+3	; 0x03
    35da:	81 ff       	sbrs	r24, 1
    35dc:	b0 c1       	rjmp	.+864    	; 0x393e <vfprintf+0x3a6>
    35de:	ce 01       	movw	r24, r28
    35e0:	01 96       	adiw	r24, 0x01	; 1
    35e2:	4c 01       	movw	r8, r24
    35e4:	f7 01       	movw	r30, r14
    35e6:	93 81       	ldd	r25, Z+3	; 0x03
    35e8:	f6 01       	movw	r30, r12
    35ea:	93 fd       	sbrc	r25, 3
    35ec:	85 91       	lpm	r24, Z+
    35ee:	93 ff       	sbrs	r25, 3
    35f0:	81 91       	ld	r24, Z+
    35f2:	6f 01       	movw	r12, r30
    35f4:	88 23       	and	r24, r24
    35f6:	09 f4       	brne	.+2      	; 0x35fa <vfprintf+0x62>
    35f8:	9e c1       	rjmp	.+828    	; 0x3936 <vfprintf+0x39e>
    35fa:	85 32       	cpi	r24, 0x25	; 37
    35fc:	39 f4       	brne	.+14     	; 0x360c <vfprintf+0x74>
    35fe:	93 fd       	sbrc	r25, 3
    3600:	85 91       	lpm	r24, Z+
    3602:	93 ff       	sbrs	r25, 3
    3604:	81 91       	ld	r24, Z+
    3606:	6f 01       	movw	r12, r30
    3608:	85 32       	cpi	r24, 0x25	; 37
    360a:	21 f4       	brne	.+8      	; 0x3614 <vfprintf+0x7c>
    360c:	b7 01       	movw	r22, r14
    360e:	90 e0       	ldi	r25, 0x00	; 0
    3610:	c7 d1       	rcall	.+910    	; 0x39a0 <fputc>
    3612:	e8 cf       	rjmp	.-48     	; 0x35e4 <vfprintf+0x4c>
    3614:	51 2c       	mov	r5, r1
    3616:	31 2c       	mov	r3, r1
    3618:	20 e0       	ldi	r18, 0x00	; 0
    361a:	20 32       	cpi	r18, 0x20	; 32
    361c:	a0 f4       	brcc	.+40     	; 0x3646 <vfprintf+0xae>
    361e:	8b 32       	cpi	r24, 0x2B	; 43
    3620:	69 f0       	breq	.+26     	; 0x363c <vfprintf+0xa4>
    3622:	30 f4       	brcc	.+12     	; 0x3630 <vfprintf+0x98>
    3624:	80 32       	cpi	r24, 0x20	; 32
    3626:	59 f0       	breq	.+22     	; 0x363e <vfprintf+0xa6>
    3628:	83 32       	cpi	r24, 0x23	; 35
    362a:	69 f4       	brne	.+26     	; 0x3646 <vfprintf+0xae>
    362c:	20 61       	ori	r18, 0x10	; 16
    362e:	2c c0       	rjmp	.+88     	; 0x3688 <vfprintf+0xf0>
    3630:	8d 32       	cpi	r24, 0x2D	; 45
    3632:	39 f0       	breq	.+14     	; 0x3642 <vfprintf+0xaa>
    3634:	80 33       	cpi	r24, 0x30	; 48
    3636:	39 f4       	brne	.+14     	; 0x3646 <vfprintf+0xae>
    3638:	21 60       	ori	r18, 0x01	; 1
    363a:	26 c0       	rjmp	.+76     	; 0x3688 <vfprintf+0xf0>
    363c:	22 60       	ori	r18, 0x02	; 2
    363e:	24 60       	ori	r18, 0x04	; 4
    3640:	23 c0       	rjmp	.+70     	; 0x3688 <vfprintf+0xf0>
    3642:	28 60       	ori	r18, 0x08	; 8
    3644:	21 c0       	rjmp	.+66     	; 0x3688 <vfprintf+0xf0>
    3646:	27 fd       	sbrc	r18, 7
    3648:	27 c0       	rjmp	.+78     	; 0x3698 <vfprintf+0x100>
    364a:	30 ed       	ldi	r19, 0xD0	; 208
    364c:	38 0f       	add	r19, r24
    364e:	3a 30       	cpi	r19, 0x0A	; 10
    3650:	78 f4       	brcc	.+30     	; 0x3670 <vfprintf+0xd8>
    3652:	26 ff       	sbrs	r18, 6
    3654:	06 c0       	rjmp	.+12     	; 0x3662 <vfprintf+0xca>
    3656:	fa e0       	ldi	r31, 0x0A	; 10
    3658:	5f 9e       	mul	r5, r31
    365a:	30 0d       	add	r19, r0
    365c:	11 24       	eor	r1, r1
    365e:	53 2e       	mov	r5, r19
    3660:	13 c0       	rjmp	.+38     	; 0x3688 <vfprintf+0xf0>
    3662:	8a e0       	ldi	r24, 0x0A	; 10
    3664:	38 9e       	mul	r3, r24
    3666:	30 0d       	add	r19, r0
    3668:	11 24       	eor	r1, r1
    366a:	33 2e       	mov	r3, r19
    366c:	20 62       	ori	r18, 0x20	; 32
    366e:	0c c0       	rjmp	.+24     	; 0x3688 <vfprintf+0xf0>
    3670:	8e 32       	cpi	r24, 0x2E	; 46
    3672:	21 f4       	brne	.+8      	; 0x367c <vfprintf+0xe4>
    3674:	26 fd       	sbrc	r18, 6
    3676:	5f c1       	rjmp	.+702    	; 0x3936 <vfprintf+0x39e>
    3678:	20 64       	ori	r18, 0x40	; 64
    367a:	06 c0       	rjmp	.+12     	; 0x3688 <vfprintf+0xf0>
    367c:	8c 36       	cpi	r24, 0x6C	; 108
    367e:	11 f4       	brne	.+4      	; 0x3684 <vfprintf+0xec>
    3680:	20 68       	ori	r18, 0x80	; 128
    3682:	02 c0       	rjmp	.+4      	; 0x3688 <vfprintf+0xf0>
    3684:	88 36       	cpi	r24, 0x68	; 104
    3686:	41 f4       	brne	.+16     	; 0x3698 <vfprintf+0x100>
    3688:	f6 01       	movw	r30, r12
    368a:	93 fd       	sbrc	r25, 3
    368c:	85 91       	lpm	r24, Z+
    368e:	93 ff       	sbrs	r25, 3
    3690:	81 91       	ld	r24, Z+
    3692:	6f 01       	movw	r12, r30
    3694:	81 11       	cpse	r24, r1
    3696:	c1 cf       	rjmp	.-126    	; 0x361a <vfprintf+0x82>
    3698:	98 2f       	mov	r25, r24
    369a:	9f 7d       	andi	r25, 0xDF	; 223
    369c:	95 54       	subi	r25, 0x45	; 69
    369e:	93 30       	cpi	r25, 0x03	; 3
    36a0:	28 f4       	brcc	.+10     	; 0x36ac <vfprintf+0x114>
    36a2:	0c 5f       	subi	r16, 0xFC	; 252
    36a4:	1f 4f       	sbci	r17, 0xFF	; 255
    36a6:	ff e3       	ldi	r31, 0x3F	; 63
    36a8:	f9 83       	std	Y+1, r31	; 0x01
    36aa:	0d c0       	rjmp	.+26     	; 0x36c6 <vfprintf+0x12e>
    36ac:	83 36       	cpi	r24, 0x63	; 99
    36ae:	31 f0       	breq	.+12     	; 0x36bc <vfprintf+0x124>
    36b0:	83 37       	cpi	r24, 0x73	; 115
    36b2:	71 f0       	breq	.+28     	; 0x36d0 <vfprintf+0x138>
    36b4:	83 35       	cpi	r24, 0x53	; 83
    36b6:	09 f0       	breq	.+2      	; 0x36ba <vfprintf+0x122>
    36b8:	57 c0       	rjmp	.+174    	; 0x3768 <vfprintf+0x1d0>
    36ba:	21 c0       	rjmp	.+66     	; 0x36fe <vfprintf+0x166>
    36bc:	f8 01       	movw	r30, r16
    36be:	80 81       	ld	r24, Z
    36c0:	89 83       	std	Y+1, r24	; 0x01
    36c2:	0e 5f       	subi	r16, 0xFE	; 254
    36c4:	1f 4f       	sbci	r17, 0xFF	; 255
    36c6:	44 24       	eor	r4, r4
    36c8:	43 94       	inc	r4
    36ca:	51 2c       	mov	r5, r1
    36cc:	54 01       	movw	r10, r8
    36ce:	14 c0       	rjmp	.+40     	; 0x36f8 <vfprintf+0x160>
    36d0:	38 01       	movw	r6, r16
    36d2:	f2 e0       	ldi	r31, 0x02	; 2
    36d4:	6f 0e       	add	r6, r31
    36d6:	71 1c       	adc	r7, r1
    36d8:	f8 01       	movw	r30, r16
    36da:	a0 80       	ld	r10, Z
    36dc:	b1 80       	ldd	r11, Z+1	; 0x01
    36de:	26 ff       	sbrs	r18, 6
    36e0:	03 c0       	rjmp	.+6      	; 0x36e8 <vfprintf+0x150>
    36e2:	65 2d       	mov	r22, r5
    36e4:	70 e0       	ldi	r23, 0x00	; 0
    36e6:	02 c0       	rjmp	.+4      	; 0x36ec <vfprintf+0x154>
    36e8:	6f ef       	ldi	r22, 0xFF	; 255
    36ea:	7f ef       	ldi	r23, 0xFF	; 255
    36ec:	c5 01       	movw	r24, r10
    36ee:	2c 87       	std	Y+12, r18	; 0x0c
    36f0:	4c d1       	rcall	.+664    	; 0x398a <strnlen>
    36f2:	2c 01       	movw	r4, r24
    36f4:	83 01       	movw	r16, r6
    36f6:	2c 85       	ldd	r18, Y+12	; 0x0c
    36f8:	2f 77       	andi	r18, 0x7F	; 127
    36fa:	22 2e       	mov	r2, r18
    36fc:	16 c0       	rjmp	.+44     	; 0x372a <vfprintf+0x192>
    36fe:	38 01       	movw	r6, r16
    3700:	f2 e0       	ldi	r31, 0x02	; 2
    3702:	6f 0e       	add	r6, r31
    3704:	71 1c       	adc	r7, r1
    3706:	f8 01       	movw	r30, r16
    3708:	a0 80       	ld	r10, Z
    370a:	b1 80       	ldd	r11, Z+1	; 0x01
    370c:	26 ff       	sbrs	r18, 6
    370e:	03 c0       	rjmp	.+6      	; 0x3716 <vfprintf+0x17e>
    3710:	65 2d       	mov	r22, r5
    3712:	70 e0       	ldi	r23, 0x00	; 0
    3714:	02 c0       	rjmp	.+4      	; 0x371a <vfprintf+0x182>
    3716:	6f ef       	ldi	r22, 0xFF	; 255
    3718:	7f ef       	ldi	r23, 0xFF	; 255
    371a:	c5 01       	movw	r24, r10
    371c:	2c 87       	std	Y+12, r18	; 0x0c
    371e:	2a d1       	rcall	.+596    	; 0x3974 <strnlen_P>
    3720:	2c 01       	movw	r4, r24
    3722:	2c 85       	ldd	r18, Y+12	; 0x0c
    3724:	20 68       	ori	r18, 0x80	; 128
    3726:	22 2e       	mov	r2, r18
    3728:	83 01       	movw	r16, r6
    372a:	23 fc       	sbrc	r2, 3
    372c:	19 c0       	rjmp	.+50     	; 0x3760 <vfprintf+0x1c8>
    372e:	83 2d       	mov	r24, r3
    3730:	90 e0       	ldi	r25, 0x00	; 0
    3732:	48 16       	cp	r4, r24
    3734:	59 06       	cpc	r5, r25
    3736:	a0 f4       	brcc	.+40     	; 0x3760 <vfprintf+0x1c8>
    3738:	b7 01       	movw	r22, r14
    373a:	80 e2       	ldi	r24, 0x20	; 32
    373c:	90 e0       	ldi	r25, 0x00	; 0
    373e:	30 d1       	rcall	.+608    	; 0x39a0 <fputc>
    3740:	3a 94       	dec	r3
    3742:	f5 cf       	rjmp	.-22     	; 0x372e <vfprintf+0x196>
    3744:	f5 01       	movw	r30, r10
    3746:	27 fc       	sbrc	r2, 7
    3748:	85 91       	lpm	r24, Z+
    374a:	27 fe       	sbrs	r2, 7
    374c:	81 91       	ld	r24, Z+
    374e:	5f 01       	movw	r10, r30
    3750:	b7 01       	movw	r22, r14
    3752:	90 e0       	ldi	r25, 0x00	; 0
    3754:	25 d1       	rcall	.+586    	; 0x39a0 <fputc>
    3756:	31 10       	cpse	r3, r1
    3758:	3a 94       	dec	r3
    375a:	f1 e0       	ldi	r31, 0x01	; 1
    375c:	4f 1a       	sub	r4, r31
    375e:	51 08       	sbc	r5, r1
    3760:	41 14       	cp	r4, r1
    3762:	51 04       	cpc	r5, r1
    3764:	79 f7       	brne	.-34     	; 0x3744 <vfprintf+0x1ac>
    3766:	de c0       	rjmp	.+444    	; 0x3924 <vfprintf+0x38c>
    3768:	84 36       	cpi	r24, 0x64	; 100
    376a:	11 f0       	breq	.+4      	; 0x3770 <vfprintf+0x1d8>
    376c:	89 36       	cpi	r24, 0x69	; 105
    376e:	31 f5       	brne	.+76     	; 0x37bc <vfprintf+0x224>
    3770:	f8 01       	movw	r30, r16
    3772:	27 ff       	sbrs	r18, 7
    3774:	07 c0       	rjmp	.+14     	; 0x3784 <vfprintf+0x1ec>
    3776:	60 81       	ld	r22, Z
    3778:	71 81       	ldd	r23, Z+1	; 0x01
    377a:	82 81       	ldd	r24, Z+2	; 0x02
    377c:	93 81       	ldd	r25, Z+3	; 0x03
    377e:	0c 5f       	subi	r16, 0xFC	; 252
    3780:	1f 4f       	sbci	r17, 0xFF	; 255
    3782:	08 c0       	rjmp	.+16     	; 0x3794 <vfprintf+0x1fc>
    3784:	60 81       	ld	r22, Z
    3786:	71 81       	ldd	r23, Z+1	; 0x01
    3788:	88 27       	eor	r24, r24
    378a:	77 fd       	sbrc	r23, 7
    378c:	80 95       	com	r24
    378e:	98 2f       	mov	r25, r24
    3790:	0e 5f       	subi	r16, 0xFE	; 254
    3792:	1f 4f       	sbci	r17, 0xFF	; 255
    3794:	2f 76       	andi	r18, 0x6F	; 111
    3796:	b2 2e       	mov	r11, r18
    3798:	97 ff       	sbrs	r25, 7
    379a:	09 c0       	rjmp	.+18     	; 0x37ae <vfprintf+0x216>
    379c:	90 95       	com	r25
    379e:	80 95       	com	r24
    37a0:	70 95       	com	r23
    37a2:	61 95       	neg	r22
    37a4:	7f 4f       	sbci	r23, 0xFF	; 255
    37a6:	8f 4f       	sbci	r24, 0xFF	; 255
    37a8:	9f 4f       	sbci	r25, 0xFF	; 255
    37aa:	20 68       	ori	r18, 0x80	; 128
    37ac:	b2 2e       	mov	r11, r18
    37ae:	2a e0       	ldi	r18, 0x0A	; 10
    37b0:	30 e0       	ldi	r19, 0x00	; 0
    37b2:	a4 01       	movw	r20, r8
    37b4:	27 d1       	rcall	.+590    	; 0x3a04 <__ultoa_invert>
    37b6:	a8 2e       	mov	r10, r24
    37b8:	a8 18       	sub	r10, r8
    37ba:	43 c0       	rjmp	.+134    	; 0x3842 <vfprintf+0x2aa>
    37bc:	85 37       	cpi	r24, 0x75	; 117
    37be:	29 f4       	brne	.+10     	; 0x37ca <vfprintf+0x232>
    37c0:	2f 7e       	andi	r18, 0xEF	; 239
    37c2:	b2 2e       	mov	r11, r18
    37c4:	2a e0       	ldi	r18, 0x0A	; 10
    37c6:	30 e0       	ldi	r19, 0x00	; 0
    37c8:	25 c0       	rjmp	.+74     	; 0x3814 <vfprintf+0x27c>
    37ca:	f2 2f       	mov	r31, r18
    37cc:	f9 7f       	andi	r31, 0xF9	; 249
    37ce:	bf 2e       	mov	r11, r31
    37d0:	8f 36       	cpi	r24, 0x6F	; 111
    37d2:	c1 f0       	breq	.+48     	; 0x3804 <vfprintf+0x26c>
    37d4:	18 f4       	brcc	.+6      	; 0x37dc <vfprintf+0x244>
    37d6:	88 35       	cpi	r24, 0x58	; 88
    37d8:	79 f0       	breq	.+30     	; 0x37f8 <vfprintf+0x260>
    37da:	ad c0       	rjmp	.+346    	; 0x3936 <vfprintf+0x39e>
    37dc:	80 37       	cpi	r24, 0x70	; 112
    37de:	19 f0       	breq	.+6      	; 0x37e6 <vfprintf+0x24e>
    37e0:	88 37       	cpi	r24, 0x78	; 120
    37e2:	21 f0       	breq	.+8      	; 0x37ec <vfprintf+0x254>
    37e4:	a8 c0       	rjmp	.+336    	; 0x3936 <vfprintf+0x39e>
    37e6:	2f 2f       	mov	r18, r31
    37e8:	20 61       	ori	r18, 0x10	; 16
    37ea:	b2 2e       	mov	r11, r18
    37ec:	b4 fe       	sbrs	r11, 4
    37ee:	0d c0       	rjmp	.+26     	; 0x380a <vfprintf+0x272>
    37f0:	8b 2d       	mov	r24, r11
    37f2:	84 60       	ori	r24, 0x04	; 4
    37f4:	b8 2e       	mov	r11, r24
    37f6:	09 c0       	rjmp	.+18     	; 0x380a <vfprintf+0x272>
    37f8:	24 ff       	sbrs	r18, 4
    37fa:	0a c0       	rjmp	.+20     	; 0x3810 <vfprintf+0x278>
    37fc:	9f 2f       	mov	r25, r31
    37fe:	96 60       	ori	r25, 0x06	; 6
    3800:	b9 2e       	mov	r11, r25
    3802:	06 c0       	rjmp	.+12     	; 0x3810 <vfprintf+0x278>
    3804:	28 e0       	ldi	r18, 0x08	; 8
    3806:	30 e0       	ldi	r19, 0x00	; 0
    3808:	05 c0       	rjmp	.+10     	; 0x3814 <vfprintf+0x27c>
    380a:	20 e1       	ldi	r18, 0x10	; 16
    380c:	30 e0       	ldi	r19, 0x00	; 0
    380e:	02 c0       	rjmp	.+4      	; 0x3814 <vfprintf+0x27c>
    3810:	20 e1       	ldi	r18, 0x10	; 16
    3812:	32 e0       	ldi	r19, 0x02	; 2
    3814:	f8 01       	movw	r30, r16
    3816:	b7 fe       	sbrs	r11, 7
    3818:	07 c0       	rjmp	.+14     	; 0x3828 <vfprintf+0x290>
    381a:	60 81       	ld	r22, Z
    381c:	71 81       	ldd	r23, Z+1	; 0x01
    381e:	82 81       	ldd	r24, Z+2	; 0x02
    3820:	93 81       	ldd	r25, Z+3	; 0x03
    3822:	0c 5f       	subi	r16, 0xFC	; 252
    3824:	1f 4f       	sbci	r17, 0xFF	; 255
    3826:	06 c0       	rjmp	.+12     	; 0x3834 <vfprintf+0x29c>
    3828:	60 81       	ld	r22, Z
    382a:	71 81       	ldd	r23, Z+1	; 0x01
    382c:	80 e0       	ldi	r24, 0x00	; 0
    382e:	90 e0       	ldi	r25, 0x00	; 0
    3830:	0e 5f       	subi	r16, 0xFE	; 254
    3832:	1f 4f       	sbci	r17, 0xFF	; 255
    3834:	a4 01       	movw	r20, r8
    3836:	e6 d0       	rcall	.+460    	; 0x3a04 <__ultoa_invert>
    3838:	a8 2e       	mov	r10, r24
    383a:	a8 18       	sub	r10, r8
    383c:	fb 2d       	mov	r31, r11
    383e:	ff 77       	andi	r31, 0x7F	; 127
    3840:	bf 2e       	mov	r11, r31
    3842:	b6 fe       	sbrs	r11, 6
    3844:	0b c0       	rjmp	.+22     	; 0x385c <vfprintf+0x2c4>
    3846:	2b 2d       	mov	r18, r11
    3848:	2e 7f       	andi	r18, 0xFE	; 254
    384a:	a5 14       	cp	r10, r5
    384c:	50 f4       	brcc	.+20     	; 0x3862 <vfprintf+0x2ca>
    384e:	b4 fe       	sbrs	r11, 4
    3850:	0a c0       	rjmp	.+20     	; 0x3866 <vfprintf+0x2ce>
    3852:	b2 fc       	sbrc	r11, 2
    3854:	08 c0       	rjmp	.+16     	; 0x3866 <vfprintf+0x2ce>
    3856:	2b 2d       	mov	r18, r11
    3858:	2e 7e       	andi	r18, 0xEE	; 238
    385a:	05 c0       	rjmp	.+10     	; 0x3866 <vfprintf+0x2ce>
    385c:	7a 2c       	mov	r7, r10
    385e:	2b 2d       	mov	r18, r11
    3860:	03 c0       	rjmp	.+6      	; 0x3868 <vfprintf+0x2d0>
    3862:	7a 2c       	mov	r7, r10
    3864:	01 c0       	rjmp	.+2      	; 0x3868 <vfprintf+0x2d0>
    3866:	75 2c       	mov	r7, r5
    3868:	24 ff       	sbrs	r18, 4
    386a:	0d c0       	rjmp	.+26     	; 0x3886 <vfprintf+0x2ee>
    386c:	fe 01       	movw	r30, r28
    386e:	ea 0d       	add	r30, r10
    3870:	f1 1d       	adc	r31, r1
    3872:	80 81       	ld	r24, Z
    3874:	80 33       	cpi	r24, 0x30	; 48
    3876:	11 f4       	brne	.+4      	; 0x387c <vfprintf+0x2e4>
    3878:	29 7e       	andi	r18, 0xE9	; 233
    387a:	09 c0       	rjmp	.+18     	; 0x388e <vfprintf+0x2f6>
    387c:	22 ff       	sbrs	r18, 2
    387e:	06 c0       	rjmp	.+12     	; 0x388c <vfprintf+0x2f4>
    3880:	73 94       	inc	r7
    3882:	73 94       	inc	r7
    3884:	04 c0       	rjmp	.+8      	; 0x388e <vfprintf+0x2f6>
    3886:	82 2f       	mov	r24, r18
    3888:	86 78       	andi	r24, 0x86	; 134
    388a:	09 f0       	breq	.+2      	; 0x388e <vfprintf+0x2f6>
    388c:	73 94       	inc	r7
    388e:	23 fd       	sbrc	r18, 3
    3890:	12 c0       	rjmp	.+36     	; 0x38b6 <vfprintf+0x31e>
    3892:	20 ff       	sbrs	r18, 0
    3894:	06 c0       	rjmp	.+12     	; 0x38a2 <vfprintf+0x30a>
    3896:	5a 2c       	mov	r5, r10
    3898:	73 14       	cp	r7, r3
    389a:	18 f4       	brcc	.+6      	; 0x38a2 <vfprintf+0x30a>
    389c:	53 0c       	add	r5, r3
    389e:	57 18       	sub	r5, r7
    38a0:	73 2c       	mov	r7, r3
    38a2:	73 14       	cp	r7, r3
    38a4:	60 f4       	brcc	.+24     	; 0x38be <vfprintf+0x326>
    38a6:	b7 01       	movw	r22, r14
    38a8:	80 e2       	ldi	r24, 0x20	; 32
    38aa:	90 e0       	ldi	r25, 0x00	; 0
    38ac:	2c 87       	std	Y+12, r18	; 0x0c
    38ae:	78 d0       	rcall	.+240    	; 0x39a0 <fputc>
    38b0:	73 94       	inc	r7
    38b2:	2c 85       	ldd	r18, Y+12	; 0x0c
    38b4:	f6 cf       	rjmp	.-20     	; 0x38a2 <vfprintf+0x30a>
    38b6:	73 14       	cp	r7, r3
    38b8:	10 f4       	brcc	.+4      	; 0x38be <vfprintf+0x326>
    38ba:	37 18       	sub	r3, r7
    38bc:	01 c0       	rjmp	.+2      	; 0x38c0 <vfprintf+0x328>
    38be:	31 2c       	mov	r3, r1
    38c0:	24 ff       	sbrs	r18, 4
    38c2:	11 c0       	rjmp	.+34     	; 0x38e6 <vfprintf+0x34e>
    38c4:	b7 01       	movw	r22, r14
    38c6:	80 e3       	ldi	r24, 0x30	; 48
    38c8:	90 e0       	ldi	r25, 0x00	; 0
    38ca:	2c 87       	std	Y+12, r18	; 0x0c
    38cc:	69 d0       	rcall	.+210    	; 0x39a0 <fputc>
    38ce:	2c 85       	ldd	r18, Y+12	; 0x0c
    38d0:	22 ff       	sbrs	r18, 2
    38d2:	16 c0       	rjmp	.+44     	; 0x3900 <vfprintf+0x368>
    38d4:	21 ff       	sbrs	r18, 1
    38d6:	03 c0       	rjmp	.+6      	; 0x38de <vfprintf+0x346>
    38d8:	88 e5       	ldi	r24, 0x58	; 88
    38da:	90 e0       	ldi	r25, 0x00	; 0
    38dc:	02 c0       	rjmp	.+4      	; 0x38e2 <vfprintf+0x34a>
    38de:	88 e7       	ldi	r24, 0x78	; 120
    38e0:	90 e0       	ldi	r25, 0x00	; 0
    38e2:	b7 01       	movw	r22, r14
    38e4:	0c c0       	rjmp	.+24     	; 0x38fe <vfprintf+0x366>
    38e6:	82 2f       	mov	r24, r18
    38e8:	86 78       	andi	r24, 0x86	; 134
    38ea:	51 f0       	breq	.+20     	; 0x3900 <vfprintf+0x368>
    38ec:	21 fd       	sbrc	r18, 1
    38ee:	02 c0       	rjmp	.+4      	; 0x38f4 <vfprintf+0x35c>
    38f0:	80 e2       	ldi	r24, 0x20	; 32
    38f2:	01 c0       	rjmp	.+2      	; 0x38f6 <vfprintf+0x35e>
    38f4:	8b e2       	ldi	r24, 0x2B	; 43
    38f6:	27 fd       	sbrc	r18, 7
    38f8:	8d e2       	ldi	r24, 0x2D	; 45
    38fa:	b7 01       	movw	r22, r14
    38fc:	90 e0       	ldi	r25, 0x00	; 0
    38fe:	50 d0       	rcall	.+160    	; 0x39a0 <fputc>
    3900:	a5 14       	cp	r10, r5
    3902:	30 f4       	brcc	.+12     	; 0x3910 <vfprintf+0x378>
    3904:	b7 01       	movw	r22, r14
    3906:	80 e3       	ldi	r24, 0x30	; 48
    3908:	90 e0       	ldi	r25, 0x00	; 0
    390a:	4a d0       	rcall	.+148    	; 0x39a0 <fputc>
    390c:	5a 94       	dec	r5
    390e:	f8 cf       	rjmp	.-16     	; 0x3900 <vfprintf+0x368>
    3910:	aa 94       	dec	r10
    3912:	f4 01       	movw	r30, r8
    3914:	ea 0d       	add	r30, r10
    3916:	f1 1d       	adc	r31, r1
    3918:	80 81       	ld	r24, Z
    391a:	b7 01       	movw	r22, r14
    391c:	90 e0       	ldi	r25, 0x00	; 0
    391e:	40 d0       	rcall	.+128    	; 0x39a0 <fputc>
    3920:	a1 10       	cpse	r10, r1
    3922:	f6 cf       	rjmp	.-20     	; 0x3910 <vfprintf+0x378>
    3924:	33 20       	and	r3, r3
    3926:	09 f4       	brne	.+2      	; 0x392a <vfprintf+0x392>
    3928:	5d ce       	rjmp	.-838    	; 0x35e4 <vfprintf+0x4c>
    392a:	b7 01       	movw	r22, r14
    392c:	80 e2       	ldi	r24, 0x20	; 32
    392e:	90 e0       	ldi	r25, 0x00	; 0
    3930:	37 d0       	rcall	.+110    	; 0x39a0 <fputc>
    3932:	3a 94       	dec	r3
    3934:	f7 cf       	rjmp	.-18     	; 0x3924 <vfprintf+0x38c>
    3936:	f7 01       	movw	r30, r14
    3938:	86 81       	ldd	r24, Z+6	; 0x06
    393a:	97 81       	ldd	r25, Z+7	; 0x07
    393c:	02 c0       	rjmp	.+4      	; 0x3942 <vfprintf+0x3aa>
    393e:	8f ef       	ldi	r24, 0xFF	; 255
    3940:	9f ef       	ldi	r25, 0xFF	; 255
    3942:	2c 96       	adiw	r28, 0x0c	; 12
    3944:	0f b6       	in	r0, 0x3f	; 63
    3946:	f8 94       	cli
    3948:	de bf       	out	0x3e, r29	; 62
    394a:	0f be       	out	0x3f, r0	; 63
    394c:	cd bf       	out	0x3d, r28	; 61
    394e:	df 91       	pop	r29
    3950:	cf 91       	pop	r28
    3952:	1f 91       	pop	r17
    3954:	0f 91       	pop	r16
    3956:	ff 90       	pop	r15
    3958:	ef 90       	pop	r14
    395a:	df 90       	pop	r13
    395c:	cf 90       	pop	r12
    395e:	bf 90       	pop	r11
    3960:	af 90       	pop	r10
    3962:	9f 90       	pop	r9
    3964:	8f 90       	pop	r8
    3966:	7f 90       	pop	r7
    3968:	6f 90       	pop	r6
    396a:	5f 90       	pop	r5
    396c:	4f 90       	pop	r4
    396e:	3f 90       	pop	r3
    3970:	2f 90       	pop	r2
    3972:	08 95       	ret

00003974 <strnlen_P>:
    3974:	fc 01       	movw	r30, r24
    3976:	05 90       	lpm	r0, Z+
    3978:	61 50       	subi	r22, 0x01	; 1
    397a:	70 40       	sbci	r23, 0x00	; 0
    397c:	01 10       	cpse	r0, r1
    397e:	d8 f7       	brcc	.-10     	; 0x3976 <strnlen_P+0x2>
    3980:	80 95       	com	r24
    3982:	90 95       	com	r25
    3984:	8e 0f       	add	r24, r30
    3986:	9f 1f       	adc	r25, r31
    3988:	08 95       	ret

0000398a <strnlen>:
    398a:	fc 01       	movw	r30, r24
    398c:	61 50       	subi	r22, 0x01	; 1
    398e:	70 40       	sbci	r23, 0x00	; 0
    3990:	01 90       	ld	r0, Z+
    3992:	01 10       	cpse	r0, r1
    3994:	d8 f7       	brcc	.-10     	; 0x398c <strnlen+0x2>
    3996:	80 95       	com	r24
    3998:	90 95       	com	r25
    399a:	8e 0f       	add	r24, r30
    399c:	9f 1f       	adc	r25, r31
    399e:	08 95       	ret

000039a0 <fputc>:
    39a0:	0f 93       	push	r16
    39a2:	1f 93       	push	r17
    39a4:	cf 93       	push	r28
    39a6:	df 93       	push	r29
    39a8:	18 2f       	mov	r17, r24
    39aa:	09 2f       	mov	r16, r25
    39ac:	eb 01       	movw	r28, r22
    39ae:	8b 81       	ldd	r24, Y+3	; 0x03
    39b0:	81 fd       	sbrc	r24, 1
    39b2:	03 c0       	rjmp	.+6      	; 0x39ba <fputc+0x1a>
    39b4:	8f ef       	ldi	r24, 0xFF	; 255
    39b6:	9f ef       	ldi	r25, 0xFF	; 255
    39b8:	20 c0       	rjmp	.+64     	; 0x39fa <fputc+0x5a>
    39ba:	82 ff       	sbrs	r24, 2
    39bc:	10 c0       	rjmp	.+32     	; 0x39de <fputc+0x3e>
    39be:	4e 81       	ldd	r20, Y+6	; 0x06
    39c0:	5f 81       	ldd	r21, Y+7	; 0x07
    39c2:	2c 81       	ldd	r18, Y+4	; 0x04
    39c4:	3d 81       	ldd	r19, Y+5	; 0x05
    39c6:	42 17       	cp	r20, r18
    39c8:	53 07       	cpc	r21, r19
    39ca:	7c f4       	brge	.+30     	; 0x39ea <fputc+0x4a>
    39cc:	e8 81       	ld	r30, Y
    39ce:	f9 81       	ldd	r31, Y+1	; 0x01
    39d0:	9f 01       	movw	r18, r30
    39d2:	2f 5f       	subi	r18, 0xFF	; 255
    39d4:	3f 4f       	sbci	r19, 0xFF	; 255
    39d6:	39 83       	std	Y+1, r19	; 0x01
    39d8:	28 83       	st	Y, r18
    39da:	10 83       	st	Z, r17
    39dc:	06 c0       	rjmp	.+12     	; 0x39ea <fputc+0x4a>
    39de:	e8 85       	ldd	r30, Y+8	; 0x08
    39e0:	f9 85       	ldd	r31, Y+9	; 0x09
    39e2:	81 2f       	mov	r24, r17
    39e4:	19 95       	eicall
    39e6:	89 2b       	or	r24, r25
    39e8:	29 f7       	brne	.-54     	; 0x39b4 <fputc+0x14>
    39ea:	2e 81       	ldd	r18, Y+6	; 0x06
    39ec:	3f 81       	ldd	r19, Y+7	; 0x07
    39ee:	2f 5f       	subi	r18, 0xFF	; 255
    39f0:	3f 4f       	sbci	r19, 0xFF	; 255
    39f2:	3f 83       	std	Y+7, r19	; 0x07
    39f4:	2e 83       	std	Y+6, r18	; 0x06
    39f6:	81 2f       	mov	r24, r17
    39f8:	90 2f       	mov	r25, r16
    39fa:	df 91       	pop	r29
    39fc:	cf 91       	pop	r28
    39fe:	1f 91       	pop	r17
    3a00:	0f 91       	pop	r16
    3a02:	08 95       	ret

00003a04 <__ultoa_invert>:
    3a04:	fa 01       	movw	r30, r20
    3a06:	aa 27       	eor	r26, r26
    3a08:	28 30       	cpi	r18, 0x08	; 8
    3a0a:	51 f1       	breq	.+84     	; 0x3a60 <__ultoa_invert+0x5c>
    3a0c:	20 31       	cpi	r18, 0x10	; 16
    3a0e:	81 f1       	breq	.+96     	; 0x3a70 <__ultoa_invert+0x6c>
    3a10:	e8 94       	clt
    3a12:	6f 93       	push	r22
    3a14:	6e 7f       	andi	r22, 0xFE	; 254
    3a16:	6e 5f       	subi	r22, 0xFE	; 254
    3a18:	7f 4f       	sbci	r23, 0xFF	; 255
    3a1a:	8f 4f       	sbci	r24, 0xFF	; 255
    3a1c:	9f 4f       	sbci	r25, 0xFF	; 255
    3a1e:	af 4f       	sbci	r26, 0xFF	; 255
    3a20:	b1 e0       	ldi	r27, 0x01	; 1
    3a22:	3e d0       	rcall	.+124    	; 0x3aa0 <__ultoa_invert+0x9c>
    3a24:	b4 e0       	ldi	r27, 0x04	; 4
    3a26:	3c d0       	rcall	.+120    	; 0x3aa0 <__ultoa_invert+0x9c>
    3a28:	67 0f       	add	r22, r23
    3a2a:	78 1f       	adc	r23, r24
    3a2c:	89 1f       	adc	r24, r25
    3a2e:	9a 1f       	adc	r25, r26
    3a30:	a1 1d       	adc	r26, r1
    3a32:	68 0f       	add	r22, r24
    3a34:	79 1f       	adc	r23, r25
    3a36:	8a 1f       	adc	r24, r26
    3a38:	91 1d       	adc	r25, r1
    3a3a:	a1 1d       	adc	r26, r1
    3a3c:	6a 0f       	add	r22, r26
    3a3e:	71 1d       	adc	r23, r1
    3a40:	81 1d       	adc	r24, r1
    3a42:	91 1d       	adc	r25, r1
    3a44:	a1 1d       	adc	r26, r1
    3a46:	20 d0       	rcall	.+64     	; 0x3a88 <__ultoa_invert+0x84>
    3a48:	09 f4       	brne	.+2      	; 0x3a4c <__ultoa_invert+0x48>
    3a4a:	68 94       	set
    3a4c:	3f 91       	pop	r19
    3a4e:	2a e0       	ldi	r18, 0x0A	; 10
    3a50:	26 9f       	mul	r18, r22
    3a52:	11 24       	eor	r1, r1
    3a54:	30 19       	sub	r19, r0
    3a56:	30 5d       	subi	r19, 0xD0	; 208
    3a58:	31 93       	st	Z+, r19
    3a5a:	de f6       	brtc	.-74     	; 0x3a12 <__ultoa_invert+0xe>
    3a5c:	cf 01       	movw	r24, r30
    3a5e:	08 95       	ret
    3a60:	46 2f       	mov	r20, r22
    3a62:	47 70       	andi	r20, 0x07	; 7
    3a64:	40 5d       	subi	r20, 0xD0	; 208
    3a66:	41 93       	st	Z+, r20
    3a68:	b3 e0       	ldi	r27, 0x03	; 3
    3a6a:	0f d0       	rcall	.+30     	; 0x3a8a <__ultoa_invert+0x86>
    3a6c:	c9 f7       	brne	.-14     	; 0x3a60 <__ultoa_invert+0x5c>
    3a6e:	f6 cf       	rjmp	.-20     	; 0x3a5c <__ultoa_invert+0x58>
    3a70:	46 2f       	mov	r20, r22
    3a72:	4f 70       	andi	r20, 0x0F	; 15
    3a74:	40 5d       	subi	r20, 0xD0	; 208
    3a76:	4a 33       	cpi	r20, 0x3A	; 58
    3a78:	18 f0       	brcs	.+6      	; 0x3a80 <__ultoa_invert+0x7c>
    3a7a:	49 5d       	subi	r20, 0xD9	; 217
    3a7c:	31 fd       	sbrc	r19, 1
    3a7e:	40 52       	subi	r20, 0x20	; 32
    3a80:	41 93       	st	Z+, r20
    3a82:	02 d0       	rcall	.+4      	; 0x3a88 <__ultoa_invert+0x84>
    3a84:	a9 f7       	brne	.-22     	; 0x3a70 <__ultoa_invert+0x6c>
    3a86:	ea cf       	rjmp	.-44     	; 0x3a5c <__ultoa_invert+0x58>
    3a88:	b4 e0       	ldi	r27, 0x04	; 4
    3a8a:	a6 95       	lsr	r26
    3a8c:	97 95       	ror	r25
    3a8e:	87 95       	ror	r24
    3a90:	77 95       	ror	r23
    3a92:	67 95       	ror	r22
    3a94:	ba 95       	dec	r27
    3a96:	c9 f7       	brne	.-14     	; 0x3a8a <__ultoa_invert+0x86>
    3a98:	00 97       	sbiw	r24, 0x00	; 0
    3a9a:	61 05       	cpc	r22, r1
    3a9c:	71 05       	cpc	r23, r1
    3a9e:	08 95       	ret
    3aa0:	9b 01       	movw	r18, r22
    3aa2:	ac 01       	movw	r20, r24
    3aa4:	0a 2e       	mov	r0, r26
    3aa6:	06 94       	lsr	r0
    3aa8:	57 95       	ror	r21
    3aaa:	47 95       	ror	r20
    3aac:	37 95       	ror	r19
    3aae:	27 95       	ror	r18
    3ab0:	ba 95       	dec	r27
    3ab2:	c9 f7       	brne	.-14     	; 0x3aa6 <__ultoa_invert+0xa2>
    3ab4:	62 0f       	add	r22, r18
    3ab6:	73 1f       	adc	r23, r19
    3ab8:	84 1f       	adc	r24, r20
    3aba:	95 1f       	adc	r25, r21
    3abc:	a0 1d       	adc	r26, r0
    3abe:	08 95       	ret

00003ac0 <_exit>:
    3ac0:	f8 94       	cli

00003ac2 <__stop_program>:
    3ac2:	ff cf       	rjmp	.-2      	; 0x3ac2 <__stop_program>
