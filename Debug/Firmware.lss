
Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000fc  00800200  00003cf8  00003d8c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003cf8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001adf  008002fc  008002fc  00003e88  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003e88  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000005b0  00000000  00000000  00003ee4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00007b31  00000000  00000000  00004494  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001a21  00000000  00000000  0000bfc5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000416a  00000000  00000000  0000d9e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001384  00000000  00000000  00011b50  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000020cb  00000000  00000000  00012ed4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000660a  00000000  00000000  00014f9f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000005f0  00000000  00000000  0001b5a9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	dc c0       	rjmp	.+440    	; 0x1ba <__ctors_end>
       2:	00 00       	nop
       4:	f6 c3       	rjmp	.+2028   	; 0x7f2 <__vector_1>
       6:	00 00       	nop
       8:	f9 c0       	rjmp	.+498    	; 0x1fc <__bad_interrupt>
       a:	00 00       	nop
       c:	f7 c0       	rjmp	.+494    	; 0x1fc <__bad_interrupt>
       e:	00 00       	nop
      10:	f5 c0       	rjmp	.+490    	; 0x1fc <__bad_interrupt>
      12:	00 00       	nop
      14:	f3 c0       	rjmp	.+486    	; 0x1fc <__bad_interrupt>
      16:	00 00       	nop
      18:	f1 c0       	rjmp	.+482    	; 0x1fc <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ef c0       	rjmp	.+478    	; 0x1fc <__bad_interrupt>
      1e:	00 00       	nop
      20:	ed c0       	rjmp	.+474    	; 0x1fc <__bad_interrupt>
      22:	00 00       	nop
      24:	eb c0       	rjmp	.+470    	; 0x1fc <__bad_interrupt>
      26:	00 00       	nop
      28:	e9 c0       	rjmp	.+466    	; 0x1fc <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e7 c0       	rjmp	.+462    	; 0x1fc <__bad_interrupt>
      2e:	00 00       	nop
      30:	e5 c0       	rjmp	.+458    	; 0x1fc <__bad_interrupt>
      32:	00 00       	nop
      34:	13 c4       	rjmp	.+2086   	; 0x85c <__vector_13>
      36:	00 00       	nop
      38:	e1 c0       	rjmp	.+450    	; 0x1fc <__bad_interrupt>
      3a:	00 00       	nop
      3c:	df c0       	rjmp	.+446    	; 0x1fc <__bad_interrupt>
      3e:	00 00       	nop
      40:	dd c0       	rjmp	.+442    	; 0x1fc <__bad_interrupt>
      42:	00 00       	nop
      44:	db c0       	rjmp	.+438    	; 0x1fc <__bad_interrupt>
      46:	00 00       	nop
      48:	d9 c0       	rjmp	.+434    	; 0x1fc <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d7 c0       	rjmp	.+430    	; 0x1fc <__bad_interrupt>
      4e:	00 00       	nop
      50:	d5 c0       	rjmp	.+426    	; 0x1fc <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 c0 08 	jmp	0x1180	; 0x1180 <__vector_21>
      58:	d1 c0       	rjmp	.+418    	; 0x1fc <__bad_interrupt>
      5a:	00 00       	nop
      5c:	cf c0       	rjmp	.+414    	; 0x1fc <__bad_interrupt>
      5e:	00 00       	nop
      60:	0c 94 6a 19 	jmp	0x32d4	; 0x32d4 <__vector_24>
      64:	0c 94 06 17 	jmp	0x2e0c	; 0x2e0c <__vector_25>
      68:	0c 94 48 17 	jmp	0x2e90	; 0x2e90 <__vector_26>
      6c:	c7 c0       	rjmp	.+398    	; 0x1fc <__bad_interrupt>
      6e:	00 00       	nop
      70:	c5 c0       	rjmp	.+394    	; 0x1fc <__bad_interrupt>
      72:	00 00       	nop
      74:	c3 c0       	rjmp	.+390    	; 0x1fc <__bad_interrupt>
      76:	00 00       	nop
      78:	c1 c0       	rjmp	.+386    	; 0x1fc <__bad_interrupt>
      7a:	00 00       	nop
      7c:	bf c0       	rjmp	.+382    	; 0x1fc <__bad_interrupt>
      7e:	00 00       	nop
      80:	bd c0       	rjmp	.+378    	; 0x1fc <__bad_interrupt>
      82:	00 00       	nop
      84:	bb c0       	rjmp	.+374    	; 0x1fc <__bad_interrupt>
      86:	00 00       	nop
      88:	b9 c0       	rjmp	.+370    	; 0x1fc <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b7 c0       	rjmp	.+366    	; 0x1fc <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 94 17 	jmp	0x2f28	; 0x2f28 <__vector_36>
      94:	0c 94 d6 17 	jmp	0x2fac	; 0x2fac <__vector_37>
      98:	b1 c0       	rjmp	.+354    	; 0x1fc <__bad_interrupt>
      9a:	00 00       	nop
      9c:	af c0       	rjmp	.+350    	; 0x1fc <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ad c0       	rjmp	.+346    	; 0x1fc <__bad_interrupt>
      a2:	00 00       	nop
      a4:	ab c0       	rjmp	.+342    	; 0x1fc <__bad_interrupt>
      a6:	00 00       	nop
      a8:	a9 c0       	rjmp	.+338    	; 0x1fc <__bad_interrupt>
      aa:	00 00       	nop
      ac:	a7 c0       	rjmp	.+334    	; 0x1fc <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a5 c0       	rjmp	.+330    	; 0x1fc <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a3 c0       	rjmp	.+326    	; 0x1fc <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a1 c0       	rjmp	.+322    	; 0x1fc <__bad_interrupt>
      ba:	00 00       	nop
      bc:	9f c0       	rjmp	.+318    	; 0x1fc <__bad_interrupt>
      be:	00 00       	nop
      c0:	9d c0       	rjmp	.+314    	; 0x1fc <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9b c0       	rjmp	.+310    	; 0x1fc <__bad_interrupt>
      c6:	00 00       	nop
      c8:	99 c0       	rjmp	.+306    	; 0x1fc <__bad_interrupt>
      ca:	00 00       	nop
      cc:	a6 12       	cpse	r10, r22
      ce:	a6 12       	cpse	r10, r22
      d0:	a6 12       	cpse	r10, r22
      d2:	de 12       	cpse	r13, r30
      d4:	cd 12       	cpse	r12, r29
      d6:	db 12       	cpse	r13, r27
      d8:	a6 12       	cpse	r10, r22
      da:	a6 12       	cpse	r10, r22
      dc:	de 12       	cpse	r13, r30
      de:	cd 12       	cpse	r12, r29
      e0:	e9 14       	cp	r14, r9
      e2:	f1 14       	cp	r15, r1
      e4:	f9 14       	cp	r15, r9
      e6:	01 15       	cp	r16, r1
      e8:	09 15       	cp	r16, r9
      ea:	0d 15       	cp	r16, r13
      ec:	8f 15       	cp	r24, r15
      ee:	8f 15       	cp	r24, r15
      f0:	8f 15       	cp	r24, r15
      f2:	8f 15       	cp	r24, r15
      f4:	8f 15       	cp	r24, r15
      f6:	4f 15       	cp	r20, r15
      f8:	8f 15       	cp	r24, r15
      fa:	8f 15       	cp	r24, r15
      fc:	8f 15       	cp	r24, r15
      fe:	8f 15       	cp	r24, r15
     100:	8f 15       	cp	r24, r15
     102:	61 15       	cp	r22, r1
     104:	80 15       	cp	r24, r0
     106:	8f 15       	cp	r24, r15
     108:	8f 15       	cp	r24, r15
     10a:	8f 15       	cp	r24, r15
     10c:	8f 15       	cp	r24, r15
     10e:	8f 15       	cp	r24, r15
     110:	8f 15       	cp	r24, r15
     112:	8f 15       	cp	r24, r15
     114:	8f 15       	cp	r24, r15
     116:	8f 15       	cp	r24, r15
     118:	8f 15       	cp	r24, r15
     11a:	8f 15       	cp	r24, r15
     11c:	8f 15       	cp	r24, r15
     11e:	8f 15       	cp	r24, r15
     120:	e5 14       	cp	r14, r5
     122:	ed 14       	cp	r14, r13
     124:	f5 14       	cp	r15, r5
     126:	fd 14       	cp	r15, r13
     128:	05 15       	cp	r16, r5
     12a:	8f 15       	cp	r24, r15
     12c:	8f 15       	cp	r24, r15
     12e:	8f 15       	cp	r24, r15
     130:	8f 15       	cp	r24, r15
     132:	8f 15       	cp	r24, r15
     134:	8f 15       	cp	r24, r15
     136:	8f 15       	cp	r24, r15
     138:	8f 15       	cp	r24, r15
     13a:	8f 15       	cp	r24, r15
     13c:	8f 15       	cp	r24, r15
     13e:	8f 15       	cp	r24, r15
     140:	8f 15       	cp	r24, r15
     142:	8f 15       	cp	r24, r15
     144:	87 15       	cp	r24, r7

00000146 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     146:	0f 2e       	mov	r0, r31
     148:	f7 ed       	ldi	r31, 0xD7	; 215
     14a:	ef 2e       	mov	r14, r31
     14c:	fd e0       	ldi	r31, 0x0D	; 13
     14e:	ff 2e       	mov	r15, r31
     150:	f0 2d       	mov	r31, r0
     152:	cf ea       	ldi	r28, 0xAF	; 175
     154:	dd e0       	ldi	r29, 0x0D	; 13
     156:	27 c0       	rjmp	.+78     	; 0x1a6 <prvIdleTask+0x60>
     158:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <vTaskSuspendAll>
     15c:	18 81       	ld	r17, Y
     15e:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xTaskResumeAll>
     162:	11 23       	and	r17, r17
     164:	01 f1       	breq	.+64     	; 0x1a6 <prvIdleTask+0x60>
     166:	0f b6       	in	r0, 0x3f	; 63
     168:	f8 94       	cli
     16a:	0f 92       	push	r0
     16c:	e0 91 b4 0d 	lds	r30, 0x0DB4
     170:	f0 91 b5 0d 	lds	r31, 0x0DB5
     174:	06 81       	ldd	r16, Z+6	; 0x06
     176:	17 81       	ldd	r17, Z+7	; 0x07
     178:	c8 01       	movw	r24, r16
     17a:	02 96       	adiw	r24, 0x02	; 2
     17c:	4e d6       	rcall	.+3228   	; 0xe1a <uxListRemove>
     17e:	80 91 ad 0d 	lds	r24, 0x0DAD
     182:	81 50       	subi	r24, 0x01	; 1
     184:	80 93 ad 0d 	sts	0x0DAD, r24
     188:	80 91 ae 0d 	lds	r24, 0x0DAE
     18c:	81 50       	subi	r24, 0x01	; 1
     18e:	80 93 ae 0d 	sts	0x0DAE, r24
     192:	0f 90       	pop	r0
     194:	0f be       	out	0x3f, r0	; 63
     196:	f8 01       	movw	r30, r16
     198:	87 89       	ldd	r24, Z+23	; 0x17
     19a:	90 8d       	ldd	r25, Z+24	; 0x18
     19c:	0e 94 f5 08 	call	0x11ea	; 0x11ea <vPortFree>
     1a0:	c8 01       	movw	r24, r16
     1a2:	0e 94 f5 08 	call	0x11ea	; 0x11ea <vPortFree>
     1a6:	80 91 ae 0d 	lds	r24, 0x0DAE
     1aa:	81 11       	cpse	r24, r1
     1ac:	d5 cf       	rjmp	.-86     	; 0x158 <prvIdleTask+0x12>
     1ae:	f7 01       	movw	r30, r14
     1b0:	80 81       	ld	r24, Z
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	c0 f3       	brcs	.-16     	; 0x1a6 <prvIdleTask+0x60>
     1b6:	0f d7       	rcall	.+3614   	; 0xfd6 <vPortYield>
     1b8:	f6 cf       	rjmp	.-20     	; 0x1a6 <prvIdleTask+0x60>

000001ba <__ctors_end>:
     1ba:	11 24       	eor	r1, r1
     1bc:	1f be       	out	0x3f, r1	; 63
     1be:	cf ef       	ldi	r28, 0xFF	; 255
     1c0:	d1 e2       	ldi	r29, 0x21	; 33
     1c2:	de bf       	out	0x3e, r29	; 62
     1c4:	cd bf       	out	0x3d, r28	; 61
     1c6:	00 e0       	ldi	r16, 0x00	; 0
     1c8:	0c bf       	out	0x3c, r16	; 60

000001ca <__do_copy_data>:
     1ca:	12 e0       	ldi	r17, 0x02	; 2
     1cc:	a0 e0       	ldi	r26, 0x00	; 0
     1ce:	b2 e0       	ldi	r27, 0x02	; 2
     1d0:	e8 ef       	ldi	r30, 0xF8	; 248
     1d2:	fc e3       	ldi	r31, 0x3C	; 60
     1d4:	00 e0       	ldi	r16, 0x00	; 0
     1d6:	0b bf       	out	0x3b, r16	; 59
     1d8:	02 c0       	rjmp	.+4      	; 0x1de <__do_copy_data+0x14>
     1da:	07 90       	elpm	r0, Z+
     1dc:	0d 92       	st	X+, r0
     1de:	ac 3f       	cpi	r26, 0xFC	; 252
     1e0:	b1 07       	cpc	r27, r17
     1e2:	d9 f7       	brne	.-10     	; 0x1da <__do_copy_data+0x10>

000001e4 <__do_clear_bss>:
     1e4:	2d e1       	ldi	r18, 0x1D	; 29
     1e6:	ac ef       	ldi	r26, 0xFC	; 252
     1e8:	b2 e0       	ldi	r27, 0x02	; 2
     1ea:	01 c0       	rjmp	.+2      	; 0x1ee <.do_clear_bss_start>

000001ec <.do_clear_bss_loop>:
     1ec:	1d 92       	st	X+, r1

000001ee <.do_clear_bss_start>:
     1ee:	ab 3d       	cpi	r26, 0xDB	; 219
     1f0:	b2 07       	cpc	r27, r18
     1f2:	e1 f7       	brne	.-8      	; 0x1ec <.do_clear_bss_loop>
     1f4:	0e 94 29 16 	call	0x2c52	; 0x2c52 <main>
     1f8:	0c 94 7a 1e 	jmp	0x3cf4	; 0x3cf4 <_exit>

000001fc <__bad_interrupt>:
     1fc:	01 cf       	rjmp	.-510    	; 0x0 <__vectors>

000001fe <_bt_status_call_back>:
	uint8_t _sreg = SREG;
	cli();
	float _tmp = ((float)_z_gyro)/GYRO_500_DPS_DIVIDER;
	SREG = _sreg;
	return _tmp;
}
     1fe:	10 92 5c 03 	sts	0x035C, r1
     202:	e0 91 5a 03 	lds	r30, 0x035A
     206:	f0 91 5b 03 	lds	r31, 0x035B
     20a:	30 97       	sbiw	r30, 0x00	; 0
     20c:	09 f0       	breq	.+2      	; 0x210 <_bt_status_call_back+0x12>
     20e:	19 95       	eicall
     210:	08 95       	ret

00000212 <_bt_call_back>:
     212:	cf 93       	push	r28
     214:	df 93       	push	r29
     216:	1f 92       	push	r1
     218:	1f 92       	push	r1
     21a:	cd b7       	in	r28, 0x3d	; 61
     21c:	de b7       	in	r29, 0x3e	; 62
     21e:	6a 83       	std	Y+2, r22	; 0x02
     220:	80 91 5c 03 	lds	r24, 0x035C
     224:	88 23       	and	r24, r24
     226:	19 f0       	breq	.+6      	; 0x22e <_bt_call_back+0x1c>
     228:	86 2f       	mov	r24, r22
     22a:	a0 d4       	rcall	.+2368   	; 0xb6c <dialog_byte_received>
     22c:	13 c0       	rjmp	.+38     	; 0x254 <_bt_call_back+0x42>
     22e:	80 91 58 03 	lds	r24, 0x0358
     232:	90 91 59 03 	lds	r25, 0x0359
     236:	00 97       	sbiw	r24, 0x00	; 0
     238:	69 f0       	breq	.+26     	; 0x254 <_bt_call_back+0x42>
     23a:	19 82       	std	Y+1, r1	; 0x01
     23c:	20 e0       	ldi	r18, 0x00	; 0
     23e:	ae 01       	movw	r20, r28
     240:	4f 5f       	subi	r20, 0xFF	; 255
     242:	5f 4f       	sbci	r21, 0xFF	; 255
     244:	be 01       	movw	r22, r28
     246:	6e 5f       	subi	r22, 0xFE	; 254
     248:	7f 4f       	sbci	r23, 0xFF	; 255
     24a:	0e 94 ae 0a 	call	0x155c	; 0x155c <xQueueGenericSendFromISR>
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	81 11       	cpse	r24, r1
     252:	c1 d6       	rcall	.+3458   	; 0xfd6 <vPortYield>
     254:	0f 90       	pop	r0
     256:	0f 90       	pop	r0
     258:	df 91       	pop	r29
     25a:	cf 91       	pop	r28
     25c:	08 95       	ret

0000025e <_mpu9250_read_reg>:
     25e:	df 92       	push	r13
     260:	ef 92       	push	r14
     262:	ff 92       	push	r15
     264:	0f 93       	push	r16
     266:	1f 93       	push	r17
     268:	cf 93       	push	r28
     26a:	df 93       	push	r29
     26c:	cd b7       	in	r28, 0x3d	; 61
     26e:	de b7       	in	r29, 0x3e	; 62
     270:	d6 2e       	mov	r13, r22
     272:	ed b6       	in	r14, 0x3d	; 61
     274:	fe b6       	in	r15, 0x3e	; 62
     276:	26 2f       	mov	r18, r22
     278:	30 e0       	ldi	r19, 0x00	; 0
     27a:	2f 5f       	subi	r18, 0xFF	; 255
     27c:	3f 4f       	sbci	r19, 0xFF	; 255
     27e:	4d b7       	in	r20, 0x3d	; 61
     280:	5e b7       	in	r21, 0x3e	; 62
     282:	42 1b       	sub	r20, r18
     284:	53 0b       	sbc	r21, r19
     286:	0f b6       	in	r0, 0x3f	; 63
     288:	f8 94       	cli
     28a:	5e bf       	out	0x3e, r21	; 62
     28c:	0f be       	out	0x3f, r0	; 63
     28e:	4d bf       	out	0x3d, r20	; 61
     290:	0d b7       	in	r16, 0x3d	; 61
     292:	1e b7       	in	r17, 0x3e	; 62
     294:	0f 5f       	subi	r16, 0xFF	; 255
     296:	1f 4f       	sbci	r17, 0xFF	; 255
     298:	98 01       	movw	r18, r16
     29a:	80 68       	ori	r24, 0x80	; 128
     29c:	ed b7       	in	r30, 0x3d	; 61
     29e:	fe b7       	in	r31, 0x3e	; 62
     2a0:	81 83       	std	Z+1, r24	; 0x01
     2a2:	66 23       	and	r22, r22
     2a4:	41 f0       	breq	.+16     	; 0x2b6 <_mpu9250_read_reg+0x58>
     2a6:	81 e0       	ldi	r24, 0x01	; 1
     2a8:	f9 01       	movw	r30, r18
     2aa:	e8 0f       	add	r30, r24
     2ac:	f1 1d       	adc	r31, r1
     2ae:	10 82       	st	Z, r1
     2b0:	8f 5f       	subi	r24, 0xFF	; 255
     2b2:	d8 16       	cp	r13, r24
     2b4:	c8 f7       	brcc	.-14     	; 0x2a8 <_mpu9250_read_reg+0x4a>
     2b6:	84 e9       	ldi	r24, 0x94	; 148
     2b8:	93 e0       	ldi	r25, 0x03	; 3
     2ba:	3d d3       	rcall	.+1658   	; 0x936 <buffer_clear>
     2bc:	41 e0       	ldi	r20, 0x01	; 1
     2be:	4d 0d       	add	r20, r13
     2c0:	b8 01       	movw	r22, r16
     2c2:	80 91 c1 03 	lds	r24, 0x03C1
     2c6:	90 91 c2 03 	lds	r25, 0x03C2
     2ca:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <spi_send_string>
     2ce:	0f b6       	in	r0, 0x3f	; 63
     2d0:	f8 94       	cli
     2d2:	fe be       	out	0x3e, r15	; 62
     2d4:	0f be       	out	0x3f, r0	; 63
     2d6:	ed be       	out	0x3d, r14	; 61
     2d8:	df 91       	pop	r29
     2da:	cf 91       	pop	r28
     2dc:	1f 91       	pop	r17
     2de:	0f 91       	pop	r16
     2e0:	ff 90       	pop	r15
     2e2:	ef 90       	pop	r14
     2e4:	df 90       	pop	r13
     2e6:	08 95       	ret

000002e8 <_send_bytes_to_bt>:
     2e8:	46 2f       	mov	r20, r22
     2ea:	bc 01       	movw	r22, r24
     2ec:	80 91 bf 03 	lds	r24, 0x03BF
     2f0:	90 91 c0 03 	lds	r25, 0x03C0
     2f4:	0c 94 c7 16 	jmp	0x2d8e	; 0x2d8e <serial_send_bytes>
     2f8:	08 95       	ret

000002fa <_mpu9250_call_back>:
     2fa:	1f 93       	push	r17
     2fc:	cf 93       	push	r28
     2fe:	df 93       	push	r29
     300:	00 d0       	rcall	.+0      	; 0x302 <_mpu9250_call_back+0x8>
     302:	1f 92       	push	r1
     304:	cd b7       	in	r28, 0x3d	; 61
     306:	de b7       	in	r29, 0x3e	; 62
     308:	80 91 ff 02 	lds	r24, 0x02FF
     30c:	82 30       	cpi	r24, 0x02	; 2
     30e:	c1 f1       	breq	.+112    	; 0x380 <_mpu9250_call_back+0x86>
     310:	28 f4       	brcc	.+10     	; 0x31c <_mpu9250_call_back+0x22>
     312:	88 23       	and	r24, r24
     314:	51 f0       	breq	.+20     	; 0x32a <_mpu9250_call_back+0x30>
     316:	81 30       	cpi	r24, 0x01	; 1
     318:	c9 f0       	breq	.+50     	; 0x34c <_mpu9250_call_back+0x52>
     31a:	f1 c0       	rjmp	.+482    	; 0x4fe <_mpu9250_call_back+0x204>
     31c:	83 30       	cpi	r24, 0x03	; 3
     31e:	09 f4       	brne	.+2      	; 0x322 <_mpu9250_call_back+0x28>
     320:	3f c0       	rjmp	.+126    	; 0x3a0 <_mpu9250_call_back+0xa6>
     322:	85 30       	cpi	r24, 0x05	; 5
     324:	09 f4       	brne	.+2      	; 0x328 <_mpu9250_call_back+0x2e>
     326:	94 c0       	rjmp	.+296    	; 0x450 <_mpu9250_call_back+0x156>
     328:	ea c0       	rjmp	.+468    	; 0x4fe <_mpu9250_call_back+0x204>
     32a:	81 e0       	ldi	r24, 0x01	; 1
     32c:	80 93 ff 02 	sts	0x02FF, r24
     330:	8c e1       	ldi	r24, 0x1C	; 28
     332:	8b 83       	std	Y+3, r24	; 0x03
     334:	1c 82       	std	Y+4, r1	; 0x04
     336:	42 e0       	ldi	r20, 0x02	; 2
     338:	be 01       	movw	r22, r28
     33a:	6d 5f       	subi	r22, 0xFD	; 253
     33c:	7f 4f       	sbci	r23, 0xFF	; 255
     33e:	80 91 c1 03 	lds	r24, 0x03C1
     342:	90 91 c2 03 	lds	r25, 0x03C2
     346:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <spi_send_string>
     34a:	d9 c0       	rjmp	.+434    	; 0x4fe <_mpu9250_call_back+0x204>
     34c:	84 e9       	ldi	r24, 0x94	; 148
     34e:	93 e0       	ldi	r25, 0x03	; 3
     350:	ef d2       	rcall	.+1502   	; 0x930 <buffer_no_of_items>
     352:	82 30       	cpi	r24, 0x02	; 2
     354:	09 f0       	breq	.+2      	; 0x358 <_mpu9250_call_back+0x5e>
     356:	d3 c0       	rjmp	.+422    	; 0x4fe <_mpu9250_call_back+0x204>
     358:	80 93 ff 02 	sts	0x02FF, r24
     35c:	84 e9       	ldi	r24, 0x94	; 148
     35e:	93 e0       	ldi	r25, 0x03	; 3
     360:	ea d2       	rcall	.+1492   	; 0x936 <buffer_clear>
     362:	8b e1       	ldi	r24, 0x1B	; 27
     364:	8b 83       	std	Y+3, r24	; 0x03
     366:	88 e0       	ldi	r24, 0x08	; 8
     368:	8c 83       	std	Y+4, r24	; 0x04
     36a:	42 e0       	ldi	r20, 0x02	; 2
     36c:	be 01       	movw	r22, r28
     36e:	6d 5f       	subi	r22, 0xFD	; 253
     370:	7f 4f       	sbci	r23, 0xFF	; 255
     372:	80 91 c1 03 	lds	r24, 0x03C1
     376:	90 91 c2 03 	lds	r25, 0x03C2
     37a:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <spi_send_string>
     37e:	bf c0       	rjmp	.+382    	; 0x4fe <_mpu9250_call_back+0x204>
     380:	84 e9       	ldi	r24, 0x94	; 148
     382:	93 e0       	ldi	r25, 0x03	; 3
     384:	d5 d2       	rcall	.+1450   	; 0x930 <buffer_no_of_items>
     386:	82 30       	cpi	r24, 0x02	; 2
     388:	09 f0       	breq	.+2      	; 0x38c <_mpu9250_call_back+0x92>
     38a:	b9 c0       	rjmp	.+370    	; 0x4fe <_mpu9250_call_back+0x204>
     38c:	83 e0       	ldi	r24, 0x03	; 3
     38e:	80 93 ff 02 	sts	0x02FF, r24
     392:	84 e9       	ldi	r24, 0x94	; 148
     394:	93 e0       	ldi	r25, 0x03	; 3
     396:	cf d2       	rcall	.+1438   	; 0x936 <buffer_clear>
     398:	66 e0       	ldi	r22, 0x06	; 6
     39a:	8b e3       	ldi	r24, 0x3B	; 59
     39c:	60 df       	rcall	.-320    	; 0x25e <_mpu9250_read_reg>
     39e:	af c0       	rjmp	.+350    	; 0x4fe <_mpu9250_call_back+0x204>
     3a0:	84 e9       	ldi	r24, 0x94	; 148
     3a2:	93 e0       	ldi	r25, 0x03	; 3
     3a4:	c5 d2       	rcall	.+1418   	; 0x930 <buffer_no_of_items>
     3a6:	87 30       	cpi	r24, 0x07	; 7
     3a8:	09 f0       	breq	.+2      	; 0x3ac <_mpu9250_call_back+0xb2>
     3aa:	a9 c0       	rjmp	.+338    	; 0x4fe <_mpu9250_call_back+0x204>
     3ac:	1f b7       	in	r17, 0x3f	; 63
     3ae:	f8 94       	cli
     3b0:	be 01       	movw	r22, r28
     3b2:	6f 5f       	subi	r22, 0xFF	; 255
     3b4:	7f 4f       	sbci	r23, 0xFF	; 255
     3b6:	84 e9       	ldi	r24, 0x94	; 148
     3b8:	93 e0       	ldi	r25, 0x03	; 3
     3ba:	8a d2       	rcall	.+1300   	; 0x8d0 <buffer_get_item>
     3bc:	be 01       	movw	r22, r28
     3be:	6e 5f       	subi	r22, 0xFE	; 254
     3c0:	7f 4f       	sbci	r23, 0xFF	; 255
     3c2:	84 e9       	ldi	r24, 0x94	; 148
     3c4:	93 e0       	ldi	r25, 0x03	; 3
     3c6:	84 d2       	rcall	.+1288   	; 0x8d0 <buffer_get_item>
     3c8:	be 01       	movw	r22, r28
     3ca:	6f 5f       	subi	r22, 0xFF	; 255
     3cc:	7f 4f       	sbci	r23, 0xFF	; 255
     3ce:	84 e9       	ldi	r24, 0x94	; 148
     3d0:	93 e0       	ldi	r25, 0x03	; 3
     3d2:	7e d2       	rcall	.+1276   	; 0x8d0 <buffer_get_item>
     3d4:	8a 81       	ldd	r24, Y+2	; 0x02
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	98 2f       	mov	r25, r24
     3da:	88 27       	eor	r24, r24
     3dc:	29 81       	ldd	r18, Y+1	; 0x01
     3de:	82 2b       	or	r24, r18
     3e0:	90 93 68 03 	sts	0x0368, r25
     3e4:	80 93 67 03 	sts	0x0367, r24
     3e8:	be 01       	movw	r22, r28
     3ea:	6e 5f       	subi	r22, 0xFE	; 254
     3ec:	7f 4f       	sbci	r23, 0xFF	; 255
     3ee:	84 e9       	ldi	r24, 0x94	; 148
     3f0:	93 e0       	ldi	r25, 0x03	; 3
     3f2:	6e d2       	rcall	.+1244   	; 0x8d0 <buffer_get_item>
     3f4:	be 01       	movw	r22, r28
     3f6:	6f 5f       	subi	r22, 0xFF	; 255
     3f8:	7f 4f       	sbci	r23, 0xFF	; 255
     3fa:	84 e9       	ldi	r24, 0x94	; 148
     3fc:	93 e0       	ldi	r25, 0x03	; 3
     3fe:	68 d2       	rcall	.+1232   	; 0x8d0 <buffer_get_item>
     400:	8a 81       	ldd	r24, Y+2	; 0x02
     402:	90 e0       	ldi	r25, 0x00	; 0
     404:	98 2f       	mov	r25, r24
     406:	88 27       	eor	r24, r24
     408:	29 81       	ldd	r18, Y+1	; 0x01
     40a:	82 2b       	or	r24, r18
     40c:	90 93 66 03 	sts	0x0366, r25
     410:	80 93 65 03 	sts	0x0365, r24
     414:	be 01       	movw	r22, r28
     416:	6e 5f       	subi	r22, 0xFE	; 254
     418:	7f 4f       	sbci	r23, 0xFF	; 255
     41a:	84 e9       	ldi	r24, 0x94	; 148
     41c:	93 e0       	ldi	r25, 0x03	; 3
     41e:	58 d2       	rcall	.+1200   	; 0x8d0 <buffer_get_item>
     420:	be 01       	movw	r22, r28
     422:	6f 5f       	subi	r22, 0xFF	; 255
     424:	7f 4f       	sbci	r23, 0xFF	; 255
     426:	84 e9       	ldi	r24, 0x94	; 148
     428:	93 e0       	ldi	r25, 0x03	; 3
     42a:	52 d2       	rcall	.+1188   	; 0x8d0 <buffer_get_item>
     42c:	1f bf       	out	0x3f, r17	; 63
     42e:	8a 81       	ldd	r24, Y+2	; 0x02
     430:	90 e0       	ldi	r25, 0x00	; 0
     432:	98 2f       	mov	r25, r24
     434:	88 27       	eor	r24, r24
     436:	29 81       	ldd	r18, Y+1	; 0x01
     438:	82 2b       	or	r24, r18
     43a:	90 93 64 03 	sts	0x0364, r25
     43e:	80 93 63 03 	sts	0x0363, r24
     442:	85 e0       	ldi	r24, 0x05	; 5
     444:	80 93 ff 02 	sts	0x02FF, r24
     448:	66 e0       	ldi	r22, 0x06	; 6
     44a:	83 e4       	ldi	r24, 0x43	; 67
     44c:	08 df       	rcall	.-496    	; 0x25e <_mpu9250_read_reg>
     44e:	57 c0       	rjmp	.+174    	; 0x4fe <_mpu9250_call_back+0x204>
     450:	84 e9       	ldi	r24, 0x94	; 148
     452:	93 e0       	ldi	r25, 0x03	; 3
     454:	6d d2       	rcall	.+1242   	; 0x930 <buffer_no_of_items>
     456:	87 30       	cpi	r24, 0x07	; 7
     458:	09 f0       	breq	.+2      	; 0x45c <_mpu9250_call_back+0x162>
     45a:	51 c0       	rjmp	.+162    	; 0x4fe <_mpu9250_call_back+0x204>
     45c:	1f b7       	in	r17, 0x3f	; 63
     45e:	f8 94       	cli
     460:	be 01       	movw	r22, r28
     462:	6f 5f       	subi	r22, 0xFF	; 255
     464:	7f 4f       	sbci	r23, 0xFF	; 255
     466:	84 e9       	ldi	r24, 0x94	; 148
     468:	93 e0       	ldi	r25, 0x03	; 3
     46a:	32 d2       	rcall	.+1124   	; 0x8d0 <buffer_get_item>
     46c:	be 01       	movw	r22, r28
     46e:	6e 5f       	subi	r22, 0xFE	; 254
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	84 e9       	ldi	r24, 0x94	; 148
     474:	93 e0       	ldi	r25, 0x03	; 3
     476:	2c d2       	rcall	.+1112   	; 0x8d0 <buffer_get_item>
     478:	be 01       	movw	r22, r28
     47a:	6f 5f       	subi	r22, 0xFF	; 255
     47c:	7f 4f       	sbci	r23, 0xFF	; 255
     47e:	84 e9       	ldi	r24, 0x94	; 148
     480:	93 e0       	ldi	r25, 0x03	; 3
     482:	26 d2       	rcall	.+1100   	; 0x8d0 <buffer_get_item>
     484:	8a 81       	ldd	r24, Y+2	; 0x02
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	98 2f       	mov	r25, r24
     48a:	88 27       	eor	r24, r24
     48c:	29 81       	ldd	r18, Y+1	; 0x01
     48e:	82 2b       	or	r24, r18
     490:	90 93 62 03 	sts	0x0362, r25
     494:	80 93 61 03 	sts	0x0361, r24
     498:	be 01       	movw	r22, r28
     49a:	6e 5f       	subi	r22, 0xFE	; 254
     49c:	7f 4f       	sbci	r23, 0xFF	; 255
     49e:	84 e9       	ldi	r24, 0x94	; 148
     4a0:	93 e0       	ldi	r25, 0x03	; 3
     4a2:	16 d2       	rcall	.+1068   	; 0x8d0 <buffer_get_item>
     4a4:	be 01       	movw	r22, r28
     4a6:	6f 5f       	subi	r22, 0xFF	; 255
     4a8:	7f 4f       	sbci	r23, 0xFF	; 255
     4aa:	84 e9       	ldi	r24, 0x94	; 148
     4ac:	93 e0       	ldi	r25, 0x03	; 3
     4ae:	10 d2       	rcall	.+1056   	; 0x8d0 <buffer_get_item>
     4b0:	8a 81       	ldd	r24, Y+2	; 0x02
     4b2:	90 e0       	ldi	r25, 0x00	; 0
     4b4:	98 2f       	mov	r25, r24
     4b6:	88 27       	eor	r24, r24
     4b8:	29 81       	ldd	r18, Y+1	; 0x01
     4ba:	82 2b       	or	r24, r18
     4bc:	90 93 60 03 	sts	0x0360, r25
     4c0:	80 93 5f 03 	sts	0x035F, r24
     4c4:	be 01       	movw	r22, r28
     4c6:	6e 5f       	subi	r22, 0xFE	; 254
     4c8:	7f 4f       	sbci	r23, 0xFF	; 255
     4ca:	84 e9       	ldi	r24, 0x94	; 148
     4cc:	93 e0       	ldi	r25, 0x03	; 3
     4ce:	00 d2       	rcall	.+1024   	; 0x8d0 <buffer_get_item>
     4d0:	be 01       	movw	r22, r28
     4d2:	6f 5f       	subi	r22, 0xFF	; 255
     4d4:	7f 4f       	sbci	r23, 0xFF	; 255
     4d6:	84 e9       	ldi	r24, 0x94	; 148
     4d8:	93 e0       	ldi	r25, 0x03	; 3
     4da:	fa d1       	rcall	.+1012   	; 0x8d0 <buffer_get_item>
     4dc:	1f bf       	out	0x3f, r17	; 63
     4de:	8a 81       	ldd	r24, Y+2	; 0x02
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	98 2f       	mov	r25, r24
     4e4:	88 27       	eor	r24, r24
     4e6:	29 81       	ldd	r18, Y+1	; 0x01
     4e8:	82 2b       	or	r24, r18
     4ea:	90 93 5e 03 	sts	0x035E, r25
     4ee:	80 93 5d 03 	sts	0x035D, r24
     4f2:	83 e0       	ldi	r24, 0x03	; 3
     4f4:	80 93 ff 02 	sts	0x02FF, r24
     4f8:	66 e0       	ldi	r22, 0x06	; 6
     4fa:	8b e3       	ldi	r24, 0x3B	; 59
     4fc:	b0 de       	rcall	.-672    	; 0x25e <_mpu9250_read_reg>
     4fe:	0f 90       	pop	r0
     500:	0f 90       	pop	r0
     502:	0f 90       	pop	r0
     504:	0f 90       	pop	r0
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	1f 91       	pop	r17
     50c:	08 95       	ret

0000050e <set_horn>:
     50e:	88 23       	and	r24, r24
     510:	11 f0       	breq	.+4      	; 0x516 <set_horn+0x8>
     512:	43 9a       	sbi	0x08, 3	; 8
     514:	08 95       	ret
     516:	43 98       	cbi	0x08, 3	; 8
     518:	08 95       	ret

0000051a <set_head_light>:
     51a:	88 23       	and	r24, r24
     51c:	11 f0       	breq	.+4      	; 0x522 <set_head_light+0x8>
     51e:	42 9a       	sbi	0x08, 2	; 8
     520:	08 95       	ret
     522:	42 98       	cbi	0x08, 2	; 8
     524:	08 95       	ret

00000526 <set_brake_light>:
     526:	88 23       	and	r24, r24
     528:	11 f0       	breq	.+4      	; 0x52e <set_brake_light+0x8>
     52a:	41 9a       	sbi	0x08, 1	; 8
     52c:	08 95       	ret
     52e:	41 98       	cbi	0x08, 1	; 8
     530:	08 95       	ret

00000532 <set_motor_speed>:
     532:	85 36       	cpi	r24, 0x65	; 101
     534:	08 f0       	brcs	.+2      	; 0x538 <set_motor_speed+0x6>
     536:	84 e6       	ldi	r24, 0x64	; 100
     538:	88 23       	and	r24, r24
     53a:	a9 f0       	breq	.+42     	; 0x566 <set_motor_speed+0x34>
     53c:	28 2f       	mov	r18, r24
     53e:	30 e0       	ldi	r19, 0x00	; 0
     540:	af e7       	ldi	r26, 0x7F	; 127
     542:	bc e0       	ldi	r27, 0x0C	; 12
     544:	0e 94 40 1a 	call	0x3480	; 0x3480 <__umulhisi3>
     548:	24 e6       	ldi	r18, 0x64	; 100
     54a:	30 e0       	ldi	r19, 0x00	; 0
     54c:	40 e0       	ldi	r20, 0x00	; 0
     54e:	50 e0       	ldi	r21, 0x00	; 0
     550:	0e 94 1e 1a 	call	0x343c	; 0x343c <__divmodsi4>
     554:	30 93 99 00 	sts	0x0099, r19
     558:	20 93 98 00 	sts	0x0098, r18
     55c:	30 93 9b 00 	sts	0x009B, r19
     560:	20 93 9a 00 	sts	0x009A, r18
     564:	08 95       	ret
     566:	10 92 99 00 	sts	0x0099, r1
     56a:	10 92 98 00 	sts	0x0098, r1
     56e:	10 92 9b 00 	sts	0x009B, r1
     572:	10 92 9a 00 	sts	0x009A, r1
     576:	08 95       	ret

00000578 <init_main_board>:
     578:	8f 92       	push	r8
     57a:	9f 92       	push	r9
     57c:	af 92       	push	r10
     57e:	bf 92       	push	r11
     580:	cf 92       	push	r12
     582:	df 92       	push	r13
     584:	ef 92       	push	r14
     586:	0f 93       	push	r16
     588:	1f 93       	push	r17
     58a:	3b 9a       	sbi	0x07, 3	; 7
     58c:	3a 9a       	sbi	0x07, 2	; 7
     58e:	39 9a       	sbi	0x07, 1	; 7
     590:	38 9a       	sbi	0x07, 0	; 7
     592:	e0 e9       	ldi	r30, 0x90	; 144
     594:	f0 e0       	ldi	r31, 0x00	; 0
     596:	80 81       	ld	r24, Z
     598:	82 60       	ori	r24, 0x02	; 2
     59a:	80 83       	st	Z, r24
     59c:	a1 e9       	ldi	r26, 0x91	; 145
     59e:	b0 e0       	ldi	r27, 0x00	; 0
     5a0:	8c 91       	ld	r24, X
     5a2:	88 61       	ori	r24, 0x18	; 24
     5a4:	8c 93       	st	X, r24
     5a6:	8f e7       	ldi	r24, 0x7F	; 127
     5a8:	9c e0       	ldi	r25, 0x0C	; 12
     5aa:	90 93 99 00 	sts	0x0099, r25
     5ae:	80 93 98 00 	sts	0x0098, r24
     5b2:	20 81       	ld	r18, Z
     5b4:	20 6c       	ori	r18, 0xC0	; 192
     5b6:	20 83       	st	Z, r18
     5b8:	6b 9a       	sbi	0x0d, 3	; 13
     5ba:	90 93 9b 00 	sts	0x009B, r25
     5be:	80 93 9a 00 	sts	0x009A, r24
     5c2:	20 81       	ld	r18, Z
     5c4:	20 63       	ori	r18, 0x30	; 48
     5c6:	20 83       	st	Z, r18
     5c8:	6c 9a       	sbi	0x0d, 4	; 13
     5ca:	90 93 97 00 	sts	0x0097, r25
     5ce:	80 93 96 00 	sts	0x0096, r24
     5d2:	8c 91       	ld	r24, X
     5d4:	81 60       	ori	r24, 0x01	; 1
     5d6:	8c 93       	st	X, r24
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	ab df       	rcall	.-170    	; 0x532 <set_motor_speed>
     5dc:	e1 e8       	ldi	r30, 0x81	; 129
     5de:	f0 e0       	ldi	r31, 0x00	; 0
     5e0:	80 81       	ld	r24, Z
     5e2:	86 60       	ori	r24, 0x06	; 6
     5e4:	80 83       	st	Z, r24
     5e6:	6a 98       	cbi	0x0d, 2	; 13
     5e8:	6d 9a       	sbi	0x0d, 5	; 13
     5ea:	75 98       	cbi	0x0e, 5	; 14
     5ec:	08 9a       	sbi	0x01, 0	; 1
     5ee:	10 98       	cbi	0x02, 0	; 2
     5f0:	09 9a       	sbi	0x01, 1	; 1
     5f2:	11 98       	cbi	0x02, 1	; 2
     5f4:	0a 9a       	sbi	0x01, 2	; 1
     5f6:	12 98       	cbi	0x02, 2	; 2
     5f8:	e9 e6       	ldi	r30, 0x69	; 105
     5fa:	f0 e0       	ldi	r31, 0x00	; 0
     5fc:	80 81       	ld	r24, Z
     5fe:	82 60       	ori	r24, 0x02	; 2
     600:	80 83       	st	Z, r24
     602:	e8 9a       	sbi	0x1d, 0	; 29
     604:	8b e2       	ldi	r24, 0x2B	; 43
     606:	93 e0       	ldi	r25, 0x03	; 3
     608:	5e d1       	rcall	.+700    	; 0x8c6 <buffer_init>
     60a:	80 e0       	ldi	r24, 0x00	; 0
     60c:	93 e0       	ldi	r25, 0x03	; 3
     60e:	5b d1       	rcall	.+694    	; 0x8c6 <buffer_init>
     610:	0f 2e       	mov	r0, r31
     612:	f9 e0       	ldi	r31, 0x09	; 9
     614:	8f 2e       	mov	r8, r31
     616:	f1 e0       	ldi	r31, 0x01	; 1
     618:	9f 2e       	mov	r9, r31
     61a:	f0 2d       	mov	r31, r0
     61c:	0f 2e       	mov	r0, r31
     61e:	f0 e0       	ldi	r31, 0x00	; 0
     620:	af 2e       	mov	r10, r31
     622:	f3 e0       	ldi	r31, 0x03	; 3
     624:	bf 2e       	mov	r11, r31
     626:	f0 2d       	mov	r31, r0
     628:	0f 2e       	mov	r0, r31
     62a:	fb e2       	ldi	r31, 0x2B	; 43
     62c:	cf 2e       	mov	r12, r31
     62e:	f3 e0       	ldi	r31, 0x03	; 3
     630:	df 2e       	mov	r13, r31
     632:	f0 2d       	mov	r31, r0
     634:	e1 2c       	mov	r14, r1
     636:	00 e0       	ldi	r16, 0x00	; 0
     638:	23 e0       	ldi	r18, 0x03	; 3
     63a:	40 e8       	ldi	r20, 0x80	; 128
     63c:	55 e2       	ldi	r21, 0x25	; 37
     63e:	60 e0       	ldi	r22, 0x00	; 0
     640:	70 e0       	ldi	r23, 0x00	; 0
     642:	80 e0       	ldi	r24, 0x00	; 0
     644:	0e 94 50 16 	call	0x2ca0	; 0x2ca0 <serial_new_instance>
     648:	90 93 c0 03 	sts	0x03C0, r25
     64c:	80 93 bf 03 	sts	0x03BF, r24
     650:	84 e9       	ldi	r24, 0x94	; 148
     652:	93 e0       	ldi	r25, 0x03	; 3
     654:	38 d1       	rcall	.+624    	; 0x8c6 <buffer_init>
     656:	89 e6       	ldi	r24, 0x69	; 105
     658:	93 e0       	ldi	r25, 0x03	; 3
     65a:	35 d1       	rcall	.+618    	; 0x8c6 <buffer_init>
     65c:	8d e7       	ldi	r24, 0x7D	; 125
     65e:	91 e0       	ldi	r25, 0x01	; 1
     660:	9f 93       	push	r25
     662:	8f 93       	push	r24
     664:	0f 2e       	mov	r0, r31
     666:	f9 e6       	ldi	r31, 0x69	; 105
     668:	8f 2e       	mov	r8, r31
     66a:	f3 e0       	ldi	r31, 0x03	; 3
     66c:	9f 2e       	mov	r9, r31
     66e:	f0 2d       	mov	r31, r0
     670:	0f 2e       	mov	r0, r31
     672:	f4 e9       	ldi	r31, 0x94	; 148
     674:	af 2e       	mov	r10, r31
     676:	f3 e0       	ldi	r31, 0x03	; 3
     678:	bf 2e       	mov	r11, r31
     67a:	f0 2d       	mov	r31, r0
     67c:	c1 2c       	mov	r12, r1
     67e:	05 e2       	ldi	r16, 0x25	; 37
     680:	10 e0       	ldi	r17, 0x00	; 0
     682:	20 e0       	ldi	r18, 0x00	; 0
     684:	43 e0       	ldi	r20, 0x03	; 3
     686:	63 e0       	ldi	r22, 0x03	; 3
     688:	80 e1       	ldi	r24, 0x10	; 16
     68a:	0e 94 5c 18 	call	0x30b8	; 0x30b8 <spi_new_instance>
     68e:	90 93 c2 03 	sts	0x03C2, r25
     692:	80 93 c1 03 	sts	0x03C1, r24
     696:	60 e0       	ldi	r22, 0x00	; 0
     698:	80 e0       	ldi	r24, 0x00	; 0
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	2e de       	rcall	.-932    	; 0x2fa <_mpu9250_call_back>
     69e:	8b e9       	ldi	r24, 0x9B	; 155
     6a0:	80 93 b3 00 	sts	0x00B3, r24
     6a4:	e1 eb       	ldi	r30, 0xB1	; 177
     6a6:	f0 e0       	ldi	r31, 0x00	; 0
     6a8:	80 81       	ld	r24, Z
     6aa:	82 60       	ori	r24, 0x02	; 2
     6ac:	80 83       	st	Z, r24
     6ae:	a0 e7       	ldi	r26, 0x70	; 112
     6b0:	b0 e0       	ldi	r27, 0x00	; 0
     6b2:	8c 91       	ld	r24, X
     6b4:	82 60       	ori	r24, 0x02	; 2
     6b6:	8c 93       	st	X, r24
     6b8:	80 81       	ld	r24, Z
     6ba:	85 60       	ori	r24, 0x05	; 5
     6bc:	80 83       	st	Z, r24
     6be:	0f 90       	pop	r0
     6c0:	0f 90       	pop	r0
     6c2:	1f 91       	pop	r17
     6c4:	0f 91       	pop	r16
     6c6:	ef 90       	pop	r14
     6c8:	df 90       	pop	r13
     6ca:	cf 90       	pop	r12
     6cc:	bf 90       	pop	r11
     6ce:	af 90       	pop	r10
     6d0:	9f 90       	pop	r9
     6d2:	8f 90       	pop	r8
     6d4:	08 95       	ret

000006d6 <set_brake>:
     6d6:	85 36       	cpi	r24, 0x65	; 101
     6d8:	08 f0       	brcs	.+2      	; 0x6dc <set_brake+0x6>
     6da:	84 e6       	ldi	r24, 0x64	; 100
     6dc:	88 23       	and	r24, r24
     6de:	a9 f0       	breq	.+42     	; 0x70a <set_brake+0x34>
     6e0:	28 2f       	mov	r18, r24
     6e2:	30 e0       	ldi	r19, 0x00	; 0
     6e4:	af e7       	ldi	r26, 0x7F	; 127
     6e6:	bc e0       	ldi	r27, 0x0C	; 12
     6e8:	0e 94 40 1a 	call	0x3480	; 0x3480 <__umulhisi3>
     6ec:	24 e6       	ldi	r18, 0x64	; 100
     6ee:	30 e0       	ldi	r19, 0x00	; 0
     6f0:	40 e0       	ldi	r20, 0x00	; 0
     6f2:	50 e0       	ldi	r21, 0x00	; 0
     6f4:	0e 94 1e 1a 	call	0x343c	; 0x343c <__divmodsi4>
     6f8:	30 93 99 00 	sts	0x0099, r19
     6fc:	20 93 98 00 	sts	0x0098, r18
     700:	10 92 9b 00 	sts	0x009B, r1
     704:	10 92 9a 00 	sts	0x009A, r1
     708:	08 95       	ret
     70a:	10 92 99 00 	sts	0x0099, r1
     70e:	10 92 98 00 	sts	0x0098, r1
     712:	10 92 9b 00 	sts	0x009B, r1
     716:	10 92 9a 00 	sts	0x009A, r1
     71a:	08 95       	ret

0000071c <get_raw_x_accel>:
     71c:	2f b7       	in	r18, 0x3f	; 63
     71e:	f8 94       	cli
     720:	80 91 67 03 	lds	r24, 0x0367
     724:	90 91 68 03 	lds	r25, 0x0368
     728:	2f bf       	out	0x3f, r18	; 63
     72a:	08 95       	ret

0000072c <get_raw_y_accel>:
     72c:	2f b7       	in	r18, 0x3f	; 63
     72e:	f8 94       	cli
     730:	80 91 65 03 	lds	r24, 0x0365
     734:	90 91 66 03 	lds	r25, 0x0366
     738:	2f bf       	out	0x3f, r18	; 63
     73a:	08 95       	ret

0000073c <get_raw_x_rotation>:

// ----------------------------------------------------------------------------------------------------------------------
int16_t get_raw_x_rotation() {
	uint8_t _sreg = SREG;
     73c:	2f b7       	in	r18, 0x3f	; 63
	cli();
     73e:	f8 94       	cli
	int16_t _tmp = _x_gyro;
     740:	80 91 61 03 	lds	r24, 0x0361
     744:	90 91 62 03 	lds	r25, 0x0362
	SREG = _sreg;
     748:	2f bf       	out	0x3f, r18	; 63
	return _tmp;
}
     74a:	08 95       	ret

0000074c <get_raw_y_rotation>:

// ----------------------------------------------------------------------------------------------------------------------
int16_t get_raw_y_rotation() {
	uint8_t _sreg = SREG;
     74c:	2f b7       	in	r18, 0x3f	; 63
	cli();
     74e:	f8 94       	cli
	int16_t _tmp = _y_gyro;
     750:	80 91 5f 03 	lds	r24, 0x035F
     754:	90 91 60 03 	lds	r25, 0x0360
	SREG = _sreg;
     758:	2f bf       	out	0x3f, r18	; 63
	return _tmp;
}
     75a:	08 95       	ret

0000075c <get_raw_z_rotation>:

// ----------------------------------------------------------------------------------------------------------------------
int16_t get_raw_z_rotation() {
	uint8_t _sreg = SREG;
     75c:	2f b7       	in	r18, 0x3f	; 63
	cli();
     75e:	f8 94       	cli
	int16_t _tmp = _z_gyro;
     760:	80 91 5d 03 	lds	r24, 0x035D
     764:	90 91 5e 03 	lds	r25, 0x035E
	SREG = _sreg;
     768:	2f bf       	out	0x3f, r18	; 63
	return _tmp;
}
     76a:	08 95       	ret

0000076c <get_tacho_count>:

// ----------------------------------------------------------------------------------------------------------------------
uint16_t get_tacho_count() {
	static uint16_t _last_reading = 0;
	
	uint16_t _tmp = TACHO_TCNT_reg;
     76c:	20 91 84 00 	lds	r18, 0x0084
     770:	30 91 85 00 	lds	r19, 0x0085
	uint16_t _tmp_last = _tmp;
	
	if (_tmp < _last_reading) {
     774:	80 91 fd 02 	lds	r24, 0x02FD
     778:	90 91 fe 02 	lds	r25, 0x02FE
     77c:	28 17       	cp	r18, r24
     77e:	39 07       	cpc	r19, r25
     780:	30 f4       	brcc	.+12     	; 0x78e <get_tacho_count+0x22>
		_tmp = (UINT16_MAX - _last_reading + _tmp);
     782:	a9 01       	movw	r20, r18
     784:	48 1b       	sub	r20, r24
     786:	59 0b       	sbc	r21, r25
     788:	ca 01       	movw	r24, r20
     78a:	01 97       	sbiw	r24, 0x01	; 1
     78c:	04 c0       	rjmp	.+8      	; 0x796 <get_tacho_count+0x2a>
		} else {
		_tmp = _tmp-_last_reading;
     78e:	a9 01       	movw	r20, r18
     790:	48 1b       	sub	r20, r24
     792:	59 0b       	sbc	r21, r25
     794:	ca 01       	movw	r24, r20
	}
	_last_reading = _tmp_last;
     796:	30 93 fe 02 	sts	0x02FE, r19
     79a:	20 93 fd 02 	sts	0x02FD, r18
	
	return _tmp;
}
     79e:	08 95       	ret

000007a0 <set_bt_reset>:

// ----------------------------------------------------------------------------------------------------------------------
void set_bt_reset(uint8_t state) {
	if (state) {
     7a0:	88 23       	and	r24, r24
     7a2:	11 f0       	breq	.+4      	; 0x7a8 <set_bt_reset+0x8>
		BT_RESET_PORT &= ~_BV(BT_RESET_PIN); // Set RESET low/active
     7a4:	10 98       	cbi	0x02, 0	; 2
     7a6:	08 95       	ret
		} else {
		BT_RESET_PORT |= _BV(BT_RESET_PIN); // Set RESET high/in-active
     7a8:	10 9a       	sbi	0x02, 0	; 2
     7aa:	08 95       	ret

000007ac <bt_send_bytes>:
static void _send_bytes_to_bt(uint8_t *bytes, uint8_t len) {
	serial_send_bytes(_bt_serial_instance, bytes, len);
}

// ----------------------------------------------------------------------------------------------------------------------
uint8_t bt_send_bytes(uint8_t *bytes, uint8_t len) {
     7ac:	46 2f       	mov	r20, r22
	return serial_send_bytes(_bt_serial_instance, bytes, len);
     7ae:	bc 01       	movw	r22, r24
     7b0:	80 91 bf 03 	lds	r24, 0x03BF
     7b4:	90 91 c0 03 	lds	r25, 0x03C0
     7b8:	0c 94 c7 16 	jmp	0x2d8e	; 0x2d8e <serial_send_bytes>
}
     7bc:	08 95       	ret

000007be <init_bt_module>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void init_bt_module(void (*bt_status_call_back)(uint8_t result), QueueHandle_t RX_Que) {
	_xRxedCharsQ = RX_Que;
     7be:	70 93 59 03 	sts	0x0359, r23
     7c2:	60 93 58 03 	sts	0x0358, r22
	_app_bt_status_call_back = bt_status_call_back;
     7c6:	90 93 5b 03 	sts	0x035B, r25
     7ca:	80 93 5a 03 	sts	0x035A, r24
	_bt_dialog_active = 1;
     7ce:	81 e0       	ldi	r24, 0x01	; 1
     7d0:	80 93 5c 03 	sts	0x035C, r24
	dialog_start(_dialog_bt_init_seq, _send_bytes_to_bt, _bt_status_call_back);
     7d4:	4f ef       	ldi	r20, 0xFF	; 255
     7d6:	50 e0       	ldi	r21, 0x00	; 0
     7d8:	64 e7       	ldi	r22, 0x74	; 116
     7da:	71 e0       	ldi	r23, 0x01	; 1
     7dc:	87 e0       	ldi	r24, 0x07	; 7
     7de:	92 e0       	ldi	r25, 0x02	; 2
     7e0:	9d c1       	rjmp	.+826    	; 0xb1c <dialog_start>
     7e2:	08 95       	ret

000007e4 <set_goal_line_semaphore>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void set_goal_line_semaphore(SemaphoreHandle_t goal_line_semaphore) {
	if (goal_line_semaphore) {
     7e4:	00 97       	sbiw	r24, 0x00	; 0
     7e6:	21 f0       	breq	.+8      	; 0x7f0 <set_goal_line_semaphore+0xc>
		_goal_line_semaphore = goal_line_semaphore;
     7e8:	90 93 57 03 	sts	0x0357, r25
     7ec:	80 93 56 03 	sts	0x0356, r24
     7f0:	08 95       	ret

000007f2 <__vector_1>:
	}
}

ISR(INT0_vect) {
     7f2:	1f 92       	push	r1
     7f4:	0f 92       	push	r0
     7f6:	0f b6       	in	r0, 0x3f	; 63
     7f8:	0f 92       	push	r0
     7fa:	11 24       	eor	r1, r1
     7fc:	0b b6       	in	r0, 0x3b	; 59
     7fe:	0f 92       	push	r0
     800:	2f 93       	push	r18
     802:	3f 93       	push	r19
     804:	4f 93       	push	r20
     806:	5f 93       	push	r21
     808:	6f 93       	push	r22
     80a:	7f 93       	push	r23
     80c:	8f 93       	push	r24
     80e:	9f 93       	push	r25
     810:	af 93       	push	r26
     812:	bf 93       	push	r27
     814:	ef 93       	push	r30
     816:	ff 93       	push	r31
	static signed portBASE_TYPE _higher_priority_task_woken;
	if (_goal_line_semaphore) {
     818:	80 91 56 03 	lds	r24, 0x0356
     81c:	90 91 57 03 	lds	r25, 0x0357
     820:	00 97       	sbiw	r24, 0x00	; 0
     822:	49 f0       	breq	.+18     	; 0x836 <__vector_1+0x44>
		_higher_priority_task_woken = pdFALSE;
     824:	10 92 fc 02 	sts	0x02FC, r1

		xSemaphoreGiveFromISR(_goal_line_semaphore, &_higher_priority_task_woken);
     828:	6c ef       	ldi	r22, 0xFC	; 252
     82a:	72 e0       	ldi	r23, 0x02	; 2
     82c:	c9 d6       	rcall	.+3474   	; 0x15c0 <xQueueGiveFromISR>
		
		if (_higher_priority_task_woken != pdFALSE) {
     82e:	80 91 fc 02 	lds	r24, 0x02FC
     832:	81 11       	cpse	r24, r1
			portYIELD();
     834:	d0 d3       	rcall	.+1952   	; 0xfd6 <vPortYield>
		}
	}
}
     836:	ff 91       	pop	r31
     838:	ef 91       	pop	r30
     83a:	bf 91       	pop	r27
     83c:	af 91       	pop	r26
     83e:	9f 91       	pop	r25
     840:	8f 91       	pop	r24
     842:	7f 91       	pop	r23
     844:	6f 91       	pop	r22
     846:	5f 91       	pop	r21
     848:	4f 91       	pop	r20
     84a:	3f 91       	pop	r19
     84c:	2f 91       	pop	r18
     84e:	0f 90       	pop	r0
     850:	0b be       	out	0x3b, r0	; 59
     852:	0f 90       	pop	r0
     854:	0f be       	out	0x3f, r0	; 63
     856:	0f 90       	pop	r0
     858:	1f 90       	pop	r1
     85a:	18 95       	reti

0000085c <__vector_13>:
	#elif ((DIALOG_HANDLER_PRESCALER == 1024))
	DIALOG_HANDLER_TCCRB_reg |= _BV(DIALOG_HANDLER_CS0_bit) | _BV(DIALOG_HANDLER_CS2_bit); ;    // Prescaler 1024 and Start Timer
	#endif
}

ISR(TIMER2_COMPA_vect) {
     85c:	1f 92       	push	r1
     85e:	0f 92       	push	r0
     860:	0f b6       	in	r0, 0x3f	; 63
     862:	0f 92       	push	r0
     864:	11 24       	eor	r1, r1
     866:	0b b6       	in	r0, 0x3b	; 59
     868:	0f 92       	push	r0
     86a:	2f 93       	push	r18
     86c:	3f 93       	push	r19
     86e:	4f 93       	push	r20
     870:	5f 93       	push	r21
     872:	6f 93       	push	r22
     874:	7f 93       	push	r23
     876:	8f 93       	push	r24
     878:	9f 93       	push	r25
     87a:	af 93       	push	r26
     87c:	bf 93       	push	r27
     87e:	ef 93       	push	r30
     880:	ff 93       	push	r31
	static uint8_t _count = 10;
	if (_bt_dialog_active) {
     882:	80 91 5c 03 	lds	r24, 0x035C
     886:	88 23       	and	r24, r24
     888:	59 f0       	breq	.+22     	; 0x8a0 <__vector_13+0x44>
		if (--_count == 0) {
     88a:	80 91 06 02 	lds	r24, 0x0206
     88e:	81 50       	subi	r24, 0x01	; 1
     890:	19 f0       	breq	.+6      	; 0x898 <__vector_13+0x3c>
     892:	80 93 06 02 	sts	0x0206, r24
     896:	04 c0       	rjmp	.+8      	; 0x8a0 <__vector_13+0x44>
			_count = 10;
     898:	8a e0       	ldi	r24, 0x0A	; 10
     89a:	80 93 06 02 	sts	0x0206, r24
			dialog_tick();
     89e:	4f d1       	rcall	.+670    	; 0xb3e <dialog_tick>
		}
	}
}
     8a0:	ff 91       	pop	r31
     8a2:	ef 91       	pop	r30
     8a4:	bf 91       	pop	r27
     8a6:	af 91       	pop	r26
     8a8:	9f 91       	pop	r25
     8aa:	8f 91       	pop	r24
     8ac:	7f 91       	pop	r23
     8ae:	6f 91       	pop	r22
     8b0:	5f 91       	pop	r21
     8b2:	4f 91       	pop	r20
     8b4:	3f 91       	pop	r19
     8b6:	2f 91       	pop	r18
     8b8:	0f 90       	pop	r0
     8ba:	0b be       	out	0x3b, r0	; 59
     8bc:	0f 90       	pop	r0
     8be:	0f be       	out	0x3f, r0	; 63
     8c0:	0f 90       	pop	r0
     8c2:	1f 90       	pop	r1
     8c4:	18 95       	reti

000008c6 <buffer_init>:
 @return true if buffer is empty.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_is_empty(buffer_struct_t *buffer) {
	return (buffer->no_in_buffer == 0);
}
     8c6:	fc 01       	movw	r30, r24
     8c8:	10 a6       	std	Z+40, r1	; 0x28
     8ca:	11 a6       	std	Z+41, r1	; 0x29
     8cc:	12 a6       	std	Z+42, r1	; 0x2a
     8ce:	08 95       	ret

000008d0 <buffer_get_item>:
     8d0:	fc 01       	movw	r30, r24
     8d2:	82 a5       	ldd	r24, Z+42	; 0x2a
     8d4:	88 23       	and	r24, r24
     8d6:	a1 f0       	breq	.+40     	; 0x900 <buffer_get_item+0x30>
     8d8:	81 a5       	ldd	r24, Z+41	; 0x29
     8da:	df 01       	movw	r26, r30
     8dc:	a8 0f       	add	r26, r24
     8de:	b1 1d       	adc	r27, r1
     8e0:	8c 91       	ld	r24, X
     8e2:	db 01       	movw	r26, r22
     8e4:	8c 93       	st	X, r24
     8e6:	81 a5       	ldd	r24, Z+41	; 0x29
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	01 96       	adiw	r24, 0x01	; 1
     8ec:	68 e2       	ldi	r22, 0x28	; 40
     8ee:	70 e0       	ldi	r23, 0x00	; 0
     8f0:	0e 94 e9 19 	call	0x33d2	; 0x33d2 <__divmodhi4>
     8f4:	81 a7       	std	Z+41, r24	; 0x29
     8f6:	82 a5       	ldd	r24, Z+42	; 0x2a
     8f8:	81 50       	subi	r24, 0x01	; 1
     8fa:	82 a7       	std	Z+42, r24	; 0x2a
     8fc:	80 e0       	ldi	r24, 0x00	; 0
     8fe:	08 95       	ret
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	08 95       	ret

00000904 <buffer_put_item>:
     904:	fc 01       	movw	r30, r24
     906:	22 a5       	ldd	r18, Z+42	; 0x2a
     908:	28 32       	cpi	r18, 0x28	; 40
     90a:	80 f4       	brcc	.+32     	; 0x92c <buffer_put_item+0x28>
     90c:	80 a5       	ldd	r24, Z+40	; 0x28
     90e:	90 e0       	ldi	r25, 0x00	; 0
     910:	df 01       	movw	r26, r30
     912:	a8 0f       	add	r26, r24
     914:	b9 1f       	adc	r27, r25
     916:	6c 93       	st	X, r22
     918:	01 96       	adiw	r24, 0x01	; 1
     91a:	68 e2       	ldi	r22, 0x28	; 40
     91c:	70 e0       	ldi	r23, 0x00	; 0
     91e:	0e 94 e9 19 	call	0x33d2	; 0x33d2 <__divmodhi4>
     922:	80 a7       	std	Z+40, r24	; 0x28
     924:	2f 5f       	subi	r18, 0xFF	; 255
     926:	22 a7       	std	Z+42, r18	; 0x2a
     928:	80 e0       	ldi	r24, 0x00	; 0
     92a:	08 95       	ret
     92c:	82 e0       	ldi	r24, 0x02	; 2
     92e:	08 95       	ret

00000930 <buffer_no_of_items>:
 @return no of items in the buffer.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_no_of_items(buffer_struct_t *buffer) {
	return buffer->no_in_buffer;
}
     930:	fc 01       	movw	r30, r24
     932:	82 a5       	ldd	r24, Z+42	; 0x2a
     934:	08 95       	ret

00000936 <buffer_clear>:
 @ingroup buffer_function
 @brief Clear the content of the buffer.

 @param *buffer pointer to the buffer structure.
 **********************************************************************/
void buffer_clear(buffer_struct_t *buffer) {
     936:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     938:	10 a6       	std	Z+40, r1	; 0x28
	buffer->out_i = 0;
     93a:	11 a6       	std	Z+41, r1	; 0x29
	buffer->no_in_buffer = 0;
     93c:	12 a6       	std	Z+42, r1	; 0x2a
     93e:	08 95       	ret

00000940 <_dialog_prepare_for_next_byte>:

 When the function returns it has setup the state variable _dialog_await_state that will be used in dialog_char_received(), and the needed argument counters etc.
 */
static void _dialog_prepare_for_next_byte() {
  // esc char?
  if (*(_dialog_format.response_p) == '%') {
     940:	e0 91 d0 03 	lds	r30, 0x03D0
     944:	f0 91 d1 03 	lds	r31, 0x03D1
     948:	80 81       	ld	r24, Z
     94a:	85 32       	cpi	r24, 0x25	; 37
     94c:	09 f0       	breq	.+2      	; 0x950 <_dialog_prepare_for_next_byte+0x10>
     94e:	85 c0       	rjmp	.+266    	; 0xa5a <_dialog_prepare_for_next_byte+0x11a>
    _dialog_format.response_p++;
     950:	cf 01       	movw	r24, r30
     952:	01 96       	adiw	r24, 0x01	; 1
     954:	90 93 d1 03 	sts	0x03D1, r25
     958:	80 93 d0 03 	sts	0x03D0, r24

    if (*(_dialog_format.response_p) == '%') {
     95c:	81 81       	ldd	r24, Z+1	; 0x01
     95e:	85 32       	cpi	r24, 0x25	; 37
     960:	19 f4       	brne	.+6      	; 0x968 <_dialog_prepare_for_next_byte+0x28>
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
     962:	10 92 c7 03 	sts	0x03C7, r1
     966:	08 95       	ret
    } else if (*_dialog_format.response_p == '*') {
     968:	8a 32       	cpi	r24, 0x2A	; 42
     96a:	e1 f5       	brne	.+120    	; 0x9e4 <_dialog_prepare_for_next_byte+0xa4>
      // Max args: %*nnB
      _dialog_format.response_p++;
     96c:	cf 01       	movw	r24, r30
     96e:	02 96       	adiw	r24, 0x02	; 2
     970:	90 93 d1 03 	sts	0x03D1, r25
     974:	80 93 d0 03 	sts	0x03D0, r24
     978:	33 96       	adiw	r30, 0x03	; 3
     97a:	20 e0       	ldi	r18, 0x00	; 0
     97c:	dc 01       	movw	r26, r24
     97e:	01 96       	adiw	r24, 0x01	; 1
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     980:	22 0f       	add	r18, r18
     982:	32 2f       	mov	r19, r18
     984:	33 0f       	add	r19, r19
     986:	33 0f       	add	r19, r19
     988:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     98a:	20 53       	subi	r18, 0x30	; 48
     98c:	3c 91       	ld	r19, X
     98e:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     990:	31 91       	ld	r19, Z+
     992:	32 34       	cpi	r19, 0x42	; 66
     994:	99 f7       	brne	.-26     	; 0x97c <_dialog_prepare_for_next_byte+0x3c>
     996:	20 93 d2 03 	sts	0x03D2, r18
      _dialog_format.response_p++;
     99a:	12 96       	adiw	r26, 0x02	; 2
     99c:	b0 93 d1 03 	sts	0x03D1, r27
     9a0:	a0 93 d0 03 	sts	0x03D0, r26
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     9a4:	80 91 d4 03 	lds	r24, 0x03D4
     9a8:	90 91 d5 03 	lds	r25, 0x03D5
     9ac:	00 97       	sbiw	r24, 0x00	; 0
     9ae:	b1 f0       	breq	.+44     	; 0x9dc <_dialog_prepare_for_next_byte+0x9c>
        _dialog_format.arg_index++;
     9b0:	e3 ed       	ldi	r30, 0xD3	; 211
     9b2:	f3 e0       	ldi	r31, 0x03	; 3
     9b4:	20 81       	ld	r18, Z
     9b6:	2f 5f       	subi	r18, 0xFF	; 255
     9b8:	20 83       	st	Z, r18
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     9ba:	33 27       	eor	r19, r19
     9bc:	27 fd       	sbrc	r18, 7
     9be:	30 95       	com	r19
     9c0:	f9 01       	movw	r30, r18
     9c2:	ee 0f       	add	r30, r30
     9c4:	ff 1f       	adc	r31, r31
     9c6:	e2 0f       	add	r30, r18
     9c8:	f3 1f       	adc	r31, r19
     9ca:	e8 0f       	add	r30, r24
     9cc:	f9 1f       	adc	r31, r25
     9ce:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     9d0:	80 81       	ld	r24, Z
     9d2:	91 81       	ldd	r25, Z+1	; 0x01
     9d4:	90 93 d7 03 	sts	0x03D7, r25
     9d8:	80 93 d6 03 	sts	0x03D6, r24
      }
      _dialog_await_state = ARG_MAX_STATE;
     9dc:	82 e0       	ldi	r24, 0x02	; 2
     9de:	80 93 c7 03 	sts	0x03C7, r24
     9e2:	08 95       	ret
     9e4:	80 91 d0 03 	lds	r24, 0x03D0
     9e8:	90 91 d1 03 	lds	r25, 0x03D1
     9ec:	dc 01       	movw	r26, r24
     9ee:	11 96       	adiw	r26, 0x01	; 1
    _dialog_format.response_p++;

    if (*(_dialog_format.response_p) == '%') {
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
    } else if (*_dialog_format.response_p == '*') {
     9f0:	20 e0       	ldi	r18, 0x00	; 0
     9f2:	fc 01       	movw	r30, r24
     9f4:	01 96       	adiw	r24, 0x01	; 1
    } else {
      // args: %nnB
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     9f6:	22 0f       	add	r18, r18
     9f8:	32 2f       	mov	r19, r18
     9fa:	33 0f       	add	r19, r19
     9fc:	33 0f       	add	r19, r19
     9fe:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     a00:	20 53       	subi	r18, 0x30	; 48
     a02:	30 81       	ld	r19, Z
     a04:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     a06:	3d 91       	ld	r19, X+
     a08:	32 34       	cpi	r19, 0x42	; 66
     a0a:	99 f7       	brne	.-26     	; 0x9f2 <_dialog_prepare_for_next_byte+0xb2>
     a0c:	20 93 d2 03 	sts	0x03D2, r18
      _dialog_format.response_p++;
     a10:	32 96       	adiw	r30, 0x02	; 2
     a12:	f0 93 d1 03 	sts	0x03D1, r31
     a16:	e0 93 d0 03 	sts	0x03D0, r30
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     a1a:	80 91 d4 03 	lds	r24, 0x03D4
     a1e:	90 91 d5 03 	lds	r25, 0x03D5
     a22:	00 97       	sbiw	r24, 0x00	; 0
     a24:	b1 f0       	breq	.+44     	; 0xa52 <_dialog_prepare_for_next_byte+0x112>
        _dialog_format.arg_index++;
     a26:	a3 ed       	ldi	r26, 0xD3	; 211
     a28:	b3 e0       	ldi	r27, 0x03	; 3
     a2a:	ec 91       	ld	r30, X
     a2c:	ef 5f       	subi	r30, 0xFF	; 255
     a2e:	ec 93       	st	X, r30
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     a30:	ff 27       	eor	r31, r31
     a32:	e7 fd       	sbrc	r30, 7
     a34:	f0 95       	com	r31
     a36:	9f 01       	movw	r18, r30
     a38:	22 0f       	add	r18, r18
     a3a:	33 1f       	adc	r19, r19
     a3c:	e2 0f       	add	r30, r18
     a3e:	f3 1f       	adc	r31, r19
     a40:	e8 0f       	add	r30, r24
     a42:	f9 1f       	adc	r31, r25
     a44:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     a46:	80 81       	ld	r24, Z
     a48:	91 81       	ldd	r25, Z+1	; 0x01
     a4a:	90 93 d7 03 	sts	0x03D7, r25
     a4e:	80 93 d6 03 	sts	0x03D6, r24
      }
      _dialog_await_state = ARG_STATE;
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	80 93 c7 03 	sts	0x03C7, r24
     a58:	08 95       	ret
    }
  } else {
    _dialog_await_state = NORMAL_STATE;
     a5a:	10 92 c7 03 	sts	0x03C7, r1
     a5e:	08 95       	ret

00000a60 <_dialog_goto_state>:
 IF the new state is either DIALOG_OK_STOP or DIALOG_ERROR_STOP then the call_back function will be called.
 ELSE the new State will be setup.

 @param[in] new_state the new state to goto.
 */
static void _dialog_goto_state(const uint8_t new_state) {
     a60:	cf 93       	push	r28
     a62:	df 93       	push	r29
  _dialog_second_counter = 0;
     a64:	10 92 cb 03 	sts	0x03CB, r1
  _dialog_current_state = new_state;
     a68:	80 93 ca 03 	sts	0x03CA, r24
  if (new_state == DIALOG_ERROR_STOP || new_state == DIALOG_OK_STOP) {
     a6c:	92 e0       	ldi	r25, 0x02	; 2
     a6e:	98 0f       	add	r25, r24
     a70:	92 30       	cpi	r25, 0x02	; 2
     a72:	30 f4       	brcc	.+12     	; 0xa80 <_dialog_goto_state+0x20>
    (*_dialog_pf_call_back)(new_state);
     a74:	e0 91 c3 03 	lds	r30, 0x03C3
     a78:	f0 91 c4 03 	lds	r31, 0x03C4
     a7c:	19 95       	eicall
     a7e:	4b c0       	rjmp	.+150    	; 0xb16 <_dialog_goto_state+0xb6>
  } else {
    // Send command if any
    if (_dialog_seq[new_state].command_length != 0) {
     a80:	9b e0       	ldi	r25, 0x0B	; 11
     a82:	89 9f       	mul	r24, r25
     a84:	e0 01       	movw	r28, r0
     a86:	11 24       	eor	r1, r1
     a88:	a0 91 c8 03 	lds	r26, 0x03C8
     a8c:	b0 91 c9 03 	lds	r27, 0x03C9
     a90:	ac 0f       	add	r26, r28
     a92:	bd 1f       	adc	r27, r29
     a94:	12 96       	adiw	r26, 0x02	; 2
     a96:	6c 91       	ld	r22, X
     a98:	12 97       	sbiw	r26, 0x02	; 2
     a9a:	66 23       	and	r22, r22
     a9c:	39 f0       	breq	.+14     	; 0xaac <_dialog_goto_state+0x4c>
      (*_dialog_pf_send)(_dialog_seq[new_state].command,
     a9e:	e0 91 c5 03 	lds	r30, 0x03C5
     aa2:	f0 91 c6 03 	lds	r31, 0x03C6
     aa6:	8d 91       	ld	r24, X+
     aa8:	9c 91       	ld	r25, X
     aaa:	19 95       	eicall
      _dialog_seq[new_state].command_length);
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
     aac:	80 91 c8 03 	lds	r24, 0x03C8
     ab0:	90 91 c9 03 	lds	r25, 0x03C9
     ab4:	c8 0f       	add	r28, r24
     ab6:	d9 1f       	adc	r29, r25
     ab8:	2d 81       	ldd	r18, Y+5	; 0x05
     aba:	22 23       	and	r18, r18
     abc:	51 f1       	breq	.+84     	; 0xb12 <_dialog_goto_state+0xb2>
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
                  _dialog_seq[new_state].responce_format;
     abe:	8b 81       	ldd	r24, Y+3	; 0x03
     ac0:	9c 81       	ldd	r25, Y+4	; 0x04
 @param[in] response_format to be waited for..
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
     ac2:	90 93 cd 03 	sts	0x03CD, r25
     ac6:	80 93 cc 03 	sts	0x03CC, r24
     aca:	90 93 d1 03 	sts	0x03D1, r25
     ace:	80 93 d0 03 	sts	0x03D0, r24
                  _dialog_seq[new_state].responce_format;
  _dialog_format.arg_buffers = _dialog_seq[new_state].arg_buffers;
     ad2:	e9 85       	ldd	r30, Y+9	; 0x09
     ad4:	fa 85       	ldd	r31, Y+10	; 0x0a
     ad6:	f0 93 d5 03 	sts	0x03D5, r31
     ada:	e0 93 d4 03 	sts	0x03D4, r30
  _dialog_format.arg_index = -1;
     ade:	3f ef       	ldi	r19, 0xFF	; 255
     ae0:	30 93 d3 03 	sts	0x03D3, r19
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
     ae4:	30 97       	sbiw	r30, 0x00	; 0
     ae6:	31 f0       	breq	.+12     	; 0xaf4 <_dialog_goto_state+0x94>
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
     ae8:	40 81       	ld	r20, Z
     aea:	51 81       	ldd	r21, Z+1	; 0x01
     aec:	50 93 d7 03 	sts	0x03D7, r21
     af0:	40 93 d6 03 	sts	0x03D6, r20
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
                  + _dialog_seq[new_state].responce_format_length - 1;
     af4:	30 e0       	ldi	r19, 0x00	; 0
     af6:	21 50       	subi	r18, 0x01	; 1
     af8:	31 09       	sbc	r19, r1
     afa:	82 0f       	add	r24, r18
     afc:	93 1f       	adc	r25, r19
  _dialog_format.arg_index = -1;
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
     afe:	90 93 cf 03 	sts	0x03CF, r25
     b02:	80 93 ce 03 	sts	0x03CE, r24
                  + _dialog_seq[new_state].responce_format_length - 1;
  _dialog_prepare_for_next_byte();
     b06:	1c df       	rcall	.-456    	; 0x940 <_dialog_prepare_for_next_byte>
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
      _dialog_await(new_state);
      _dialog_second_counter = _dialog_seq[new_state].max_response_time
     b08:	8e 81       	ldd	r24, Y+6	; 0x06
     b0a:	8f 5f       	subi	r24, 0xFF	; 255
     b0c:	80 93 cb 03 	sts	0x03CB, r24
     b10:	02 c0       	rjmp	.+4      	; 0xb16 <_dialog_goto_state+0xb6>
                      + 1; // add one because of 1 sec jitter in second timer
    } else {
      _dialog_goto_state(_dialog_seq[new_state].ok_state);
     b12:	8f 81       	ldd	r24, Y+7	; 0x07
     b14:	a5 df       	rcall	.-182    	; 0xa60 <_dialog_goto_state>
    }
  }
}
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	08 95       	ret

00000b1c <dialog_start>:
 @endcode
 */
void dialog_start(dialog_seq_t *p_seq,
		void (*pf_send)(uint8_t *command, uint8_t command_length),
		void (*pf_call_back)(uint8_t result)) {
  _dialog_seq = p_seq;
     b1c:	90 93 c9 03 	sts	0x03C9, r25
     b20:	80 93 c8 03 	sts	0x03C8, r24
  _dialog_pf_send = pf_send;
     b24:	70 93 c6 03 	sts	0x03C6, r23
     b28:	60 93 c5 03 	sts	0x03C5, r22
  _dialog_pf_call_back = pf_call_back;
     b2c:	50 93 c4 03 	sts	0x03C4, r21
     b30:	40 93 c3 03 	sts	0x03C3, r20
  _dialog_current_state = 0;
     b34:	10 92 ca 03 	sts	0x03CA, r1
  _dialog_goto_state(0);
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	92 cf       	rjmp	.-220    	; 0xa60 <_dialog_goto_state>
     b3c:	08 95       	ret

00000b3e <dialog_tick>:
 @brief Housekeeping function that must be called every second when a dialog is active.

 If the maximum wait time is exceeded the the dialog will change to error state.
 */
void dialog_tick() {
  if (_dialog_second_counter) {
     b3e:	80 91 cb 03 	lds	r24, 0x03CB
     b42:	88 23       	and	r24, r24
     b44:	91 f0       	breq	.+36     	; 0xb6a <dialog_tick+0x2c>
    if (--_dialog_second_counter == 0) {
     b46:	81 50       	subi	r24, 0x01	; 1
     b48:	80 93 cb 03 	sts	0x03CB, r24
     b4c:	81 11       	cpse	r24, r1
     b4e:	0d c0       	rjmp	.+26     	; 0xb6a <dialog_tick+0x2c>
      _dialog_goto_state(_dialog_seq[_dialog_current_state].error_state);
     b50:	80 91 ca 03 	lds	r24, 0x03CA
     b54:	e0 91 c8 03 	lds	r30, 0x03C8
     b58:	f0 91 c9 03 	lds	r31, 0x03C9
     b5c:	9b e0       	ldi	r25, 0x0B	; 11
     b5e:	89 9f       	mul	r24, r25
     b60:	e0 0d       	add	r30, r0
     b62:	f1 1d       	adc	r31, r1
     b64:	11 24       	eor	r1, r1
     b66:	80 85       	ldd	r24, Z+8	; 0x08
     b68:	7b cf       	rjmp	.-266    	; 0xa60 <_dialog_goto_state>
     b6a:	08 95       	ret

00000b6c <dialog_byte_received>:
If there are specified a pointer to an argument buffer in the current state of the dialog_seq, the received argument bytes will be stored in this buffer, else the argument values will be thrown away.

 When/If the expected response string is received the dialog state is changed to the current dialog states OK state.
 @param[in] byte received from device we are communication with.
 */
void dialog_byte_received(const uint8_t byte) {
     b6c:	6f 92       	push	r6
     b6e:	7f 92       	push	r7
     b70:	8f 92       	push	r8
     b72:	9f 92       	push	r9
     b74:	af 92       	push	r10
     b76:	bf 92       	push	r11
     b78:	cf 92       	push	r12
     b7a:	df 92       	push	r13
     b7c:	ef 92       	push	r14
     b7e:	ff 92       	push	r15
     b80:	0f 93       	push	r16
     b82:	1f 93       	push	r17
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	98 2e       	mov	r9, r24
  uint8_t _retry;
  
  switch (_dialog_await_state) {
     b8a:	80 91 c7 03 	lds	r24, 0x03C7
     b8e:	81 30       	cpi	r24, 0x01	; 1
     b90:	09 f4       	brne	.+2      	; 0xb94 <dialog_byte_received+0x28>
     b92:	42 c0       	rjmp	.+132    	; 0xc18 <dialog_byte_received+0xac>
     b94:	20 f0       	brcs	.+8      	; 0xb9e <dialog_byte_received+0x32>
     b96:	82 30       	cpi	r24, 0x02	; 2
     b98:	09 f4       	brne	.+2      	; 0xb9c <dialog_byte_received+0x30>
     b9a:	70 c0       	rjmp	.+224    	; 0xc7c <dialog_byte_received+0x110>
     b9c:	af c0       	rjmp	.+350    	; 0xcfc <dialog_byte_received+0x190>
     b9e:	81 2c       	mov	r8, r1
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     ba0:	c0 ed       	ldi	r28, 0xD0	; 208
     ba2:	d3 e0       	ldi	r29, 0x03	; 3
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     ba4:	0f 2e       	mov	r0, r31
     ba6:	fc ec       	ldi	r31, 0xCC	; 204
     ba8:	cf 2e       	mov	r12, r31
     baa:	f3 e0       	ldi	r31, 0x03	; 3
     bac:	df 2e       	mov	r13, r31
     bae:	f0 2d       	mov	r31, r0

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     bb0:	0f 2e       	mov	r0, r31
     bb2:	f3 ed       	ldi	r31, 0xD3	; 211
     bb4:	ef 2e       	mov	r14, r31
     bb6:	f3 e0       	ldi	r31, 0x03	; 3
     bb8:	ff 2e       	mov	r15, r31
     bba:	f0 2d       	mov	r31, r0
        if (_dialog_format.arg_buffers != 0) {
     bbc:	04 ed       	ldi	r16, 0xD4	; 212
     bbe:	13 e0       	ldi	r17, 0x03	; 3
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
        }

        if (!_retry) {
     bc0:	77 24       	eor	r7, r7
     bc2:	73 94       	inc	r7
     bc4:	61 2c       	mov	r6, r1
        _dialog_format.response_p = _dialog_format.response;

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
        if (_dialog_format.arg_buffers != 0) {
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     bc6:	0f 2e       	mov	r0, r31
     bc8:	f6 ed       	ldi	r31, 0xD6	; 214
     bca:	af 2e       	mov	r10, r31
     bcc:	f3 e0       	ldi	r31, 0x03	; 3
     bce:	bf 2e       	mov	r11, r31
     bd0:	f0 2d       	mov	r31, r0
  
  switch (_dialog_await_state) {
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     bd2:	e8 81       	ld	r30, Y
     bd4:	f9 81       	ldd	r31, Y+1	; 0x01
     bd6:	9f 01       	movw	r18, r30
     bd8:	2f 5f       	subi	r18, 0xFF	; 255
     bda:	3f 4f       	sbci	r19, 0xFF	; 255
     bdc:	39 83       	std	Y+1, r19	; 0x01
     bde:	28 83       	st	Y, r18
     be0:	80 81       	ld	r24, Z
     be2:	89 15       	cp	r24, r9
     be4:	a9 f0       	breq	.+42     	; 0xc10 <dialog_byte_received+0xa4>
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     be6:	d6 01       	movw	r26, r12
     be8:	8d 91       	ld	r24, X+
     bea:	9c 91       	ld	r25, X
     bec:	99 83       	std	Y+1, r25	; 0x01
     bee:	88 83       	st	Y, r24

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     bf0:	f7 01       	movw	r30, r14
     bf2:	10 82       	st	Z, r1
        if (_dialog_format.arg_buffers != 0) {
     bf4:	d8 01       	movw	r26, r16
     bf6:	ed 91       	ld	r30, X+
     bf8:	fc 91       	ld	r31, X
     bfa:	30 97       	sbiw	r30, 0x00	; 0
     bfc:	29 f0       	breq	.+10     	; 0xc08 <dialog_byte_received+0x9c>
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     bfe:	80 81       	ld	r24, Z
     c00:	91 81       	ldd	r25, Z+1	; 0x01
     c02:	f5 01       	movw	r30, r10
     c04:	91 83       	std	Z+1, r25	; 0x01
     c06:	80 83       	st	Z, r24
        }

        if (!_retry) {
     c08:	87 2d       	mov	r24, r7
     c0a:	81 10       	cpse	r8, r1
     c0c:	86 2d       	mov	r24, r6
          _retry = 1;
     c0e:	88 2e       	mov	r8, r24
        } else {
          _retry = 0;
        }
      }
      _dialog_prepare_for_next_byte();
     c10:	97 de       	rcall	.-722    	; 0x940 <_dialog_prepare_for_next_byte>
    } while (_retry);
     c12:	81 10       	cpse	r8, r1
     c14:	de cf       	rjmp	.-68     	; 0xbd2 <dialog_byte_received+0x66>
     c16:	72 c0       	rjmp	.+228    	; 0xcfc <dialog_byte_received+0x190>
    break;

  case ARG_STATE:
    // Test if buffer is specified
    if (_dialog_format.arg_buffers != 0) {
     c18:	20 91 d4 03 	lds	r18, 0x03D4
     c1c:	30 91 d5 03 	lds	r19, 0x03D5
     c20:	21 15       	cp	r18, r1
     c22:	31 05       	cpc	r19, r1
     c24:	11 f1       	breq	.+68     	; 0xc6a <dialog_byte_received+0xfe>
      *_dialog_format.arg_buf_p++ = byte;
     c26:	a6 ed       	ldi	r26, 0xD6	; 214
     c28:	b3 e0       	ldi	r27, 0x03	; 3
     c2a:	ed 91       	ld	r30, X+
     c2c:	fc 91       	ld	r31, X
     c2e:	11 97       	sbiw	r26, 0x01	; 1
     c30:	cf 01       	movw	r24, r30
     c32:	01 96       	adiw	r24, 0x01	; 1
     c34:	8d 93       	st	X+, r24
     c36:	9c 93       	st	X, r25
     c38:	90 82       	st	Z, r9
      // Update length of received argument in arg_buffers
      _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     c3a:	e0 91 d3 03 	lds	r30, 0x03D3
     c3e:	ff 27       	eor	r31, r31
     c40:	e7 fd       	sbrc	r30, 7
     c42:	f0 95       	com	r31
     c44:	cf 01       	movw	r24, r30
     c46:	88 0f       	add	r24, r24
     c48:	99 1f       	adc	r25, r25
     c4a:	e8 0f       	add	r30, r24
     c4c:	f9 1f       	adc	r31, r25
     c4e:	e2 0f       	add	r30, r18
     c50:	f3 1f       	adc	r31, r19
     c52:	82 81       	ldd	r24, Z+2	; 0x02
     c54:	8f 5f       	subi	r24, 0xFF	; 255
     c56:	82 83       	std	Z+2, r24	; 0x02

      // have we got all the bytes in the this argument
      if (--(_dialog_format.arg_cnt) == 0) {
     c58:	e2 ed       	ldi	r30, 0xD2	; 210
     c5a:	f3 e0       	ldi	r31, 0x03	; 3
     c5c:	80 81       	ld	r24, Z
     c5e:	81 50       	subi	r24, 0x01	; 1
     c60:	80 83       	st	Z, r24
     c62:	81 11       	cpse	r24, r1
     c64:	4b c0       	rjmp	.+150    	; 0xcfc <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     c66:	6c de       	rcall	.-808    	; 0x940 <_dialog_prepare_for_next_byte>
     c68:	49 c0       	rjmp	.+146    	; 0xcfc <dialog_byte_received+0x190>
      }
    } else if (--(_dialog_format.arg_cnt) == 0) {
     c6a:	e2 ed       	ldi	r30, 0xD2	; 210
     c6c:	f3 e0       	ldi	r31, 0x03	; 3
     c6e:	80 81       	ld	r24, Z
     c70:	81 50       	subi	r24, 0x01	; 1
     c72:	80 83       	st	Z, r24
     c74:	81 11       	cpse	r24, r1
     c76:	42 c0       	rjmp	.+132    	; 0xcfc <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     c78:	63 de       	rcall	.-826    	; 0x940 <_dialog_prepare_for_next_byte>
     c7a:	40 c0       	rjmp	.+128    	; 0xcfc <dialog_byte_received+0x190>
    }
    break;

  case ARG_MAX_STATE:
    // Test if we still are receiving argument bytes
    if (byte != *_dialog_format.response_p) {
     c7c:	e0 91 d0 03 	lds	r30, 0x03D0
     c80:	f0 91 d1 03 	lds	r31, 0x03D1
     c84:	80 81       	ld	r24, Z
     c86:	89 15       	cp	r24, r9
     c88:	51 f1       	breq	.+84     	; 0xcde <dialog_byte_received+0x172>
      // Test if buffer is specified
      if (_dialog_format.arg_buffers != 0) {
     c8a:	80 91 d4 03 	lds	r24, 0x03D4
     c8e:	90 91 d5 03 	lds	r25, 0x03D5
     c92:	00 97       	sbiw	r24, 0x00	; 0
     c94:	09 f4       	brne	.+2      	; 0xc98 <dialog_byte_received+0x12c>
     c96:	4e c0       	rjmp	.+156    	; 0xd34 <dialog_byte_received+0x1c8>
        *_dialog_format.arg_buf_p++ = byte;
     c98:	a6 ed       	ldi	r26, 0xD6	; 214
     c9a:	b3 e0       	ldi	r27, 0x03	; 3
     c9c:	ed 91       	ld	r30, X+
     c9e:	fc 91       	ld	r31, X
     ca0:	11 97       	sbiw	r26, 0x01	; 1
     ca2:	9f 01       	movw	r18, r30
     ca4:	2f 5f       	subi	r18, 0xFF	; 255
     ca6:	3f 4f       	sbci	r19, 0xFF	; 255
     ca8:	2d 93       	st	X+, r18
     caa:	3c 93       	st	X, r19
     cac:	90 82       	st	Z, r9
        // Update length of received argument in arg_buffers
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     cae:	20 91 d3 03 	lds	r18, 0x03D3
     cb2:	33 27       	eor	r19, r19
     cb4:	27 fd       	sbrc	r18, 7
     cb6:	30 95       	com	r19
     cb8:	f9 01       	movw	r30, r18
     cba:	ee 0f       	add	r30, r30
     cbc:	ff 1f       	adc	r31, r31
     cbe:	e2 0f       	add	r30, r18
     cc0:	f3 1f       	adc	r31, r19
     cc2:	e8 0f       	add	r30, r24
     cc4:	f9 1f       	adc	r31, r25
     cc6:	82 81       	ldd	r24, Z+2	; 0x02
     cc8:	8f 5f       	subi	r24, 0xFF	; 255
     cca:	82 83       	std	Z+2, r24	; 0x02

        // Have we received the maximum number of bytes in argument?
        if (--(_dialog_format.arg_cnt) == 0) {
     ccc:	e2 ed       	ldi	r30, 0xD2	; 210
     cce:	f3 e0       	ldi	r31, 0x03	; 3
     cd0:	80 81       	ld	r24, Z
     cd2:	81 50       	subi	r24, 0x01	; 1
     cd4:	80 83       	st	Z, r24
     cd6:	81 11       	cpse	r24, r1
     cd8:	11 c0       	rjmp	.+34     	; 0xcfc <dialog_byte_received+0x190>
          _dialog_prepare_for_next_byte();
     cda:	32 de       	rcall	.-924    	; 0x940 <_dialog_prepare_for_next_byte>
     cdc:	0f c0       	rjmp	.+30     	; 0xcfc <dialog_byte_received+0x190>
        }
      }
    } else if (--(_dialog_format.arg_cnt) == 0) { // or have we received the maximum allowed no of bytes in the argument?
     cde:	a2 ed       	ldi	r26, 0xD2	; 210
     ce0:	b3 e0       	ldi	r27, 0x03	; 3
     ce2:	8c 91       	ld	r24, X
     ce4:	81 50       	subi	r24, 0x01	; 1
     ce6:	8c 93       	st	X, r24
     ce8:	81 11       	cpse	r24, r1
     cea:	02 c0       	rjmp	.+4      	; 0xcf0 <dialog_byte_received+0x184>
      _dialog_prepare_for_next_byte();
     cec:	29 de       	rcall	.-942    	; 0x940 <_dialog_prepare_for_next_byte>
     cee:	06 c0       	rjmp	.+12     	; 0xcfc <dialog_byte_received+0x190>
    } else {
      // Next byte in normal response is received
      _dialog_format.response_p++;
     cf0:	31 96       	adiw	r30, 0x01	; 1
     cf2:	f0 93 d1 03 	sts	0x03D1, r31
     cf6:	e0 93 d0 03 	sts	0x03D0, r30
      _dialog_prepare_for_next_byte();
     cfa:	22 de       	rcall	.-956    	; 0x940 <_dialog_prepare_for_next_byte>
  default:
    break;
  }

  // Test if we are done - have received all bytes in this state of the dialog_seq
  if ((_dialog_await_state == NORMAL_STATE) && (_dialog_format.response_p > _dialog_format.last)) {
     cfc:	80 91 c7 03 	lds	r24, 0x03C7
     d00:	81 11       	cpse	r24, r1
     d02:	18 c0       	rjmp	.+48     	; 0xd34 <dialog_byte_received+0x1c8>
     d04:	20 91 d0 03 	lds	r18, 0x03D0
     d08:	30 91 d1 03 	lds	r19, 0x03D1
     d0c:	80 91 ce 03 	lds	r24, 0x03CE
     d10:	90 91 cf 03 	lds	r25, 0x03CF
     d14:	82 17       	cp	r24, r18
     d16:	93 07       	cpc	r25, r19
     d18:	68 f4       	brcc	.+26     	; 0xd34 <dialog_byte_received+0x1c8>
    // OK - goto OK state
    _dialog_goto_state(_dialog_seq[_dialog_current_state].ok_state);
     d1a:	80 91 ca 03 	lds	r24, 0x03CA
     d1e:	e0 91 c8 03 	lds	r30, 0x03C8
     d22:	f0 91 c9 03 	lds	r31, 0x03C9
     d26:	9b e0       	ldi	r25, 0x0B	; 11
     d28:	89 9f       	mul	r24, r25
     d2a:	e0 0d       	add	r30, r0
     d2c:	f1 1d       	adc	r31, r1
     d2e:	11 24       	eor	r1, r1
     d30:	87 81       	ldd	r24, Z+7	; 0x07
     d32:	96 de       	rcall	.-724    	; 0xa60 <_dialog_goto_state>
  }
}
     d34:	df 91       	pop	r29
     d36:	cf 91       	pop	r28
     d38:	1f 91       	pop	r17
     d3a:	0f 91       	pop	r16
     d3c:	ff 90       	pop	r15
     d3e:	ef 90       	pop	r14
     d40:	df 90       	pop	r13
     d42:	cf 90       	pop	r12
     d44:	bf 90       	pop	r11
     d46:	af 90       	pop	r10
     d48:	9f 90       	pop	r9
     d4a:	8f 90       	pop	r8
     d4c:	7f 90       	pop	r7
     d4e:	6f 90       	pop	r6
     d50:	08 95       	ret

00000d52 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     d52:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d54:	03 96       	adiw	r24, 0x03	; 3
     d56:	92 83       	std	Z+2, r25	; 0x02
     d58:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d5a:	2f ef       	ldi	r18, 0xFF	; 255
     d5c:	3f ef       	ldi	r19, 0xFF	; 255
     d5e:	34 83       	std	Z+4, r19	; 0x04
     d60:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d62:	96 83       	std	Z+6, r25	; 0x06
     d64:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d66:	90 87       	std	Z+8, r25	; 0x08
     d68:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     d6a:	10 82       	st	Z, r1
     d6c:	08 95       	ret

00000d6e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     d6e:	fc 01       	movw	r30, r24
     d70:	11 86       	std	Z+9, r1	; 0x09
     d72:	10 86       	std	Z+8, r1	; 0x08
     d74:	08 95       	ret

00000d76 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     d76:	cf 93       	push	r28
     d78:	df 93       	push	r29
     d7a:	9c 01       	movw	r18, r24
     d7c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     d7e:	dc 01       	movw	r26, r24
     d80:	11 96       	adiw	r26, 0x01	; 1
     d82:	cd 91       	ld	r28, X+
     d84:	dc 91       	ld	r29, X
     d86:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     d88:	d3 83       	std	Z+3, r29	; 0x03
     d8a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     d8c:	8c 81       	ldd	r24, Y+4	; 0x04
     d8e:	9d 81       	ldd	r25, Y+5	; 0x05
     d90:	95 83       	std	Z+5, r25	; 0x05
     d92:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     d94:	8c 81       	ldd	r24, Y+4	; 0x04
     d96:	9d 81       	ldd	r25, Y+5	; 0x05
     d98:	dc 01       	movw	r26, r24
     d9a:	13 96       	adiw	r26, 0x03	; 3
     d9c:	7c 93       	st	X, r23
     d9e:	6e 93       	st	-X, r22
     da0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     da2:	7d 83       	std	Y+5, r23	; 0x05
     da4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     da6:	31 87       	std	Z+9, r19	; 0x09
     da8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     daa:	f9 01       	movw	r30, r18
     dac:	80 81       	ld	r24, Z
     dae:	8f 5f       	subi	r24, 0xFF	; 255
     db0:	80 83       	st	Z, r24
}
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	08 95       	ret

00000db8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     db8:	cf 93       	push	r28
     dba:	df 93       	push	r29
     dbc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     dbe:	48 81       	ld	r20, Y
     dc0:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     dc2:	4f 3f       	cpi	r20, 0xFF	; 255
     dc4:	2f ef       	ldi	r18, 0xFF	; 255
     dc6:	52 07       	cpc	r21, r18
     dc8:	21 f4       	brne	.+8      	; 0xdd2 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     dca:	fc 01       	movw	r30, r24
     dcc:	a7 81       	ldd	r26, Z+7	; 0x07
     dce:	b0 85       	ldd	r27, Z+8	; 0x08
     dd0:	0d c0       	rjmp	.+26     	; 0xdec <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dd2:	dc 01       	movw	r26, r24
     dd4:	13 96       	adiw	r26, 0x03	; 3
     dd6:	12 96       	adiw	r26, 0x02	; 2
     dd8:	ed 91       	ld	r30, X+
     dda:	fc 91       	ld	r31, X
     ddc:	13 97       	sbiw	r26, 0x03	; 3
     dde:	20 81       	ld	r18, Z
     de0:	31 81       	ldd	r19, Z+1	; 0x01
     de2:	42 17       	cp	r20, r18
     de4:	53 07       	cpc	r21, r19
     de6:	10 f0       	brcs	.+4      	; 0xdec <vListInsert+0x34>
     de8:	df 01       	movw	r26, r30
     dea:	f5 cf       	rjmp	.-22     	; 0xdd6 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     dec:	12 96       	adiw	r26, 0x02	; 2
     dee:	ed 91       	ld	r30, X+
     df0:	fc 91       	ld	r31, X
     df2:	13 97       	sbiw	r26, 0x03	; 3
     df4:	fb 83       	std	Y+3, r31	; 0x03
     df6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     df8:	d5 83       	std	Z+5, r29	; 0x05
     dfa:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     dfc:	bd 83       	std	Y+5, r27	; 0x05
     dfe:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     e00:	13 96       	adiw	r26, 0x03	; 3
     e02:	dc 93       	st	X, r29
     e04:	ce 93       	st	-X, r28
     e06:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e08:	99 87       	std	Y+9, r25	; 0x09
     e0a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     e0c:	fc 01       	movw	r30, r24
     e0e:	20 81       	ld	r18, Z
     e10:	2f 5f       	subi	r18, 0xFF	; 255
     e12:	20 83       	st	Z, r18
}
     e14:	df 91       	pop	r29
     e16:	cf 91       	pop	r28
     e18:	08 95       	ret

00000e1a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     e1a:	cf 93       	push	r28
     e1c:	df 93       	push	r29
     e1e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     e20:	a0 85       	ldd	r26, Z+8	; 0x08
     e22:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     e24:	c2 81       	ldd	r28, Z+2	; 0x02
     e26:	d3 81       	ldd	r29, Z+3	; 0x03
     e28:	84 81       	ldd	r24, Z+4	; 0x04
     e2a:	95 81       	ldd	r25, Z+5	; 0x05
     e2c:	9d 83       	std	Y+5, r25	; 0x05
     e2e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e30:	c4 81       	ldd	r28, Z+4	; 0x04
     e32:	d5 81       	ldd	r29, Z+5	; 0x05
     e34:	82 81       	ldd	r24, Z+2	; 0x02
     e36:	93 81       	ldd	r25, Z+3	; 0x03
     e38:	9b 83       	std	Y+3, r25	; 0x03
     e3a:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e3c:	11 96       	adiw	r26, 0x01	; 1
     e3e:	cd 91       	ld	r28, X+
     e40:	dc 91       	ld	r29, X
     e42:	12 97       	sbiw	r26, 0x02	; 2
     e44:	ce 17       	cp	r28, r30
     e46:	df 07       	cpc	r29, r31
     e48:	31 f4       	brne	.+12     	; 0xe56 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e4a:	8c 81       	ldd	r24, Y+4	; 0x04
     e4c:	9d 81       	ldd	r25, Y+5	; 0x05
     e4e:	12 96       	adiw	r26, 0x02	; 2
     e50:	9c 93       	st	X, r25
     e52:	8e 93       	st	-X, r24
     e54:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     e56:	11 86       	std	Z+9, r1	; 0x09
     e58:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     e5a:	8c 91       	ld	r24, X
     e5c:	81 50       	subi	r24, 0x01	; 1
     e5e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     e60:	df 91       	pop	r29
     e62:	cf 91       	pop	r28
     e64:	08 95       	ret

00000e66 <pxPortInitialiseStack>:
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */

#if defined( portUSE_TIMER0 )
   /* Setup clock source and compare match behaviour. Assuming 328p*/
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     e66:	31 e1       	ldi	r19, 0x11	; 17
     e68:	fc 01       	movw	r30, r24
     e6a:	30 83       	st	Z, r19
     e6c:	31 97       	sbiw	r30, 0x01	; 1
     e6e:	22 e2       	ldi	r18, 0x22	; 34
     e70:	20 83       	st	Z, r18
     e72:	31 97       	sbiw	r30, 0x01	; 1
     e74:	a3 e3       	ldi	r26, 0x33	; 51
     e76:	a0 83       	st	Z, r26
     e78:	31 97       	sbiw	r30, 0x01	; 1
     e7a:	60 83       	st	Z, r22
     e7c:	31 97       	sbiw	r30, 0x01	; 1
     e7e:	70 83       	st	Z, r23
     e80:	31 97       	sbiw	r30, 0x01	; 1
     e82:	10 82       	st	Z, r1
     e84:	31 97       	sbiw	r30, 0x01	; 1
     e86:	10 82       	st	Z, r1
     e88:	31 97       	sbiw	r30, 0x01	; 1
     e8a:	60 e8       	ldi	r22, 0x80	; 128
     e8c:	60 83       	st	Z, r22
     e8e:	31 97       	sbiw	r30, 0x01	; 1
     e90:	10 82       	st	Z, r1
     e92:	31 97       	sbiw	r30, 0x01	; 1
     e94:	10 82       	st	Z, r1
     e96:	31 97       	sbiw	r30, 0x01	; 1
     e98:	10 82       	st	Z, r1
     e9a:	31 97       	sbiw	r30, 0x01	; 1
     e9c:	62 e0       	ldi	r22, 0x02	; 2
     e9e:	60 83       	st	Z, r22
     ea0:	31 97       	sbiw	r30, 0x01	; 1
     ea2:	63 e0       	ldi	r22, 0x03	; 3
     ea4:	60 83       	st	Z, r22
     ea6:	31 97       	sbiw	r30, 0x01	; 1
     ea8:	64 e0       	ldi	r22, 0x04	; 4
     eaa:	60 83       	st	Z, r22
     eac:	31 97       	sbiw	r30, 0x01	; 1
     eae:	65 e0       	ldi	r22, 0x05	; 5
     eb0:	60 83       	st	Z, r22
     eb2:	31 97       	sbiw	r30, 0x01	; 1
     eb4:	66 e0       	ldi	r22, 0x06	; 6
     eb6:	60 83       	st	Z, r22
     eb8:	31 97       	sbiw	r30, 0x01	; 1
     eba:	67 e0       	ldi	r22, 0x07	; 7
     ebc:	60 83       	st	Z, r22
     ebe:	31 97       	sbiw	r30, 0x01	; 1
     ec0:	68 e0       	ldi	r22, 0x08	; 8
     ec2:	60 83       	st	Z, r22
     ec4:	31 97       	sbiw	r30, 0x01	; 1
     ec6:	69 e0       	ldi	r22, 0x09	; 9
     ec8:	60 83       	st	Z, r22
     eca:	31 97       	sbiw	r30, 0x01	; 1
     ecc:	60 e1       	ldi	r22, 0x10	; 16
     ece:	60 83       	st	Z, r22
     ed0:	31 97       	sbiw	r30, 0x01	; 1
     ed2:	30 83       	st	Z, r19
     ed4:	31 97       	sbiw	r30, 0x01	; 1
     ed6:	32 e1       	ldi	r19, 0x12	; 18
     ed8:	30 83       	st	Z, r19
     eda:	31 97       	sbiw	r30, 0x01	; 1
     edc:	33 e1       	ldi	r19, 0x13	; 19
     ede:	30 83       	st	Z, r19
     ee0:	31 97       	sbiw	r30, 0x01	; 1
     ee2:	34 e1       	ldi	r19, 0x14	; 20
     ee4:	30 83       	st	Z, r19
     ee6:	31 97       	sbiw	r30, 0x01	; 1
     ee8:	35 e1       	ldi	r19, 0x15	; 21
     eea:	30 83       	st	Z, r19
     eec:	31 97       	sbiw	r30, 0x01	; 1
     eee:	36 e1       	ldi	r19, 0x16	; 22
     ef0:	30 83       	st	Z, r19
     ef2:	31 97       	sbiw	r30, 0x01	; 1
     ef4:	37 e1       	ldi	r19, 0x17	; 23
     ef6:	30 83       	st	Z, r19
     ef8:	31 97       	sbiw	r30, 0x01	; 1
     efa:	38 e1       	ldi	r19, 0x18	; 24
     efc:	30 83       	st	Z, r19
     efe:	31 97       	sbiw	r30, 0x01	; 1
     f00:	39 e1       	ldi	r19, 0x19	; 25
     f02:	30 83       	st	Z, r19
     f04:	31 97       	sbiw	r30, 0x01	; 1
     f06:	30 e2       	ldi	r19, 0x20	; 32
     f08:	30 83       	st	Z, r19
     f0a:	31 97       	sbiw	r30, 0x01	; 1
     f0c:	31 e2       	ldi	r19, 0x21	; 33
     f0e:	30 83       	st	Z, r19
     f10:	31 97       	sbiw	r30, 0x01	; 1
     f12:	20 83       	st	Z, r18
     f14:	31 97       	sbiw	r30, 0x01	; 1
     f16:	23 e2       	ldi	r18, 0x23	; 35
     f18:	20 83       	st	Z, r18
     f1a:	31 97       	sbiw	r30, 0x01	; 1
     f1c:	40 83       	st	Z, r20
     f1e:	31 97       	sbiw	r30, 0x01	; 1
     f20:	50 83       	st	Z, r21
     f22:	31 97       	sbiw	r30, 0x01	; 1
     f24:	26 e2       	ldi	r18, 0x26	; 38
     f26:	20 83       	st	Z, r18
     f28:	31 97       	sbiw	r30, 0x01	; 1
     f2a:	27 e2       	ldi	r18, 0x27	; 39
     f2c:	20 83       	st	Z, r18
     f2e:	31 97       	sbiw	r30, 0x01	; 1
     f30:	28 e2       	ldi	r18, 0x28	; 40
     f32:	20 83       	st	Z, r18
     f34:	31 97       	sbiw	r30, 0x01	; 1
     f36:	29 e2       	ldi	r18, 0x29	; 41
     f38:	20 83       	st	Z, r18
     f3a:	31 97       	sbiw	r30, 0x01	; 1
     f3c:	20 e3       	ldi	r18, 0x30	; 48
     f3e:	20 83       	st	Z, r18
     f40:	31 97       	sbiw	r30, 0x01	; 1
     f42:	21 e3       	ldi	r18, 0x31	; 49
     f44:	20 83       	st	Z, r18
     f46:	89 97       	sbiw	r24, 0x29	; 41
     f48:	08 95       	ret

00000f4a <xPortStartScheduler>:
     f4a:	88 ee       	ldi	r24, 0xE8	; 232
     f4c:	93 e0       	ldi	r25, 0x03	; 3
     f4e:	90 93 db 03 	sts	0x03DB, r25
     f52:	80 93 da 03 	sts	0x03DA, r24
     f56:	90 93 d9 03 	sts	0x03D9, r25
     f5a:	80 93 d8 03 	sts	0x03D8, r24
     f5e:	89 ef       	ldi	r24, 0xF9	; 249
     f60:	87 bd       	out	0x27, r24	; 39
     f62:	82 e0       	ldi	r24, 0x02	; 2
     f64:	84 bd       	out	0x24, r24	; 36
     f66:	83 e0       	ldi	r24, 0x03	; 3
     f68:	85 bd       	out	0x25, r24	; 37
     f6a:	ee e6       	ldi	r30, 0x6E	; 110
     f6c:	f0 e0       	ldi	r31, 0x00	; 0
     f6e:	80 81       	ld	r24, Z
     f70:	82 60       	ori	r24, 0x02	; 2
     f72:	80 83       	st	Z, r24
     f74:	a0 91 fb 0d 	lds	r26, 0x0DFB
     f78:	b0 91 fc 0d 	lds	r27, 0x0DFC
     f7c:	cd 91       	ld	r28, X+
     f7e:	cd bf       	out	0x3d, r28	; 61
     f80:	dd 91       	ld	r29, X+
     f82:	de bf       	out	0x3e, r29	; 62
     f84:	ff 91       	pop	r31
     f86:	ef 91       	pop	r30
     f88:	df 91       	pop	r29
     f8a:	cf 91       	pop	r28
     f8c:	bf 91       	pop	r27
     f8e:	af 91       	pop	r26
     f90:	9f 91       	pop	r25
     f92:	8f 91       	pop	r24
     f94:	7f 91       	pop	r23
     f96:	6f 91       	pop	r22
     f98:	5f 91       	pop	r21
     f9a:	4f 91       	pop	r20
     f9c:	3f 91       	pop	r19
     f9e:	2f 91       	pop	r18
     fa0:	1f 91       	pop	r17
     fa2:	0f 91       	pop	r16
     fa4:	ff 90       	pop	r15
     fa6:	ef 90       	pop	r14
     fa8:	df 90       	pop	r13
     faa:	cf 90       	pop	r12
     fac:	bf 90       	pop	r11
     fae:	af 90       	pop	r10
     fb0:	9f 90       	pop	r9
     fb2:	8f 90       	pop	r8
     fb4:	7f 90       	pop	r7
     fb6:	6f 90       	pop	r6
     fb8:	5f 90       	pop	r5
     fba:	4f 90       	pop	r4
     fbc:	3f 90       	pop	r3
     fbe:	2f 90       	pop	r2
     fc0:	1f 90       	pop	r1
     fc2:	0f 90       	pop	r0
     fc4:	0c be       	out	0x3c, r0	; 60
     fc6:	0f 90       	pop	r0
     fc8:	0b be       	out	0x3b, r0	; 59
     fca:	0f 90       	pop	r0
     fcc:	0f be       	out	0x3f, r0	; 63
     fce:	0f 90       	pop	r0
     fd0:	08 95       	ret
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	08 95       	ret

00000fd6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     fd6:	0f 92       	push	r0
     fd8:	0f b6       	in	r0, 0x3f	; 63
     fda:	f8 94       	cli
     fdc:	0f 92       	push	r0
     fde:	0b b6       	in	r0, 0x3b	; 59
     fe0:	0f 92       	push	r0
     fe2:	0c b6       	in	r0, 0x3c	; 60
     fe4:	0f 92       	push	r0
     fe6:	1f 92       	push	r1
     fe8:	11 24       	eor	r1, r1
     fea:	2f 92       	push	r2
     fec:	3f 92       	push	r3
     fee:	4f 92       	push	r4
     ff0:	5f 92       	push	r5
     ff2:	6f 92       	push	r6
     ff4:	7f 92       	push	r7
     ff6:	8f 92       	push	r8
     ff8:	9f 92       	push	r9
     ffa:	af 92       	push	r10
     ffc:	bf 92       	push	r11
     ffe:	cf 92       	push	r12
    1000:	df 92       	push	r13
    1002:	ef 92       	push	r14
    1004:	ff 92       	push	r15
    1006:	0f 93       	push	r16
    1008:	1f 93       	push	r17
    100a:	2f 93       	push	r18
    100c:	3f 93       	push	r19
    100e:	4f 93       	push	r20
    1010:	5f 93       	push	r21
    1012:	6f 93       	push	r22
    1014:	7f 93       	push	r23
    1016:	8f 93       	push	r24
    1018:	9f 93       	push	r25
    101a:	af 93       	push	r26
    101c:	bf 93       	push	r27
    101e:	cf 93       	push	r28
    1020:	df 93       	push	r29
    1022:	ef 93       	push	r30
    1024:	ff 93       	push	r31
    1026:	a0 91 fb 0d 	lds	r26, 0x0DFB
    102a:	b0 91 fc 0d 	lds	r27, 0x0DFC
    102e:	0d b6       	in	r0, 0x3d	; 61
    1030:	0d 92       	st	X+, r0
    1032:	0e b6       	in	r0, 0x3e	; 62
    1034:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1036:	dd d6       	rcall	.+3514   	; 0x1df2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1038:	a0 91 fb 0d 	lds	r26, 0x0DFB
    103c:	b0 91 fc 0d 	lds	r27, 0x0DFC
    1040:	cd 91       	ld	r28, X+
    1042:	cd bf       	out	0x3d, r28	; 61
    1044:	dd 91       	ld	r29, X+
    1046:	de bf       	out	0x3e, r29	; 62
    1048:	ff 91       	pop	r31
    104a:	ef 91       	pop	r30
    104c:	df 91       	pop	r29
    104e:	cf 91       	pop	r28
    1050:	bf 91       	pop	r27
    1052:	af 91       	pop	r26
    1054:	9f 91       	pop	r25
    1056:	8f 91       	pop	r24
    1058:	7f 91       	pop	r23
    105a:	6f 91       	pop	r22
    105c:	5f 91       	pop	r21
    105e:	4f 91       	pop	r20
    1060:	3f 91       	pop	r19
    1062:	2f 91       	pop	r18
    1064:	1f 91       	pop	r17
    1066:	0f 91       	pop	r16
    1068:	ff 90       	pop	r15
    106a:	ef 90       	pop	r14
    106c:	df 90       	pop	r13
    106e:	cf 90       	pop	r12
    1070:	bf 90       	pop	r11
    1072:	af 90       	pop	r10
    1074:	9f 90       	pop	r9
    1076:	8f 90       	pop	r8
    1078:	7f 90       	pop	r7
    107a:	6f 90       	pop	r6
    107c:	5f 90       	pop	r5
    107e:	4f 90       	pop	r4
    1080:	3f 90       	pop	r3
    1082:	2f 90       	pop	r2
    1084:	1f 90       	pop	r1
    1086:	0f 90       	pop	r0
    1088:	0c be       	out	0x3c, r0	; 60
    108a:	0f 90       	pop	r0
    108c:	0b be       	out	0x3b, r0	; 59
    108e:	0f 90       	pop	r0
    1090:	0f be       	out	0x3f, r0	; 63
    1092:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1094:	08 95       	ret

00001096 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1096:	0f 92       	push	r0
    1098:	0f b6       	in	r0, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	0f 92       	push	r0
    109e:	0b b6       	in	r0, 0x3b	; 59
    10a0:	0f 92       	push	r0
    10a2:	0c b6       	in	r0, 0x3c	; 60
    10a4:	0f 92       	push	r0
    10a6:	1f 92       	push	r1
    10a8:	11 24       	eor	r1, r1
    10aa:	2f 92       	push	r2
    10ac:	3f 92       	push	r3
    10ae:	4f 92       	push	r4
    10b0:	5f 92       	push	r5
    10b2:	6f 92       	push	r6
    10b4:	7f 92       	push	r7
    10b6:	8f 92       	push	r8
    10b8:	9f 92       	push	r9
    10ba:	af 92       	push	r10
    10bc:	bf 92       	push	r11
    10be:	cf 92       	push	r12
    10c0:	df 92       	push	r13
    10c2:	ef 92       	push	r14
    10c4:	ff 92       	push	r15
    10c6:	0f 93       	push	r16
    10c8:	1f 93       	push	r17
    10ca:	2f 93       	push	r18
    10cc:	3f 93       	push	r19
    10ce:	4f 93       	push	r20
    10d0:	5f 93       	push	r21
    10d2:	6f 93       	push	r22
    10d4:	7f 93       	push	r23
    10d6:	8f 93       	push	r24
    10d8:	9f 93       	push	r25
    10da:	af 93       	push	r26
    10dc:	bf 93       	push	r27
    10de:	cf 93       	push	r28
    10e0:	df 93       	push	r29
    10e2:	ef 93       	push	r30
    10e4:	ff 93       	push	r31
    10e6:	a0 91 fb 0d 	lds	r26, 0x0DFB
    10ea:	b0 91 fc 0d 	lds	r27, 0x0DFC
    10ee:	0d b6       	in	r0, 0x3d	; 61
    10f0:	0d 92       	st	X+, r0
    10f2:	0e b6       	in	r0, 0x3e	; 62
    10f4:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
    10f6:	80 91 d8 03 	lds	r24, 0x03D8
    10fa:	90 91 d9 03 	lds	r25, 0x03D9
    10fe:	01 97       	sbiw	r24, 0x01	; 1
    1100:	90 93 d9 03 	sts	0x03D9, r25
    1104:	80 93 d8 03 	sts	0x03D8, r24
    1108:	89 2b       	or	r24, r25
    110a:	41 f4       	brne	.+16     	; 0x111c <vPortYieldFromTick+0x86>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
    110c:	80 91 da 03 	lds	r24, 0x03DA
    1110:	90 91 db 03 	lds	r25, 0x03DB
    1114:	90 93 d9 03 	sts	0x03D9, r25
    1118:	80 93 d8 03 	sts	0x03D8, r24
	}

	if( xTaskIncrementTick() != pdFALSE )
    111c:	16 d5       	rcall	.+2604   	; 0x1b4a <xTaskIncrementTick>
    111e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1120:	68 d6       	rcall	.+3280   	; 0x1df2 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    1122:	a0 91 fb 0d 	lds	r26, 0x0DFB
    1126:	b0 91 fc 0d 	lds	r27, 0x0DFC
    112a:	cd 91       	ld	r28, X+
    112c:	cd bf       	out	0x3d, r28	; 61
    112e:	dd 91       	ld	r29, X+
    1130:	de bf       	out	0x3e, r29	; 62
    1132:	ff 91       	pop	r31
    1134:	ef 91       	pop	r30
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	bf 91       	pop	r27
    113c:	af 91       	pop	r26
    113e:	9f 91       	pop	r25
    1140:	8f 91       	pop	r24
    1142:	7f 91       	pop	r23
    1144:	6f 91       	pop	r22
    1146:	5f 91       	pop	r21
    1148:	4f 91       	pop	r20
    114a:	3f 91       	pop	r19
    114c:	2f 91       	pop	r18
    114e:	1f 91       	pop	r17
    1150:	0f 91       	pop	r16
    1152:	ff 90       	pop	r15
    1154:	ef 90       	pop	r14
    1156:	df 90       	pop	r13
    1158:	cf 90       	pop	r12
    115a:	bf 90       	pop	r11
    115c:	af 90       	pop	r10
    115e:	9f 90       	pop	r9
    1160:	8f 90       	pop	r8
    1162:	7f 90       	pop	r7
    1164:	6f 90       	pop	r6
    1166:	5f 90       	pop	r5
    1168:	4f 90       	pop	r4
    116a:	3f 90       	pop	r3
    116c:	2f 90       	pop	r2
    116e:	1f 90       	pop	r1
    1170:	0f 90       	pop	r0
    1172:	0c be       	out	0x3c, r0	; 60
    1174:	0f 90       	pop	r0
    1176:	0b be       	out	0x3b, r0	; 59
    1178:	0f 90       	pop	r0
    117a:	0f be       	out	0x3f, r0	; 63
    117c:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    117e:	08 95       	ret

00001180 <__vector_21>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
    1180:	8a df       	rcall	.-236    	; 0x1096 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1182:	18 95       	reti

00001184 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1184:	cf 93       	push	r28
    1186:	df 93       	push	r29
    1188:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    118a:	cf d4       	rcall	.+2462   	; 0x1b2a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    118c:	80 91 dc 03 	lds	r24, 0x03DC
    1190:	90 91 dd 03 	lds	r25, 0x03DD
    1194:	89 2b       	or	r24, r25
    1196:	31 f4       	brne	.+12     	; 0x11a4 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1198:	81 ee       	ldi	r24, 0xE1	; 225
    119a:	93 e0       	ldi	r25, 0x03	; 3
    119c:	90 93 dd 03 	sts	0x03DD, r25
    11a0:	80 93 dc 03 	sts	0x03DC, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    11a4:	40 91 de 03 	lds	r20, 0x03DE
    11a8:	50 91 df 03 	lds	r21, 0x03DF
    11ac:	9e 01       	movw	r18, r28
    11ae:	24 0f       	add	r18, r20
    11b0:	35 1f       	adc	r19, r21
    11b2:	23 3c       	cpi	r18, 0xC3	; 195
    11b4:	89 e0       	ldi	r24, 0x09	; 9
    11b6:	38 07       	cpc	r19, r24
    11b8:	70 f4       	brcc	.+28     	; 0x11d6 <pvPortMalloc+0x52>
    11ba:	42 17       	cp	r20, r18
    11bc:	53 07       	cpc	r21, r19
    11be:	70 f4       	brcc	.+28     	; 0x11dc <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    11c0:	c0 91 dc 03 	lds	r28, 0x03DC
    11c4:	d0 91 dd 03 	lds	r29, 0x03DD
    11c8:	c4 0f       	add	r28, r20
    11ca:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    11cc:	30 93 df 03 	sts	0x03DF, r19
    11d0:	20 93 de 03 	sts	0x03DE, r18
    11d4:	05 c0       	rjmp	.+10     	; 0x11e0 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    11d6:	c0 e0       	ldi	r28, 0x00	; 0
    11d8:	d0 e0       	ldi	r29, 0x00	; 0
    11da:	02 c0       	rjmp	.+4      	; 0x11e0 <pvPortMalloc+0x5c>
    11dc:	c0 e0       	ldi	r28, 0x00	; 0
    11de:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    11e0:	6f d5       	rcall	.+2782   	; 0x1cc0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    11e2:	ce 01       	movw	r24, r28
    11e4:	df 91       	pop	r29
    11e6:	cf 91       	pop	r28
    11e8:	08 95       	ret

000011ea <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    11ea:	08 95       	ret

000011ec <prvCopyDataToQueue>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    11ec:	1f 93       	push	r17
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	ec 01       	movw	r28, r24
    11f4:	14 2f       	mov	r17, r20
    11f6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11f8:	81 11       	cpse	r24, r1
    11fa:	0b c0       	rjmp	.+22     	; 0x1212 <prvCopyDataToQueue+0x26>
    11fc:	88 81       	ld	r24, Y
    11fe:	99 81       	ldd	r25, Y+1	; 0x01
    1200:	89 2b       	or	r24, r25
    1202:	09 f0       	breq	.+2      	; 0x1206 <prvCopyDataToQueue+0x1a>
    1204:	46 c0       	rjmp	.+140    	; 0x1292 <prvCopyDataToQueue+0xa6>
    1206:	8a 81       	ldd	r24, Y+2	; 0x02
    1208:	9b 81       	ldd	r25, Y+3	; 0x03
    120a:	98 d7       	rcall	.+3888   	; 0x213c <xTaskPriorityDisinherit>
    120c:	1b 82       	std	Y+3, r1	; 0x03
    120e:	1a 82       	std	Y+2, r1	; 0x02
    1210:	47 c0       	rjmp	.+142    	; 0x12a0 <prvCopyDataToQueue+0xb4>
    1212:	41 11       	cpse	r20, r1
    1214:	18 c0       	rjmp	.+48     	; 0x1246 <prvCopyDataToQueue+0x5a>
    1216:	48 2f       	mov	r20, r24
    1218:	50 e0       	ldi	r21, 0x00	; 0
    121a:	8c 81       	ldd	r24, Y+4	; 0x04
    121c:	9d 81       	ldd	r25, Y+5	; 0x05
    121e:	0e 94 a7 1b 	call	0x374e	; 0x374e <memcpy>
    1222:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1224:	8c 81       	ldd	r24, Y+4	; 0x04
    1226:	9d 81       	ldd	r25, Y+5	; 0x05
    1228:	82 0f       	add	r24, r18
    122a:	91 1d       	adc	r25, r1
    122c:	9d 83       	std	Y+5, r25	; 0x05
    122e:	8c 83       	std	Y+4, r24	; 0x04
    1230:	2a 81       	ldd	r18, Y+2	; 0x02
    1232:	3b 81       	ldd	r19, Y+3	; 0x03
    1234:	82 17       	cp	r24, r18
    1236:	93 07       	cpc	r25, r19
    1238:	70 f1       	brcs	.+92     	; 0x1296 <prvCopyDataToQueue+0xaa>
    123a:	88 81       	ld	r24, Y
    123c:	99 81       	ldd	r25, Y+1	; 0x01
    123e:	9d 83       	std	Y+5, r25	; 0x05
    1240:	8c 83       	std	Y+4, r24	; 0x04
    1242:	80 e0       	ldi	r24, 0x00	; 0
    1244:	2d c0       	rjmp	.+90     	; 0x12a0 <prvCopyDataToQueue+0xb4>
    1246:	48 2f       	mov	r20, r24
    1248:	50 e0       	ldi	r21, 0x00	; 0
    124a:	8e 81       	ldd	r24, Y+6	; 0x06
    124c:	9f 81       	ldd	r25, Y+7	; 0x07
    124e:	0e 94 a7 1b 	call	0x374e	; 0x374e <memcpy>
    1252:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1254:	30 e0       	ldi	r19, 0x00	; 0
    1256:	31 95       	neg	r19
    1258:	21 95       	neg	r18
    125a:	31 09       	sbc	r19, r1
    125c:	8e 81       	ldd	r24, Y+6	; 0x06
    125e:	9f 81       	ldd	r25, Y+7	; 0x07
    1260:	82 0f       	add	r24, r18
    1262:	93 1f       	adc	r25, r19
    1264:	9f 83       	std	Y+7, r25	; 0x07
    1266:	8e 83       	std	Y+6, r24	; 0x06
    1268:	68 81       	ld	r22, Y
    126a:	79 81       	ldd	r23, Y+1	; 0x01
    126c:	86 17       	cp	r24, r22
    126e:	97 07       	cpc	r25, r23
    1270:	30 f4       	brcc	.+12     	; 0x127e <prvCopyDataToQueue+0x92>
    1272:	8a 81       	ldd	r24, Y+2	; 0x02
    1274:	9b 81       	ldd	r25, Y+3	; 0x03
    1276:	28 0f       	add	r18, r24
    1278:	39 1f       	adc	r19, r25
    127a:	3f 83       	std	Y+7, r19	; 0x07
    127c:	2e 83       	std	Y+6, r18	; 0x06
    127e:	12 30       	cpi	r17, 0x02	; 2
    1280:	61 f4       	brne	.+24     	; 0x129a <prvCopyDataToQueue+0xae>
    1282:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1284:	88 23       	and	r24, r24
    1286:	59 f0       	breq	.+22     	; 0x129e <prvCopyDataToQueue+0xb2>
    1288:	8a 8d       	ldd	r24, Y+26	; 0x1a
    128a:	81 50       	subi	r24, 0x01	; 1
    128c:	8a 8f       	std	Y+26, r24	; 0x1a
    128e:	80 e0       	ldi	r24, 0x00	; 0
    1290:	07 c0       	rjmp	.+14     	; 0x12a0 <prvCopyDataToQueue+0xb4>
    1292:	80 e0       	ldi	r24, 0x00	; 0
    1294:	05 c0       	rjmp	.+10     	; 0x12a0 <prvCopyDataToQueue+0xb4>
    1296:	80 e0       	ldi	r24, 0x00	; 0
    1298:	03 c0       	rjmp	.+6      	; 0x12a0 <prvCopyDataToQueue+0xb4>
    129a:	80 e0       	ldi	r24, 0x00	; 0
    129c:	01 c0       	rjmp	.+2      	; 0x12a0 <prvCopyDataToQueue+0xb4>
    129e:	80 e0       	ldi	r24, 0x00	; 0
    12a0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    12a2:	9f 5f       	subi	r25, 0xFF	; 255
    12a4:	9a 8f       	std	Y+26, r25	; 0x1a
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	1f 91       	pop	r17
    12ac:	08 95       	ret

000012ae <prvCopyDataFromQueue>:
    12ae:	fc 01       	movw	r30, r24
    12b0:	cb 01       	movw	r24, r22
    12b2:	44 8d       	ldd	r20, Z+28	; 0x1c
    12b4:	44 23       	and	r20, r20
    12b6:	a1 f0       	breq	.+40     	; 0x12e0 <prvCopyDataFromQueue+0x32>
    12b8:	50 e0       	ldi	r21, 0x00	; 0
    12ba:	26 81       	ldd	r18, Z+6	; 0x06
    12bc:	37 81       	ldd	r19, Z+7	; 0x07
    12be:	24 0f       	add	r18, r20
    12c0:	35 1f       	adc	r19, r21
    12c2:	37 83       	std	Z+7, r19	; 0x07
    12c4:	26 83       	std	Z+6, r18	; 0x06
    12c6:	62 81       	ldd	r22, Z+2	; 0x02
    12c8:	73 81       	ldd	r23, Z+3	; 0x03
    12ca:	26 17       	cp	r18, r22
    12cc:	37 07       	cpc	r19, r23
    12ce:	20 f0       	brcs	.+8      	; 0x12d8 <prvCopyDataFromQueue+0x2a>
    12d0:	20 81       	ld	r18, Z
    12d2:	31 81       	ldd	r19, Z+1	; 0x01
    12d4:	37 83       	std	Z+7, r19	; 0x07
    12d6:	26 83       	std	Z+6, r18	; 0x06
    12d8:	66 81       	ldd	r22, Z+6	; 0x06
    12da:	77 81       	ldd	r23, Z+7	; 0x07
    12dc:	0c 94 a7 1b 	jmp	0x374e	; 0x374e <memcpy>
    12e0:	08 95       	ret

000012e2 <prvUnlockQueue>:
    12e2:	0f 93       	push	r16
    12e4:	1f 93       	push	r17
    12e6:	cf 93       	push	r28
    12e8:	df 93       	push	r29
    12ea:	ec 01       	movw	r28, r24
    12ec:	0f b6       	in	r0, 0x3f	; 63
    12ee:	f8 94       	cli
    12f0:	0f 92       	push	r0
    12f2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12f4:	18 16       	cp	r1, r24
    12f6:	a4 f4       	brge	.+40     	; 0x1320 <prvUnlockQueue+0x3e>
    12f8:	89 89       	ldd	r24, Y+17	; 0x11
    12fa:	88 23       	and	r24, r24
    12fc:	89 f0       	breq	.+34     	; 0x1320 <prvUnlockQueue+0x3e>
    12fe:	8e 01       	movw	r16, r28
    1300:	0f 5e       	subi	r16, 0xEF	; 239
    1302:	1f 4f       	sbci	r17, 0xFF	; 255
    1304:	03 c0       	rjmp	.+6      	; 0x130c <prvUnlockQueue+0x2a>
    1306:	89 89       	ldd	r24, Y+17	; 0x11
    1308:	88 23       	and	r24, r24
    130a:	51 f0       	breq	.+20     	; 0x1320 <prvUnlockQueue+0x3e>
    130c:	c8 01       	movw	r24, r16
    130e:	21 d6       	rcall	.+3138   	; 0x1f52 <xTaskRemoveFromEventList>
    1310:	81 11       	cpse	r24, r1
    1312:	a4 d6       	rcall	.+3400   	; 0x205c <vTaskMissedYield>
    1314:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1316:	81 50       	subi	r24, 0x01	; 1
    1318:	8e 8f       	std	Y+30, r24	; 0x1e
    131a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    131c:	18 16       	cp	r1, r24
    131e:	9c f3       	brlt	.-26     	; 0x1306 <prvUnlockQueue+0x24>
    1320:	8f ef       	ldi	r24, 0xFF	; 255
    1322:	8e 8f       	std	Y+30, r24	; 0x1e
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63
    1328:	0f b6       	in	r0, 0x3f	; 63
    132a:	f8 94       	cli
    132c:	0f 92       	push	r0
    132e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1330:	18 16       	cp	r1, r24
    1332:	a4 f4       	brge	.+40     	; 0x135c <prvUnlockQueue+0x7a>
    1334:	88 85       	ldd	r24, Y+8	; 0x08
    1336:	88 23       	and	r24, r24
    1338:	89 f0       	breq	.+34     	; 0x135c <prvUnlockQueue+0x7a>
    133a:	8e 01       	movw	r16, r28
    133c:	08 5f       	subi	r16, 0xF8	; 248
    133e:	1f 4f       	sbci	r17, 0xFF	; 255
    1340:	03 c0       	rjmp	.+6      	; 0x1348 <prvUnlockQueue+0x66>
    1342:	88 85       	ldd	r24, Y+8	; 0x08
    1344:	88 23       	and	r24, r24
    1346:	51 f0       	breq	.+20     	; 0x135c <prvUnlockQueue+0x7a>
    1348:	c8 01       	movw	r24, r16
    134a:	03 d6       	rcall	.+3078   	; 0x1f52 <xTaskRemoveFromEventList>
    134c:	81 11       	cpse	r24, r1
    134e:	86 d6       	rcall	.+3340   	; 0x205c <vTaskMissedYield>
    1350:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1352:	81 50       	subi	r24, 0x01	; 1
    1354:	8d 8f       	std	Y+29, r24	; 0x1d
    1356:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1358:	18 16       	cp	r1, r24
    135a:	9c f3       	brlt	.-26     	; 0x1342 <prvUnlockQueue+0x60>
    135c:	8f ef       	ldi	r24, 0xFF	; 255
    135e:	8d 8f       	std	Y+29, r24	; 0x1d
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63
    1364:	df 91       	pop	r29
    1366:	cf 91       	pop	r28
    1368:	1f 91       	pop	r17
    136a:	0f 91       	pop	r16
    136c:	08 95       	ret

0000136e <xQueueGenericReset>:
    136e:	cf 93       	push	r28
    1370:	df 93       	push	r29
    1372:	ec 01       	movw	r28, r24
    1374:	0f b6       	in	r0, 0x3f	; 63
    1376:	f8 94       	cli
    1378:	0f 92       	push	r0
    137a:	88 81       	ld	r24, Y
    137c:	99 81       	ldd	r25, Y+1	; 0x01
    137e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1380:	30 e0       	ldi	r19, 0x00	; 0
    1382:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1384:	72 9f       	mul	r23, r18
    1386:	a0 01       	movw	r20, r0
    1388:	73 9f       	mul	r23, r19
    138a:	50 0d       	add	r21, r0
    138c:	11 24       	eor	r1, r1
    138e:	fc 01       	movw	r30, r24
    1390:	e4 0f       	add	r30, r20
    1392:	f5 1f       	adc	r31, r21
    1394:	fb 83       	std	Y+3, r31	; 0x03
    1396:	ea 83       	std	Y+2, r30	; 0x02
    1398:	1a 8e       	std	Y+26, r1	; 0x1a
    139a:	9d 83       	std	Y+5, r25	; 0x05
    139c:	8c 83       	std	Y+4, r24	; 0x04
    139e:	42 1b       	sub	r20, r18
    13a0:	53 0b       	sbc	r21, r19
    13a2:	84 0f       	add	r24, r20
    13a4:	95 1f       	adc	r25, r21
    13a6:	9f 83       	std	Y+7, r25	; 0x07
    13a8:	8e 83       	std	Y+6, r24	; 0x06
    13aa:	8f ef       	ldi	r24, 0xFF	; 255
    13ac:	8d 8f       	std	Y+29, r24	; 0x1d
    13ae:	8e 8f       	std	Y+30, r24	; 0x1e
    13b0:	61 11       	cpse	r22, r1
    13b2:	0a c0       	rjmp	.+20     	; 0x13c8 <xQueueGenericReset+0x5a>
    13b4:	88 85       	ldd	r24, Y+8	; 0x08
    13b6:	88 23       	and	r24, r24
    13b8:	69 f0       	breq	.+26     	; 0x13d4 <xQueueGenericReset+0x66>
    13ba:	ce 01       	movw	r24, r28
    13bc:	08 96       	adiw	r24, 0x08	; 8
    13be:	c9 d5       	rcall	.+2962   	; 0x1f52 <xTaskRemoveFromEventList>
    13c0:	81 30       	cpi	r24, 0x01	; 1
    13c2:	41 f4       	brne	.+16     	; 0x13d4 <xQueueGenericReset+0x66>
    13c4:	08 de       	rcall	.-1008   	; 0xfd6 <vPortYield>
    13c6:	06 c0       	rjmp	.+12     	; 0x13d4 <xQueueGenericReset+0x66>
    13c8:	ce 01       	movw	r24, r28
    13ca:	08 96       	adiw	r24, 0x08	; 8
    13cc:	c2 dc       	rcall	.-1660   	; 0xd52 <vListInitialise>
    13ce:	ce 01       	movw	r24, r28
    13d0:	41 96       	adiw	r24, 0x11	; 17
    13d2:	bf dc       	rcall	.-1666   	; 0xd52 <vListInitialise>
    13d4:	0f 90       	pop	r0
    13d6:	0f be       	out	0x3f, r0	; 63
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	df 91       	pop	r29
    13dc:	cf 91       	pop	r28
    13de:	08 95       	ret

000013e0 <xQueueGenericCreate>:
    13e0:	0f 93       	push	r16
    13e2:	1f 93       	push	r17
    13e4:	cf 93       	push	r28
    13e6:	df 93       	push	r29
    13e8:	08 2f       	mov	r16, r24
    13ea:	16 2f       	mov	r17, r22
    13ec:	66 23       	and	r22, r22
    13ee:	b9 f0       	breq	.+46     	; 0x141e <xQueueGenericCreate+0x3e>
    13f0:	86 9f       	mul	r24, r22
    13f2:	c0 01       	movw	r24, r0
    13f4:	11 24       	eor	r1, r1
    13f6:	80 96       	adiw	r24, 0x20	; 32
    13f8:	c5 de       	rcall	.-630    	; 0x1184 <pvPortMalloc>
    13fa:	ec 01       	movw	r28, r24
    13fc:	00 97       	sbiw	r24, 0x00	; 0
    13fe:	21 f4       	brne	.+8      	; 0x1408 <xQueueGenericCreate+0x28>
    1400:	14 c0       	rjmp	.+40     	; 0x142a <xQueueGenericCreate+0x4a>
    1402:	d9 83       	std	Y+1, r29	; 0x01
    1404:	c8 83       	st	Y, r28
    1406:	05 c0       	rjmp	.+10     	; 0x1412 <xQueueGenericCreate+0x32>
    1408:	9c 01       	movw	r18, r24
    140a:	21 5e       	subi	r18, 0xE1	; 225
    140c:	3f 4f       	sbci	r19, 0xFF	; 255
    140e:	39 83       	std	Y+1, r19	; 0x01
    1410:	28 83       	st	Y, r18
    1412:	0b 8f       	std	Y+27, r16	; 0x1b
    1414:	1c 8f       	std	Y+28, r17	; 0x1c
    1416:	61 e0       	ldi	r22, 0x01	; 1
    1418:	ce 01       	movw	r24, r28
    141a:	a9 df       	rcall	.-174    	; 0x136e <xQueueGenericReset>
    141c:	06 c0       	rjmp	.+12     	; 0x142a <xQueueGenericCreate+0x4a>
    141e:	8f e1       	ldi	r24, 0x1F	; 31
    1420:	90 e0       	ldi	r25, 0x00	; 0
    1422:	b0 de       	rcall	.-672    	; 0x1184 <pvPortMalloc>
    1424:	ec 01       	movw	r28, r24
    1426:	00 97       	sbiw	r24, 0x00	; 0
    1428:	61 f7       	brne	.-40     	; 0x1402 <xQueueGenericCreate+0x22>
    142a:	ce 01       	movw	r24, r28
    142c:	df 91       	pop	r29
    142e:	cf 91       	pop	r28
    1430:	1f 91       	pop	r17
    1432:	0f 91       	pop	r16
    1434:	08 95       	ret

00001436 <xQueueGenericSend>:
    1436:	9f 92       	push	r9
    1438:	af 92       	push	r10
    143a:	bf 92       	push	r11
    143c:	cf 92       	push	r12
    143e:	df 92       	push	r13
    1440:	ef 92       	push	r14
    1442:	ff 92       	push	r15
    1444:	0f 93       	push	r16
    1446:	1f 93       	push	r17
    1448:	cf 93       	push	r28
    144a:	df 93       	push	r29
    144c:	00 d0       	rcall	.+0      	; 0x144e <xQueueGenericSend+0x18>
    144e:	1f 92       	push	r1
    1450:	1f 92       	push	r1
    1452:	cd b7       	in	r28, 0x3d	; 61
    1454:	de b7       	in	r29, 0x3e	; 62
    1456:	8c 01       	movw	r16, r24
    1458:	6b 01       	movw	r12, r22
    145a:	5d 83       	std	Y+5, r21	; 0x05
    145c:	4c 83       	std	Y+4, r20	; 0x04
    145e:	a2 2e       	mov	r10, r18
    1460:	b1 2c       	mov	r11, r1
    1462:	99 24       	eor	r9, r9
    1464:	93 94       	inc	r9
    1466:	7c 01       	movw	r14, r24
    1468:	88 e0       	ldi	r24, 0x08	; 8
    146a:	e8 0e       	add	r14, r24
    146c:	f1 1c       	adc	r15, r1
    146e:	0f b6       	in	r0, 0x3f	; 63
    1470:	f8 94       	cli
    1472:	0f 92       	push	r0
    1474:	f8 01       	movw	r30, r16
    1476:	92 8d       	ldd	r25, Z+26	; 0x1a
    1478:	83 8d       	ldd	r24, Z+27	; 0x1b
    147a:	98 17       	cp	r25, r24
    147c:	18 f0       	brcs	.+6      	; 0x1484 <xQueueGenericSend+0x4e>
    147e:	f2 e0       	ldi	r31, 0x02	; 2
    1480:	af 12       	cpse	r10, r31
    1482:	15 c0       	rjmp	.+42     	; 0x14ae <xQueueGenericSend+0x78>
    1484:	4a 2d       	mov	r20, r10
    1486:	b6 01       	movw	r22, r12
    1488:	c8 01       	movw	r24, r16
    148a:	b0 de       	rcall	.-672    	; 0x11ec <prvCopyDataToQueue>
    148c:	f8 01       	movw	r30, r16
    148e:	91 89       	ldd	r25, Z+17	; 0x11
    1490:	99 23       	and	r25, r25
    1492:	39 f0       	breq	.+14     	; 0x14a2 <xQueueGenericSend+0x6c>
    1494:	c8 01       	movw	r24, r16
    1496:	41 96       	adiw	r24, 0x11	; 17
    1498:	5c d5       	rcall	.+2744   	; 0x1f52 <xTaskRemoveFromEventList>
    149a:	81 30       	cpi	r24, 0x01	; 1
    149c:	21 f4       	brne	.+8      	; 0x14a6 <xQueueGenericSend+0x70>
    149e:	9b dd       	rcall	.-1226   	; 0xfd6 <vPortYield>
    14a0:	02 c0       	rjmp	.+4      	; 0x14a6 <xQueueGenericSend+0x70>
    14a2:	81 11       	cpse	r24, r1
    14a4:	98 dd       	rcall	.-1232   	; 0xfd6 <vPortYield>
    14a6:	0f 90       	pop	r0
    14a8:	0f be       	out	0x3f, r0	; 63
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	46 c0       	rjmp	.+140    	; 0x153a <xQueueGenericSend+0x104>
    14ae:	ec 81       	ldd	r30, Y+4	; 0x04
    14b0:	fd 81       	ldd	r31, Y+5	; 0x05
    14b2:	ef 2b       	or	r30, r31
    14b4:	21 f4       	brne	.+8      	; 0x14be <xQueueGenericSend+0x88>
    14b6:	0f 90       	pop	r0
    14b8:	0f be       	out	0x3f, r0	; 63
    14ba:	80 e0       	ldi	r24, 0x00	; 0
    14bc:	3e c0       	rjmp	.+124    	; 0x153a <xQueueGenericSend+0x104>
    14be:	b1 10       	cpse	r11, r1
    14c0:	04 c0       	rjmp	.+8      	; 0x14ca <xQueueGenericSend+0x94>
    14c2:	ce 01       	movw	r24, r28
    14c4:	01 96       	adiw	r24, 0x01	; 1
    14c6:	8d d5       	rcall	.+2842   	; 0x1fe2 <vTaskSetTimeOutState>
    14c8:	b9 2c       	mov	r11, r9
    14ca:	0f 90       	pop	r0
    14cc:	0f be       	out	0x3f, r0	; 63
    14ce:	2d d3       	rcall	.+1626   	; 0x1b2a <vTaskSuspendAll>
    14d0:	0f b6       	in	r0, 0x3f	; 63
    14d2:	f8 94       	cli
    14d4:	0f 92       	push	r0
    14d6:	f8 01       	movw	r30, r16
    14d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    14da:	8f 3f       	cpi	r24, 0xFF	; 255
    14dc:	09 f4       	brne	.+2      	; 0x14e0 <xQueueGenericSend+0xaa>
    14de:	15 8e       	std	Z+29, r1	; 0x1d
    14e0:	f8 01       	movw	r30, r16
    14e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    14e4:	8f 3f       	cpi	r24, 0xFF	; 255
    14e6:	09 f4       	brne	.+2      	; 0x14ea <xQueueGenericSend+0xb4>
    14e8:	16 8e       	std	Z+30, r1	; 0x1e
    14ea:	0f 90       	pop	r0
    14ec:	0f be       	out	0x3f, r0	; 63
    14ee:	be 01       	movw	r22, r28
    14f0:	6c 5f       	subi	r22, 0xFC	; 252
    14f2:	7f 4f       	sbci	r23, 0xFF	; 255
    14f4:	ce 01       	movw	r24, r28
    14f6:	01 96       	adiw	r24, 0x01	; 1
    14f8:	7f d5       	rcall	.+2814   	; 0x1ff8 <xTaskCheckForTimeOut>
    14fa:	81 11       	cpse	r24, r1
    14fc:	1a c0       	rjmp	.+52     	; 0x1532 <xQueueGenericSend+0xfc>
    14fe:	0f b6       	in	r0, 0x3f	; 63
    1500:	f8 94       	cli
    1502:	0f 92       	push	r0
    1504:	f8 01       	movw	r30, r16
    1506:	92 8d       	ldd	r25, Z+26	; 0x1a
    1508:	0f 90       	pop	r0
    150a:	0f be       	out	0x3f, r0	; 63
    150c:	f8 01       	movw	r30, r16
    150e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1510:	98 13       	cpse	r25, r24
    1512:	0b c0       	rjmp	.+22     	; 0x152a <xQueueGenericSend+0xf4>
    1514:	6c 81       	ldd	r22, Y+4	; 0x04
    1516:	7d 81       	ldd	r23, Y+5	; 0x05
    1518:	c7 01       	movw	r24, r14
    151a:	e3 d4       	rcall	.+2502   	; 0x1ee2 <vTaskPlaceOnEventList>
    151c:	c8 01       	movw	r24, r16
    151e:	e1 de       	rcall	.-574    	; 0x12e2 <prvUnlockQueue>
    1520:	cf d3       	rcall	.+1950   	; 0x1cc0 <xTaskResumeAll>
    1522:	81 11       	cpse	r24, r1
    1524:	a4 cf       	rjmp	.-184    	; 0x146e <xQueueGenericSend+0x38>
    1526:	57 dd       	rcall	.-1362   	; 0xfd6 <vPortYield>
    1528:	a2 cf       	rjmp	.-188    	; 0x146e <xQueueGenericSend+0x38>
    152a:	c8 01       	movw	r24, r16
    152c:	da de       	rcall	.-588    	; 0x12e2 <prvUnlockQueue>
    152e:	c8 d3       	rcall	.+1936   	; 0x1cc0 <xTaskResumeAll>
    1530:	9e cf       	rjmp	.-196    	; 0x146e <xQueueGenericSend+0x38>
    1532:	c8 01       	movw	r24, r16
    1534:	d6 de       	rcall	.-596    	; 0x12e2 <prvUnlockQueue>
    1536:	c4 d3       	rcall	.+1928   	; 0x1cc0 <xTaskResumeAll>
    1538:	80 e0       	ldi	r24, 0x00	; 0
    153a:	0f 90       	pop	r0
    153c:	0f 90       	pop	r0
    153e:	0f 90       	pop	r0
    1540:	0f 90       	pop	r0
    1542:	0f 90       	pop	r0
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	1f 91       	pop	r17
    154a:	0f 91       	pop	r16
    154c:	ff 90       	pop	r15
    154e:	ef 90       	pop	r14
    1550:	df 90       	pop	r13
    1552:	cf 90       	pop	r12
    1554:	bf 90       	pop	r11
    1556:	af 90       	pop	r10
    1558:	9f 90       	pop	r9
    155a:	08 95       	ret

0000155c <xQueueGenericSendFromISR>:
    155c:	0f 93       	push	r16
    155e:	1f 93       	push	r17
    1560:	cf 93       	push	r28
    1562:	df 93       	push	r29
    1564:	ec 01       	movw	r28, r24
    1566:	8a 01       	movw	r16, r20
    1568:	9a 8d       	ldd	r25, Y+26	; 0x1a
    156a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    156c:	98 17       	cp	r25, r24
    156e:	10 f0       	brcs	.+4      	; 0x1574 <xQueueGenericSendFromISR+0x18>
    1570:	22 30       	cpi	r18, 0x02	; 2
    1572:	d1 f4       	brne	.+52     	; 0x15a8 <xQueueGenericSendFromISR+0x4c>
    1574:	42 2f       	mov	r20, r18
    1576:	ce 01       	movw	r24, r28
    1578:	39 de       	rcall	.-910    	; 0x11ec <prvCopyDataToQueue>
    157a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    157c:	8f 3f       	cpi	r24, 0xFF	; 255
    157e:	79 f4       	brne	.+30     	; 0x159e <xQueueGenericSendFromISR+0x42>
    1580:	89 89       	ldd	r24, Y+17	; 0x11
    1582:	88 23       	and	r24, r24
    1584:	99 f0       	breq	.+38     	; 0x15ac <xQueueGenericSendFromISR+0x50>
    1586:	ce 01       	movw	r24, r28
    1588:	41 96       	adiw	r24, 0x11	; 17
    158a:	e3 d4       	rcall	.+2502   	; 0x1f52 <xTaskRemoveFromEventList>
    158c:	88 23       	and	r24, r24
    158e:	81 f0       	breq	.+32     	; 0x15b0 <xQueueGenericSendFromISR+0x54>
    1590:	01 15       	cp	r16, r1
    1592:	11 05       	cpc	r17, r1
    1594:	79 f0       	breq	.+30     	; 0x15b4 <xQueueGenericSendFromISR+0x58>
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	f8 01       	movw	r30, r16
    159a:	80 83       	st	Z, r24
    159c:	0c c0       	rjmp	.+24     	; 0x15b6 <xQueueGenericSendFromISR+0x5a>
    159e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15a0:	8f 5f       	subi	r24, 0xFF	; 255
    15a2:	8e 8f       	std	Y+30, r24	; 0x1e
    15a4:	81 e0       	ldi	r24, 0x01	; 1
    15a6:	07 c0       	rjmp	.+14     	; 0x15b6 <xQueueGenericSendFromISR+0x5a>
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	05 c0       	rjmp	.+10     	; 0x15b6 <xQueueGenericSendFromISR+0x5a>
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	03 c0       	rjmp	.+6      	; 0x15b6 <xQueueGenericSendFromISR+0x5a>
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	01 c0       	rjmp	.+2      	; 0x15b6 <xQueueGenericSendFromISR+0x5a>
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	08 95       	ret

000015c0 <xQueueGiveFromISR>:
    15c0:	cf 93       	push	r28
    15c2:	df 93       	push	r29
    15c4:	fc 01       	movw	r30, r24
    15c6:	eb 01       	movw	r28, r22
    15c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    15ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    15cc:	98 17       	cp	r25, r24
    15ce:	c0 f4       	brcc	.+48     	; 0x1600 <xQueueGiveFromISR+0x40>
    15d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    15d2:	8f 5f       	subi	r24, 0xFF	; 255
    15d4:	82 8f       	std	Z+26, r24	; 0x1a
    15d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    15d8:	8f 3f       	cpi	r24, 0xFF	; 255
    15da:	69 f4       	brne	.+26     	; 0x15f6 <xQueueGiveFromISR+0x36>
    15dc:	81 89       	ldd	r24, Z+17	; 0x11
    15de:	88 23       	and	r24, r24
    15e0:	89 f0       	breq	.+34     	; 0x1604 <xQueueGiveFromISR+0x44>
    15e2:	cf 01       	movw	r24, r30
    15e4:	41 96       	adiw	r24, 0x11	; 17
    15e6:	b5 d4       	rcall	.+2410   	; 0x1f52 <xTaskRemoveFromEventList>
    15e8:	88 23       	and	r24, r24
    15ea:	71 f0       	breq	.+28     	; 0x1608 <xQueueGiveFromISR+0x48>
    15ec:	20 97       	sbiw	r28, 0x00	; 0
    15ee:	71 f0       	breq	.+28     	; 0x160c <xQueueGiveFromISR+0x4c>
    15f0:	81 e0       	ldi	r24, 0x01	; 1
    15f2:	88 83       	st	Y, r24
    15f4:	0c c0       	rjmp	.+24     	; 0x160e <xQueueGiveFromISR+0x4e>
    15f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    15f8:	8f 5f       	subi	r24, 0xFF	; 255
    15fa:	86 8f       	std	Z+30, r24	; 0x1e
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	07 c0       	rjmp	.+14     	; 0x160e <xQueueGiveFromISR+0x4e>
    1600:	80 e0       	ldi	r24, 0x00	; 0
    1602:	05 c0       	rjmp	.+10     	; 0x160e <xQueueGiveFromISR+0x4e>
    1604:	81 e0       	ldi	r24, 0x01	; 1
    1606:	03 c0       	rjmp	.+6      	; 0x160e <xQueueGiveFromISR+0x4e>
    1608:	81 e0       	ldi	r24, 0x01	; 1
    160a:	01 c0       	rjmp	.+2      	; 0x160e <xQueueGiveFromISR+0x4e>
    160c:	81 e0       	ldi	r24, 0x01	; 1
    160e:	df 91       	pop	r29
    1610:	cf 91       	pop	r28
    1612:	08 95       	ret

00001614 <xQueueGenericReceive>:
    1614:	9f 92       	push	r9
    1616:	af 92       	push	r10
    1618:	bf 92       	push	r11
    161a:	cf 92       	push	r12
    161c:	df 92       	push	r13
    161e:	ef 92       	push	r14
    1620:	ff 92       	push	r15
    1622:	0f 93       	push	r16
    1624:	1f 93       	push	r17
    1626:	cf 93       	push	r28
    1628:	df 93       	push	r29
    162a:	00 d0       	rcall	.+0      	; 0x162c <xQueueGenericReceive+0x18>
    162c:	1f 92       	push	r1
    162e:	1f 92       	push	r1
    1630:	cd b7       	in	r28, 0x3d	; 61
    1632:	de b7       	in	r29, 0x3e	; 62
    1634:	8c 01       	movw	r16, r24
    1636:	6b 01       	movw	r12, r22
    1638:	5d 83       	std	Y+5, r21	; 0x05
    163a:	4c 83       	std	Y+4, r20	; 0x04
    163c:	b2 2e       	mov	r11, r18
    163e:	a1 2c       	mov	r10, r1
    1640:	99 24       	eor	r9, r9
    1642:	93 94       	inc	r9
    1644:	7c 01       	movw	r14, r24
    1646:	81 e1       	ldi	r24, 0x11	; 17
    1648:	e8 0e       	add	r14, r24
    164a:	f1 1c       	adc	r15, r1
    164c:	0f b6       	in	r0, 0x3f	; 63
    164e:	f8 94       	cli
    1650:	0f 92       	push	r0
    1652:	f8 01       	movw	r30, r16
    1654:	82 8d       	ldd	r24, Z+26	; 0x1a
    1656:	88 23       	and	r24, r24
    1658:	69 f1       	breq	.+90     	; 0x16b4 <xQueueGenericReceive+0xa0>
    165a:	e6 80       	ldd	r14, Z+6	; 0x06
    165c:	f7 80       	ldd	r15, Z+7	; 0x07
    165e:	b6 01       	movw	r22, r12
    1660:	c8 01       	movw	r24, r16
    1662:	25 de       	rcall	.-950    	; 0x12ae <prvCopyDataFromQueue>
    1664:	b1 10       	cpse	r11, r1
    1666:	17 c0       	rjmp	.+46     	; 0x1696 <xQueueGenericReceive+0x82>
    1668:	f8 01       	movw	r30, r16
    166a:	82 8d       	ldd	r24, Z+26	; 0x1a
    166c:	81 50       	subi	r24, 0x01	; 1
    166e:	82 8f       	std	Z+26, r24	; 0x1a
    1670:	80 81       	ld	r24, Z
    1672:	91 81       	ldd	r25, Z+1	; 0x01
    1674:	89 2b       	or	r24, r25
    1676:	21 f4       	brne	.+8      	; 0x1680 <xQueueGenericReceive+0x6c>
    1678:	a0 d5       	rcall	.+2880   	; 0x21ba <pvTaskIncrementMutexHeldCount>
    167a:	f8 01       	movw	r30, r16
    167c:	93 83       	std	Z+3, r25	; 0x03
    167e:	82 83       	std	Z+2, r24	; 0x02
    1680:	f8 01       	movw	r30, r16
    1682:	80 85       	ldd	r24, Z+8	; 0x08
    1684:	88 23       	and	r24, r24
    1686:	91 f0       	breq	.+36     	; 0x16ac <xQueueGenericReceive+0x98>
    1688:	c8 01       	movw	r24, r16
    168a:	08 96       	adiw	r24, 0x08	; 8
    168c:	62 d4       	rcall	.+2244   	; 0x1f52 <xTaskRemoveFromEventList>
    168e:	81 30       	cpi	r24, 0x01	; 1
    1690:	69 f4       	brne	.+26     	; 0x16ac <xQueueGenericReceive+0x98>
    1692:	a1 dc       	rcall	.-1726   	; 0xfd6 <vPortYield>
    1694:	0b c0       	rjmp	.+22     	; 0x16ac <xQueueGenericReceive+0x98>
    1696:	f8 01       	movw	r30, r16
    1698:	f7 82       	std	Z+7, r15	; 0x07
    169a:	e6 82       	std	Z+6, r14	; 0x06
    169c:	81 89       	ldd	r24, Z+17	; 0x11
    169e:	88 23       	and	r24, r24
    16a0:	29 f0       	breq	.+10     	; 0x16ac <xQueueGenericReceive+0x98>
    16a2:	c8 01       	movw	r24, r16
    16a4:	41 96       	adiw	r24, 0x11	; 17
    16a6:	55 d4       	rcall	.+2218   	; 0x1f52 <xTaskRemoveFromEventList>
    16a8:	81 11       	cpse	r24, r1
    16aa:	95 dc       	rcall	.-1750   	; 0xfd6 <vPortYield>
    16ac:	0f 90       	pop	r0
    16ae:	0f be       	out	0x3f, r0	; 63
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	52 c0       	rjmp	.+164    	; 0x1758 <xQueueGenericReceive+0x144>
    16b4:	4c 81       	ldd	r20, Y+4	; 0x04
    16b6:	5d 81       	ldd	r21, Y+5	; 0x05
    16b8:	45 2b       	or	r20, r21
    16ba:	21 f4       	brne	.+8      	; 0x16c4 <xQueueGenericReceive+0xb0>
    16bc:	0f 90       	pop	r0
    16be:	0f be       	out	0x3f, r0	; 63
    16c0:	80 e0       	ldi	r24, 0x00	; 0
    16c2:	4a c0       	rjmp	.+148    	; 0x1758 <xQueueGenericReceive+0x144>
    16c4:	a1 10       	cpse	r10, r1
    16c6:	04 c0       	rjmp	.+8      	; 0x16d0 <xQueueGenericReceive+0xbc>
    16c8:	ce 01       	movw	r24, r28
    16ca:	01 96       	adiw	r24, 0x01	; 1
    16cc:	8a d4       	rcall	.+2324   	; 0x1fe2 <vTaskSetTimeOutState>
    16ce:	a9 2c       	mov	r10, r9
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	2a d2       	rcall	.+1108   	; 0x1b2a <vTaskSuspendAll>
    16d6:	0f b6       	in	r0, 0x3f	; 63
    16d8:	f8 94       	cli
    16da:	0f 92       	push	r0
    16dc:	f8 01       	movw	r30, r16
    16de:	85 8d       	ldd	r24, Z+29	; 0x1d
    16e0:	8f 3f       	cpi	r24, 0xFF	; 255
    16e2:	09 f4       	brne	.+2      	; 0x16e6 <xQueueGenericReceive+0xd2>
    16e4:	15 8e       	std	Z+29, r1	; 0x1d
    16e6:	f8 01       	movw	r30, r16
    16e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    16ea:	8f 3f       	cpi	r24, 0xFF	; 255
    16ec:	09 f4       	brne	.+2      	; 0x16f0 <xQueueGenericReceive+0xdc>
    16ee:	16 8e       	std	Z+30, r1	; 0x1e
    16f0:	0f 90       	pop	r0
    16f2:	0f be       	out	0x3f, r0	; 63
    16f4:	be 01       	movw	r22, r28
    16f6:	6c 5f       	subi	r22, 0xFC	; 252
    16f8:	7f 4f       	sbci	r23, 0xFF	; 255
    16fa:	ce 01       	movw	r24, r28
    16fc:	01 96       	adiw	r24, 0x01	; 1
    16fe:	7c d4       	rcall	.+2296   	; 0x1ff8 <xTaskCheckForTimeOut>
    1700:	81 11       	cpse	r24, r1
    1702:	26 c0       	rjmp	.+76     	; 0x1750 <xQueueGenericReceive+0x13c>
    1704:	0f b6       	in	r0, 0x3f	; 63
    1706:	f8 94       	cli
    1708:	0f 92       	push	r0
    170a:	f8 01       	movw	r30, r16
    170c:	82 8d       	ldd	r24, Z+26	; 0x1a
    170e:	0f 90       	pop	r0
    1710:	0f be       	out	0x3f, r0	; 63
    1712:	81 11       	cpse	r24, r1
    1714:	19 c0       	rjmp	.+50     	; 0x1748 <xQueueGenericReceive+0x134>
    1716:	f8 01       	movw	r30, r16
    1718:	80 81       	ld	r24, Z
    171a:	91 81       	ldd	r25, Z+1	; 0x01
    171c:	89 2b       	or	r24, r25
    171e:	49 f4       	brne	.+18     	; 0x1732 <xQueueGenericReceive+0x11e>
    1720:	0f b6       	in	r0, 0x3f	; 63
    1722:	f8 94       	cli
    1724:	0f 92       	push	r0
    1726:	f8 01       	movw	r30, r16
    1728:	82 81       	ldd	r24, Z+2	; 0x02
    172a:	93 81       	ldd	r25, Z+3	; 0x03
    172c:	a9 d4       	rcall	.+2386   	; 0x2080 <vTaskPriorityInherit>
    172e:	0f 90       	pop	r0
    1730:	0f be       	out	0x3f, r0	; 63
    1732:	6c 81       	ldd	r22, Y+4	; 0x04
    1734:	7d 81       	ldd	r23, Y+5	; 0x05
    1736:	c7 01       	movw	r24, r14
    1738:	d4 d3       	rcall	.+1960   	; 0x1ee2 <vTaskPlaceOnEventList>
    173a:	c8 01       	movw	r24, r16
    173c:	d2 dd       	rcall	.-1116   	; 0x12e2 <prvUnlockQueue>
    173e:	c0 d2       	rcall	.+1408   	; 0x1cc0 <xTaskResumeAll>
    1740:	81 11       	cpse	r24, r1
    1742:	84 cf       	rjmp	.-248    	; 0x164c <xQueueGenericReceive+0x38>
    1744:	48 dc       	rcall	.-1904   	; 0xfd6 <vPortYield>
    1746:	82 cf       	rjmp	.-252    	; 0x164c <xQueueGenericReceive+0x38>
    1748:	c8 01       	movw	r24, r16
    174a:	cb dd       	rcall	.-1130   	; 0x12e2 <prvUnlockQueue>
    174c:	b9 d2       	rcall	.+1394   	; 0x1cc0 <xTaskResumeAll>
    174e:	7e cf       	rjmp	.-260    	; 0x164c <xQueueGenericReceive+0x38>
    1750:	c8 01       	movw	r24, r16
    1752:	c7 dd       	rcall	.-1138   	; 0x12e2 <prvUnlockQueue>
    1754:	b5 d2       	rcall	.+1386   	; 0x1cc0 <xTaskResumeAll>
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	0f 90       	pop	r0
    175a:	0f 90       	pop	r0
    175c:	0f 90       	pop	r0
    175e:	0f 90       	pop	r0
    1760:	0f 90       	pop	r0
    1762:	df 91       	pop	r29
    1764:	cf 91       	pop	r28
    1766:	1f 91       	pop	r17
    1768:	0f 91       	pop	r16
    176a:	ff 90       	pop	r15
    176c:	ef 90       	pop	r14
    176e:	df 90       	pop	r13
    1770:	cf 90       	pop	r12
    1772:	bf 90       	pop	r11
    1774:	af 90       	pop	r10
    1776:	9f 90       	pop	r9
    1778:	08 95       	ret

0000177a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
    177a:	cf 93       	push	r28
    177c:	df 93       	push	r29
    177e:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1780:	0f b6       	in	r0, 0x3f	; 63
    1782:	f8 94       	cli
    1784:	0f 92       	push	r0
    1786:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1788:	8f 3f       	cpi	r24, 0xFF	; 255
    178a:	09 f4       	brne	.+2      	; 0x178e <vQueueWaitForMessageRestricted+0x14>
    178c:	1d 8e       	std	Y+29, r1	; 0x1d
    178e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1790:	8f 3f       	cpi	r24, 0xFF	; 255
    1792:	09 f4       	brne	.+2      	; 0x1796 <vQueueWaitForMessageRestricted+0x1c>
    1794:	1e 8e       	std	Y+30, r1	; 0x1e
    1796:	0f 90       	pop	r0
    1798:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    179a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    179c:	81 11       	cpse	r24, r1
    179e:	03 c0       	rjmp	.+6      	; 0x17a6 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17a0:	ce 01       	movw	r24, r28
    17a2:	41 96       	adiw	r24, 0x11	; 17
    17a4:	ba d3       	rcall	.+1908   	; 0x1f1a <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    17a6:	ce 01       	movw	r24, r28
    17a8:	9c dd       	rcall	.-1224   	; 0x12e2 <prvUnlockQueue>
	}
    17aa:	df 91       	pop	r29
    17ac:	cf 91       	pop	r28
    17ae:	08 95       	ret

000017b0 <prvResetNextTaskUnblockTime>:
    17b0:	e0 91 c3 0d 	lds	r30, 0x0DC3
    17b4:	f0 91 c4 0d 	lds	r31, 0x0DC4
    17b8:	80 81       	ld	r24, Z
    17ba:	81 11       	cpse	r24, r1
    17bc:	07 c0       	rjmp	.+14     	; 0x17cc <prvResetNextTaskUnblockTime+0x1c>
    17be:	8f ef       	ldi	r24, 0xFF	; 255
    17c0:	9f ef       	ldi	r25, 0xFF	; 255
    17c2:	90 93 4a 02 	sts	0x024A, r25
    17c6:	80 93 49 02 	sts	0x0249, r24
    17ca:	08 95       	ret
    17cc:	e0 91 c3 0d 	lds	r30, 0x0DC3
    17d0:	f0 91 c4 0d 	lds	r31, 0x0DC4
    17d4:	05 80       	ldd	r0, Z+5	; 0x05
    17d6:	f6 81       	ldd	r31, Z+6	; 0x06
    17d8:	e0 2d       	mov	r30, r0
    17da:	06 80       	ldd	r0, Z+6	; 0x06
    17dc:	f7 81       	ldd	r31, Z+7	; 0x07
    17de:	e0 2d       	mov	r30, r0
    17e0:	82 81       	ldd	r24, Z+2	; 0x02
    17e2:	93 81       	ldd	r25, Z+3	; 0x03
    17e4:	90 93 4a 02 	sts	0x024A, r25
    17e8:	80 93 49 02 	sts	0x0249, r24
    17ec:	08 95       	ret

000017ee <prvAddCurrentTaskToDelayedList>:
    17ee:	cf 93       	push	r28
    17f0:	df 93       	push	r29
    17f2:	ec 01       	movw	r28, r24
    17f4:	e0 91 fb 0d 	lds	r30, 0x0DFB
    17f8:	f0 91 fc 0d 	lds	r31, 0x0DFC
    17fc:	93 83       	std	Z+3, r25	; 0x03
    17fe:	82 83       	std	Z+2, r24	; 0x02
    1800:	80 91 ab 0d 	lds	r24, 0x0DAB
    1804:	90 91 ac 0d 	lds	r25, 0x0DAC
    1808:	c8 17       	cp	r28, r24
    180a:	d9 07       	cpc	r29, r25
    180c:	60 f4       	brcc	.+24     	; 0x1826 <prvAddCurrentTaskToDelayedList+0x38>
    180e:	60 91 fb 0d 	lds	r22, 0x0DFB
    1812:	70 91 fc 0d 	lds	r23, 0x0DFC
    1816:	80 91 c1 0d 	lds	r24, 0x0DC1
    181a:	90 91 c2 0d 	lds	r25, 0x0DC2
    181e:	6e 5f       	subi	r22, 0xFE	; 254
    1820:	7f 4f       	sbci	r23, 0xFF	; 255
    1822:	ca da       	rcall	.-2668   	; 0xdb8 <vListInsert>
    1824:	16 c0       	rjmp	.+44     	; 0x1852 <prvAddCurrentTaskToDelayedList+0x64>
    1826:	60 91 fb 0d 	lds	r22, 0x0DFB
    182a:	70 91 fc 0d 	lds	r23, 0x0DFC
    182e:	80 91 c3 0d 	lds	r24, 0x0DC3
    1832:	90 91 c4 0d 	lds	r25, 0x0DC4
    1836:	6e 5f       	subi	r22, 0xFE	; 254
    1838:	7f 4f       	sbci	r23, 0xFF	; 255
    183a:	be da       	rcall	.-2692   	; 0xdb8 <vListInsert>
    183c:	80 91 49 02 	lds	r24, 0x0249
    1840:	90 91 4a 02 	lds	r25, 0x024A
    1844:	c8 17       	cp	r28, r24
    1846:	d9 07       	cpc	r29, r25
    1848:	20 f4       	brcc	.+8      	; 0x1852 <prvAddCurrentTaskToDelayedList+0x64>
    184a:	d0 93 4a 02 	sts	0x024A, r29
    184e:	c0 93 49 02 	sts	0x0249, r28
    1852:	df 91       	pop	r29
    1854:	cf 91       	pop	r28
    1856:	08 95       	ret

00001858 <xTaskGenericCreate>:
    1858:	4f 92       	push	r4
    185a:	5f 92       	push	r5
    185c:	6f 92       	push	r6
    185e:	7f 92       	push	r7
    1860:	8f 92       	push	r8
    1862:	9f 92       	push	r9
    1864:	af 92       	push	r10
    1866:	bf 92       	push	r11
    1868:	cf 92       	push	r12
    186a:	df 92       	push	r13
    186c:	ef 92       	push	r14
    186e:	ff 92       	push	r15
    1870:	0f 93       	push	r16
    1872:	1f 93       	push	r17
    1874:	cf 93       	push	r28
    1876:	df 93       	push	r29
    1878:	4c 01       	movw	r8, r24
    187a:	5b 01       	movw	r10, r22
    187c:	2a 01       	movw	r4, r20
    187e:	39 01       	movw	r6, r18
    1880:	c1 14       	cp	r12, r1
    1882:	d1 04       	cpc	r13, r1
    1884:	31 f4       	brne	.+12     	; 0x1892 <xTaskGenericCreate+0x3a>
    1886:	ca 01       	movw	r24, r20
    1888:	7d dc       	rcall	.-1798   	; 0x1184 <pvPortMalloc>
    188a:	6c 01       	movw	r12, r24
    188c:	00 97       	sbiw	r24, 0x00	; 0
    188e:	09 f4       	brne	.+2      	; 0x1892 <xTaskGenericCreate+0x3a>
    1890:	cc c0       	rjmp	.+408    	; 0x1a2a <xTaskGenericCreate+0x1d2>
    1892:	88 e2       	ldi	r24, 0x28	; 40
    1894:	90 e0       	ldi	r25, 0x00	; 0
    1896:	76 dc       	rcall	.-1812   	; 0x1184 <pvPortMalloc>
    1898:	ec 01       	movw	r28, r24
    189a:	00 97       	sbiw	r24, 0x00	; 0
    189c:	71 f0       	breq	.+28     	; 0x18ba <xTaskGenericCreate+0x62>
    189e:	d8 8e       	std	Y+24, r13	; 0x18
    18a0:	cf 8a       	std	Y+23, r12	; 0x17
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	48 1a       	sub	r4, r24
    18a6:	51 08       	sbc	r5, r1
    18a8:	c4 0c       	add	r12, r4
    18aa:	d5 1c       	adc	r13, r5
    18ac:	d5 01       	movw	r26, r10
    18ae:	8c 91       	ld	r24, X
    18b0:	89 8f       	std	Y+25, r24	; 0x19
    18b2:	8c 91       	ld	r24, X
    18b4:	81 11       	cpse	r24, r1
    18b6:	04 c0       	rjmp	.+8      	; 0x18c0 <xTaskGenericCreate+0x68>
    18b8:	14 c0       	rjmp	.+40     	; 0x18e2 <xTaskGenericCreate+0x8a>
    18ba:	c6 01       	movw	r24, r12
    18bc:	96 dc       	rcall	.-1748   	; 0x11ea <vPortFree>
    18be:	b5 c0       	rjmp	.+362    	; 0x1a2a <xTaskGenericCreate+0x1d2>
    18c0:	ae 01       	movw	r20, r28
    18c2:	46 5e       	subi	r20, 0xE6	; 230
    18c4:	5f 4f       	sbci	r21, 0xFF	; 255
    18c6:	f5 01       	movw	r30, r10
    18c8:	31 96       	adiw	r30, 0x01	; 1
    18ca:	27 e0       	ldi	r18, 0x07	; 7
    18cc:	cf 01       	movw	r24, r30
    18ce:	31 91       	ld	r19, Z+
    18d0:	da 01       	movw	r26, r20
    18d2:	3d 93       	st	X+, r19
    18d4:	ad 01       	movw	r20, r26
    18d6:	dc 01       	movw	r26, r24
    18d8:	8c 91       	ld	r24, X
    18da:	88 23       	and	r24, r24
    18dc:	11 f0       	breq	.+4      	; 0x18e2 <xTaskGenericCreate+0x8a>
    18de:	21 50       	subi	r18, 0x01	; 1
    18e0:	a9 f7       	brne	.-22     	; 0x18cc <xTaskGenericCreate+0x74>
    18e2:	18 a2       	std	Y+32, r1	; 0x20
    18e4:	10 2f       	mov	r17, r16
    18e6:	04 30       	cpi	r16, 0x04	; 4
    18e8:	08 f0       	brcs	.+2      	; 0x18ec <xTaskGenericCreate+0x94>
    18ea:	13 e0       	ldi	r17, 0x03	; 3
    18ec:	1e 8b       	std	Y+22, r17	; 0x16
    18ee:	19 a3       	std	Y+33, r17	; 0x21
    18f0:	1a a2       	std	Y+34, r1	; 0x22
    18f2:	5e 01       	movw	r10, r28
    18f4:	b2 e0       	ldi	r27, 0x02	; 2
    18f6:	ab 0e       	add	r10, r27
    18f8:	b1 1c       	adc	r11, r1
    18fa:	c5 01       	movw	r24, r10
    18fc:	38 da       	rcall	.-2960   	; 0xd6e <vListInitialiseItem>
    18fe:	ce 01       	movw	r24, r28
    1900:	0c 96       	adiw	r24, 0x0c	; 12
    1902:	35 da       	rcall	.-2966   	; 0xd6e <vListInitialiseItem>
    1904:	d9 87       	std	Y+9, r29	; 0x09
    1906:	c8 87       	std	Y+8, r28	; 0x08
    1908:	84 e0       	ldi	r24, 0x04	; 4
    190a:	90 e0       	ldi	r25, 0x00	; 0
    190c:	81 1b       	sub	r24, r17
    190e:	91 09       	sbc	r25, r1
    1910:	9d 87       	std	Y+13, r25	; 0x0d
    1912:	8c 87       	std	Y+12, r24	; 0x0c
    1914:	db 8b       	std	Y+19, r29	; 0x13
    1916:	ca 8b       	std	Y+18, r28	; 0x12
    1918:	1b a2       	std	Y+35, r1	; 0x23
    191a:	1c a2       	std	Y+36, r1	; 0x24
    191c:	1d a2       	std	Y+37, r1	; 0x25
    191e:	1e a2       	std	Y+38, r1	; 0x26
    1920:	1f a2       	std	Y+39, r1	; 0x27
    1922:	a3 01       	movw	r20, r6
    1924:	b4 01       	movw	r22, r8
    1926:	c6 01       	movw	r24, r12
    1928:	9e da       	rcall	.-2756   	; 0xe66 <pxPortInitialiseStack>
    192a:	99 83       	std	Y+1, r25	; 0x01
    192c:	88 83       	st	Y, r24
    192e:	e1 14       	cp	r14, r1
    1930:	f1 04       	cpc	r15, r1
    1932:	19 f0       	breq	.+6      	; 0x193a <xTaskGenericCreate+0xe2>
    1934:	f7 01       	movw	r30, r14
    1936:	d1 83       	std	Z+1, r29	; 0x01
    1938:	c0 83       	st	Z, r28
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	f8 94       	cli
    193e:	0f 92       	push	r0
    1940:	80 91 ad 0d 	lds	r24, 0x0DAD
    1944:	8f 5f       	subi	r24, 0xFF	; 255
    1946:	80 93 ad 0d 	sts	0x0DAD, r24
    194a:	80 91 fb 0d 	lds	r24, 0x0DFB
    194e:	90 91 fc 0d 	lds	r25, 0x0DFC
    1952:	89 2b       	or	r24, r25
    1954:	69 f5       	brne	.+90     	; 0x19b0 <xTaskGenericCreate+0x158>
    1956:	d0 93 fc 0d 	sts	0x0DFC, r29
    195a:	c0 93 fb 0d 	sts	0x0DFB, r28
    195e:	80 91 ad 0d 	lds	r24, 0x0DAD
    1962:	81 30       	cpi	r24, 0x01	; 1
    1964:	a1 f5       	brne	.+104    	; 0x19ce <xTaskGenericCreate+0x176>
    1966:	87 ed       	ldi	r24, 0xD7	; 215
    1968:	9d e0       	ldi	r25, 0x0D	; 13
    196a:	f3 d9       	rcall	.-3098   	; 0xd52 <vListInitialise>
    196c:	80 ee       	ldi	r24, 0xE0	; 224
    196e:	9d e0       	ldi	r25, 0x0D	; 13
    1970:	f0 d9       	rcall	.-3104   	; 0xd52 <vListInitialise>
    1972:	89 ee       	ldi	r24, 0xE9	; 233
    1974:	9d e0       	ldi	r25, 0x0D	; 13
    1976:	ed d9       	rcall	.-3110   	; 0xd52 <vListInitialise>
    1978:	82 ef       	ldi	r24, 0xF2	; 242
    197a:	9d e0       	ldi	r25, 0x0D	; 13
    197c:	ea d9       	rcall	.-3116   	; 0xd52 <vListInitialise>
    197e:	8e ec       	ldi	r24, 0xCE	; 206
    1980:	9d e0       	ldi	r25, 0x0D	; 13
    1982:	e7 d9       	rcall	.-3122   	; 0xd52 <vListInitialise>
    1984:	85 ec       	ldi	r24, 0xC5	; 197
    1986:	9d e0       	ldi	r25, 0x0D	; 13
    1988:	e4 d9       	rcall	.-3128   	; 0xd52 <vListInitialise>
    198a:	88 eb       	ldi	r24, 0xB8	; 184
    198c:	9d e0       	ldi	r25, 0x0D	; 13
    198e:	e1 d9       	rcall	.-3134   	; 0xd52 <vListInitialise>
    1990:	8f ea       	ldi	r24, 0xAF	; 175
    1992:	9d e0       	ldi	r25, 0x0D	; 13
    1994:	de d9       	rcall	.-3140   	; 0xd52 <vListInitialise>
    1996:	8e ec       	ldi	r24, 0xCE	; 206
    1998:	9d e0       	ldi	r25, 0x0D	; 13
    199a:	90 93 c4 0d 	sts	0x0DC4, r25
    199e:	80 93 c3 0d 	sts	0x0DC3, r24
    19a2:	85 ec       	ldi	r24, 0xC5	; 197
    19a4:	9d e0       	ldi	r25, 0x0D	; 13
    19a6:	90 93 c2 0d 	sts	0x0DC2, r25
    19aa:	80 93 c1 0d 	sts	0x0DC1, r24
    19ae:	0f c0       	rjmp	.+30     	; 0x19ce <xTaskGenericCreate+0x176>
    19b0:	80 91 a9 0d 	lds	r24, 0x0DA9
    19b4:	81 11       	cpse	r24, r1
    19b6:	0b c0       	rjmp	.+22     	; 0x19ce <xTaskGenericCreate+0x176>
    19b8:	e0 91 fb 0d 	lds	r30, 0x0DFB
    19bc:	f0 91 fc 0d 	lds	r31, 0x0DFC
    19c0:	86 89       	ldd	r24, Z+22	; 0x16
    19c2:	08 17       	cp	r16, r24
    19c4:	20 f0       	brcs	.+8      	; 0x19ce <xTaskGenericCreate+0x176>
    19c6:	d0 93 fc 0d 	sts	0x0DFC, r29
    19ca:	c0 93 fb 0d 	sts	0x0DFB, r28
    19ce:	80 91 a5 0d 	lds	r24, 0x0DA5
    19d2:	8f 5f       	subi	r24, 0xFF	; 255
    19d4:	80 93 a5 0d 	sts	0x0DA5, r24
    19d8:	8e 89       	ldd	r24, Y+22	; 0x16
    19da:	90 91 aa 0d 	lds	r25, 0x0DAA
    19de:	98 17       	cp	r25, r24
    19e0:	10 f4       	brcc	.+4      	; 0x19e6 <xTaskGenericCreate+0x18e>
    19e2:	80 93 aa 0d 	sts	0x0DAA, r24
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	9c 01       	movw	r18, r24
    19ea:	22 0f       	add	r18, r18
    19ec:	33 1f       	adc	r19, r19
    19ee:	22 0f       	add	r18, r18
    19f0:	33 1f       	adc	r19, r19
    19f2:	22 0f       	add	r18, r18
    19f4:	33 1f       	adc	r19, r19
    19f6:	82 0f       	add	r24, r18
    19f8:	93 1f       	adc	r25, r19
    19fa:	b5 01       	movw	r22, r10
    19fc:	89 52       	subi	r24, 0x29	; 41
    19fe:	92 4f       	sbci	r25, 0xF2	; 242
    1a00:	ba d9       	rcall	.-3212   	; 0xd76 <vListInsertEnd>
    1a02:	0f 90       	pop	r0
    1a04:	0f be       	out	0x3f, r0	; 63
    1a06:	80 91 a9 0d 	lds	r24, 0x0DA9
    1a0a:	88 23       	and	r24, r24
    1a0c:	51 f0       	breq	.+20     	; 0x1a22 <xTaskGenericCreate+0x1ca>
    1a0e:	e0 91 fb 0d 	lds	r30, 0x0DFB
    1a12:	f0 91 fc 0d 	lds	r31, 0x0DFC
    1a16:	86 89       	ldd	r24, Z+22	; 0x16
    1a18:	80 17       	cp	r24, r16
    1a1a:	28 f4       	brcc	.+10     	; 0x1a26 <xTaskGenericCreate+0x1ce>
    1a1c:	dc da       	rcall	.-2632   	; 0xfd6 <vPortYield>
    1a1e:	81 e0       	ldi	r24, 0x01	; 1
    1a20:	05 c0       	rjmp	.+10     	; 0x1a2c <xTaskGenericCreate+0x1d4>
    1a22:	81 e0       	ldi	r24, 0x01	; 1
    1a24:	03 c0       	rjmp	.+6      	; 0x1a2c <xTaskGenericCreate+0x1d4>
    1a26:	81 e0       	ldi	r24, 0x01	; 1
    1a28:	01 c0       	rjmp	.+2      	; 0x1a2c <xTaskGenericCreate+0x1d4>
    1a2a:	8f ef       	ldi	r24, 0xFF	; 255
    1a2c:	df 91       	pop	r29
    1a2e:	cf 91       	pop	r28
    1a30:	1f 91       	pop	r17
    1a32:	0f 91       	pop	r16
    1a34:	ff 90       	pop	r15
    1a36:	ef 90       	pop	r14
    1a38:	df 90       	pop	r13
    1a3a:	cf 90       	pop	r12
    1a3c:	bf 90       	pop	r11
    1a3e:	af 90       	pop	r10
    1a40:	9f 90       	pop	r9
    1a42:	8f 90       	pop	r8
    1a44:	7f 90       	pop	r7
    1a46:	6f 90       	pop	r6
    1a48:	5f 90       	pop	r5
    1a4a:	4f 90       	pop	r4
    1a4c:	08 95       	ret

00001a4e <vTaskDelete>:
    1a4e:	0f 93       	push	r16
    1a50:	1f 93       	push	r17
    1a52:	cf 93       	push	r28
    1a54:	df 93       	push	r29
    1a56:	ec 01       	movw	r28, r24
    1a58:	0f b6       	in	r0, 0x3f	; 63
    1a5a:	f8 94       	cli
    1a5c:	0f 92       	push	r0
    1a5e:	00 97       	sbiw	r24, 0x00	; 0
    1a60:	21 f4       	brne	.+8      	; 0x1a6a <vTaskDelete+0x1c>
    1a62:	c0 91 fb 0d 	lds	r28, 0x0DFB
    1a66:	d0 91 fc 0d 	lds	r29, 0x0DFC
    1a6a:	8e 01       	movw	r16, r28
    1a6c:	0e 5f       	subi	r16, 0xFE	; 254
    1a6e:	1f 4f       	sbci	r17, 0xFF	; 255
    1a70:	c8 01       	movw	r24, r16
    1a72:	d3 d9       	rcall	.-3162   	; 0xe1a <uxListRemove>
    1a74:	8c 89       	ldd	r24, Y+20	; 0x14
    1a76:	9d 89       	ldd	r25, Y+21	; 0x15
    1a78:	89 2b       	or	r24, r25
    1a7a:	19 f0       	breq	.+6      	; 0x1a82 <vTaskDelete+0x34>
    1a7c:	ce 01       	movw	r24, r28
    1a7e:	0c 96       	adiw	r24, 0x0c	; 12
    1a80:	cc d9       	rcall	.-3176   	; 0xe1a <uxListRemove>
    1a82:	b8 01       	movw	r22, r16
    1a84:	8f ea       	ldi	r24, 0xAF	; 175
    1a86:	9d e0       	ldi	r25, 0x0D	; 13
    1a88:	76 d9       	rcall	.-3348   	; 0xd76 <vListInsertEnd>
    1a8a:	80 91 ae 0d 	lds	r24, 0x0DAE
    1a8e:	8f 5f       	subi	r24, 0xFF	; 255
    1a90:	80 93 ae 0d 	sts	0x0DAE, r24
    1a94:	80 91 a5 0d 	lds	r24, 0x0DA5
    1a98:	8f 5f       	subi	r24, 0xFF	; 255
    1a9a:	80 93 a5 0d 	sts	0x0DA5, r24
    1a9e:	0f 90       	pop	r0
    1aa0:	0f be       	out	0x3f, r0	; 63
    1aa2:	80 91 a9 0d 	lds	r24, 0x0DA9
    1aa6:	88 23       	and	r24, r24
    1aa8:	79 f0       	breq	.+30     	; 0x1ac8 <vTaskDelete+0x7a>
    1aaa:	80 91 fb 0d 	lds	r24, 0x0DFB
    1aae:	90 91 fc 0d 	lds	r25, 0x0DFC
    1ab2:	c8 17       	cp	r28, r24
    1ab4:	d9 07       	cpc	r29, r25
    1ab6:	11 f4       	brne	.+4      	; 0x1abc <vTaskDelete+0x6e>
    1ab8:	8e da       	rcall	.-2788   	; 0xfd6 <vPortYield>
    1aba:	06 c0       	rjmp	.+12     	; 0x1ac8 <vTaskDelete+0x7a>
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	0f 92       	push	r0
    1ac2:	76 de       	rcall	.-788    	; 0x17b0 <prvResetNextTaskUnblockTime>
    1ac4:	0f 90       	pop	r0
    1ac6:	0f be       	out	0x3f, r0	; 63
    1ac8:	df 91       	pop	r29
    1aca:	cf 91       	pop	r28
    1acc:	1f 91       	pop	r17
    1ace:	0f 91       	pop	r16
    1ad0:	08 95       	ret

00001ad2 <vTaskStartScheduler>:
    1ad2:	af 92       	push	r10
    1ad4:	bf 92       	push	r11
    1ad6:	cf 92       	push	r12
    1ad8:	df 92       	push	r13
    1ada:	ef 92       	push	r14
    1adc:	ff 92       	push	r15
    1ade:	0f 93       	push	r16
    1ae0:	a1 2c       	mov	r10, r1
    1ae2:	b1 2c       	mov	r11, r1
    1ae4:	c1 2c       	mov	r12, r1
    1ae6:	d1 2c       	mov	r13, r1
    1ae8:	e1 2c       	mov	r14, r1
    1aea:	f1 2c       	mov	r15, r1
    1aec:	00 e0       	ldi	r16, 0x00	; 0
    1aee:	20 e0       	ldi	r18, 0x00	; 0
    1af0:	30 e0       	ldi	r19, 0x00	; 0
    1af2:	49 eb       	ldi	r20, 0xB9	; 185
    1af4:	50 e0       	ldi	r21, 0x00	; 0
    1af6:	66 e8       	ldi	r22, 0x86	; 134
    1af8:	72 e0       	ldi	r23, 0x02	; 2
    1afa:	83 ea       	ldi	r24, 0xA3	; 163
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	ac de       	rcall	.-680    	; 0x1858 <xTaskGenericCreate>
    1b00:	81 30       	cpi	r24, 0x01	; 1
    1b02:	59 f4       	brne	.+22     	; 0x1b1a <vTaskStartScheduler+0x48>
    1b04:	c3 d3       	rcall	.+1926   	; 0x228c <xTimerCreateTimerTask>
    1b06:	81 30       	cpi	r24, 0x01	; 1
    1b08:	41 f4       	brne	.+16     	; 0x1b1a <vTaskStartScheduler+0x48>
    1b0a:	f8 94       	cli
    1b0c:	80 93 a9 0d 	sts	0x0DA9, r24
    1b10:	10 92 ac 0d 	sts	0x0DAC, r1
    1b14:	10 92 ab 0d 	sts	0x0DAB, r1
    1b18:	18 da       	rcall	.-3024   	; 0xf4a <xPortStartScheduler>
    1b1a:	0f 91       	pop	r16
    1b1c:	ff 90       	pop	r15
    1b1e:	ef 90       	pop	r14
    1b20:	df 90       	pop	r13
    1b22:	cf 90       	pop	r12
    1b24:	bf 90       	pop	r11
    1b26:	af 90       	pop	r10
    1b28:	08 95       	ret

00001b2a <vTaskSuspendAll>:
    1b2a:	80 91 a4 0d 	lds	r24, 0x0DA4
    1b2e:	8f 5f       	subi	r24, 0xFF	; 255
    1b30:	80 93 a4 0d 	sts	0x0DA4, r24
    1b34:	08 95       	ret

00001b36 <xTaskGetTickCount>:
    1b36:	0f b6       	in	r0, 0x3f	; 63
    1b38:	f8 94       	cli
    1b3a:	0f 92       	push	r0
    1b3c:	80 91 ab 0d 	lds	r24, 0x0DAB
    1b40:	90 91 ac 0d 	lds	r25, 0x0DAC
    1b44:	0f 90       	pop	r0
    1b46:	0f be       	out	0x3f, r0	; 63
    1b48:	08 95       	ret

00001b4a <xTaskIncrementTick>:
    1b4a:	cf 92       	push	r12
    1b4c:	df 92       	push	r13
    1b4e:	ef 92       	push	r14
    1b50:	ff 92       	push	r15
    1b52:	0f 93       	push	r16
    1b54:	1f 93       	push	r17
    1b56:	cf 93       	push	r28
    1b58:	df 93       	push	r29
    1b5a:	80 91 a4 0d 	lds	r24, 0x0DA4
    1b5e:	81 11       	cpse	r24, r1
    1b60:	96 c0       	rjmp	.+300    	; 0x1c8e <xTaskIncrementTick+0x144>
    1b62:	80 91 ab 0d 	lds	r24, 0x0DAB
    1b66:	90 91 ac 0d 	lds	r25, 0x0DAC
    1b6a:	01 96       	adiw	r24, 0x01	; 1
    1b6c:	90 93 ac 0d 	sts	0x0DAC, r25
    1b70:	80 93 ab 0d 	sts	0x0DAB, r24
    1b74:	e0 90 ab 0d 	lds	r14, 0x0DAB
    1b78:	f0 90 ac 0d 	lds	r15, 0x0DAC
    1b7c:	e1 14       	cp	r14, r1
    1b7e:	f1 04       	cpc	r15, r1
    1b80:	b1 f4       	brne	.+44     	; 0x1bae <xTaskIncrementTick+0x64>
    1b82:	80 91 c3 0d 	lds	r24, 0x0DC3
    1b86:	90 91 c4 0d 	lds	r25, 0x0DC4
    1b8a:	20 91 c1 0d 	lds	r18, 0x0DC1
    1b8e:	30 91 c2 0d 	lds	r19, 0x0DC2
    1b92:	30 93 c4 0d 	sts	0x0DC4, r19
    1b96:	20 93 c3 0d 	sts	0x0DC3, r18
    1b9a:	90 93 c2 0d 	sts	0x0DC2, r25
    1b9e:	80 93 c1 0d 	sts	0x0DC1, r24
    1ba2:	80 91 a6 0d 	lds	r24, 0x0DA6
    1ba6:	8f 5f       	subi	r24, 0xFF	; 255
    1ba8:	80 93 a6 0d 	sts	0x0DA6, r24
    1bac:	01 de       	rcall	.-1022   	; 0x17b0 <prvResetNextTaskUnblockTime>
    1bae:	80 91 49 02 	lds	r24, 0x0249
    1bb2:	90 91 4a 02 	lds	r25, 0x024A
    1bb6:	e8 16       	cp	r14, r24
    1bb8:	f9 06       	cpc	r15, r25
    1bba:	08 f4       	brcc	.+2      	; 0x1bbe <xTaskIncrementTick+0x74>
    1bbc:	51 c0       	rjmp	.+162    	; 0x1c60 <xTaskIncrementTick+0x116>
    1bbe:	d1 2c       	mov	r13, r1
    1bc0:	cc 24       	eor	r12, r12
    1bc2:	c3 94       	inc	r12
    1bc4:	01 c0       	rjmp	.+2      	; 0x1bc8 <xTaskIncrementTick+0x7e>
    1bc6:	dc 2c       	mov	r13, r12
    1bc8:	e0 91 c3 0d 	lds	r30, 0x0DC3
    1bcc:	f0 91 c4 0d 	lds	r31, 0x0DC4
    1bd0:	80 81       	ld	r24, Z
    1bd2:	81 11       	cpse	r24, r1
    1bd4:	07 c0       	rjmp	.+14     	; 0x1be4 <xTaskIncrementTick+0x9a>
    1bd6:	8f ef       	ldi	r24, 0xFF	; 255
    1bd8:	9f ef       	ldi	r25, 0xFF	; 255
    1bda:	90 93 4a 02 	sts	0x024A, r25
    1bde:	80 93 49 02 	sts	0x0249, r24
    1be2:	3f c0       	rjmp	.+126    	; 0x1c62 <xTaskIncrementTick+0x118>
    1be4:	e0 91 c3 0d 	lds	r30, 0x0DC3
    1be8:	f0 91 c4 0d 	lds	r31, 0x0DC4
    1bec:	05 80       	ldd	r0, Z+5	; 0x05
    1bee:	f6 81       	ldd	r31, Z+6	; 0x06
    1bf0:	e0 2d       	mov	r30, r0
    1bf2:	c6 81       	ldd	r28, Z+6	; 0x06
    1bf4:	d7 81       	ldd	r29, Z+7	; 0x07
    1bf6:	2a 81       	ldd	r18, Y+2	; 0x02
    1bf8:	3b 81       	ldd	r19, Y+3	; 0x03
    1bfa:	e2 16       	cp	r14, r18
    1bfc:	f3 06       	cpc	r15, r19
    1bfe:	28 f4       	brcc	.+10     	; 0x1c0a <xTaskIncrementTick+0xc0>
    1c00:	30 93 4a 02 	sts	0x024A, r19
    1c04:	20 93 49 02 	sts	0x0249, r18
    1c08:	2c c0       	rjmp	.+88     	; 0x1c62 <xTaskIncrementTick+0x118>
    1c0a:	8e 01       	movw	r16, r28
    1c0c:	0e 5f       	subi	r16, 0xFE	; 254
    1c0e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c10:	c8 01       	movw	r24, r16
    1c12:	03 d9       	rcall	.-3578   	; 0xe1a <uxListRemove>
    1c14:	8c 89       	ldd	r24, Y+20	; 0x14
    1c16:	9d 89       	ldd	r25, Y+21	; 0x15
    1c18:	89 2b       	or	r24, r25
    1c1a:	19 f0       	breq	.+6      	; 0x1c22 <xTaskIncrementTick+0xd8>
    1c1c:	ce 01       	movw	r24, r28
    1c1e:	0c 96       	adiw	r24, 0x0c	; 12
    1c20:	fc d8       	rcall	.-3592   	; 0xe1a <uxListRemove>
    1c22:	2e 89       	ldd	r18, Y+22	; 0x16
    1c24:	80 91 aa 0d 	lds	r24, 0x0DAA
    1c28:	82 17       	cp	r24, r18
    1c2a:	10 f4       	brcc	.+4      	; 0x1c30 <xTaskIncrementTick+0xe6>
    1c2c:	20 93 aa 0d 	sts	0x0DAA, r18
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	c9 01       	movw	r24, r18
    1c34:	88 0f       	add	r24, r24
    1c36:	99 1f       	adc	r25, r25
    1c38:	88 0f       	add	r24, r24
    1c3a:	99 1f       	adc	r25, r25
    1c3c:	88 0f       	add	r24, r24
    1c3e:	99 1f       	adc	r25, r25
    1c40:	82 0f       	add	r24, r18
    1c42:	93 1f       	adc	r25, r19
    1c44:	b8 01       	movw	r22, r16
    1c46:	89 52       	subi	r24, 0x29	; 41
    1c48:	92 4f       	sbci	r25, 0xF2	; 242
    1c4a:	95 d8       	rcall	.-3798   	; 0xd76 <vListInsertEnd>
    1c4c:	e0 91 fb 0d 	lds	r30, 0x0DFB
    1c50:	f0 91 fc 0d 	lds	r31, 0x0DFC
    1c54:	9e 89       	ldd	r25, Y+22	; 0x16
    1c56:	86 89       	ldd	r24, Z+22	; 0x16
    1c58:	98 17       	cp	r25, r24
    1c5a:	08 f0       	brcs	.+2      	; 0x1c5e <xTaskIncrementTick+0x114>
    1c5c:	b4 cf       	rjmp	.-152    	; 0x1bc6 <xTaskIncrementTick+0x7c>
    1c5e:	b4 cf       	rjmp	.-152    	; 0x1bc8 <xTaskIncrementTick+0x7e>
    1c60:	d1 2c       	mov	r13, r1
    1c62:	e0 91 fb 0d 	lds	r30, 0x0DFB
    1c66:	f0 91 fc 0d 	lds	r31, 0x0DFC
    1c6a:	86 89       	ldd	r24, Z+22	; 0x16
    1c6c:	90 e0       	ldi	r25, 0x00	; 0
    1c6e:	fc 01       	movw	r30, r24
    1c70:	ee 0f       	add	r30, r30
    1c72:	ff 1f       	adc	r31, r31
    1c74:	ee 0f       	add	r30, r30
    1c76:	ff 1f       	adc	r31, r31
    1c78:	ee 0f       	add	r30, r30
    1c7a:	ff 1f       	adc	r31, r31
    1c7c:	8e 0f       	add	r24, r30
    1c7e:	9f 1f       	adc	r25, r31
    1c80:	fc 01       	movw	r30, r24
    1c82:	e9 52       	subi	r30, 0x29	; 41
    1c84:	f2 4f       	sbci	r31, 0xF2	; 242
    1c86:	80 81       	ld	r24, Z
    1c88:	82 30       	cpi	r24, 0x02	; 2
    1c8a:	40 f4       	brcc	.+16     	; 0x1c9c <xTaskIncrementTick+0x152>
    1c8c:	09 c0       	rjmp	.+18     	; 0x1ca0 <xTaskIncrementTick+0x156>
    1c8e:	80 91 a8 0d 	lds	r24, 0x0DA8
    1c92:	8f 5f       	subi	r24, 0xFF	; 255
    1c94:	80 93 a8 0d 	sts	0x0DA8, r24
    1c98:	d1 2c       	mov	r13, r1
    1c9a:	02 c0       	rjmp	.+4      	; 0x1ca0 <xTaskIncrementTick+0x156>
    1c9c:	dd 24       	eor	r13, r13
    1c9e:	d3 94       	inc	r13
    1ca0:	80 91 a7 0d 	lds	r24, 0x0DA7
    1ca4:	88 23       	and	r24, r24
    1ca6:	11 f0       	breq	.+4      	; 0x1cac <xTaskIncrementTick+0x162>
    1ca8:	dd 24       	eor	r13, r13
    1caa:	d3 94       	inc	r13
    1cac:	8d 2d       	mov	r24, r13
    1cae:	df 91       	pop	r29
    1cb0:	cf 91       	pop	r28
    1cb2:	1f 91       	pop	r17
    1cb4:	0f 91       	pop	r16
    1cb6:	ff 90       	pop	r15
    1cb8:	ef 90       	pop	r14
    1cba:	df 90       	pop	r13
    1cbc:	cf 90       	pop	r12
    1cbe:	08 95       	ret

00001cc0 <xTaskResumeAll>:
    1cc0:	df 92       	push	r13
    1cc2:	ef 92       	push	r14
    1cc4:	ff 92       	push	r15
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
    1cce:	0f b6       	in	r0, 0x3f	; 63
    1cd0:	f8 94       	cli
    1cd2:	0f 92       	push	r0
    1cd4:	80 91 a4 0d 	lds	r24, 0x0DA4
    1cd8:	81 50       	subi	r24, 0x01	; 1
    1cda:	80 93 a4 0d 	sts	0x0DA4, r24
    1cde:	80 91 a4 0d 	lds	r24, 0x0DA4
    1ce2:	81 11       	cpse	r24, r1
    1ce4:	5c c0       	rjmp	.+184    	; 0x1d9e <xTaskResumeAll+0xde>
    1ce6:	80 91 ad 0d 	lds	r24, 0x0DAD
    1cea:	88 23       	and	r24, r24
    1cec:	09 f4       	brne	.+2      	; 0x1cf0 <xTaskResumeAll+0x30>
    1cee:	59 c0       	rjmp	.+178    	; 0x1da2 <xTaskResumeAll+0xe2>
    1cf0:	0f 2e       	mov	r0, r31
    1cf2:	f8 eb       	ldi	r31, 0xB8	; 184
    1cf4:	ef 2e       	mov	r14, r31
    1cf6:	fd e0       	ldi	r31, 0x0D	; 13
    1cf8:	ff 2e       	mov	r15, r31
    1cfa:	f0 2d       	mov	r31, r0
    1cfc:	dd 24       	eor	r13, r13
    1cfe:	d3 94       	inc	r13
    1d00:	2d c0       	rjmp	.+90     	; 0x1d5c <xTaskResumeAll+0x9c>
    1d02:	e0 91 bd 0d 	lds	r30, 0x0DBD
    1d06:	f0 91 be 0d 	lds	r31, 0x0DBE
    1d0a:	c6 81       	ldd	r28, Z+6	; 0x06
    1d0c:	d7 81       	ldd	r29, Z+7	; 0x07
    1d0e:	ce 01       	movw	r24, r28
    1d10:	0c 96       	adiw	r24, 0x0c	; 12
    1d12:	83 d8       	rcall	.-3834   	; 0xe1a <uxListRemove>
    1d14:	8e 01       	movw	r16, r28
    1d16:	0e 5f       	subi	r16, 0xFE	; 254
    1d18:	1f 4f       	sbci	r17, 0xFF	; 255
    1d1a:	c8 01       	movw	r24, r16
    1d1c:	7e d8       	rcall	.-3844   	; 0xe1a <uxListRemove>
    1d1e:	8e 89       	ldd	r24, Y+22	; 0x16
    1d20:	90 91 aa 0d 	lds	r25, 0x0DAA
    1d24:	98 17       	cp	r25, r24
    1d26:	10 f4       	brcc	.+4      	; 0x1d2c <xTaskResumeAll+0x6c>
    1d28:	80 93 aa 0d 	sts	0x0DAA, r24
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	9c 01       	movw	r18, r24
    1d30:	22 0f       	add	r18, r18
    1d32:	33 1f       	adc	r19, r19
    1d34:	22 0f       	add	r18, r18
    1d36:	33 1f       	adc	r19, r19
    1d38:	22 0f       	add	r18, r18
    1d3a:	33 1f       	adc	r19, r19
    1d3c:	82 0f       	add	r24, r18
    1d3e:	93 1f       	adc	r25, r19
    1d40:	b8 01       	movw	r22, r16
    1d42:	89 52       	subi	r24, 0x29	; 41
    1d44:	92 4f       	sbci	r25, 0xF2	; 242
    1d46:	17 d8       	rcall	.-4050   	; 0xd76 <vListInsertEnd>
    1d48:	e0 91 fb 0d 	lds	r30, 0x0DFB
    1d4c:	f0 91 fc 0d 	lds	r31, 0x0DFC
    1d50:	9e 89       	ldd	r25, Y+22	; 0x16
    1d52:	86 89       	ldd	r24, Z+22	; 0x16
    1d54:	98 17       	cp	r25, r24
    1d56:	10 f0       	brcs	.+4      	; 0x1d5c <xTaskResumeAll+0x9c>
    1d58:	d0 92 a7 0d 	sts	0x0DA7, r13
    1d5c:	f7 01       	movw	r30, r14
    1d5e:	80 81       	ld	r24, Z
    1d60:	81 11       	cpse	r24, r1
    1d62:	cf cf       	rjmp	.-98     	; 0x1d02 <xTaskResumeAll+0x42>
    1d64:	80 91 a8 0d 	lds	r24, 0x0DA8
    1d68:	88 23       	and	r24, r24
    1d6a:	91 f0       	breq	.+36     	; 0x1d90 <xTaskResumeAll+0xd0>
    1d6c:	80 91 a8 0d 	lds	r24, 0x0DA8
    1d70:	88 23       	and	r24, r24
    1d72:	71 f0       	breq	.+28     	; 0x1d90 <xTaskResumeAll+0xd0>
    1d74:	c1 e0       	ldi	r28, 0x01	; 1
    1d76:	e9 de       	rcall	.-558    	; 0x1b4a <xTaskIncrementTick>
    1d78:	81 11       	cpse	r24, r1
    1d7a:	c0 93 a7 0d 	sts	0x0DA7, r28
    1d7e:	80 91 a8 0d 	lds	r24, 0x0DA8
    1d82:	81 50       	subi	r24, 0x01	; 1
    1d84:	80 93 a8 0d 	sts	0x0DA8, r24
    1d88:	80 91 a8 0d 	lds	r24, 0x0DA8
    1d8c:	81 11       	cpse	r24, r1
    1d8e:	f3 cf       	rjmp	.-26     	; 0x1d76 <xTaskResumeAll+0xb6>
    1d90:	80 91 a7 0d 	lds	r24, 0x0DA7
    1d94:	81 30       	cpi	r24, 0x01	; 1
    1d96:	39 f4       	brne	.+14     	; 0x1da6 <xTaskResumeAll+0xe6>
    1d98:	1e d9       	rcall	.-3524   	; 0xfd6 <vPortYield>
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	05 c0       	rjmp	.+10     	; 0x1da8 <xTaskResumeAll+0xe8>
    1d9e:	80 e0       	ldi	r24, 0x00	; 0
    1da0:	03 c0       	rjmp	.+6      	; 0x1da8 <xTaskResumeAll+0xe8>
    1da2:	80 e0       	ldi	r24, 0x00	; 0
    1da4:	01 c0       	rjmp	.+2      	; 0x1da8 <xTaskResumeAll+0xe8>
    1da6:	80 e0       	ldi	r24, 0x00	; 0
    1da8:	0f 90       	pop	r0
    1daa:	0f be       	out	0x3f, r0	; 63
    1dac:	df 91       	pop	r29
    1dae:	cf 91       	pop	r28
    1db0:	1f 91       	pop	r17
    1db2:	0f 91       	pop	r16
    1db4:	ff 90       	pop	r15
    1db6:	ef 90       	pop	r14
    1db8:	df 90       	pop	r13
    1dba:	08 95       	ret

00001dbc <vTaskDelay>:
    1dbc:	cf 93       	push	r28
    1dbe:	df 93       	push	r29
    1dc0:	ec 01       	movw	r28, r24
    1dc2:	00 97       	sbiw	r24, 0x00	; 0
    1dc4:	91 f0       	breq	.+36     	; 0x1dea <vTaskDelay+0x2e>
    1dc6:	b1 de       	rcall	.-670    	; 0x1b2a <vTaskSuspendAll>
    1dc8:	80 91 ab 0d 	lds	r24, 0x0DAB
    1dcc:	90 91 ac 0d 	lds	r25, 0x0DAC
    1dd0:	c8 0f       	add	r28, r24
    1dd2:	d9 1f       	adc	r29, r25
    1dd4:	80 91 fb 0d 	lds	r24, 0x0DFB
    1dd8:	90 91 fc 0d 	lds	r25, 0x0DFC
    1ddc:	02 96       	adiw	r24, 0x02	; 2
    1dde:	1d d8       	rcall	.-4038   	; 0xe1a <uxListRemove>
    1de0:	ce 01       	movw	r24, r28
    1de2:	05 dd       	rcall	.-1526   	; 0x17ee <prvAddCurrentTaskToDelayedList>
    1de4:	6d df       	rcall	.-294    	; 0x1cc0 <xTaskResumeAll>
    1de6:	81 11       	cpse	r24, r1
    1de8:	01 c0       	rjmp	.+2      	; 0x1dec <vTaskDelay+0x30>
    1dea:	f5 d8       	rcall	.-3606   	; 0xfd6 <vPortYield>
    1dec:	df 91       	pop	r29
    1dee:	cf 91       	pop	r28
    1df0:	08 95       	ret

00001df2 <vTaskSwitchContext>:
    1df2:	80 91 a4 0d 	lds	r24, 0x0DA4
    1df6:	88 23       	and	r24, r24
    1df8:	21 f0       	breq	.+8      	; 0x1e02 <vTaskSwitchContext+0x10>
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	80 93 a7 0d 	sts	0x0DA7, r24
    1e00:	08 95       	ret
    1e02:	10 92 a7 0d 	sts	0x0DA7, r1
    1e06:	a0 91 fb 0d 	lds	r26, 0x0DFB
    1e0a:	b0 91 fc 0d 	lds	r27, 0x0DFC
    1e0e:	e0 91 fb 0d 	lds	r30, 0x0DFB
    1e12:	f0 91 fc 0d 	lds	r31, 0x0DFC
    1e16:	2d 91       	ld	r18, X+
    1e18:	3c 91       	ld	r19, X
    1e1a:	87 89       	ldd	r24, Z+23	; 0x17
    1e1c:	90 8d       	ldd	r25, Z+24	; 0x18
    1e1e:	82 17       	cp	r24, r18
    1e20:	93 07       	cpc	r25, r19
    1e22:	58 f0       	brcs	.+22     	; 0x1e3a <vTaskSwitchContext+0x48>
    1e24:	60 91 fb 0d 	lds	r22, 0x0DFB
    1e28:	70 91 fc 0d 	lds	r23, 0x0DFC
    1e2c:	80 91 fb 0d 	lds	r24, 0x0DFB
    1e30:	90 91 fc 0d 	lds	r25, 0x0DFC
    1e34:	67 5e       	subi	r22, 0xE7	; 231
    1e36:	7f 4f       	sbci	r23, 0xFF	; 255
    1e38:	32 d7       	rcall	.+3684   	; 0x2c9e <vApplicationStackOverflowHook>
    1e3a:	80 91 aa 0d 	lds	r24, 0x0DAA
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	fc 01       	movw	r30, r24
    1e42:	ee 0f       	add	r30, r30
    1e44:	ff 1f       	adc	r31, r31
    1e46:	ee 0f       	add	r30, r30
    1e48:	ff 1f       	adc	r31, r31
    1e4a:	ee 0f       	add	r30, r30
    1e4c:	ff 1f       	adc	r31, r31
    1e4e:	8e 0f       	add	r24, r30
    1e50:	9f 1f       	adc	r25, r31
    1e52:	fc 01       	movw	r30, r24
    1e54:	e9 52       	subi	r30, 0x29	; 41
    1e56:	f2 4f       	sbci	r31, 0xF2	; 242
    1e58:	80 81       	ld	r24, Z
    1e5a:	81 11       	cpse	r24, r1
    1e5c:	17 c0       	rjmp	.+46     	; 0x1e8c <vTaskSwitchContext+0x9a>
    1e5e:	80 91 aa 0d 	lds	r24, 0x0DAA
    1e62:	81 50       	subi	r24, 0x01	; 1
    1e64:	80 93 aa 0d 	sts	0x0DAA, r24
    1e68:	80 91 aa 0d 	lds	r24, 0x0DAA
    1e6c:	90 e0       	ldi	r25, 0x00	; 0
    1e6e:	fc 01       	movw	r30, r24
    1e70:	ee 0f       	add	r30, r30
    1e72:	ff 1f       	adc	r31, r31
    1e74:	ee 0f       	add	r30, r30
    1e76:	ff 1f       	adc	r31, r31
    1e78:	ee 0f       	add	r30, r30
    1e7a:	ff 1f       	adc	r31, r31
    1e7c:	8e 0f       	add	r24, r30
    1e7e:	9f 1f       	adc	r25, r31
    1e80:	fc 01       	movw	r30, r24
    1e82:	e9 52       	subi	r30, 0x29	; 41
    1e84:	f2 4f       	sbci	r31, 0xF2	; 242
    1e86:	80 81       	ld	r24, Z
    1e88:	88 23       	and	r24, r24
    1e8a:	49 f3       	breq	.-46     	; 0x1e5e <vTaskSwitchContext+0x6c>
    1e8c:	e0 91 aa 0d 	lds	r30, 0x0DAA
    1e90:	f0 e0       	ldi	r31, 0x00	; 0
    1e92:	cf 01       	movw	r24, r30
    1e94:	88 0f       	add	r24, r24
    1e96:	99 1f       	adc	r25, r25
    1e98:	88 0f       	add	r24, r24
    1e9a:	99 1f       	adc	r25, r25
    1e9c:	88 0f       	add	r24, r24
    1e9e:	99 1f       	adc	r25, r25
    1ea0:	e8 0f       	add	r30, r24
    1ea2:	f9 1f       	adc	r31, r25
    1ea4:	e9 52       	subi	r30, 0x29	; 41
    1ea6:	f2 4f       	sbci	r31, 0xF2	; 242
    1ea8:	a1 81       	ldd	r26, Z+1	; 0x01
    1eaa:	b2 81       	ldd	r27, Z+2	; 0x02
    1eac:	12 96       	adiw	r26, 0x02	; 2
    1eae:	0d 90       	ld	r0, X+
    1eb0:	bc 91       	ld	r27, X
    1eb2:	a0 2d       	mov	r26, r0
    1eb4:	b2 83       	std	Z+2, r27	; 0x02
    1eb6:	a1 83       	std	Z+1, r26	; 0x01
    1eb8:	cf 01       	movw	r24, r30
    1eba:	03 96       	adiw	r24, 0x03	; 3
    1ebc:	a8 17       	cp	r26, r24
    1ebe:	b9 07       	cpc	r27, r25
    1ec0:	31 f4       	brne	.+12     	; 0x1ece <vTaskSwitchContext+0xdc>
    1ec2:	12 96       	adiw	r26, 0x02	; 2
    1ec4:	8d 91       	ld	r24, X+
    1ec6:	9c 91       	ld	r25, X
    1ec8:	13 97       	sbiw	r26, 0x03	; 3
    1eca:	92 83       	std	Z+2, r25	; 0x02
    1ecc:	81 83       	std	Z+1, r24	; 0x01
    1ece:	01 80       	ldd	r0, Z+1	; 0x01
    1ed0:	f2 81       	ldd	r31, Z+2	; 0x02
    1ed2:	e0 2d       	mov	r30, r0
    1ed4:	86 81       	ldd	r24, Z+6	; 0x06
    1ed6:	97 81       	ldd	r25, Z+7	; 0x07
    1ed8:	90 93 fc 0d 	sts	0x0DFC, r25
    1edc:	80 93 fb 0d 	sts	0x0DFB, r24
    1ee0:	08 95       	ret

00001ee2 <vTaskPlaceOnEventList>:
    1ee2:	cf 93       	push	r28
    1ee4:	df 93       	push	r29
    1ee6:	eb 01       	movw	r28, r22
    1ee8:	60 91 fb 0d 	lds	r22, 0x0DFB
    1eec:	70 91 fc 0d 	lds	r23, 0x0DFC
    1ef0:	64 5f       	subi	r22, 0xF4	; 244
    1ef2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ef4:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <vListInsert>
    1ef8:	80 91 fb 0d 	lds	r24, 0x0DFB
    1efc:	90 91 fc 0d 	lds	r25, 0x0DFC
    1f00:	02 96       	adiw	r24, 0x02	; 2
    1f02:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
    1f06:	80 91 ab 0d 	lds	r24, 0x0DAB
    1f0a:	90 91 ac 0d 	lds	r25, 0x0DAC
    1f0e:	8c 0f       	add	r24, r28
    1f10:	9d 1f       	adc	r25, r29
    1f12:	6d dc       	rcall	.-1830   	; 0x17ee <prvAddCurrentTaskToDelayedList>
    1f14:	df 91       	pop	r29
    1f16:	cf 91       	pop	r28
    1f18:	08 95       	ret

00001f1a <vTaskPlaceOnEventListRestricted>:
    1f1a:	cf 93       	push	r28
    1f1c:	df 93       	push	r29
    1f1e:	eb 01       	movw	r28, r22
    1f20:	60 91 fb 0d 	lds	r22, 0x0DFB
    1f24:	70 91 fc 0d 	lds	r23, 0x0DFC
    1f28:	64 5f       	subi	r22, 0xF4	; 244
    1f2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f2c:	0e 94 bb 06 	call	0xd76	; 0xd76 <vListInsertEnd>
    1f30:	80 91 fb 0d 	lds	r24, 0x0DFB
    1f34:	90 91 fc 0d 	lds	r25, 0x0DFC
    1f38:	02 96       	adiw	r24, 0x02	; 2
    1f3a:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
    1f3e:	80 91 ab 0d 	lds	r24, 0x0DAB
    1f42:	90 91 ac 0d 	lds	r25, 0x0DAC
    1f46:	8c 0f       	add	r24, r28
    1f48:	9d 1f       	adc	r25, r29
    1f4a:	51 dc       	rcall	.-1886   	; 0x17ee <prvAddCurrentTaskToDelayedList>
    1f4c:	df 91       	pop	r29
    1f4e:	cf 91       	pop	r28
    1f50:	08 95       	ret

00001f52 <xTaskRemoveFromEventList>:
    1f52:	0f 93       	push	r16
    1f54:	1f 93       	push	r17
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
    1f5a:	dc 01       	movw	r26, r24
    1f5c:	15 96       	adiw	r26, 0x05	; 5
    1f5e:	ed 91       	ld	r30, X+
    1f60:	fc 91       	ld	r31, X
    1f62:	16 97       	sbiw	r26, 0x06	; 6
    1f64:	c6 81       	ldd	r28, Z+6	; 0x06
    1f66:	d7 81       	ldd	r29, Z+7	; 0x07
    1f68:	8e 01       	movw	r16, r28
    1f6a:	04 5f       	subi	r16, 0xF4	; 244
    1f6c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f6e:	c8 01       	movw	r24, r16
    1f70:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
    1f74:	80 91 a4 0d 	lds	r24, 0x0DA4
    1f78:	81 11       	cpse	r24, r1
    1f7a:	1c c0       	rjmp	.+56     	; 0x1fb4 <xTaskRemoveFromEventList+0x62>
    1f7c:	0a 50       	subi	r16, 0x0A	; 10
    1f7e:	11 09       	sbc	r17, r1
    1f80:	c8 01       	movw	r24, r16
    1f82:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
    1f86:	8e 89       	ldd	r24, Y+22	; 0x16
    1f88:	90 91 aa 0d 	lds	r25, 0x0DAA
    1f8c:	98 17       	cp	r25, r24
    1f8e:	10 f4       	brcc	.+4      	; 0x1f94 <xTaskRemoveFromEventList+0x42>
    1f90:	80 93 aa 0d 	sts	0x0DAA, r24
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	9c 01       	movw	r18, r24
    1f98:	22 0f       	add	r18, r18
    1f9a:	33 1f       	adc	r19, r19
    1f9c:	22 0f       	add	r18, r18
    1f9e:	33 1f       	adc	r19, r19
    1fa0:	22 0f       	add	r18, r18
    1fa2:	33 1f       	adc	r19, r19
    1fa4:	82 0f       	add	r24, r18
    1fa6:	93 1f       	adc	r25, r19
    1fa8:	b8 01       	movw	r22, r16
    1faa:	89 52       	subi	r24, 0x29	; 41
    1fac:	92 4f       	sbci	r25, 0xF2	; 242
    1fae:	0e 94 bb 06 	call	0xd76	; 0xd76 <vListInsertEnd>
    1fb2:	05 c0       	rjmp	.+10     	; 0x1fbe <xTaskRemoveFromEventList+0x6c>
    1fb4:	b8 01       	movw	r22, r16
    1fb6:	88 eb       	ldi	r24, 0xB8	; 184
    1fb8:	9d e0       	ldi	r25, 0x0D	; 13
    1fba:	0e 94 bb 06 	call	0xd76	; 0xd76 <vListInsertEnd>
    1fbe:	e0 91 fb 0d 	lds	r30, 0x0DFB
    1fc2:	f0 91 fc 0d 	lds	r31, 0x0DFC
    1fc6:	9e 89       	ldd	r25, Y+22	; 0x16
    1fc8:	86 89       	ldd	r24, Z+22	; 0x16
    1fca:	89 17       	cp	r24, r25
    1fcc:	20 f4       	brcc	.+8      	; 0x1fd6 <xTaskRemoveFromEventList+0x84>
    1fce:	81 e0       	ldi	r24, 0x01	; 1
    1fd0:	80 93 a7 0d 	sts	0x0DA7, r24
    1fd4:	01 c0       	rjmp	.+2      	; 0x1fd8 <xTaskRemoveFromEventList+0x86>
    1fd6:	80 e0       	ldi	r24, 0x00	; 0
    1fd8:	df 91       	pop	r29
    1fda:	cf 91       	pop	r28
    1fdc:	1f 91       	pop	r17
    1fde:	0f 91       	pop	r16
    1fe0:	08 95       	ret

00001fe2 <vTaskSetTimeOutState>:
    1fe2:	20 91 a6 0d 	lds	r18, 0x0DA6
    1fe6:	fc 01       	movw	r30, r24
    1fe8:	20 83       	st	Z, r18
    1fea:	20 91 ab 0d 	lds	r18, 0x0DAB
    1fee:	30 91 ac 0d 	lds	r19, 0x0DAC
    1ff2:	32 83       	std	Z+2, r19	; 0x02
    1ff4:	21 83       	std	Z+1, r18	; 0x01
    1ff6:	08 95       	ret

00001ff8 <xTaskCheckForTimeOut>:
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	f8 94       	cli
    1ffc:	0f 92       	push	r0
    1ffe:	20 91 ab 0d 	lds	r18, 0x0DAB
    2002:	30 91 ac 0d 	lds	r19, 0x0DAC
    2006:	40 91 a6 0d 	lds	r20, 0x0DA6
    200a:	dc 01       	movw	r26, r24
    200c:	5c 91       	ld	r21, X
    200e:	54 17       	cp	r21, r20
    2010:	39 f0       	breq	.+14     	; 0x2020 <xTaskCheckForTimeOut+0x28>
    2012:	11 96       	adiw	r26, 0x01	; 1
    2014:	4d 91       	ld	r20, X+
    2016:	5c 91       	ld	r21, X
    2018:	12 97       	sbiw	r26, 0x02	; 2
    201a:	24 17       	cp	r18, r20
    201c:	35 07       	cpc	r19, r21
    201e:	c0 f4       	brcc	.+48     	; 0x2050 <xTaskCheckForTimeOut+0x58>
    2020:	dc 01       	movw	r26, r24
    2022:	11 96       	adiw	r26, 0x01	; 1
    2024:	ed 91       	ld	r30, X+
    2026:	fc 91       	ld	r31, X
    2028:	12 97       	sbiw	r26, 0x02	; 2
    202a:	db 01       	movw	r26, r22
    202c:	4d 91       	ld	r20, X+
    202e:	5c 91       	ld	r21, X
    2030:	d9 01       	movw	r26, r18
    2032:	ae 1b       	sub	r26, r30
    2034:	bf 0b       	sbc	r27, r31
    2036:	a4 17       	cp	r26, r20
    2038:	b5 07       	cpc	r27, r21
    203a:	60 f4       	brcc	.+24     	; 0x2054 <xTaskCheckForTimeOut+0x5c>
    203c:	e2 1b       	sub	r30, r18
    203e:	f3 0b       	sbc	r31, r19
    2040:	4e 0f       	add	r20, r30
    2042:	5f 1f       	adc	r21, r31
    2044:	fb 01       	movw	r30, r22
    2046:	51 83       	std	Z+1, r21	; 0x01
    2048:	40 83       	st	Z, r20
    204a:	cb df       	rcall	.-106    	; 0x1fe2 <vTaskSetTimeOutState>
    204c:	80 e0       	ldi	r24, 0x00	; 0
    204e:	03 c0       	rjmp	.+6      	; 0x2056 <xTaskCheckForTimeOut+0x5e>
    2050:	81 e0       	ldi	r24, 0x01	; 1
    2052:	01 c0       	rjmp	.+2      	; 0x2056 <xTaskCheckForTimeOut+0x5e>
    2054:	81 e0       	ldi	r24, 0x01	; 1
    2056:	0f 90       	pop	r0
    2058:	0f be       	out	0x3f, r0	; 63
    205a:	08 95       	ret

0000205c <vTaskMissedYield>:
    205c:	81 e0       	ldi	r24, 0x01	; 1
    205e:	80 93 a7 0d 	sts	0x0DA7, r24
    2062:	08 95       	ret

00002064 <xTaskGetSchedulerState>:
    2064:	80 91 a9 0d 	lds	r24, 0x0DA9
    2068:	88 23       	and	r24, r24
    206a:	31 f0       	breq	.+12     	; 0x2078 <xTaskGetSchedulerState+0x14>
    206c:	80 91 a4 0d 	lds	r24, 0x0DA4
    2070:	81 11       	cpse	r24, r1
    2072:	04 c0       	rjmp	.+8      	; 0x207c <xTaskGetSchedulerState+0x18>
    2074:	82 e0       	ldi	r24, 0x02	; 2
    2076:	08 95       	ret
    2078:	81 e0       	ldi	r24, 0x01	; 1
    207a:	08 95       	ret
    207c:	80 e0       	ldi	r24, 0x00	; 0
    207e:	08 95       	ret

00002080 <vTaskPriorityInherit>:
    2080:	0f 93       	push	r16
    2082:	1f 93       	push	r17
    2084:	cf 93       	push	r28
    2086:	df 93       	push	r29
    2088:	ec 01       	movw	r28, r24
    208a:	00 97       	sbiw	r24, 0x00	; 0
    208c:	09 f4       	brne	.+2      	; 0x2090 <vTaskPriorityInherit+0x10>
    208e:	51 c0       	rjmp	.+162    	; 0x2132 <vTaskPriorityInherit+0xb2>
    2090:	8e 89       	ldd	r24, Y+22	; 0x16
    2092:	e0 91 fb 0d 	lds	r30, 0x0DFB
    2096:	f0 91 fc 0d 	lds	r31, 0x0DFC
    209a:	96 89       	ldd	r25, Z+22	; 0x16
    209c:	89 17       	cp	r24, r25
    209e:	08 f0       	brcs	.+2      	; 0x20a2 <vTaskPriorityInherit+0x22>
    20a0:	48 c0       	rjmp	.+144    	; 0x2132 <vTaskPriorityInherit+0xb2>
    20a2:	2c 85       	ldd	r18, Y+12	; 0x0c
    20a4:	3d 85       	ldd	r19, Y+13	; 0x0d
    20a6:	33 23       	and	r19, r19
    20a8:	5c f0       	brlt	.+22     	; 0x20c0 <vTaskPriorityInherit+0x40>
    20aa:	e0 91 fb 0d 	lds	r30, 0x0DFB
    20ae:	f0 91 fc 0d 	lds	r31, 0x0DFC
    20b2:	96 89       	ldd	r25, Z+22	; 0x16
    20b4:	24 e0       	ldi	r18, 0x04	; 4
    20b6:	30 e0       	ldi	r19, 0x00	; 0
    20b8:	29 1b       	sub	r18, r25
    20ba:	31 09       	sbc	r19, r1
    20bc:	3d 87       	std	Y+13, r19	; 0x0d
    20be:	2c 87       	std	Y+12, r18	; 0x0c
    20c0:	90 e0       	ldi	r25, 0x00	; 0
    20c2:	9c 01       	movw	r18, r24
    20c4:	22 0f       	add	r18, r18
    20c6:	33 1f       	adc	r19, r19
    20c8:	22 0f       	add	r18, r18
    20ca:	33 1f       	adc	r19, r19
    20cc:	22 0f       	add	r18, r18
    20ce:	33 1f       	adc	r19, r19
    20d0:	82 0f       	add	r24, r18
    20d2:	93 1f       	adc	r25, r19
    20d4:	89 52       	subi	r24, 0x29	; 41
    20d6:	92 4f       	sbci	r25, 0xF2	; 242
    20d8:	2a 85       	ldd	r18, Y+10	; 0x0a
    20da:	3b 85       	ldd	r19, Y+11	; 0x0b
    20dc:	28 17       	cp	r18, r24
    20de:	39 07       	cpc	r19, r25
    20e0:	11 f5       	brne	.+68     	; 0x2126 <vTaskPriorityInherit+0xa6>
    20e2:	8e 01       	movw	r16, r28
    20e4:	0e 5f       	subi	r16, 0xFE	; 254
    20e6:	1f 4f       	sbci	r17, 0xFF	; 255
    20e8:	c8 01       	movw	r24, r16
    20ea:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
    20ee:	e0 91 fb 0d 	lds	r30, 0x0DFB
    20f2:	f0 91 fc 0d 	lds	r31, 0x0DFC
    20f6:	86 89       	ldd	r24, Z+22	; 0x16
    20f8:	8e 8b       	std	Y+22, r24	; 0x16
    20fa:	90 91 aa 0d 	lds	r25, 0x0DAA
    20fe:	98 17       	cp	r25, r24
    2100:	10 f4       	brcc	.+4      	; 0x2106 <vTaskPriorityInherit+0x86>
    2102:	80 93 aa 0d 	sts	0x0DAA, r24
    2106:	90 e0       	ldi	r25, 0x00	; 0
    2108:	9c 01       	movw	r18, r24
    210a:	22 0f       	add	r18, r18
    210c:	33 1f       	adc	r19, r19
    210e:	22 0f       	add	r18, r18
    2110:	33 1f       	adc	r19, r19
    2112:	22 0f       	add	r18, r18
    2114:	33 1f       	adc	r19, r19
    2116:	82 0f       	add	r24, r18
    2118:	93 1f       	adc	r25, r19
    211a:	b8 01       	movw	r22, r16
    211c:	89 52       	subi	r24, 0x29	; 41
    211e:	92 4f       	sbci	r25, 0xF2	; 242
    2120:	0e 94 bb 06 	call	0xd76	; 0xd76 <vListInsertEnd>
    2124:	06 c0       	rjmp	.+12     	; 0x2132 <vTaskPriorityInherit+0xb2>
    2126:	e0 91 fb 0d 	lds	r30, 0x0DFB
    212a:	f0 91 fc 0d 	lds	r31, 0x0DFC
    212e:	86 89       	ldd	r24, Z+22	; 0x16
    2130:	8e 8b       	std	Y+22, r24	; 0x16
    2132:	df 91       	pop	r29
    2134:	cf 91       	pop	r28
    2136:	1f 91       	pop	r17
    2138:	0f 91       	pop	r16
    213a:	08 95       	ret

0000213c <xTaskPriorityDisinherit>:
    213c:	0f 93       	push	r16
    213e:	1f 93       	push	r17
    2140:	cf 93       	push	r28
    2142:	df 93       	push	r29
    2144:	ec 01       	movw	r28, r24
    2146:	00 97       	sbiw	r24, 0x00	; 0
    2148:	71 f1       	breq	.+92     	; 0x21a6 <xTaskPriorityDisinherit+0x6a>
    214a:	8a a1       	ldd	r24, Y+34	; 0x22
    214c:	81 50       	subi	r24, 0x01	; 1
    214e:	8a a3       	std	Y+34, r24	; 0x22
    2150:	2e 89       	ldd	r18, Y+22	; 0x16
    2152:	99 a1       	ldd	r25, Y+33	; 0x21
    2154:	29 17       	cp	r18, r25
    2156:	49 f1       	breq	.+82     	; 0x21aa <xTaskPriorityDisinherit+0x6e>
    2158:	81 11       	cpse	r24, r1
    215a:	29 c0       	rjmp	.+82     	; 0x21ae <xTaskPriorityDisinherit+0x72>
    215c:	8e 01       	movw	r16, r28
    215e:	0e 5f       	subi	r16, 0xFE	; 254
    2160:	1f 4f       	sbci	r17, 0xFF	; 255
    2162:	c8 01       	movw	r24, r16
    2164:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
    2168:	89 a1       	ldd	r24, Y+33	; 0x21
    216a:	8e 8b       	std	Y+22, r24	; 0x16
    216c:	24 e0       	ldi	r18, 0x04	; 4
    216e:	30 e0       	ldi	r19, 0x00	; 0
    2170:	28 1b       	sub	r18, r24
    2172:	31 09       	sbc	r19, r1
    2174:	3d 87       	std	Y+13, r19	; 0x0d
    2176:	2c 87       	std	Y+12, r18	; 0x0c
    2178:	90 91 aa 0d 	lds	r25, 0x0DAA
    217c:	98 17       	cp	r25, r24
    217e:	10 f4       	brcc	.+4      	; 0x2184 <xTaskPriorityDisinherit+0x48>
    2180:	80 93 aa 0d 	sts	0x0DAA, r24
    2184:	90 e0       	ldi	r25, 0x00	; 0
    2186:	9c 01       	movw	r18, r24
    2188:	22 0f       	add	r18, r18
    218a:	33 1f       	adc	r19, r19
    218c:	22 0f       	add	r18, r18
    218e:	33 1f       	adc	r19, r19
    2190:	22 0f       	add	r18, r18
    2192:	33 1f       	adc	r19, r19
    2194:	82 0f       	add	r24, r18
    2196:	93 1f       	adc	r25, r19
    2198:	b8 01       	movw	r22, r16
    219a:	89 52       	subi	r24, 0x29	; 41
    219c:	92 4f       	sbci	r25, 0xF2	; 242
    219e:	0e 94 bb 06 	call	0xd76	; 0xd76 <vListInsertEnd>
    21a2:	81 e0       	ldi	r24, 0x01	; 1
    21a4:	05 c0       	rjmp	.+10     	; 0x21b0 <xTaskPriorityDisinherit+0x74>
    21a6:	80 e0       	ldi	r24, 0x00	; 0
    21a8:	03 c0       	rjmp	.+6      	; 0x21b0 <xTaskPriorityDisinherit+0x74>
    21aa:	80 e0       	ldi	r24, 0x00	; 0
    21ac:	01 c0       	rjmp	.+2      	; 0x21b0 <xTaskPriorityDisinherit+0x74>
    21ae:	80 e0       	ldi	r24, 0x00	; 0
    21b0:	df 91       	pop	r29
    21b2:	cf 91       	pop	r28
    21b4:	1f 91       	pop	r17
    21b6:	0f 91       	pop	r16
    21b8:	08 95       	ret

000021ba <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    21ba:	80 91 fb 0d 	lds	r24, 0x0DFB
    21be:	90 91 fc 0d 	lds	r25, 0x0DFC
    21c2:	89 2b       	or	r24, r25
    21c4:	39 f0       	breq	.+14     	; 0x21d4 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    21c6:	e0 91 fb 0d 	lds	r30, 0x0DFB
    21ca:	f0 91 fc 0d 	lds	r31, 0x0DFC
    21ce:	82 a1       	ldd	r24, Z+34	; 0x22
    21d0:	8f 5f       	subi	r24, 0xFF	; 255
    21d2:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    21d4:	80 91 fb 0d 	lds	r24, 0x0DFB
    21d8:	90 91 fc 0d 	lds	r25, 0x0DFC
	}
    21dc:	08 95       	ret

000021de <prvInsertTimerInActiveList>:

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    21de:	fc 01       	movw	r30, r24
    21e0:	73 83       	std	Z+3, r23	; 0x03
    21e2:	62 83       	std	Z+2, r22	; 0x02
    21e4:	91 87       	std	Z+9, r25	; 0x09
    21e6:	80 87       	std	Z+8, r24	; 0x08
    21e8:	46 17       	cp	r20, r22
    21ea:	57 07       	cpc	r21, r23
    21ec:	90 f0       	brcs	.+36     	; 0x2212 <__stack+0x13>
    21ee:	42 1b       	sub	r20, r18
    21f0:	53 0b       	sbc	r21, r19
    21f2:	84 85       	ldd	r24, Z+12	; 0x0c
    21f4:	95 85       	ldd	r25, Z+13	; 0x0d
    21f6:	48 17       	cp	r20, r24
    21f8:	59 07       	cpc	r21, r25
    21fa:	e0 f4       	brcc	.+56     	; 0x2234 <__stack+0x35>
    21fc:	bf 01       	movw	r22, r30
    21fe:	6e 5f       	subi	r22, 0xFE	; 254
    2200:	7f 4f       	sbci	r23, 0xFF	; 255
    2202:	80 91 01 0e 	lds	r24, 0x0E01
    2206:	90 91 02 0e 	lds	r25, 0x0E02
    220a:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <vListInsert>
    220e:	80 e0       	ldi	r24, 0x00	; 0
    2210:	08 95       	ret
    2212:	42 17       	cp	r20, r18
    2214:	53 07       	cpc	r21, r19
    2216:	18 f4       	brcc	.+6      	; 0x221e <__stack+0x1f>
    2218:	62 17       	cp	r22, r18
    221a:	73 07       	cpc	r23, r19
    221c:	68 f4       	brcc	.+26     	; 0x2238 <__stack+0x39>
    221e:	bf 01       	movw	r22, r30
    2220:	6e 5f       	subi	r22, 0xFE	; 254
    2222:	7f 4f       	sbci	r23, 0xFF	; 255
    2224:	80 91 03 0e 	lds	r24, 0x0E03
    2228:	90 91 04 0e 	lds	r25, 0x0E04
    222c:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <vListInsert>
    2230:	80 e0       	ldi	r24, 0x00	; 0
    2232:	08 95       	ret
    2234:	81 e0       	ldi	r24, 0x01	; 1
    2236:	08 95       	ret
    2238:	81 e0       	ldi	r24, 0x01	; 1
    223a:	08 95       	ret

0000223c <prvCheckForValidListAndQueue>:
    223c:	0f b6       	in	r0, 0x3f	; 63
    223e:	f8 94       	cli
    2240:	0f 92       	push	r0
    2242:	80 91 ff 0d 	lds	r24, 0x0DFF
    2246:	90 91 00 0e 	lds	r25, 0x0E00
    224a:	89 2b       	or	r24, r25
    224c:	e1 f4       	brne	.+56     	; 0x2286 <prvCheckForValidListAndQueue+0x4a>
    224e:	8e e0       	ldi	r24, 0x0E	; 14
    2250:	9e e0       	ldi	r25, 0x0E	; 14
    2252:	0e 94 a9 06 	call	0xd52	; 0xd52 <vListInitialise>
    2256:	85 e0       	ldi	r24, 0x05	; 5
    2258:	9e e0       	ldi	r25, 0x0E	; 14
    225a:	0e 94 a9 06 	call	0xd52	; 0xd52 <vListInitialise>
    225e:	8e e0       	ldi	r24, 0x0E	; 14
    2260:	9e e0       	ldi	r25, 0x0E	; 14
    2262:	90 93 04 0e 	sts	0x0E04, r25
    2266:	80 93 03 0e 	sts	0x0E03, r24
    226a:	85 e0       	ldi	r24, 0x05	; 5
    226c:	9e e0       	ldi	r25, 0x0E	; 14
    226e:	90 93 02 0e 	sts	0x0E02, r25
    2272:	80 93 01 0e 	sts	0x0E01, r24
    2276:	40 e0       	ldi	r20, 0x00	; 0
    2278:	65 e0       	ldi	r22, 0x05	; 5
    227a:	8a e0       	ldi	r24, 0x0A	; 10
    227c:	b1 d8       	rcall	.-3742   	; 0x13e0 <xQueueGenericCreate>
    227e:	90 93 00 0e 	sts	0x0E00, r25
    2282:	80 93 ff 0d 	sts	0x0DFF, r24
    2286:	0f 90       	pop	r0
    2288:	0f be       	out	0x3f, r0	; 63
    228a:	08 95       	ret

0000228c <xTimerCreateTimerTask>:
    228c:	af 92       	push	r10
    228e:	bf 92       	push	r11
    2290:	cf 92       	push	r12
    2292:	df 92       	push	r13
    2294:	ef 92       	push	r14
    2296:	ff 92       	push	r15
    2298:	0f 93       	push	r16
    229a:	d0 df       	rcall	.-96     	; 0x223c <prvCheckForValidListAndQueue>
    229c:	80 91 ff 0d 	lds	r24, 0x0DFF
    22a0:	90 91 00 0e 	lds	r25, 0x0E00
    22a4:	89 2b       	or	r24, r25
    22a6:	89 f0       	breq	.+34     	; 0x22ca <xTimerCreateTimerTask+0x3e>
    22a8:	a1 2c       	mov	r10, r1
    22aa:	b1 2c       	mov	r11, r1
    22ac:	c1 2c       	mov	r12, r1
    22ae:	d1 2c       	mov	r13, r1
    22b0:	e1 2c       	mov	r14, r1
    22b2:	f1 2c       	mov	r15, r1
    22b4:	05 e0       	ldi	r16, 0x05	; 5
    22b6:	20 e0       	ldi	r18, 0x00	; 0
    22b8:	30 e0       	ldi	r19, 0x00	; 0
    22ba:	49 eb       	ldi	r20, 0xB9	; 185
    22bc:	50 e0       	ldi	r21, 0x00	; 0
    22be:	6b e8       	ldi	r22, 0x8B	; 139
    22c0:	72 e0       	ldi	r23, 0x02	; 2
    22c2:	80 e2       	ldi	r24, 0x20	; 32
    22c4:	92 e1       	ldi	r25, 0x12	; 18
    22c6:	c8 da       	rcall	.-2672   	; 0x1858 <xTaskGenericCreate>
    22c8:	01 c0       	rjmp	.+2      	; 0x22cc <xTimerCreateTimerTask+0x40>
    22ca:	80 e0       	ldi	r24, 0x00	; 0
    22cc:	0f 91       	pop	r16
    22ce:	ff 90       	pop	r15
    22d0:	ef 90       	pop	r14
    22d2:	df 90       	pop	r13
    22d4:	cf 90       	pop	r12
    22d6:	bf 90       	pop	r11
    22d8:	af 90       	pop	r10
    22da:	08 95       	ret

000022dc <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    22dc:	0f 93       	push	r16
    22de:	1f 93       	push	r17
    22e0:	cf 93       	push	r28
    22e2:	df 93       	push	r29
    22e4:	00 d0       	rcall	.+0      	; 0x22e6 <xTimerGenericCommand+0xa>
    22e6:	1f 92       	push	r1
    22e8:	1f 92       	push	r1
    22ea:	cd b7       	in	r28, 0x3d	; 61
    22ec:	de b7       	in	r29, 0x3e	; 62
    22ee:	d9 01       	movw	r26, r18
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    22f0:	e0 91 ff 0d 	lds	r30, 0x0DFF
    22f4:	f0 91 00 0e 	lds	r31, 0x0E00
    22f8:	30 97       	sbiw	r30, 0x00	; 0
    22fa:	49 f1       	breq	.+82     	; 0x234e <xTimerGenericCommand+0x72>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    22fc:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    22fe:	5b 83       	std	Y+3, r21	; 0x03
    2300:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2302:	9d 83       	std	Y+5, r25	; 0x05
    2304:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2306:	66 30       	cpi	r22, 0x06	; 6
    2308:	d4 f4       	brge	.+52     	; 0x233e <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    230a:	ac de       	rcall	.-680    	; 0x2064 <xTaskGetSchedulerState>
    230c:	82 30       	cpi	r24, 0x02	; 2
    230e:	59 f4       	brne	.+22     	; 0x2326 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2310:	20 e0       	ldi	r18, 0x00	; 0
    2312:	a8 01       	movw	r20, r16
    2314:	be 01       	movw	r22, r28
    2316:	6f 5f       	subi	r22, 0xFF	; 255
    2318:	7f 4f       	sbci	r23, 0xFF	; 255
    231a:	80 91 ff 0d 	lds	r24, 0x0DFF
    231e:	90 91 00 0e 	lds	r25, 0x0E00
    2322:	89 d8       	rcall	.-3822   	; 0x1436 <xQueueGenericSend>
    2324:	15 c0       	rjmp	.+42     	; 0x2350 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2326:	20 e0       	ldi	r18, 0x00	; 0
    2328:	40 e0       	ldi	r20, 0x00	; 0
    232a:	50 e0       	ldi	r21, 0x00	; 0
    232c:	be 01       	movw	r22, r28
    232e:	6f 5f       	subi	r22, 0xFF	; 255
    2330:	7f 4f       	sbci	r23, 0xFF	; 255
    2332:	80 91 ff 0d 	lds	r24, 0x0DFF
    2336:	90 91 00 0e 	lds	r25, 0x0E00
    233a:	7d d8       	rcall	.-3846   	; 0x1436 <xQueueGenericSend>
    233c:	09 c0       	rjmp	.+18     	; 0x2350 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    233e:	20 e0       	ldi	r18, 0x00	; 0
    2340:	ad 01       	movw	r20, r26
    2342:	be 01       	movw	r22, r28
    2344:	6f 5f       	subi	r22, 0xFF	; 255
    2346:	7f 4f       	sbci	r23, 0xFF	; 255
    2348:	cf 01       	movw	r24, r30
    234a:	08 d9       	rcall	.-3568   	; 0x155c <xQueueGenericSendFromISR>
    234c:	01 c0       	rjmp	.+2      	; 0x2350 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    234e:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2350:	0f 90       	pop	r0
    2352:	0f 90       	pop	r0
    2354:	0f 90       	pop	r0
    2356:	0f 90       	pop	r0
    2358:	0f 90       	pop	r0
    235a:	df 91       	pop	r29
    235c:	cf 91       	pop	r28
    235e:	1f 91       	pop	r17
    2360:	0f 91       	pop	r16
    2362:	08 95       	ret

00002364 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2364:	af 92       	push	r10
    2366:	bf 92       	push	r11
    2368:	cf 92       	push	r12
    236a:	df 92       	push	r13
    236c:	ef 92       	push	r14
    236e:	ff 92       	push	r15
    2370:	0f 93       	push	r16
    2372:	1f 93       	push	r17
    2374:	cf 93       	push	r28
    2376:	df 93       	push	r29
    2378:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    237a:	dd db       	rcall	.-2118   	; 0x1b36 <xTaskGetTickCount>
    237c:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    237e:	80 91 fd 0d 	lds	r24, 0x0DFD
    2382:	90 91 fe 0d 	lds	r25, 0x0DFE
    2386:	e8 16       	cp	r14, r24
    2388:	f9 06       	cpc	r15, r25
    238a:	08 f0       	brcs	.+2      	; 0x238e <prvSampleTimeNow+0x2a>
    238c:	47 c0       	rjmp	.+142    	; 0x241c <prvSampleTimeNow+0xb8>
    238e:	2f c0       	rjmp	.+94     	; 0x23ee <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2390:	05 80       	ldd	r0, Z+5	; 0x05
    2392:	f6 81       	ldd	r31, Z+6	; 0x06
    2394:	e0 2d       	mov	r30, r0
    2396:	a0 80       	ld	r10, Z
    2398:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    239a:	c6 81       	ldd	r28, Z+6	; 0x06
    239c:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    239e:	8e 01       	movw	r16, r28
    23a0:	0e 5f       	subi	r16, 0xFE	; 254
    23a2:	1f 4f       	sbci	r17, 0xFF	; 255
    23a4:	c8 01       	movw	r24, r16
    23a6:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    23aa:	e9 89       	ldd	r30, Y+17	; 0x11
    23ac:	fa 89       	ldd	r31, Y+18	; 0x12
    23ae:	ce 01       	movw	r24, r28
    23b0:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    23b2:	8e 85       	ldd	r24, Y+14	; 0x0e
    23b4:	81 30       	cpi	r24, 0x01	; 1
    23b6:	d9 f4       	brne	.+54     	; 0x23ee <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    23b8:	8c 85       	ldd	r24, Y+12	; 0x0c
    23ba:	9d 85       	ldd	r25, Y+13	; 0x0d
    23bc:	8a 0d       	add	r24, r10
    23be:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    23c0:	a8 16       	cp	r10, r24
    23c2:	b9 06       	cpc	r11, r25
    23c4:	60 f4       	brcc	.+24     	; 0x23de <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    23c6:	9b 83       	std	Y+3, r25	; 0x03
    23c8:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    23ca:	d9 87       	std	Y+9, r29	; 0x09
    23cc:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    23ce:	b8 01       	movw	r22, r16
    23d0:	80 91 03 0e 	lds	r24, 0x0E03
    23d4:	90 91 04 0e 	lds	r25, 0x0E04
    23d8:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <vListInsert>
    23dc:	08 c0       	rjmp	.+16     	; 0x23ee <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    23de:	00 e0       	ldi	r16, 0x00	; 0
    23e0:	10 e0       	ldi	r17, 0x00	; 0
    23e2:	20 e0       	ldi	r18, 0x00	; 0
    23e4:	30 e0       	ldi	r19, 0x00	; 0
    23e6:	a5 01       	movw	r20, r10
    23e8:	60 e0       	ldi	r22, 0x00	; 0
    23ea:	ce 01       	movw	r24, r28
    23ec:	77 df       	rcall	.-274    	; 0x22dc <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    23ee:	e0 91 03 0e 	lds	r30, 0x0E03
    23f2:	f0 91 04 0e 	lds	r31, 0x0E04
    23f6:	80 81       	ld	r24, Z
    23f8:	81 11       	cpse	r24, r1
    23fa:	ca cf       	rjmp	.-108    	; 0x2390 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    23fc:	80 91 01 0e 	lds	r24, 0x0E01
    2400:	90 91 02 0e 	lds	r25, 0x0E02
    2404:	90 93 04 0e 	sts	0x0E04, r25
    2408:	80 93 03 0e 	sts	0x0E03, r24
	pxOverflowTimerList = pxTemp;
    240c:	f0 93 02 0e 	sts	0x0E02, r31
    2410:	e0 93 01 0e 	sts	0x0E01, r30
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2414:	81 e0       	ldi	r24, 0x01	; 1
    2416:	f6 01       	movw	r30, r12
    2418:	80 83       	st	Z, r24
    241a:	02 c0       	rjmp	.+4      	; 0x2420 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    241c:	f6 01       	movw	r30, r12
    241e:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    2420:	f0 92 fe 0d 	sts	0x0DFE, r15
    2424:	e0 92 fd 0d 	sts	0x0DFD, r14

	return xTimeNow;
}
    2428:	c7 01       	movw	r24, r14
    242a:	df 91       	pop	r29
    242c:	cf 91       	pop	r28
    242e:	1f 91       	pop	r17
    2430:	0f 91       	pop	r16
    2432:	ff 90       	pop	r15
    2434:	ef 90       	pop	r14
    2436:	df 90       	pop	r13
    2438:	cf 90       	pop	r12
    243a:	bf 90       	pop	r11
    243c:	af 90       	pop	r10
    243e:	08 95       	ret

00002440 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2440:	cf 93       	push	r28
    2442:	df 93       	push	r29
    2444:	00 d0       	rcall	.+0      	; 0x2446 <prvTimerTask+0x6>
    2446:	00 d0       	rcall	.+0      	; 0x2448 <prvTimerTask+0x8>
    2448:	cd b7       	in	r28, 0x3d	; 61
    244a:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    244c:	ce 01       	movw	r24, r28
    244e:	01 96       	adiw	r24, 0x01	; 1
    2450:	6c 01       	movw	r12, r24
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2452:	81 2c       	mov	r8, r1
    2454:	91 2c       	mov	r9, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2456:	68 2e       	mov	r6, r24
    2458:	7d 2c       	mov	r7, r13
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    245a:	e0 91 03 0e 	lds	r30, 0x0E03
    245e:	f0 91 04 0e 	lds	r31, 0x0E04
	if( *pxListWasEmpty == pdFALSE )
    2462:	80 81       	ld	r24, Z
    2464:	88 23       	and	r24, r24
    2466:	09 f4       	brne	.+2      	; 0x246a <prvTimerTask+0x2a>
    2468:	b6 c0       	rjmp	.+364    	; 0x25d6 <prvTimerTask+0x196>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    246a:	05 80       	ldd	r0, Z+5	; 0x05
    246c:	f6 81       	ldd	r31, Z+6	; 0x06
    246e:	e0 2d       	mov	r30, r0
    2470:	e0 80       	ld	r14, Z
    2472:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2474:	5a db       	rcall	.-2380   	; 0x1b2a <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2476:	c6 01       	movw	r24, r12
    2478:	75 df       	rcall	.-278    	; 0x2364 <prvSampleTimeNow>
    247a:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    247c:	89 81       	ldd	r24, Y+1	; 0x01
    247e:	81 11       	cpse	r24, r1
    2480:	43 c0       	rjmp	.+134    	; 0x2508 <prvTimerTask+0xc8>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2482:	0e 15       	cp	r16, r14
    2484:	1f 05       	cpc	r17, r15
    2486:	90 f1       	brcs	.+100    	; 0x24ec <prvTimerTask+0xac>
			{
				( void ) xTaskResumeAll();
    2488:	1b dc       	rcall	.-1994   	; 0x1cc0 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    248a:	e0 91 03 0e 	lds	r30, 0x0E03
    248e:	f0 91 04 0e 	lds	r31, 0x0E04
    2492:	05 80       	ldd	r0, Z+5	; 0x05
    2494:	f6 81       	ldd	r31, Z+6	; 0x06
    2496:	e0 2d       	mov	r30, r0
    2498:	a6 80       	ldd	r10, Z+6	; 0x06
    249a:	b7 80       	ldd	r11, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    249c:	c5 01       	movw	r24, r10
    249e:	02 96       	adiw	r24, 0x02	; 2
    24a0:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    24a4:	d5 01       	movw	r26, r10
    24a6:	1e 96       	adiw	r26, 0x0e	; 14
    24a8:	8c 91       	ld	r24, X
    24aa:	1e 97       	sbiw	r26, 0x0e	; 14
    24ac:	81 30       	cpi	r24, 0x01	; 1
    24ae:	a1 f4       	brne	.+40     	; 0x24d8 <prvTimerTask+0x98>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    24b0:	1c 96       	adiw	r26, 0x0c	; 12
    24b2:	6d 91       	ld	r22, X+
    24b4:	7c 91       	ld	r23, X
    24b6:	1d 97       	sbiw	r26, 0x0d	; 13
    24b8:	6e 0d       	add	r22, r14
    24ba:	7f 1d       	adc	r23, r15
    24bc:	97 01       	movw	r18, r14
    24be:	a8 01       	movw	r20, r16
    24c0:	c5 01       	movw	r24, r10
    24c2:	8d de       	rcall	.-742    	; 0x21de <prvInsertTimerInActiveList>
    24c4:	81 30       	cpi	r24, 0x01	; 1
    24c6:	41 f4       	brne	.+16     	; 0x24d8 <prvTimerTask+0x98>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    24c8:	08 2d       	mov	r16, r8
    24ca:	19 2d       	mov	r17, r9
    24cc:	28 2d       	mov	r18, r8
    24ce:	39 2d       	mov	r19, r9
    24d0:	a7 01       	movw	r20, r14
    24d2:	60 e0       	ldi	r22, 0x00	; 0
    24d4:	c5 01       	movw	r24, r10
    24d6:	02 df       	rcall	.-508    	; 0x22dc <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    24d8:	d5 01       	movw	r26, r10
    24da:	51 96       	adiw	r26, 0x11	; 17
    24dc:	ed 91       	ld	r30, X+
    24de:	fc 91       	ld	r31, X
    24e0:	52 97       	sbiw	r26, 0x12	; 18
    24e2:	c5 01       	movw	r24, r10
    24e4:	19 95       	eicall
    24e6:	6a c0       	rjmp	.+212    	; 0x25bc <prvTimerTask+0x17c>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    24e8:	e8 2c       	mov	r14, r8
    24ea:	f9 2c       	mov	r15, r9
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    24ec:	b7 01       	movw	r22, r14
    24ee:	60 1b       	sub	r22, r16
    24f0:	71 0b       	sbc	r23, r17
    24f2:	80 91 ff 0d 	lds	r24, 0x0DFF
    24f6:	90 91 00 0e 	lds	r25, 0x0E00
    24fa:	3f d9       	rcall	.-3458   	; 0x177a <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    24fc:	e1 db       	rcall	.-2110   	; 0x1cc0 <xTaskResumeAll>
    24fe:	81 11       	cpse	r24, r1
    2500:	5d c0       	rjmp	.+186    	; 0x25bc <prvTimerTask+0x17c>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2502:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <vPortYield>
    2506:	5a c0       	rjmp	.+180    	; 0x25bc <prvTimerTask+0x17c>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2508:	db db       	rcall	.-2122   	; 0x1cc0 <xTaskResumeAll>
    250a:	58 c0       	rjmp	.+176    	; 0x25bc <prvTimerTask+0x17c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    250c:	89 81       	ldd	r24, Y+1	; 0x01
    250e:	88 23       	and	r24, r24
    2510:	0c f4       	brge	.+2      	; 0x2514 <prvTimerTask+0xd4>
    2512:	54 c0       	rjmp	.+168    	; 0x25bc <prvTimerTask+0x17c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2514:	ec 80       	ldd	r14, Y+4	; 0x04
    2516:	fd 80       	ldd	r15, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2518:	f7 01       	movw	r30, r14
    251a:	82 85       	ldd	r24, Z+10	; 0x0a
    251c:	93 85       	ldd	r25, Z+11	; 0x0b
    251e:	89 2b       	or	r24, r25
    2520:	21 f0       	breq	.+8      	; 0x252a <prvTimerTask+0xea>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2522:	c7 01       	movw	r24, r14
    2524:	02 96       	adiw	r24, 0x02	; 2
    2526:	0e 94 0d 07 	call	0xe1a	; 0xe1a <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    252a:	ce 01       	movw	r24, r28
    252c:	06 96       	adiw	r24, 0x06	; 6
    252e:	1a df       	rcall	.-460    	; 0x2364 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    2530:	09 81       	ldd	r16, Y+1	; 0x01
    2532:	11 27       	eor	r17, r17
    2534:	07 fd       	sbrc	r16, 7
    2536:	10 95       	com	r17
    2538:	21 2f       	mov	r18, r17
    253a:	31 2f       	mov	r19, r17
    253c:	0a 30       	cpi	r16, 0x0A	; 10
    253e:	11 05       	cpc	r17, r1
    2540:	08 f0       	brcs	.+2      	; 0x2544 <prvTimerTask+0x104>
    2542:	3c c0       	rjmp	.+120    	; 0x25bc <prvTimerTask+0x17c>
    2544:	f8 01       	movw	r30, r16
    2546:	ea 59       	subi	r30, 0x9A	; 154
    2548:	ff 4f       	sbci	r31, 0xFF	; 255
    254a:	94 c7       	rjmp	.+3880   	; 0x3474 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    254c:	2a 81       	ldd	r18, Y+2	; 0x02
    254e:	3b 81       	ldd	r19, Y+3	; 0x03
    2550:	d7 01       	movw	r26, r14
    2552:	1c 96       	adiw	r26, 0x0c	; 12
    2554:	6d 91       	ld	r22, X+
    2556:	7c 91       	ld	r23, X
    2558:	1d 97       	sbiw	r26, 0x0d	; 13
    255a:	62 0f       	add	r22, r18
    255c:	73 1f       	adc	r23, r19
    255e:	ac 01       	movw	r20, r24
    2560:	c7 01       	movw	r24, r14
    2562:	3d de       	rcall	.-902    	; 0x21de <prvInsertTimerInActiveList>
    2564:	81 30       	cpi	r24, 0x01	; 1
    2566:	51 f5       	brne	.+84     	; 0x25bc <prvTimerTask+0x17c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2568:	d7 01       	movw	r26, r14
    256a:	51 96       	adiw	r26, 0x11	; 17
    256c:	ed 91       	ld	r30, X+
    256e:	fc 91       	ld	r31, X
    2570:	52 97       	sbiw	r26, 0x12	; 18
    2572:	c7 01       	movw	r24, r14
    2574:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2576:	f7 01       	movw	r30, r14
    2578:	86 85       	ldd	r24, Z+14	; 0x0e
    257a:	81 30       	cpi	r24, 0x01	; 1
    257c:	f9 f4       	brne	.+62     	; 0x25bc <prvTimerTask+0x17c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    257e:	44 85       	ldd	r20, Z+12	; 0x0c
    2580:	55 85       	ldd	r21, Z+13	; 0x0d
    2582:	8a 81       	ldd	r24, Y+2	; 0x02
    2584:	9b 81       	ldd	r25, Y+3	; 0x03
    2586:	48 0f       	add	r20, r24
    2588:	59 1f       	adc	r21, r25
    258a:	08 2d       	mov	r16, r8
    258c:	19 2d       	mov	r17, r9
    258e:	28 2d       	mov	r18, r8
    2590:	39 2d       	mov	r19, r9
    2592:	60 e0       	ldi	r22, 0x00	; 0
    2594:	c7 01       	movw	r24, r14
    2596:	a2 de       	rcall	.-700    	; 0x22dc <xTimerGenericCommand>
    2598:	11 c0       	rjmp	.+34     	; 0x25bc <prvTimerTask+0x17c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    259a:	6a 81       	ldd	r22, Y+2	; 0x02
    259c:	7b 81       	ldd	r23, Y+3	; 0x03
    259e:	d7 01       	movw	r26, r14
    25a0:	1d 96       	adiw	r26, 0x0d	; 13
    25a2:	7c 93       	st	X, r23
    25a4:	6e 93       	st	-X, r22
    25a6:	1c 97       	sbiw	r26, 0x0c	; 12
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    25a8:	68 0f       	add	r22, r24
    25aa:	79 1f       	adc	r23, r25
    25ac:	9c 01       	movw	r18, r24
    25ae:	ac 01       	movw	r20, r24
    25b0:	c7 01       	movw	r24, r14
    25b2:	15 de       	rcall	.-982    	; 0x21de <prvInsertTimerInActiveList>
    25b4:	03 c0       	rjmp	.+6      	; 0x25bc <prvTimerTask+0x17c>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    25b6:	c7 01       	movw	r24, r14
    25b8:	0e 94 f5 08 	call	0x11ea	; 0x11ea <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    25bc:	20 e0       	ldi	r18, 0x00	; 0
    25be:	48 2d       	mov	r20, r8
    25c0:	59 2d       	mov	r21, r9
    25c2:	66 2d       	mov	r22, r6
    25c4:	77 2d       	mov	r23, r7
    25c6:	80 91 ff 0d 	lds	r24, 0x0DFF
    25ca:	90 91 00 0e 	lds	r25, 0x0E00
    25ce:	22 d8       	rcall	.-4028   	; 0x1614 <xQueueGenericReceive>
    25d0:	81 11       	cpse	r24, r1
    25d2:	9c cf       	rjmp	.-200    	; 0x250c <prvTimerTask+0xcc>
    25d4:	42 cf       	rjmp	.-380    	; 0x245a <prvTimerTask+0x1a>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    25d6:	a9 da       	rcall	.-2734   	; 0x1b2a <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    25d8:	c6 01       	movw	r24, r12
    25da:	c4 de       	rcall	.-632    	; 0x2364 <prvSampleTimeNow>
    25dc:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    25de:	89 81       	ldd	r24, Y+1	; 0x01
    25e0:	88 23       	and	r24, r24
    25e2:	09 f4       	brne	.+2      	; 0x25e6 <prvTimerTask+0x1a6>
    25e4:	81 cf       	rjmp	.-254    	; 0x24e8 <prvTimerTask+0xa8>
    25e6:	90 cf       	rjmp	.-224    	; 0x2508 <prvTimerTask+0xc8>

000025e8 <bt_status_call_back>:
int sendingDataFlag = 0;
uint16_t samplingData[samplingPoints][3] = {};
TaskHandle_t xHandle = NULL;

void bt_status_call_back(uint8_t status) {
	if (status == DIALOG_OK_STOP) {
    25e8:	8f 3f       	cpi	r24, 0xFF	; 255
    25ea:	19 f4       	brne	.+6      	; 0x25f2 <bt_status_call_back+0xa>
		bt_initialised = 1;
    25ec:	81 e0       	ldi	r24, 0x01	; 1
    25ee:	80 93 82 17 	sts	0x1782, r24
    25f2:	08 95       	ret

000025f4 <vLearnTrack>:
		} else if (status == DIALOG_ERROR_STOP) {
	}
}

void vLearnTrack(void *pvParameters) {
    25f4:	4f 92       	push	r4
    25f6:	5f 92       	push	r5
    25f8:	6f 92       	push	r6
    25fa:	7f 92       	push	r7
    25fc:	8f 92       	push	r8
    25fe:	9f 92       	push	r9
    2600:	af 92       	push	r10
    2602:	bf 92       	push	r11
    2604:	cf 92       	push	r12
    2606:	df 92       	push	r13
    2608:	ef 92       	push	r14
    260a:	ff 92       	push	r15
    260c:	0f 93       	push	r16
    260e:	1f 93       	push	r17
    2610:	cf 93       	push	r28
    2612:	df 93       	push	r29
    2614:	cd b7       	in	r28, 0x3d	; 61
    2616:	de b7       	in	r29, 0x3e	; 62
    2618:	a8 97       	sbiw	r28, 0x28	; 40
    261a:	0f b6       	in	r0, 0x3f	; 63
    261c:	f8 94       	cli
    261e:	de bf       	out	0x3e, r29	; 62
    2620:	0f be       	out	0x3f, r0	; 63
    2622:	cd bf       	out	0x3d, r28	; 61
	( void ) pvParameters;
	uint16_t l;
	finishFlag = 0;
    2624:	10 92 7b 17 	sts	0x177B, r1
	set_motor_speed(65);
    2628:	81 e4       	ldi	r24, 0x41	; 65
    262a:	0e 94 99 02 	call	0x532	; 0x532 <set_motor_speed>
	for (l = 0; l < samplingPoints; l++)
	{
		if (finishFlag == 1)
    262e:	80 91 7b 17 	lds	r24, 0x177B
    2632:	81 30       	cpi	r24, 0x01	; 1
    2634:	09 f0       	breq	.+2      	; 0x2638 <vLearnTrack+0x44>
    2636:	c3 c0       	rjmp	.+390    	; 0x27be <vLearnTrack+0x1ca>
    2638:	1b c0       	rjmp	.+54     	; 0x2670 <vLearnTrack+0x7c>
    263a:	80 91 7b 17 	lds	r24, 0x177B
    263e:	81 30       	cpi	r24, 0x01	; 1
    2640:	b9 f0       	breq	.+46     	; 0x2670 <vLearnTrack+0x7c>
		{
			break;
		}
		samplingData[l][0] = get_raw_y_accel();
    2642:	0e 94 96 03 	call	0x72c	; 0x72c <get_raw_y_accel>
    2646:	f8 01       	movw	r30, r16
    2648:	91 83       	std	Z+1, r25	; 0x01
    264a:	80 83       	st	Z, r24
		samplingData[l][1] = get_raw_z_rotation();
    264c:	0e 94 ae 03 	call	0x75c	; 0x75c <get_raw_z_rotation>
    2650:	f8 01       	movw	r30, r16
    2652:	93 83       	std	Z+3, r25	; 0x03
    2654:	82 83       	std	Z+2, r24	; 0x02
		samplingData[l][2] = get_tacho_count();
    2656:	0e 94 b6 03 	call	0x76c	; 0x76c <get_tacho_count>
    265a:	f8 01       	movw	r30, r16
    265c:	95 83       	std	Z+5, r25	; 0x05
    265e:	84 83       	std	Z+4, r24	; 0x04

		vTaskDelay(50);
    2660:	82 e3       	ldi	r24, 0x32	; 50
    2662:	90 e0       	ldi	r25, 0x00	; 0
    2664:	ab db       	rcall	.-2218   	; 0x1dbc <vTaskDelay>
    2666:	0a 5f       	subi	r16, 0xFA	; 250
    2668:	1f 4f       	sbci	r17, 0xFF	; 255
void vLearnTrack(void *pvParameters) {
	( void ) pvParameters;
	uint16_t l;
	finishFlag = 0;
	set_motor_speed(65);
	for (l = 0; l < samplingPoints; l++)
    266a:	0e 15       	cp	r16, r14
    266c:	1f 05       	cpc	r17, r15
    266e:	29 f7       	brne	.-54     	; 0x263a <vLearnTrack+0x46>
		samplingData[l][1] = get_raw_z_rotation();
		samplingData[l][2] = get_tacho_count();

		vTaskDelay(50);
	}
	set_motor_speed(0);
    2670:	80 e0       	ldi	r24, 0x00	; 0
    2672:	0e 94 99 02 	call	0x532	; 0x532 <set_motor_speed>
	char buf[40];
	
	sprintf(buf, "!");
    2676:	81 e2       	ldi	r24, 0x21	; 33
    2678:	90 e0       	ldi	r25, 0x00	; 0
    267a:	9a 83       	std	Y+2, r25	; 0x02
    267c:	89 83       	std	Y+1, r24	; 0x01
	bt_send_bytes((uint8_t *)buf, strlen(buf));
    267e:	ce 01       	movw	r24, r28
    2680:	01 96       	adiw	r24, 0x01	; 1
    2682:	fc 01       	movw	r30, r24
    2684:	01 90       	ld	r0, Z+
    2686:	00 20       	and	r0, r0
    2688:	e9 f7       	brne	.-6      	; 0x2684 <vLearnTrack+0x90>
    268a:	31 97       	sbiw	r30, 0x01	; 1
    268c:	bf 01       	movw	r22, r30
    268e:	68 1b       	sub	r22, r24
    2690:	79 0b       	sbc	r23, r25
    2692:	0e 94 d6 03 	call	0x7ac	; 0x7ac <bt_send_bytes>
	
	vTaskDelay(300);
    2696:	8c e2       	ldi	r24, 0x2C	; 44
    2698:	91 e0       	ldi	r25, 0x01	; 1
    269a:	90 db       	rcall	.-2272   	; 0x1dbc <vTaskDelay>
	set_brake_light(1);
    269c:	81 e0       	ldi	r24, 0x01	; 1
    269e:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
	uint16_t raw_y;
	uint16_t tacho;
	l=0;
	for (l = 0; l < samplingPoints; l++)
	{
		if (samplingData[l][0] == 0)
    26a2:	00 91 17 0e 	lds	r16, 0x0E17
    26a6:	10 91 18 0e 	lds	r17, 0x0E18
    26aa:	01 15       	cp	r16, r1
    26ac:	11 05       	cpc	r17, r1
    26ae:	09 f0       	breq	.+2      	; 0x26b2 <vLearnTrack+0xbe>
    26b0:	49 c0       	rjmp	.+146    	; 0x2744 <vLearnTrack+0x150>
    26b2:	2e c0       	rjmp	.+92     	; 0x2710 <vLearnTrack+0x11c>
    26b4:	f8 01       	movw	r30, r16
    26b6:	c0 80       	ld	r12, Z
    26b8:	d1 80       	ldd	r13, Z+1	; 0x01
    26ba:	c1 14       	cp	r12, r1
    26bc:	d1 04       	cpc	r13, r1
    26be:	41 f1       	breq	.+80     	; 0x2710 <vLearnTrack+0x11c>
		{
			break;
		}
		raw_y = samplingData[l][0];
		raw_z = samplingData[l][1];
    26c0:	72 80       	ldd	r7, Z+2	; 0x02
    26c2:	63 80       	ldd	r6, Z+3	; 0x03
		tacho = samplingData[l][2];
    26c4:	54 80       	ldd	r5, Z+4	; 0x04
    26c6:	45 80       	ldd	r4, Z+5	; 0x05
		vTaskDelay(100);
    26c8:	84 e6       	ldi	r24, 0x64	; 100
    26ca:	90 e0       	ldi	r25, 0x00	; 0
    26cc:	77 db       	rcall	.-2322   	; 0x1dbc <vTaskDelay>
		sprintf(buf, "y%4dz%4dt%4d", raw_y, raw_z, tacho);
    26ce:	4f 92       	push	r4
    26d0:	5f 92       	push	r5
    26d2:	6f 92       	push	r6
    26d4:	7f 92       	push	r7
    26d6:	df 92       	push	r13
    26d8:	cf 92       	push	r12
    26da:	bf 92       	push	r11
    26dc:	af 92       	push	r10
    26de:	ff 92       	push	r15
    26e0:	ef 92       	push	r14
    26e2:	0e 94 b8 1b 	call	0x3770	; 0x3770 <sprintf>
		bt_send_bytes((uint8_t *)buf, strlen(buf));
    26e6:	f7 01       	movw	r30, r14
    26e8:	01 90       	ld	r0, Z+
    26ea:	00 20       	and	r0, r0
    26ec:	e9 f7       	brne	.-6      	; 0x26e8 <vLearnTrack+0xf4>
    26ee:	31 97       	sbiw	r30, 0x01	; 1
    26f0:	bf 01       	movw	r22, r30
    26f2:	6e 19       	sub	r22, r14
    26f4:	7f 09       	sbc	r23, r15
    26f6:	c7 01       	movw	r24, r14
    26f8:	0e 94 d6 03 	call	0x7ac	; 0x7ac <bt_send_bytes>
    26fc:	0a 5f       	subi	r16, 0xFA	; 250
    26fe:	1f 4f       	sbci	r17, 0xFF	; 255

	uint16_t raw_z;
	uint16_t raw_y;
	uint16_t tacho;
	l=0;
	for (l = 0; l < samplingPoints; l++)
    2700:	0f b6       	in	r0, 0x3f	; 63
    2702:	f8 94       	cli
    2704:	de bf       	out	0x3e, r29	; 62
    2706:	0f be       	out	0x3f, r0	; 63
    2708:	cd bf       	out	0x3d, r28	; 61
    270a:	08 15       	cp	r16, r8
    270c:	19 05       	cpc	r17, r9
    270e:	91 f6       	brne	.-92     	; 0x26b4 <vLearnTrack+0xc0>
		tacho = samplingData[l][2];
		vTaskDelay(100);
		sprintf(buf, "y%4dz%4dt%4d", raw_y, raw_z, tacho);
		bt_send_bytes((uint8_t *)buf, strlen(buf));
	}
	set_brake_light(0);
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
	vTaskDelay(300);
    2716:	8c e2       	ldi	r24, 0x2C	; 44
    2718:	91 e0       	ldi	r25, 0x01	; 1
    271a:	50 db       	rcall	.-2400   	; 0x1dbc <vTaskDelay>
	sprintf(buf, "!");
    271c:	81 e2       	ldi	r24, 0x21	; 33
    271e:	90 e0       	ldi	r25, 0x00	; 0
    2720:	9a 83       	std	Y+2, r25	; 0x02
    2722:	89 83       	std	Y+1, r24	; 0x01
	bt_send_bytes((uint8_t *)buf, strlen(buf));
    2724:	ce 01       	movw	r24, r28
    2726:	01 96       	adiw	r24, 0x01	; 1
    2728:	fc 01       	movw	r30, r24
    272a:	01 90       	ld	r0, Z+
    272c:	00 20       	and	r0, r0
    272e:	e9 f7       	brne	.-6      	; 0x272a <vLearnTrack+0x136>
    2730:	31 97       	sbiw	r30, 0x01	; 1
    2732:	bf 01       	movw	r22, r30
    2734:	68 1b       	sub	r22, r24
    2736:	79 0b       	sbc	r23, r25
    2738:	0e 94 d6 03 	call	0x7ac	; 0x7ac <bt_send_bytes>
	vTaskDelete(NULL);
    273c:	80 e0       	ldi	r24, 0x00	; 0
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	86 d9       	rcall	.-3316   	; 0x1a4e <vTaskDelete>
    2742:	5b c0       	rjmp	.+182    	; 0x27fa <vLearnTrack+0x206>
		if (samplingData[l][0] == 0)
		{
			break;
		}
		raw_y = samplingData[l][0];
		raw_z = samplingData[l][1];
    2744:	e9 e1       	ldi	r30, 0x19	; 25
    2746:	fe e0       	ldi	r31, 0x0E	; 14
    2748:	f0 80       	ld	r15, Z
    274a:	e1 80       	ldd	r14, Z+1	; 0x01
		tacho = samplingData[l][2];
    274c:	eb e1       	ldi	r30, 0x1B	; 27
    274e:	fe e0       	ldi	r31, 0x0E	; 14
    2750:	d0 80       	ld	r13, Z
    2752:	c1 80       	ldd	r12, Z+1	; 0x01
		vTaskDelay(100);
    2754:	84 e6       	ldi	r24, 0x64	; 100
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	31 db       	rcall	.-2462   	; 0x1dbc <vTaskDelay>
		sprintf(buf, "y%4dz%4dt%4d", raw_y, raw_z, tacho);
    275a:	cf 92       	push	r12
    275c:	df 92       	push	r13
    275e:	ef 92       	push	r14
    2760:	ff 92       	push	r15
    2762:	1f 93       	push	r17
    2764:	0f 93       	push	r16
    2766:	83 e9       	ldi	r24, 0x93	; 147
    2768:	92 e0       	ldi	r25, 0x02	; 2
    276a:	9f 93       	push	r25
    276c:	8f 93       	push	r24
    276e:	8e 01       	movw	r16, r28
    2770:	0f 5f       	subi	r16, 0xFF	; 255
    2772:	1f 4f       	sbci	r17, 0xFF	; 255
    2774:	1f 93       	push	r17
    2776:	0f 93       	push	r16
    2778:	fb d7       	rcall	.+4086   	; 0x3770 <sprintf>
		bt_send_bytes((uint8_t *)buf, strlen(buf));
    277a:	f8 01       	movw	r30, r16
    277c:	01 90       	ld	r0, Z+
    277e:	00 20       	and	r0, r0
    2780:	e9 f7       	brne	.-6      	; 0x277c <vLearnTrack+0x188>
    2782:	31 97       	sbiw	r30, 0x01	; 1
    2784:	bf 01       	movw	r22, r30
    2786:	60 1b       	sub	r22, r16
    2788:	71 0b       	sbc	r23, r17
    278a:	c8 01       	movw	r24, r16
    278c:	0e 94 d6 03 	call	0x7ac	; 0x7ac <bt_send_bytes>
    2790:	0d e1       	ldi	r16, 0x1D	; 29
    2792:	1e e0       	ldi	r17, 0x0E	; 14
    2794:	0f 2e       	mov	r0, r31
    2796:	f7 e7       	ldi	r31, 0x77	; 119
    2798:	8f 2e       	mov	r8, r31
    279a:	f7 e1       	ldi	r31, 0x17	; 23
    279c:	9f 2e       	mov	r9, r31
    279e:	f0 2d       	mov	r31, r0
    27a0:	0f b6       	in	r0, 0x3f	; 63
    27a2:	f8 94       	cli
    27a4:	de bf       	out	0x3e, r29	; 62
    27a6:	0f be       	out	0x3f, r0	; 63
    27a8:	cd bf       	out	0x3d, r28	; 61
		}
		raw_y = samplingData[l][0];
		raw_z = samplingData[l][1];
		tacho = samplingData[l][2];
		vTaskDelay(100);
		sprintf(buf, "y%4dz%4dt%4d", raw_y, raw_z, tacho);
    27aa:	0f 2e       	mov	r0, r31
    27ac:	f3 e9       	ldi	r31, 0x93	; 147
    27ae:	af 2e       	mov	r10, r31
    27b0:	f2 e0       	ldi	r31, 0x02	; 2
    27b2:	bf 2e       	mov	r11, r31
    27b4:	f0 2d       	mov	r31, r0
    27b6:	ce 01       	movw	r24, r28
    27b8:	01 96       	adiw	r24, 0x01	; 1
    27ba:	7c 01       	movw	r14, r24
    27bc:	7b cf       	rjmp	.-266    	; 0x26b4 <vLearnTrack+0xc0>
	{
		if (finishFlag == 1)
		{
			break;
		}
		samplingData[l][0] = get_raw_y_accel();
    27be:	0e 94 96 03 	call	0x72c	; 0x72c <get_raw_y_accel>
    27c2:	90 93 18 0e 	sts	0x0E18, r25
    27c6:	80 93 17 0e 	sts	0x0E17, r24
		samplingData[l][1] = get_raw_z_rotation();
    27ca:	0e 94 ae 03 	call	0x75c	; 0x75c <get_raw_z_rotation>
    27ce:	90 93 1a 0e 	sts	0x0E1A, r25
    27d2:	80 93 19 0e 	sts	0x0E19, r24
		samplingData[l][2] = get_tacho_count();
    27d6:	0e 94 b6 03 	call	0x76c	; 0x76c <get_tacho_count>
    27da:	90 93 1c 0e 	sts	0x0E1C, r25
    27de:	80 93 1b 0e 	sts	0x0E1B, r24

		vTaskDelay(50);
    27e2:	82 e3       	ldi	r24, 0x32	; 50
    27e4:	90 e0       	ldi	r25, 0x00	; 0
    27e6:	ea da       	rcall	.-2604   	; 0x1dbc <vTaskDelay>
    27e8:	0d e1       	ldi	r16, 0x1D	; 29
    27ea:	1e e0       	ldi	r17, 0x0E	; 14
    27ec:	0f 2e       	mov	r0, r31
    27ee:	f7 e7       	ldi	r31, 0x77	; 119
    27f0:	ef 2e       	mov	r14, r31
    27f2:	f7 e1       	ldi	r31, 0x17	; 23
    27f4:	ff 2e       	mov	r15, r31
    27f6:	f0 2d       	mov	r31, r0
    27f8:	20 cf       	rjmp	.-448    	; 0x263a <vLearnTrack+0x46>
	set_brake_light(0);
	vTaskDelay(300);
	sprintf(buf, "!");
	bt_send_bytes((uint8_t *)buf, strlen(buf));
	vTaskDelete(NULL);
}
    27fa:	a8 96       	adiw	r28, 0x28	; 40
    27fc:	0f b6       	in	r0, 0x3f	; 63
    27fe:	f8 94       	cli
    2800:	de bf       	out	0x3e, r29	; 62
    2802:	0f be       	out	0x3f, r0	; 63
    2804:	cd bf       	out	0x3d, r28	; 61
    2806:	df 91       	pop	r29
    2808:	cf 91       	pop	r28
    280a:	1f 91       	pop	r17
    280c:	0f 91       	pop	r16
    280e:	ff 90       	pop	r15
    2810:	ef 90       	pop	r14
    2812:	df 90       	pop	r13
    2814:	cf 90       	pop	r12
    2816:	bf 90       	pop	r11
    2818:	af 90       	pop	r10
    281a:	9f 90       	pop	r9
    281c:	8f 90       	pop	r8
    281e:	7f 90       	pop	r7
    2820:	6f 90       	pop	r6
    2822:	5f 90       	pop	r5
    2824:	4f 90       	pop	r4
    2826:	08 95       	ret

00002828 <vCountTacho>:

void vCountTacho(void *pvParameters ) {
	( void ) pvParameters;
	get_tacho_count();
    2828:	0e 94 b6 03 	call	0x76c	; 0x76c <get_tacho_count>
	for (;;)
	{
		cumulativeTacho = cumulativeTacho + get_tacho_count();
    282c:	0e 94 b6 03 	call	0x76c	; 0x76c <get_tacho_count>
    2830:	20 91 d3 1d 	lds	r18, 0x1DD3
    2834:	30 91 d4 1d 	lds	r19, 0x1DD4
    2838:	82 0f       	add	r24, r18
    283a:	93 1f       	adc	r25, r19
    283c:	90 93 d4 1d 	sts	0x1DD4, r25
    2840:	80 93 d3 1d 	sts	0x1DD3, r24
		if (cumulativeTacho >= accData[planCount])
    2844:	e0 91 79 17 	lds	r30, 0x1779
    2848:	f0 91 7a 17 	lds	r31, 0x177A
    284c:	ee 0f       	add	r30, r30
    284e:	ff 1f       	adc	r31, r31
    2850:	eb 57       	subi	r30, 0x7B	; 123
    2852:	f8 4e       	sbci	r31, 0xE8	; 232
    2854:	20 81       	ld	r18, Z
    2856:	31 81       	ldd	r19, Z+1	; 0x01
    2858:	82 17       	cp	r24, r18
    285a:	93 07       	cpc	r25, r19
    285c:	38 f3       	brcs	.-50     	; 0x282c <vCountTacho+0x4>
		{
			xSemaphoreGive(speed_adjusting_semaphore);
    285e:	20 e0       	ldi	r18, 0x00	; 0
    2860:	40 e0       	ldi	r20, 0x00	; 0
    2862:	50 e0       	ldi	r21, 0x00	; 0
    2864:	60 e0       	ldi	r22, 0x00	; 0
    2866:	70 e0       	ldi	r23, 0x00	; 0
    2868:	80 91 c7 1d 	lds	r24, 0x1DC7
    286c:	90 91 c8 1d 	lds	r25, 0x1DC8
    2870:	0e 94 1b 0a 	call	0x1436	; 0x1436 <xQueueGenericSend>
    2874:	db cf       	rjmp	.-74     	; 0x282c <vCountTacho+0x4>

00002876 <vAdjustSpeed>:
	}
}

void vAdjustSpeed(void *pvParameters ) {
	( void ) pvParameters;
	finishFlag = 0;
    2876:	10 92 7b 17 	sts	0x177B, r1
	get_tacho_count();
    287a:	0e 94 b6 03 	call	0x76c	; 0x76c <get_tacho_count>
	set_head_light(1);
    287e:	81 e0       	ldi	r24, 0x01	; 1
    2880:	0e 94 8d 02 	call	0x51a	; 0x51a <set_head_light>
	planCount = 0;
    2884:	10 92 7a 17 	sts	0x177A, r1
    2888:	10 92 79 17 	sts	0x1779, r1
	while (finishFlag == 0)
    288c:	46 c0       	rjmp	.+140    	; 0x291a <vAdjustSpeed+0xa4>
	{
		if (xSemaphoreTake(speed_adjusting_semaphore, 1000))
    288e:	20 e0       	ldi	r18, 0x00	; 0
    2890:	48 ee       	ldi	r20, 0xE8	; 232
    2892:	53 e0       	ldi	r21, 0x03	; 3
    2894:	60 e0       	ldi	r22, 0x00	; 0
    2896:	70 e0       	ldi	r23, 0x00	; 0
    2898:	80 91 c7 1d 	lds	r24, 0x1DC7
    289c:	90 91 c8 1d 	lds	r25, 0x1DC8
    28a0:	0e 94 0a 0b 	call	0x1614	; 0x1614 <xQueueGenericReceive>
    28a4:	88 23       	and	r24, r24
    28a6:	c9 f1       	breq	.+114    	; 0x291a <vAdjustSpeed+0xa4>
		{
			if (accData[planCount+1] <= 100)
    28a8:	e0 91 79 17 	lds	r30, 0x1779
    28ac:	f0 91 7a 17 	lds	r31, 0x177A
    28b0:	ee 0f       	add	r30, r30
    28b2:	ff 1f       	adc	r31, r31
    28b4:	e9 57       	subi	r30, 0x79	; 121
    28b6:	f8 4e       	sbci	r31, 0xE8	; 232
    28b8:	80 81       	ld	r24, Z
    28ba:	91 81       	ldd	r25, Z+1	; 0x01
    28bc:	85 36       	cpi	r24, 0x65	; 101
    28be:	91 05       	cpc	r25, r1
    28c0:	78 f4       	brcc	.+30     	; 0x28e0 <vAdjustSpeed+0x6a>
			{
				set_brake_light(0);
    28c2:	80 e0       	ldi	r24, 0x00	; 0
    28c4:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
				set_motor_speed(accData[planCount+1]);
    28c8:	e0 91 79 17 	lds	r30, 0x1779
    28cc:	f0 91 7a 17 	lds	r31, 0x177A
    28d0:	ee 0f       	add	r30, r30
    28d2:	ff 1f       	adc	r31, r31
    28d4:	e9 57       	subi	r30, 0x79	; 121
    28d6:	f8 4e       	sbci	r31, 0xE8	; 232
    28d8:	80 81       	ld	r24, Z
    28da:	0e 94 99 02 	call	0x532	; 0x532 <set_motor_speed>
    28de:	09 c0       	rjmp	.+18     	; 0x28f2 <vAdjustSpeed+0x7c>
			} else if (accData[planCount+1] > 100) {
				set_brake(accData[planCount+1]-100);
    28e0:	84 56       	subi	r24, 0x64	; 100
    28e2:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <set_brake>
				set_brake_light(1);
    28e6:	81 e0       	ldi	r24, 0x01	; 1
    28e8:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
				set_motor_speed(0);
    28ec:	80 e0       	ldi	r24, 0x00	; 0
    28ee:	0e 94 99 02 	call	0x532	; 0x532 <set_motor_speed>
			} else {
				set_motor_speed(0);
			}
			nextVal= accData[planCount+1];
    28f2:	80 91 79 17 	lds	r24, 0x1779
    28f6:	90 91 7a 17 	lds	r25, 0x177A
    28fa:	fc 01       	movw	r30, r24
    28fc:	ee 0f       	add	r30, r30
    28fe:	ff 1f       	adc	r31, r31
    2900:	e9 57       	subi	r30, 0x79	; 121
    2902:	f8 4e       	sbci	r31, 0xE8	; 232
    2904:	20 81       	ld	r18, Z
    2906:	31 81       	ldd	r19, Z+1	; 0x01
    2908:	30 93 84 17 	sts	0x1784, r19
    290c:	20 93 83 17 	sts	0x1783, r18
			planCount = planCount + 2;
    2910:	02 96       	adiw	r24, 0x02	; 2
    2912:	90 93 7a 17 	sts	0x177A, r25
    2916:	80 93 79 17 	sts	0x1779, r24
	( void ) pvParameters;
	finishFlag = 0;
	get_tacho_count();
	set_head_light(1);
	planCount = 0;
	while (finishFlag == 0)
    291a:	80 91 7b 17 	lds	r24, 0x177B
    291e:	88 23       	and	r24, r24
    2920:	09 f4       	brne	.+2      	; 0x2924 <vAdjustSpeed+0xae>
    2922:	b5 cf       	rjmp	.-150    	; 0x288e <vAdjustSpeed+0x18>
			}
			nextVal= accData[planCount+1];
			planCount = planCount + 2;
		}
	}
	set_brake_light(0);
    2924:	80 e0       	ldi	r24, 0x00	; 0
    2926:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
	set_head_light(0);
    292a:	80 e0       	ldi	r24, 0x00	; 0
    292c:	0e 94 8d 02 	call	0x51a	; 0x51a <set_head_light>
	set_motor_speed(0);
    2930:	80 e0       	ldi	r24, 0x00	; 0
    2932:	0e 94 99 02 	call	0x532	; 0x532 <set_motor_speed>
	set_horn(1);
    2936:	81 e0       	ldi	r24, 0x01	; 1
    2938:	0e 94 87 02 	call	0x50e	; 0x50e <set_horn>
	vTaskDelay(500);
    293c:	84 ef       	ldi	r24, 0xF4	; 244
    293e:	91 e0       	ldi	r25, 0x01	; 1
    2940:	3d da       	rcall	.-2950   	; 0x1dbc <vTaskDelay>
	set_horn(0);
    2942:	80 e0       	ldi	r24, 0x00	; 0
    2944:	0e 94 87 02 	call	0x50e	; 0x50e <set_horn>
	vTaskDelete(NULL);
    2948:	80 e0       	ldi	r24, 0x00	; 0
    294a:	90 e0       	ldi	r25, 0x00	; 0
    294c:	80 c8       	rjmp	.-3840   	; 0x1a4e <vTaskDelete>
    294e:	08 95       	ret

00002950 <vGoalLineTask>:
	( void ) pvParameters;

	/* Cycle for ever, one cycle each time the goal line is passed. */
	for( ;; )
	{
		if (xSemaphoreTake(goal_line_semaphore, portMAX_DELAY))
    2950:	20 e0       	ldi	r18, 0x00	; 0
    2952:	4f ef       	ldi	r20, 0xFF	; 255
    2954:	5f ef       	ldi	r21, 0xFF	; 255
    2956:	60 e0       	ldi	r22, 0x00	; 0
    2958:	70 e0       	ldi	r23, 0x00	; 0
    295a:	80 91 c9 1d 	lds	r24, 0x1DC9
    295e:	90 91 ca 1d 	lds	r25, 0x1DCA
    2962:	0e 94 0a 0b 	call	0x1614	; 0x1614 <xQueueGenericReceive>
    2966:	88 23       	and	r24, r24
    2968:	99 f3       	breq	.-26     	; 0x2950 <vGoalLineTask>
		{
			set_horn(1);
    296a:	81 e0       	ldi	r24, 0x01	; 1
    296c:	0e 94 87 02 	call	0x50e	; 0x50e <set_horn>
			finishFlag = 1;
    2970:	81 e0       	ldi	r24, 0x01	; 1
    2972:	80 93 7b 17 	sts	0x177B, r24
			vTaskDelay(50);
    2976:	82 e3       	ldi	r24, 0x32	; 50
    2978:	90 e0       	ldi	r25, 0x00	; 0
    297a:	20 da       	rcall	.-3008   	; 0x1dbc <vTaskDelay>
			set_horn(0);
    297c:	80 e0       	ldi	r24, 0x00	; 0
    297e:	0e 94 87 02 	call	0x50e	; 0x50e <set_horn>
    2982:	e6 cf       	rjmp	.-52     	; 0x2950 <vGoalLineTask>

00002984 <bt_com_call_back>:
			//}
		//}
	//}
//}

void bt_com_call_back(uint8_t byte) {
    2984:	af 92       	push	r10
    2986:	bf 92       	push	r11
    2988:	cf 92       	push	r12
    298a:	df 92       	push	r13
    298c:	ef 92       	push	r14
    298e:	ff 92       	push	r15
    2990:	0f 93       	push	r16
    2992:	1f 93       	push	r17
    2994:	cf 93       	push	r28
    2996:	df 93       	push	r29
    2998:	cd b7       	in	r28, 0x3d	; 61
    299a:	de b7       	in	r29, 0x3e	; 62
    299c:	a8 97       	sbiw	r28, 0x28	; 40
    299e:	0f b6       	in	r0, 0x3f	; 63
    29a0:	f8 94       	cli
    29a2:	de bf       	out	0x3e, r29	; 62
    29a4:	0f be       	out	0x3f, r0	; 63
    29a6:	cd bf       	out	0x3d, r28	; 61
	char buf[40];
	
	if (bt_initialised) {
    29a8:	90 91 82 17 	lds	r25, 0x1782
    29ac:	99 23       	and	r25, r25
    29ae:	09 f4       	brne	.+2      	; 0x29b2 <bt_com_call_back+0x2e>
    29b0:	e5 c0       	rjmp	.+458    	; 0x2b7c <bt_com_call_back+0x1f8>
		switch (byte) {
    29b2:	48 2f       	mov	r20, r24
    29b4:	50 e0       	ldi	r21, 0x00	; 0
    29b6:	fa 01       	movw	r30, r20
    29b8:	e1 54       	subi	r30, 0x41	; 65
    29ba:	f1 09       	sbc	r31, r1
    29bc:	e3 33       	cpi	r30, 0x33	; 51
    29be:	f1 05       	cpc	r31, r1
    29c0:	08 f0       	brcs	.+2      	; 0x29c4 <bt_com_call_back+0x40>
    29c2:	ad c0       	rjmp	.+346    	; 0x2b1e <bt_com_call_back+0x19a>
    29c4:	e0 59       	subi	r30, 0x90	; 144
    29c6:	ff 4f       	sbci	r31, 0xFF	; 255
    29c8:	55 c5       	rjmp	.+2730   	; 0x3474 <__tablejump2__>
			case 'a': {
				set_head_light(0);
    29ca:	80 e0       	ldi	r24, 0x00	; 0
    29cc:	0e 94 8d 02 	call	0x51a	; 0x51a <set_head_light>
				break;
    29d0:	d5 c0       	rjmp	.+426    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'A': {
				set_head_light(1);
    29d2:	81 e0       	ldi	r24, 0x01	; 1
    29d4:	0e 94 8d 02 	call	0x51a	; 0x51a <set_head_light>
				break;
    29d8:	d1 c0       	rjmp	.+418    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'b': {
				set_brake_light(0);
    29da:	80 e0       	ldi	r24, 0x00	; 0
    29dc:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
				break;
    29e0:	cd c0       	rjmp	.+410    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'B': {
				set_brake_light(1);
    29e2:	81 e0       	ldi	r24, 0x01	; 1
    29e4:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
				break;
    29e8:	c9 c0       	rjmp	.+402    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'c': {
				set_horn(0);
    29ea:	80 e0       	ldi	r24, 0x00	; 0
    29ec:	0e 94 87 02 	call	0x50e	; 0x50e <set_horn>
				break;
    29f0:	c5 c0       	rjmp	.+394    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'C': {
				set_horn(1);
    29f2:	81 e0       	ldi	r24, 0x01	; 1
    29f4:	0e 94 87 02 	call	0x50e	; 0x50e <set_horn>
				break;
    29f8:	c1 c0       	rjmp	.+386    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'd': {
				set_motor_speed(0);
    29fa:	80 e0       	ldi	r24, 0x00	; 0
    29fc:	0e 94 99 02 	call	0x532	; 0x532 <set_motor_speed>
				break;
    2a00:	bd c0       	rjmp	.+378    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'D': {
				set_motor_speed(65);
    2a02:	81 e4       	ldi	r24, 0x41	; 65
    2a04:	0e 94 99 02 	call	0x532	; 0x532 <set_motor_speed>
				break;
    2a08:	b9 c0       	rjmp	.+370    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'e': {
				set_brake(0);
    2a0a:	80 e0       	ldi	r24, 0x00	; 0
    2a0c:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <set_brake>
				break;
    2a10:	b5 c0       	rjmp	.+362    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'E': {
				set_brake(100);
    2a12:	84 e6       	ldi	r24, 0x64	; 100
    2a14:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <set_brake>
				break;
    2a18:	b1 c0       	rjmp	.+354    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'F': {
				uint16_t raw_x = get_raw_x_accel();
    2a1a:	0e 94 8e 03 	call	0x71c	; 0x71c <get_raw_x_accel>
    2a1e:	18 2f       	mov	r17, r24
    2a20:	09 2f       	mov	r16, r25
				uint16_t raw_y = get_raw_y_accel();
    2a22:	0e 94 96 03 	call	0x72c	; 0x72c <get_raw_y_accel>
    2a26:	f8 2e       	mov	r15, r24
    2a28:	e9 2e       	mov	r14, r25
				tick = xTaskGetTickCount();
    2a2a:	85 d8       	rcall	.-3830   	; 0x1b36 <xTaskGetTickCount>
    2a2c:	90 93 d6 1d 	sts	0x1DD6, r25
    2a30:	80 93 d5 1d 	sts	0x1DD5, r24
				//uint16_t raw_z = get_raw_z_accel();
				uint16_t raw_rx = get_raw_x_rotation();
    2a34:	0e 94 9e 03 	call	0x73c	; 0x73c <get_raw_x_rotation>
    2a38:	d8 2e       	mov	r13, r24
    2a3a:	c9 2e       	mov	r12, r25
				uint16_t raw_ry = get_raw_y_rotation();
    2a3c:	0e 94 a6 03 	call	0x74c	; 0x74c <get_raw_y_rotation>
    2a40:	b8 2e       	mov	r11, r24
    2a42:	a9 2e       	mov	r10, r25
				uint16_t tacho = get_tacho_count();
    2a44:	0e 94 b6 03 	call	0x76c	; 0x76c <get_tacho_count>
				sprintf(buf, "x%4dy%4dz%4dr%4dq%4dt%4d", raw_x, raw_y, tick, raw_rx, raw_ry, tacho);
    2a48:	9f 93       	push	r25
    2a4a:	8f 93       	push	r24
    2a4c:	af 92       	push	r10
    2a4e:	bf 92       	push	r11
    2a50:	cf 92       	push	r12
    2a52:	df 92       	push	r13
    2a54:	80 91 d6 1d 	lds	r24, 0x1DD6
    2a58:	8f 93       	push	r24
    2a5a:	80 91 d5 1d 	lds	r24, 0x1DD5
    2a5e:	8f 93       	push	r24
    2a60:	ef 92       	push	r14
    2a62:	ff 92       	push	r15
    2a64:	0f 93       	push	r16
    2a66:	1f 93       	push	r17
    2a68:	80 ea       	ldi	r24, 0xA0	; 160
    2a6a:	92 e0       	ldi	r25, 0x02	; 2
    2a6c:	9f 93       	push	r25
    2a6e:	8f 93       	push	r24
    2a70:	8e 01       	movw	r16, r28
    2a72:	0f 5f       	subi	r16, 0xFF	; 255
    2a74:	1f 4f       	sbci	r17, 0xFF	; 255
    2a76:	1f 93       	push	r17
    2a78:	0f 93       	push	r16
    2a7a:	7a d6       	rcall	.+3316   	; 0x3770 <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    2a7c:	f8 01       	movw	r30, r16
    2a7e:	01 90       	ld	r0, Z+
    2a80:	00 20       	and	r0, r0
    2a82:	e9 f7       	brne	.-6      	; 0x2a7e <bt_com_call_back+0xfa>
    2a84:	31 97       	sbiw	r30, 0x01	; 1
    2a86:	bf 01       	movw	r22, r30
    2a88:	60 1b       	sub	r22, r16
    2a8a:	71 0b       	sbc	r23, r17
    2a8c:	c8 01       	movw	r24, r16
    2a8e:	0e 94 d6 03 	call	0x7ac	; 0x7ac <bt_send_bytes>
				break;
    2a92:	0f b6       	in	r0, 0x3f	; 63
    2a94:	f8 94       	cli
    2a96:	de bf       	out	0x3e, r29	; 62
    2a98:	0f be       	out	0x3f, r0	; 63
    2a9a:	cd bf       	out	0x3d, r28	; 61
    2a9c:	6f c0       	rjmp	.+222    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'L': {
				xTaskCreate( vLearnTrack, "LearnTrack", configMINIMAL_STACK_SIZE, NULL, learn_TASK_PRIORITY, NULL);
    2a9e:	a1 2c       	mov	r10, r1
    2aa0:	b1 2c       	mov	r11, r1
    2aa2:	c1 2c       	mov	r12, r1
    2aa4:	d1 2c       	mov	r13, r1
    2aa6:	e1 2c       	mov	r14, r1
    2aa8:	f1 2c       	mov	r15, r1
    2aaa:	01 e0       	ldi	r16, 0x01	; 1
    2aac:	20 e0       	ldi	r18, 0x00	; 0
    2aae:	30 e0       	ldi	r19, 0x00	; 0
    2ab0:	49 eb       	ldi	r20, 0xB9	; 185
    2ab2:	50 e0       	ldi	r21, 0x00	; 0
    2ab4:	69 eb       	ldi	r22, 0xB9	; 185
    2ab6:	72 e0       	ldi	r23, 0x02	; 2
    2ab8:	8a ef       	ldi	r24, 0xFA	; 250
    2aba:	92 e1       	ldi	r25, 0x12	; 18
    2abc:	0e 94 2c 0c 	call	0x1858	; 0x1858 <xTaskGenericCreate>
				break;
    2ac0:	5d c0       	rjmp	.+186    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'R': {
				set_brake_light(0);
    2ac2:	80 e0       	ldi	r24, 0x00	; 0
    2ac4:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
				xTaskCreate( vCountTacho, "CountTacho", configMINIMAL_STACK_SIZE, NULL, count_tacho_TASK_PRIORITY, NULL );
    2ac8:	a1 2c       	mov	r10, r1
    2aca:	b1 2c       	mov	r11, r1
    2acc:	c1 2c       	mov	r12, r1
    2ace:	d1 2c       	mov	r13, r1
    2ad0:	e1 2c       	mov	r14, r1
    2ad2:	f1 2c       	mov	r15, r1
    2ad4:	01 e0       	ldi	r16, 0x01	; 1
    2ad6:	20 e0       	ldi	r18, 0x00	; 0
    2ad8:	30 e0       	ldi	r19, 0x00	; 0
    2ada:	49 eb       	ldi	r20, 0xB9	; 185
    2adc:	50 e0       	ldi	r21, 0x00	; 0
    2ade:	64 ec       	ldi	r22, 0xC4	; 196
    2ae0:	72 e0       	ldi	r23, 0x02	; 2
    2ae2:	84 e1       	ldi	r24, 0x14	; 20
    2ae4:	94 e1       	ldi	r25, 0x14	; 20
    2ae6:	0e 94 2c 0c 	call	0x1858	; 0x1858 <xTaskGenericCreate>
				xTaskCreate( vAdjustSpeed, "AdjustSpeed", configMINIMAL_STACK_SIZE, NULL, adjust_speed_TASK_PRIORITY, NULL );
    2aea:	20 e0       	ldi	r18, 0x00	; 0
    2aec:	30 e0       	ldi	r19, 0x00	; 0
    2aee:	49 eb       	ldi	r20, 0xB9	; 185
    2af0:	50 e0       	ldi	r21, 0x00	; 0
    2af2:	6f ec       	ldi	r22, 0xCF	; 207
    2af4:	72 e0       	ldi	r23, 0x02	; 2
    2af6:	8b e3       	ldi	r24, 0x3B	; 59
    2af8:	94 e1       	ldi	r25, 0x14	; 20
    2afa:	0e 94 2c 0c 	call	0x1858	; 0x1858 <xTaskGenericCreate>
				break;
    2afe:	3e c0       	rjmp	.+124    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 'S': {
				sendingDataFlag = 1;
    2b00:	81 e0       	ldi	r24, 0x01	; 1
    2b02:	90 e0       	ldi	r25, 0x00	; 0
    2b04:	90 93 78 17 	sts	0x1778, r25
    2b08:	80 93 77 17 	sts	0x1777, r24
				break;
    2b0c:	37 c0       	rjmp	.+110    	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			case 's': {
				set_brake_light(1);
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	0e 94 93 02 	call	0x526	; 0x526 <set_brake_light>
				sendingDataFlag = 0;
    2b14:	10 92 78 17 	sts	0x1778, r1
    2b18:	10 92 77 17 	sts	0x1777, r1
				break;
    2b1c:	2f c0       	rjmp	.+94     	; 0x2b7c <bt_com_call_back+0x1f8>
			}
			
			default: {
				if (sendingDataFlag == 1) {
    2b1e:	20 91 77 17 	lds	r18, 0x1777
    2b22:	30 91 78 17 	lds	r19, 0x1778
    2b26:	21 30       	cpi	r18, 0x01	; 1
    2b28:	31 05       	cpc	r19, r1
    2b2a:	41 f5       	brne	.+80     	; 0x2b7c <bt_com_call_back+0x1f8>
					sendValue[charCount] = byte;
    2b2c:	90 91 81 17 	lds	r25, 0x1781
    2b30:	e9 2f       	mov	r30, r25
    2b32:	f0 e0       	ldi	r31, 0x00	; 0
    2b34:	e4 58       	subi	r30, 0x84	; 132
    2b36:	f8 4e       	sbci	r31, 0xE8	; 232
    2b38:	80 83       	st	Z, r24
					charCount++;
    2b3a:	9f 5f       	subi	r25, 0xFF	; 255
    2b3c:	90 93 81 17 	sts	0x1781, r25
					if(byte == 33) {
    2b40:	81 32       	cpi	r24, 0x21	; 33
    2b42:	e1 f4       	brne	.+56     	; 0x2b7c <bt_com_call_back+0x1f8>
						set_horn(1);
    2b44:	81 e0       	ldi	r24, 0x01	; 1
    2b46:	0e 94 87 02 	call	0x50e	; 0x50e <set_horn>
						accData[nextVal] = atoi(sendValue);
    2b4a:	00 91 83 17 	lds	r16, 0x1783
    2b4e:	10 91 84 17 	lds	r17, 0x1784
    2b52:	8c e7       	ldi	r24, 0x7C	; 124
    2b54:	97 e1       	ldi	r25, 0x17	; 23
    2b56:	de d5       	rcall	.+3004   	; 0x3714 <atoi>
    2b58:	f8 01       	movw	r30, r16
    2b5a:	ee 0f       	add	r30, r30
    2b5c:	ff 1f       	adc	r31, r31
    2b5e:	eb 57       	subi	r30, 0x7B	; 123
    2b60:	f8 4e       	sbci	r31, 0xE8	; 232
    2b62:	91 83       	std	Z+1, r25	; 0x01
    2b64:	80 83       	st	Z, r24
						nextVal++;
    2b66:	0f 5f       	subi	r16, 0xFF	; 255
    2b68:	1f 4f       	sbci	r17, 0xFF	; 255
    2b6a:	10 93 84 17 	sts	0x1784, r17
    2b6e:	00 93 83 17 	sts	0x1783, r16
						charCount=0;
    2b72:	10 92 81 17 	sts	0x1781, r1
						set_horn(0);
    2b76:	80 e0       	ldi	r24, 0x00	; 0
    2b78:	0e 94 87 02 	call	0x50e	; 0x50e <set_horn>
					}
				}
			}
		}
	}
}
    2b7c:	a8 96       	adiw	r28, 0x28	; 40
    2b7e:	0f b6       	in	r0, 0x3f	; 63
    2b80:	f8 94       	cli
    2b82:	de bf       	out	0x3e, r29	; 62
    2b84:	0f be       	out	0x3f, r0	; 63
    2b86:	cd bf       	out	0x3d, r28	; 61
    2b88:	df 91       	pop	r29
    2b8a:	cf 91       	pop	r28
    2b8c:	1f 91       	pop	r17
    2b8e:	0f 91       	pop	r16
    2b90:	ff 90       	pop	r15
    2b92:	ef 90       	pop	r14
    2b94:	df 90       	pop	r13
    2b96:	cf 90       	pop	r12
    2b98:	bf 90       	pop	r11
    2b9a:	af 90       	pop	r10
    2b9c:	08 95       	ret

00002b9e <vstartupTask>:
			set_horn(0);
		}
	}
}

static void vstartupTask( void *pvParameters ) {
    2b9e:	cf 93       	push	r28
    2ba0:	df 93       	push	r29
    2ba2:	1f 92       	push	r1
    2ba4:	cd b7       	in	r28, 0x3d	; 61
    2ba6:	de b7       	in	r29, 0x3e	; 62
	/* The parameters are not used. */
	( void ) pvParameters;
	
	goal_line_semaphore = xSemaphoreCreateBinary();
    2ba8:	43 e0       	ldi	r20, 0x03	; 3
    2baa:	60 e0       	ldi	r22, 0x00	; 0
    2bac:	81 e0       	ldi	r24, 0x01	; 1
    2bae:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <xQueueGenericCreate>
    2bb2:	90 93 ca 1d 	sts	0x1DCA, r25
    2bb6:	80 93 c9 1d 	sts	0x1DC9, r24
	speed_adjusting_semaphore = xSemaphoreCreateBinary();
    2bba:	43 e0       	ldi	r20, 0x03	; 3
    2bbc:	60 e0       	ldi	r22, 0x00	; 0
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <xQueueGenericCreate>
    2bc4:	90 93 c8 1d 	sts	0x1DC8, r25
    2bc8:	80 93 c7 1d 	sts	0x1DC7, r24
	_xBT_received_chars_queue = xQueueCreate( _BT_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
    2bcc:	40 e0       	ldi	r20, 0x00	; 0
    2bce:	61 e0       	ldi	r22, 0x01	; 1
    2bd0:	8e e1       	ldi	r24, 0x1E	; 30
    2bd2:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <xQueueGenericCreate>
    2bd6:	90 93 c6 1d 	sts	0x1DC6, r25
    2bda:	80 93 c5 1d 	sts	0x1DC5, r24
	
	if( goal_line_semaphore == NULL ) {
    2bde:	80 91 c9 1d 	lds	r24, 0x1DC9
    2be2:	90 91 ca 1d 	lds	r25, 0x1DCA
    2be6:	00 97       	sbiw	r24, 0x00	; 0
    2be8:	11 f0       	breq	.+4      	; 0x2bee <vstartupTask+0x50>
		/* There was insufficient OpenRTOS heap available for the semaphore to
		be created successfully. */
	} else {
		set_goal_line_semaphore(goal_line_semaphore);
    2bea:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <set_goal_line_semaphore>
	}
	
	// Initialize Bluetooth Module
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    2bee:	88 ee       	ldi	r24, 0xE8	; 232
    2bf0:	93 e0       	ldi	r25, 0x03	; 3
    2bf2:	e4 d8       	rcall	.-3640   	; 0x1dbc <vTaskDelay>
	set_bt_reset(0);  // Disable reset line of Blue tooth module
    2bf4:	80 e0       	ldi	r24, 0x00	; 0
    2bf6:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <set_bt_reset>
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    2bfa:	88 ee       	ldi	r24, 0xE8	; 232
    2bfc:	93 e0       	ldi	r25, 0x03	; 3
    2bfe:	de d8       	rcall	.-3652   	; 0x1dbc <vTaskDelay>
	init_bt_module(bt_status_call_back, _xBT_received_chars_queue);
    2c00:	60 91 c5 1d 	lds	r22, 0x1DC5
    2c04:	70 91 c6 1d 	lds	r23, 0x1DC6
    2c08:	84 ef       	ldi	r24, 0xF4	; 244
    2c0a:	92 e1       	ldi	r25, 0x12	; 18
    2c0c:	0e 94 df 03 	call	0x7be	; 0x7be <init_bt_module>
	
	xTaskCreate( vGoalLineTask, "GoalLineTask", configMINIMAL_STACK_SIZE, NULL, goal_line_task_TASK_PRIORITY, NULL );
    2c10:	a1 2c       	mov	r10, r1
    2c12:	b1 2c       	mov	r11, r1
    2c14:	c1 2c       	mov	r12, r1
    2c16:	d1 2c       	mov	r13, r1
    2c18:	e1 2c       	mov	r14, r1
    2c1a:	f1 2c       	mov	r15, r1
    2c1c:	02 e0       	ldi	r16, 0x02	; 2
    2c1e:	20 e0       	ldi	r18, 0x00	; 0
    2c20:	30 e0       	ldi	r19, 0x00	; 0
    2c22:	49 eb       	ldi	r20, 0xB9	; 185
    2c24:	50 e0       	ldi	r21, 0x00	; 0
    2c26:	6b ed       	ldi	r22, 0xDB	; 219
    2c28:	72 e0       	ldi	r23, 0x02	; 2
    2c2a:	88 ea       	ldi	r24, 0xA8	; 168
    2c2c:	94 e1       	ldi	r25, 0x14	; 20
    2c2e:	0e 94 2c 0c 	call	0x1858	; 0x1858 <xTaskGenericCreate>
	
	uint8_t _byte;
	for( ;; ) {
		xQueueReceive( _xBT_received_chars_queue, &_byte, portMAX_DELAY );
    2c32:	20 e0       	ldi	r18, 0x00	; 0
    2c34:	4f ef       	ldi	r20, 0xFF	; 255
    2c36:	5f ef       	ldi	r21, 0xFF	; 255
    2c38:	be 01       	movw	r22, r28
    2c3a:	6f 5f       	subi	r22, 0xFF	; 255
    2c3c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c3e:	80 91 c5 1d 	lds	r24, 0x1DC5
    2c42:	90 91 c6 1d 	lds	r25, 0x1DC6
    2c46:	0e 94 0a 0b 	call	0x1614	; 0x1614 <xQueueGenericReceive>
		bt_com_call_back(_byte);
    2c4a:	89 81       	ldd	r24, Y+1	; 0x01
    2c4c:	9b de       	rcall	.-714    	; 0x2984 <bt_com_call_back>
		_byte = NULL;
    2c4e:	19 82       	std	Y+1, r1	; 0x01
    2c50:	f0 cf       	rjmp	.-32     	; 0x2c32 <vstartupTask+0x94>

00002c52 <main>:
	}
}

int main(void)
{
    2c52:	af 92       	push	r10
    2c54:	bf 92       	push	r11
    2c56:	cf 92       	push	r12
    2c58:	df 92       	push	r13
    2c5a:	ef 92       	push	r14
    2c5c:	ff 92       	push	r15
    2c5e:	0f 93       	push	r16
	init_main_board();
    2c60:	0e 94 bc 02 	call	0x578	; 0x578 <init_main_board>
	xTaskCreate( vstartupTask, "StartupTask", configMINIMAL_STACK_SIZE, NULL, startup_TASK_PRIORITY, NULL );
    2c64:	a1 2c       	mov	r10, r1
    2c66:	b1 2c       	mov	r11, r1
    2c68:	c1 2c       	mov	r12, r1
    2c6a:	d1 2c       	mov	r13, r1
    2c6c:	e1 2c       	mov	r14, r1
    2c6e:	f1 2c       	mov	r15, r1
    2c70:	01 e0       	ldi	r16, 0x01	; 1
    2c72:	20 e0       	ldi	r18, 0x00	; 0
    2c74:	30 e0       	ldi	r19, 0x00	; 0
    2c76:	49 eb       	ldi	r20, 0xB9	; 185
    2c78:	50 e0       	ldi	r21, 0x00	; 0
    2c7a:	68 ee       	ldi	r22, 0xE8	; 232
    2c7c:	72 e0       	ldi	r23, 0x02	; 2
    2c7e:	8f ec       	ldi	r24, 0xCF	; 207
    2c80:	95 e1       	ldi	r25, 0x15	; 21
    2c82:	0e 94 2c 0c 	call	0x1858	; 0x1858 <xTaskGenericCreate>
	vTaskStartScheduler();
    2c86:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskStartScheduler>
}
    2c8a:	80 e0       	ldi	r24, 0x00	; 0
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	0f 91       	pop	r16
    2c90:	ff 90       	pop	r15
    2c92:	ef 90       	pop	r14
    2c94:	df 90       	pop	r13
    2c96:	cf 90       	pop	r12
    2c98:	bf 90       	pop	r11
    2c9a:	af 90       	pop	r10
    2c9c:	08 95       	ret

00002c9e <vApplicationStackOverflowHook>:


// Called is TASK Stack overflows
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
    2c9e:	08 95       	ret

00002ca0 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
    2ca0:	4f 92       	push	r4
    2ca2:	5f 92       	push	r5
    2ca4:	6f 92       	push	r6
    2ca6:	7f 92       	push	r7
    2ca8:	8f 92       	push	r8
    2caa:	9f 92       	push	r9
    2cac:	af 92       	push	r10
    2cae:	bf 92       	push	r11
    2cb0:	cf 92       	push	r12
    2cb2:	df 92       	push	r13
    2cb4:	ff 92       	push	r15
    2cb6:	0f 93       	push	r16
    2cb8:	1f 93       	push	r17
    2cba:	cf 93       	push	r28
    2cbc:	df 93       	push	r29
    2cbe:	cd b7       	in	r28, 0x3d	; 61
    2cc0:	de b7       	in	r29, 0x3e	; 62
    2cc2:	f8 2e       	mov	r15, r24
    2cc4:	2a 01       	movw	r4, r20
    2cc6:	3b 01       	movw	r6, r22
    2cc8:	88 e0       	ldi	r24, 0x08	; 8
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	fc d3       	rcall	.+2040   	; 0x34c6 <malloc>
    2cce:	8c 01       	movw	r16, r24
    2cd0:	8f 2d       	mov	r24, r15
    2cd2:	90 e0       	ldi	r25, 0x00	; 0
    2cd4:	88 0f       	add	r24, r24
    2cd6:	99 1f       	adc	r25, r25
    2cd8:	fc 01       	movw	r30, r24
    2cda:	e5 53       	subi	r30, 0x35	; 53
    2cdc:	f2 4e       	sbci	r31, 0xE2	; 226
    2cde:	11 83       	std	Z+1, r17	; 0x01
    2ce0:	00 83       	st	Z, r16
    2ce2:	fc 01       	movw	r30, r24
    2ce4:	e5 5b       	subi	r30, 0xB5	; 181
    2ce6:	fd 4f       	sbci	r31, 0xFD	; 253
    2ce8:	80 81       	ld	r24, Z
    2cea:	91 81       	ldd	r25, Z+1	; 0x01
    2cec:	d8 01       	movw	r26, r16
    2cee:	11 96       	adiw	r26, 0x01	; 1
    2cf0:	9c 93       	st	X, r25
    2cf2:	8e 93       	st	-X, r24
    2cf4:	13 96       	adiw	r26, 0x03	; 3
    2cf6:	bc 92       	st	X, r11
    2cf8:	ae 92       	st	-X, r10
    2cfa:	12 97       	sbiw	r26, 0x02	; 2
    2cfc:	15 96       	adiw	r26, 0x05	; 5
    2cfe:	dc 92       	st	X, r13
    2d00:	ce 92       	st	-X, r12
    2d02:	14 97       	sbiw	r26, 0x04	; 4
    2d04:	17 96       	adiw	r26, 0x07	; 7
    2d06:	9c 92       	st	X, r9
    2d08:	8e 92       	st	-X, r8
    2d0a:	16 97       	sbiw	r26, 0x06	; 6
    2d0c:	ff b6       	in	r15, 0x3f	; 63
    2d0e:	f8 94       	cli
    2d10:	d8 01       	movw	r26, r16
    2d12:	ed 91       	ld	r30, X+
    2d14:	fc 91       	ld	r31, X
    2d16:	11 97       	sbiw	r26, 0x01	; 1
    2d18:	36 97       	sbiw	r30, 0x06	; 6
    2d1a:	80 81       	ld	r24, Z
    2d1c:	82 60       	ori	r24, 0x02	; 2
    2d1e:	80 83       	st	Z, r24
    2d20:	cd 90       	ld	r12, X+
    2d22:	dc 90       	ld	r13, X
    2d24:	44 0c       	add	r4, r4
    2d26:	55 1c       	adc	r5, r5
    2d28:	66 1c       	adc	r6, r6
    2d2a:	77 1c       	adc	r7, r7
    2d2c:	44 0c       	add	r4, r4
    2d2e:	55 1c       	adc	r5, r5
    2d30:	66 1c       	adc	r6, r6
    2d32:	77 1c       	adc	r7, r7
    2d34:	a3 01       	movw	r20, r6
    2d36:	92 01       	movw	r18, r4
    2d38:	22 0f       	add	r18, r18
    2d3a:	33 1f       	adc	r19, r19
    2d3c:	44 1f       	adc	r20, r20
    2d3e:	55 1f       	adc	r21, r21
    2d40:	60 e0       	ldi	r22, 0x00	; 0
    2d42:	74 e2       	ldi	r23, 0x24	; 36
    2d44:	84 ef       	ldi	r24, 0xF4	; 244
    2d46:	90 e0       	ldi	r25, 0x00	; 0
    2d48:	57 d3       	rcall	.+1710   	; 0x33f8 <__udivmodsi4>
    2d4a:	21 50       	subi	r18, 0x01	; 1
    2d4c:	f6 01       	movw	r30, r12
    2d4e:	32 97       	sbiw	r30, 0x02	; 2
    2d50:	20 83       	st	Z, r18
    2d52:	d8 01       	movw	r26, r16
    2d54:	ed 91       	ld	r30, X+
    2d56:	fc 91       	ld	r31, X
    2d58:	11 97       	sbiw	r26, 0x01	; 1
    2d5a:	35 97       	sbiw	r30, 0x05	; 5
    2d5c:	88 e9       	ldi	r24, 0x98	; 152
    2d5e:	80 83       	st	Z, r24
    2d60:	ed 91       	ld	r30, X+
    2d62:	fc 91       	ld	r31, X
    2d64:	34 97       	sbiw	r30, 0x04	; 4
    2d66:	86 e0       	ldi	r24, 0x06	; 6
    2d68:	80 83       	st	Z, r24
    2d6a:	ff be       	out	0x3f, r15	; 63
    2d6c:	c8 01       	movw	r24, r16
    2d6e:	df 91       	pop	r29
    2d70:	cf 91       	pop	r28
    2d72:	1f 91       	pop	r17
    2d74:	0f 91       	pop	r16
    2d76:	ff 90       	pop	r15
    2d78:	df 90       	pop	r13
    2d7a:	cf 90       	pop	r12
    2d7c:	bf 90       	pop	r11
    2d7e:	af 90       	pop	r10
    2d80:	9f 90       	pop	r9
    2d82:	8f 90       	pop	r8
    2d84:	7f 90       	pop	r7
    2d86:	6f 90       	pop	r6
    2d88:	5f 90       	pop	r5
    2d8a:	4f 90       	pop	r4
    2d8c:	08 95       	ret

00002d8e <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
    2d8e:	ef 92       	push	r14
    2d90:	ff 92       	push	r15
    2d92:	0f 93       	push	r16
    2d94:	1f 93       	push	r17
    2d96:	cf 93       	push	r28
    2d98:	df 93       	push	r29
    2d9a:	8c 01       	movw	r16, r24
    2d9c:	e4 2e       	mov	r14, r20
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    2d9e:	dc 01       	movw	r26, r24
    2da0:	12 96       	adiw	r26, 0x02	; 2
    2da2:	ed 91       	ld	r30, X+
    2da4:	fc 91       	ld	r31, X
    2da6:	13 97       	sbiw	r26, 0x03	; 3
    2da8:	30 97       	sbiw	r30, 0x00	; 0
    2daa:	69 f0       	breq	.+26     	; 0x2dc6 <serial_send_bytes+0x38>
    2dac:	24 2f       	mov	r18, r20
    2dae:	30 e0       	ldi	r19, 0x00	; 0
    2db0:	42 a5       	ldd	r20, Z+42	; 0x2a
    2db2:	88 e2       	ldi	r24, 0x28	; 40
    2db4:	90 e0       	ldi	r25, 0x00	; 0
    2db6:	84 1b       	sub	r24, r20
    2db8:	91 09       	sbc	r25, r1
    2dba:	82 17       	cp	r24, r18
    2dbc:	93 07       	cpc	r25, r19
    2dbe:	e4 f0       	brlt	.+56     	; 0x2df8 <serial_send_bytes+0x6a>
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2dc0:	e1 10       	cpse	r14, r1
    2dc2:	05 c0       	rjmp	.+10     	; 0x2dce <serial_send_bytes+0x40>
    2dc4:	10 c0       	rjmp	.+32     	; 0x2de6 <serial_send_bytes+0x58>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    2dc6:	b1 e0       	ldi	r27, 0x01	; 1
    2dc8:	b4 17       	cp	r27, r20
    2dca:	c0 f0       	brcs	.+48     	; 0x2dfc <serial_send_bytes+0x6e>
    2dcc:	f9 cf       	rjmp	.-14     	; 0x2dc0 <serial_send_bytes+0x32>
    2dce:	c6 2f       	mov	r28, r22
    2dd0:	d7 2f       	mov	r29, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2dd2:	f1 2c       	mov	r15, r1
		buffer_put_item(handle->_tx_buf, buf[i]);
    2dd4:	69 91       	ld	r22, Y+
    2dd6:	f8 01       	movw	r30, r16
    2dd8:	82 81       	ldd	r24, Z+2	; 0x02
    2dda:	93 81       	ldd	r25, Z+3	; 0x03
    2ddc:	0e 94 82 04 	call	0x904	; 0x904 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2de0:	f3 94       	inc	r15
    2de2:	fe 10       	cpse	r15, r14
    2de4:	f7 cf       	rjmp	.-18     	; 0x2dd4 <serial_send_bytes+0x46>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
    2de6:	d8 01       	movw	r26, r16
    2de8:	ed 91       	ld	r30, X+
    2dea:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
    2dec:	35 97       	sbiw	r30, 0x05	; 5
    2dee:	80 81       	ld	r24, Z
    2df0:	80 62       	ori	r24, 0x20	; 32
    2df2:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
    2df4:	80 e0       	ldi	r24, 0x00	; 0
    2df6:	03 c0       	rjmp	.+6      	; 0x2dfe <serial_send_bytes+0x70>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
    2df8:	82 e0       	ldi	r24, 0x02	; 2
    2dfa:	01 c0       	rjmp	.+2      	; 0x2dfe <serial_send_bytes+0x70>
    2dfc:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
    2dfe:	df 91       	pop	r29
    2e00:	cf 91       	pop	r28
    2e02:	1f 91       	pop	r17
    2e04:	0f 91       	pop	r16
    2e06:	ff 90       	pop	r15
    2e08:	ef 90       	pop	r14
    2e0a:	08 95       	ret

00002e0c <__vector_25>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    2e0c:	1f 92       	push	r1
    2e0e:	0f 92       	push	r0
    2e10:	0f b6       	in	r0, 0x3f	; 63
    2e12:	0f 92       	push	r0
    2e14:	11 24       	eor	r1, r1
    2e16:	0b b6       	in	r0, 0x3b	; 59
    2e18:	0f 92       	push	r0
    2e1a:	2f 93       	push	r18
    2e1c:	3f 93       	push	r19
    2e1e:	4f 93       	push	r20
    2e20:	5f 93       	push	r21
    2e22:	6f 93       	push	r22
    2e24:	7f 93       	push	r23
    2e26:	8f 93       	push	r24
    2e28:	9f 93       	push	r25
    2e2a:	af 93       	push	r26
    2e2c:	bf 93       	push	r27
    2e2e:	cf 93       	push	r28
    2e30:	ef 93       	push	r30
    2e32:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    2e34:	e0 91 cb 1d 	lds	r30, 0x1DCB
    2e38:	f0 91 cc 1d 	lds	r31, 0x1DCC
    2e3c:	30 97       	sbiw	r30, 0x00	; 0
    2e3e:	a1 f0       	breq	.+40     	; 0x2e68 <__vector_25+0x5c>
		item = UDR0;
    2e40:	c0 91 c6 00 	lds	r28, 0x00C6
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
    2e44:	6c 2f       	mov	r22, r28
    2e46:	84 81       	ldd	r24, Z+4	; 0x04
    2e48:	95 81       	ldd	r25, Z+5	; 0x05
    2e4a:	0e 94 82 04 	call	0x904	; 0x904 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
    2e4e:	80 91 cb 1d 	lds	r24, 0x1DCB
    2e52:	90 91 cc 1d 	lds	r25, 0x1DCC
    2e56:	dc 01       	movw	r26, r24
    2e58:	16 96       	adiw	r26, 0x06	; 6
    2e5a:	ed 91       	ld	r30, X+
    2e5c:	fc 91       	ld	r31, X
    2e5e:	17 97       	sbiw	r26, 0x07	; 7
    2e60:	30 97       	sbiw	r30, 0x00	; 0
    2e62:	11 f0       	breq	.+4      	; 0x2e68 <__vector_25+0x5c>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
    2e64:	6c 2f       	mov	r22, r28
    2e66:	19 95       	eicall
		}
	}
}
    2e68:	ff 91       	pop	r31
    2e6a:	ef 91       	pop	r30
    2e6c:	cf 91       	pop	r28
    2e6e:	bf 91       	pop	r27
    2e70:	af 91       	pop	r26
    2e72:	9f 91       	pop	r25
    2e74:	8f 91       	pop	r24
    2e76:	7f 91       	pop	r23
    2e78:	6f 91       	pop	r22
    2e7a:	5f 91       	pop	r21
    2e7c:	4f 91       	pop	r20
    2e7e:	3f 91       	pop	r19
    2e80:	2f 91       	pop	r18
    2e82:	0f 90       	pop	r0
    2e84:	0b be       	out	0x3b, r0	; 59
    2e86:	0f 90       	pop	r0
    2e88:	0f be       	out	0x3f, r0	; 63
    2e8a:	0f 90       	pop	r0
    2e8c:	1f 90       	pop	r1
    2e8e:	18 95       	reti

00002e90 <__vector_26>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
    2e90:	1f 92       	push	r1
    2e92:	0f 92       	push	r0
    2e94:	0f b6       	in	r0, 0x3f	; 63
    2e96:	0f 92       	push	r0
    2e98:	11 24       	eor	r1, r1
    2e9a:	0b b6       	in	r0, 0x3b	; 59
    2e9c:	0f 92       	push	r0
    2e9e:	2f 93       	push	r18
    2ea0:	3f 93       	push	r19
    2ea2:	4f 93       	push	r20
    2ea4:	5f 93       	push	r21
    2ea6:	6f 93       	push	r22
    2ea8:	7f 93       	push	r23
    2eaa:	8f 93       	push	r24
    2eac:	9f 93       	push	r25
    2eae:	af 93       	push	r26
    2eb0:	bf 93       	push	r27
    2eb2:	ef 93       	push	r30
    2eb4:	ff 93       	push	r31
    2eb6:	cf 93       	push	r28
    2eb8:	df 93       	push	r29
    2eba:	1f 92       	push	r1
    2ebc:	cd b7       	in	r28, 0x3d	; 61
    2ebe:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    2ec0:	e0 91 cb 1d 	lds	r30, 0x1DCB
    2ec4:	f0 91 cc 1d 	lds	r31, 0x1DCC
    2ec8:	30 97       	sbiw	r30, 0x00	; 0
    2eca:	99 f0       	breq	.+38     	; 0x2ef2 <__vector_26+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
    2ecc:	be 01       	movw	r22, r28
    2ece:	6f 5f       	subi	r22, 0xFF	; 255
    2ed0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed2:	82 81       	ldd	r24, Z+2	; 0x02
    2ed4:	93 81       	ldd	r25, Z+3	; 0x03
    2ed6:	0e 94 68 04 	call	0x8d0	; 0x8d0 <buffer_get_item>
    2eda:	81 11       	cpse	r24, r1
    2edc:	04 c0       	rjmp	.+8      	; 0x2ee6 <__vector_26+0x56>
			UDR0 = item;
    2ede:	89 81       	ldd	r24, Y+1	; 0x01
    2ee0:	80 93 c6 00 	sts	0x00C6, r24
    2ee4:	0b c0       	rjmp	.+22     	; 0x2efc <__vector_26+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
    2ee6:	e1 ec       	ldi	r30, 0xC1	; 193
    2ee8:	f0 e0       	ldi	r31, 0x00	; 0
    2eea:	80 81       	ld	r24, Z
    2eec:	8f 7d       	andi	r24, 0xDF	; 223
    2eee:	80 83       	st	Z, r24
    2ef0:	05 c0       	rjmp	.+10     	; 0x2efc <__vector_26+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    2ef2:	e1 ec       	ldi	r30, 0xC1	; 193
    2ef4:	f0 e0       	ldi	r31, 0x00	; 0
    2ef6:	80 81       	ld	r24, Z
    2ef8:	8f 7d       	andi	r24, 0xDF	; 223
    2efa:	80 83       	st	Z, r24
	}
}
    2efc:	0f 90       	pop	r0
    2efe:	df 91       	pop	r29
    2f00:	cf 91       	pop	r28
    2f02:	ff 91       	pop	r31
    2f04:	ef 91       	pop	r30
    2f06:	bf 91       	pop	r27
    2f08:	af 91       	pop	r26
    2f0a:	9f 91       	pop	r25
    2f0c:	8f 91       	pop	r24
    2f0e:	7f 91       	pop	r23
    2f10:	6f 91       	pop	r22
    2f12:	5f 91       	pop	r21
    2f14:	4f 91       	pop	r20
    2f16:	3f 91       	pop	r19
    2f18:	2f 91       	pop	r18
    2f1a:	0f 90       	pop	r0
    2f1c:	0b be       	out	0x3b, r0	; 59
    2f1e:	0f 90       	pop	r0
    2f20:	0f be       	out	0x3f, r0	; 63
    2f22:	0f 90       	pop	r0
    2f24:	1f 90       	pop	r1
    2f26:	18 95       	reti

00002f28 <__vector_36>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    2f28:	1f 92       	push	r1
    2f2a:	0f 92       	push	r0
    2f2c:	0f b6       	in	r0, 0x3f	; 63
    2f2e:	0f 92       	push	r0
    2f30:	11 24       	eor	r1, r1
    2f32:	0b b6       	in	r0, 0x3b	; 59
    2f34:	0f 92       	push	r0
    2f36:	2f 93       	push	r18
    2f38:	3f 93       	push	r19
    2f3a:	4f 93       	push	r20
    2f3c:	5f 93       	push	r21
    2f3e:	6f 93       	push	r22
    2f40:	7f 93       	push	r23
    2f42:	8f 93       	push	r24
    2f44:	9f 93       	push	r25
    2f46:	af 93       	push	r26
    2f48:	bf 93       	push	r27
    2f4a:	cf 93       	push	r28
    2f4c:	ef 93       	push	r30
    2f4e:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    2f50:	e0 91 cd 1d 	lds	r30, 0x1DCD
    2f54:	f0 91 ce 1d 	lds	r31, 0x1DCE
    2f58:	30 97       	sbiw	r30, 0x00	; 0
    2f5a:	a1 f0       	breq	.+40     	; 0x2f84 <__vector_36+0x5c>
		item = UDR1;
    2f5c:	c0 91 ce 00 	lds	r28, 0x00CE
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    2f60:	6c 2f       	mov	r22, r28
    2f62:	84 81       	ldd	r24, Z+4	; 0x04
    2f64:	95 81       	ldd	r25, Z+5	; 0x05
    2f66:	0e 94 82 04 	call	0x904	; 0x904 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    2f6a:	80 91 cd 1d 	lds	r24, 0x1DCD
    2f6e:	90 91 ce 1d 	lds	r25, 0x1DCE
    2f72:	dc 01       	movw	r26, r24
    2f74:	16 96       	adiw	r26, 0x06	; 6
    2f76:	ed 91       	ld	r30, X+
    2f78:	fc 91       	ld	r31, X
    2f7a:	17 97       	sbiw	r26, 0x07	; 7
    2f7c:	30 97       	sbiw	r30, 0x00	; 0
    2f7e:	11 f0       	breq	.+4      	; 0x2f84 <__vector_36+0x5c>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    2f80:	6c 2f       	mov	r22, r28
    2f82:	19 95       	eicall
		}
	}
}
    2f84:	ff 91       	pop	r31
    2f86:	ef 91       	pop	r30
    2f88:	cf 91       	pop	r28
    2f8a:	bf 91       	pop	r27
    2f8c:	af 91       	pop	r26
    2f8e:	9f 91       	pop	r25
    2f90:	8f 91       	pop	r24
    2f92:	7f 91       	pop	r23
    2f94:	6f 91       	pop	r22
    2f96:	5f 91       	pop	r21
    2f98:	4f 91       	pop	r20
    2f9a:	3f 91       	pop	r19
    2f9c:	2f 91       	pop	r18
    2f9e:	0f 90       	pop	r0
    2fa0:	0b be       	out	0x3b, r0	; 59
    2fa2:	0f 90       	pop	r0
    2fa4:	0f be       	out	0x3f, r0	; 63
    2fa6:	0f 90       	pop	r0
    2fa8:	1f 90       	pop	r1
    2faa:	18 95       	reti

00002fac <__vector_37>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    2fac:	1f 92       	push	r1
    2fae:	0f 92       	push	r0
    2fb0:	0f b6       	in	r0, 0x3f	; 63
    2fb2:	0f 92       	push	r0
    2fb4:	11 24       	eor	r1, r1
    2fb6:	0b b6       	in	r0, 0x3b	; 59
    2fb8:	0f 92       	push	r0
    2fba:	2f 93       	push	r18
    2fbc:	3f 93       	push	r19
    2fbe:	4f 93       	push	r20
    2fc0:	5f 93       	push	r21
    2fc2:	6f 93       	push	r22
    2fc4:	7f 93       	push	r23
    2fc6:	8f 93       	push	r24
    2fc8:	9f 93       	push	r25
    2fca:	af 93       	push	r26
    2fcc:	bf 93       	push	r27
    2fce:	ef 93       	push	r30
    2fd0:	ff 93       	push	r31
    2fd2:	cf 93       	push	r28
    2fd4:	df 93       	push	r29
    2fd6:	1f 92       	push	r1
    2fd8:	cd b7       	in	r28, 0x3d	; 61
    2fda:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    2fdc:	e0 91 cd 1d 	lds	r30, 0x1DCD
    2fe0:	f0 91 ce 1d 	lds	r31, 0x1DCE
    2fe4:	30 97       	sbiw	r30, 0x00	; 0
    2fe6:	99 f0       	breq	.+38     	; 0x300e <__vector_37+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    2fe8:	be 01       	movw	r22, r28
    2fea:	6f 5f       	subi	r22, 0xFF	; 255
    2fec:	7f 4f       	sbci	r23, 0xFF	; 255
    2fee:	82 81       	ldd	r24, Z+2	; 0x02
    2ff0:	93 81       	ldd	r25, Z+3	; 0x03
    2ff2:	0e 94 68 04 	call	0x8d0	; 0x8d0 <buffer_get_item>
    2ff6:	81 11       	cpse	r24, r1
    2ff8:	04 c0       	rjmp	.+8      	; 0x3002 <__vector_37+0x56>
			UDR1 = item;
    2ffa:	89 81       	ldd	r24, Y+1	; 0x01
    2ffc:	80 93 ce 00 	sts	0x00CE, r24
    3000:	0b c0       	rjmp	.+22     	; 0x3018 <__vector_37+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    3002:	e9 ec       	ldi	r30, 0xC9	; 201
    3004:	f0 e0       	ldi	r31, 0x00	; 0
    3006:	80 81       	ld	r24, Z
    3008:	8f 7d       	andi	r24, 0xDF	; 223
    300a:	80 83       	st	Z, r24
    300c:	05 c0       	rjmp	.+10     	; 0x3018 <__vector_37+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    300e:	e9 ec       	ldi	r30, 0xC9	; 201
    3010:	f0 e0       	ldi	r31, 0x00	; 0
    3012:	80 81       	ld	r24, Z
    3014:	8f 7d       	andi	r24, 0xDF	; 223
    3016:	80 83       	st	Z, r24
	}
}
    3018:	0f 90       	pop	r0
    301a:	df 91       	pop	r29
    301c:	cf 91       	pop	r28
    301e:	ff 91       	pop	r31
    3020:	ef 91       	pop	r30
    3022:	bf 91       	pop	r27
    3024:	af 91       	pop	r26
    3026:	9f 91       	pop	r25
    3028:	8f 91       	pop	r24
    302a:	7f 91       	pop	r23
    302c:	6f 91       	pop	r22
    302e:	5f 91       	pop	r21
    3030:	4f 91       	pop	r20
    3032:	3f 91       	pop	r19
    3034:	2f 91       	pop	r18
    3036:	0f 90       	pop	r0
    3038:	0b be       	out	0x3b, r0	; 59
    303a:	0f 90       	pop	r0
    303c:	0f be       	out	0x3f, r0	; 63
    303e:	0f 90       	pop	r0
    3040:	1f 90       	pop	r1
    3042:	18 95       	reti

00003044 <_select_instance>:
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    3044:	e0 91 d0 1d 	lds	r30, 0x1DD0
    3048:	f0 91 d1 1d 	lds	r31, 0x1DD1
    304c:	30 97       	sbiw	r30, 0x00	; 0
    304e:	01 f1       	breq	.+64     	; 0x3090 <_select_instance+0x4c>
    3050:	23 81       	ldd	r18, Z+3	; 0x03
    3052:	21 30       	cpi	r18, 0x01	; 1
    3054:	79 f4       	brne	.+30     	; 0x3074 <_select_instance+0x30>
    3056:	a0 81       	ld	r26, Z
    3058:	b1 81       	ldd	r27, Z+1	; 0x01
    305a:	4c 91       	ld	r20, X
    305c:	21 e0       	ldi	r18, 0x01	; 1
    305e:	30 e0       	ldi	r19, 0x00	; 0
    3060:	02 80       	ldd	r0, Z+2	; 0x02
    3062:	02 c0       	rjmp	.+4      	; 0x3068 <_select_instance+0x24>
    3064:	22 0f       	add	r18, r18
    3066:	33 1f       	adc	r19, r19
    3068:	0a 94       	dec	r0
    306a:	e2 f7       	brpl	.-8      	; 0x3064 <_select_instance+0x20>
    306c:	20 95       	com	r18
    306e:	24 23       	and	r18, r20
    3070:	2c 93       	st	X, r18
    3072:	0e c0       	rjmp	.+28     	; 0x3090 <_select_instance+0x4c>
    3074:	a0 81       	ld	r26, Z
    3076:	b1 81       	ldd	r27, Z+1	; 0x01
    3078:	6c 91       	ld	r22, X
    307a:	41 e0       	ldi	r20, 0x01	; 1
    307c:	50 e0       	ldi	r21, 0x00	; 0
    307e:	9a 01       	movw	r18, r20
    3080:	02 80       	ldd	r0, Z+2	; 0x02
    3082:	02 c0       	rjmp	.+4      	; 0x3088 <_select_instance+0x44>
    3084:	22 0f       	add	r18, r18
    3086:	33 1f       	adc	r19, r19
    3088:	0a 94       	dec	r0
    308a:	e2 f7       	brpl	.-8      	; 0x3084 <_select_instance+0x40>
    308c:	26 2b       	or	r18, r22
    308e:	2c 93       	st	X, r18
    3090:	90 93 d1 1d 	sts	0x1DD1, r25
    3094:	80 93 d0 1d 	sts	0x1DD0, r24
    3098:	00 97       	sbiw	r24, 0x00	; 0
    309a:	69 f0       	breq	.+26     	; 0x30b6 <_select_instance+0x72>
    309c:	10 92 d2 1d 	sts	0x1DD2, r1
    30a0:	2c b5       	in	r18, 0x2c	; 44
    30a2:	2f 73       	andi	r18, 0x3F	; 63
    30a4:	2c bd       	out	0x2c, r18	; 44
    30a6:	fc 01       	movw	r30, r24
    30a8:	24 81       	ldd	r18, Z+4	; 0x04
    30aa:	2c bd       	out	0x2c, r18	; 44
    30ac:	85 81       	ldd	r24, Z+5	; 0x05
    30ae:	8d bd       	out	0x2d, r24	; 45
    30b0:	8c b5       	in	r24, 0x2c	; 44
    30b2:	80 64       	ori	r24, 0x40	; 64
    30b4:	8c bd       	out	0x2c, r24	; 44
    30b6:	08 95       	ret

000030b8 <spi_new_instance>:
    30b8:	6f 92       	push	r6
    30ba:	7f 92       	push	r7
    30bc:	8f 92       	push	r8
    30be:	9f 92       	push	r9
    30c0:	af 92       	push	r10
    30c2:	bf 92       	push	r11
    30c4:	cf 92       	push	r12
    30c6:	df 92       	push	r13
    30c8:	ef 92       	push	r14
    30ca:	ff 92       	push	r15
    30cc:	0f 93       	push	r16
    30ce:	1f 93       	push	r17
    30d0:	cf 93       	push	r28
    30d2:	df 93       	push	r29
    30d4:	cd b7       	in	r28, 0x3d	; 61
    30d6:	de b7       	in	r29, 0x3e	; 62
    30d8:	d8 2e       	mov	r13, r24
    30da:	f6 2e       	mov	r15, r22
    30dc:	64 2e       	mov	r6, r20
    30de:	72 2e       	mov	r7, r18
    30e0:	80 91 cf 1d 	lds	r24, 0x1DCF
    30e4:	81 11       	cpse	r24, r1
    30e6:	06 c0       	rjmp	.+12     	; 0x30f4 <spi_new_instance+0x3c>
    30e8:	84 b1       	in	r24, 0x04	; 4
    30ea:	87 60       	ori	r24, 0x07	; 7
    30ec:	84 b9       	out	0x04, r24	; 4
    30ee:	81 e0       	ldi	r24, 0x01	; 1
    30f0:	80 93 cf 1d 	sts	0x1DCF, r24
    30f4:	8c e0       	ldi	r24, 0x0C	; 12
    30f6:	90 e0       	ldi	r25, 0x00	; 0
    30f8:	e6 d1       	rcall	.+972    	; 0x34c6 <malloc>
    30fa:	fc 01       	movw	r30, r24
    30fc:	00 83       	st	Z, r16
    30fe:	11 83       	std	Z+1, r17	; 0x01
    3100:	e2 82       	std	Z+2, r14	; 0x02
    3102:	a0 2f       	mov	r26, r16
    3104:	b1 2f       	mov	r27, r17
    3106:	4e 91       	ld	r20, -X
    3108:	21 e0       	ldi	r18, 0x01	; 1
    310a:	30 e0       	ldi	r19, 0x00	; 0
    310c:	c9 01       	movw	r24, r18
    310e:	02 c0       	rjmp	.+4      	; 0x3114 <spi_new_instance+0x5c>
    3110:	88 0f       	add	r24, r24
    3112:	99 1f       	adc	r25, r25
    3114:	ea 94       	dec	r14
    3116:	e2 f7       	brpl	.-8      	; 0x3110 <spi_new_instance+0x58>
    3118:	84 2b       	or	r24, r20
    311a:	8c 93       	st	X, r24
    311c:	c3 82       	std	Z+3, r12	; 0x03
    311e:	66 0c       	add	r6, r6
    3120:	66 0c       	add	r6, r6
    3122:	76 28       	or	r7, r6
    3124:	af 2d       	mov	r26, r15
    3126:	bb 27       	eor	r27, r27
    3128:	a7 fd       	sbrc	r26, 7
    312a:	b0 95       	com	r27
    312c:	ac 50       	subi	r26, 0x0C	; 12
    312e:	bd 4f       	sbci	r27, 0xFD	; 253
    3130:	6c 90       	ld	r6, X
    3132:	d6 28       	or	r13, r6
    3134:	d7 28       	or	r13, r7
    3136:	d4 82       	std	Z+4, r13	; 0x04
    3138:	83 e0       	ldi	r24, 0x03	; 3
    313a:	8f 15       	cp	r24, r15
    313c:	14 f4       	brge	.+4      	; 0x3142 <spi_new_instance+0x8a>
    313e:	81 e0       	ldi	r24, 0x01	; 1
    3140:	85 83       	std	Z+5, r24	; 0x05
    3142:	97 82       	std	Z+7, r9	; 0x07
    3144:	86 82       	std	Z+6, r8	; 0x06
    3146:	b1 86       	std	Z+9, r11	; 0x09
    3148:	a0 86       	std	Z+8, r10	; 0x08
    314a:	8a 89       	ldd	r24, Y+18	; 0x12
    314c:	9b 89       	ldd	r25, Y+19	; 0x13
    314e:	93 87       	std	Z+11, r25	; 0x0b
    3150:	82 87       	std	Z+10, r24	; 0x0a
    3152:	6f b7       	in	r22, 0x3f	; 63
    3154:	f8 94       	cli
    3156:	80 91 d0 1d 	lds	r24, 0x1DD0
    315a:	90 91 d1 1d 	lds	r25, 0x1DD1
    315e:	f0 93 d1 1d 	sts	0x1DD1, r31
    3162:	e0 93 d0 1d 	sts	0x1DD0, r30
    3166:	23 81       	ldd	r18, Z+3	; 0x03
    3168:	21 30       	cpi	r18, 0x01	; 1
    316a:	81 f4       	brne	.+32     	; 0x318c <spi_new_instance+0xd4>
    316c:	a0 81       	ld	r26, Z
    316e:	b1 81       	ldd	r27, Z+1	; 0x01
    3170:	7c 91       	ld	r23, X
    3172:	41 e0       	ldi	r20, 0x01	; 1
    3174:	50 e0       	ldi	r21, 0x00	; 0
    3176:	9a 01       	movw	r18, r20
    3178:	02 80       	ldd	r0, Z+2	; 0x02
    317a:	02 c0       	rjmp	.+4      	; 0x3180 <spi_new_instance+0xc8>
    317c:	22 0f       	add	r18, r18
    317e:	33 1f       	adc	r19, r19
    3180:	0a 94       	dec	r0
    3182:	e2 f7       	brpl	.-8      	; 0x317c <spi_new_instance+0xc4>
    3184:	20 95       	com	r18
    3186:	27 23       	and	r18, r23
    3188:	2c 93       	st	X, r18
    318a:	0e c0       	rjmp	.+28     	; 0x31a8 <spi_new_instance+0xf0>
    318c:	a0 81       	ld	r26, Z
    318e:	b1 81       	ldd	r27, Z+1	; 0x01
    3190:	7c 91       	ld	r23, X
    3192:	41 e0       	ldi	r20, 0x01	; 1
    3194:	50 e0       	ldi	r21, 0x00	; 0
    3196:	9a 01       	movw	r18, r20
    3198:	02 80       	ldd	r0, Z+2	; 0x02
    319a:	02 c0       	rjmp	.+4      	; 0x31a0 <spi_new_instance+0xe8>
    319c:	22 0f       	add	r18, r18
    319e:	33 1f       	adc	r19, r19
    31a0:	0a 94       	dec	r0
    31a2:	e2 f7       	brpl	.-8      	; 0x319c <spi_new_instance+0xe4>
    31a4:	27 2b       	or	r18, r23
    31a6:	2c 93       	st	X, r18
    31a8:	90 93 d1 1d 	sts	0x1DD1, r25
    31ac:	80 93 d0 1d 	sts	0x1DD0, r24
    31b0:	6f bf       	out	0x3f, r22	; 63
    31b2:	cf 01       	movw	r24, r30
    31b4:	df 91       	pop	r29
    31b6:	cf 91       	pop	r28
    31b8:	1f 91       	pop	r17
    31ba:	0f 91       	pop	r16
    31bc:	ff 90       	pop	r15
    31be:	ef 90       	pop	r14
    31c0:	df 90       	pop	r13
    31c2:	cf 90       	pop	r12
    31c4:	bf 90       	pop	r11
    31c6:	af 90       	pop	r10
    31c8:	9f 90       	pop	r9
    31ca:	8f 90       	pop	r8
    31cc:	7f 90       	pop	r7
    31ce:	6f 90       	pop	r6
    31d0:	08 95       	ret

000031d2 <spi_send_string>:
SPI_ILLEGAL_INSTANCE: instance is null.
@param spi to send to.
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
    31d2:	df 92       	push	r13
    31d4:	ef 92       	push	r14
    31d6:	ff 92       	push	r15
    31d8:	0f 93       	push	r16
    31da:	1f 93       	push	r17
    31dc:	cf 93       	push	r28
    31de:	df 93       	push	r29
    31e0:	ec 01       	movw	r28, r24
    31e2:	8b 01       	movw	r16, r22
    31e4:	f4 2e       	mov	r15, r20
	if (spi == 0) {
    31e6:	00 97       	sbiw	r24, 0x00	; 0
    31e8:	09 f4       	brne	.+2      	; 0x31ec <spi_send_string+0x1a>
    31ea:	6b c0       	rjmp	.+214    	; 0x32c2 <spi_send_string+0xf0>
		return SPI_ILLEGAL_INSTANCE;
	}

	// Select correct instance
	if (_this != spi ) {
    31ec:	80 91 d0 1d 	lds	r24, 0x1DD0
    31f0:	90 91 d1 1d 	lds	r25, 0x1DD1
    31f4:	8c 17       	cp	r24, r28
    31f6:	9d 07       	cpc	r25, r29
    31f8:	11 f0       	breq	.+4      	; 0x31fe <spi_send_string+0x2c>
		_select_instance(spi);
    31fa:	ce 01       	movw	r24, r28
    31fc:	23 df       	rcall	.-442    	; 0x3044 <_select_instance>
	uint8_t tmp = 0;

	// Critical section
	{
		// disable interrupt
		uint8_t c_sreg = SREG;
    31fe:	ef b6       	in	r14, 0x3f	; 63
		cli();
    3200:	f8 94       	cli

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
    3202:	ee 81       	ldd	r30, Y+6	; 0x06
    3204:	ff 81       	ldd	r31, Y+7	; 0x07
    3206:	30 97       	sbiw	r30, 0x00	; 0
    3208:	61 f0       	breq	.+24     	; 0x3222 <spi_send_string+0x50>
    320a:	2f 2d       	mov	r18, r15
    320c:	30 e0       	ldi	r19, 0x00	; 0
    320e:	42 a5       	ldd	r20, Z+42	; 0x2a
    3210:	88 e2       	ldi	r24, 0x28	; 40
    3212:	90 e0       	ldi	r25, 0x00	; 0
    3214:	84 1b       	sub	r24, r20
    3216:	91 09       	sbc	r25, r1
    3218:	82 17       	cp	r24, r18
    321a:	93 07       	cpc	r25, r19
    321c:	0c f4       	brge	.+2      	; 0x3220 <spi_send_string+0x4e>
    321e:	48 c0       	rjmp	.+144    	; 0x32b0 <spi_send_string+0xde>
    3220:	04 c0       	rjmp	.+8      	; 0x322a <spi_send_string+0x58>
    3222:	81 e0       	ldi	r24, 0x01	; 1
    3224:	8f 15       	cp	r24, r15
    3226:	08 f4       	brcc	.+2      	; 0x322a <spi_send_string+0x58>
    3228:	45 c0       	rjmp	.+138    	; 0x32b4 <spi_send_string+0xe2>
			result = SPI_NO_ROOM_IN_TX_BUFFER;
			} else {
			// If SPI in idle send the first byte
			if (!_spi_active) {
    322a:	80 91 d2 1d 	lds	r24, 0x1DD2
    322e:	81 11       	cpse	r24, r1
    3230:	30 c0       	rjmp	.+96     	; 0x3292 <spi_send_string+0xc0>
				_spi_active = 1;
    3232:	81 e0       	ldi	r24, 0x01	; 1
    3234:	80 93 d2 1d 	sts	0x1DD2, r24
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    3238:	e0 91 d0 1d 	lds	r30, 0x1DD0
    323c:	f0 91 d1 1d 	lds	r31, 0x1DD1
    3240:	83 81       	ldd	r24, Z+3	; 0x03
    3242:	81 30       	cpi	r24, 0x01	; 1
    3244:	79 f4       	brne	.+30     	; 0x3264 <spi_send_string+0x92>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    3246:	a0 81       	ld	r26, Z
    3248:	b1 81       	ldd	r27, Z+1	; 0x01
    324a:	4c 91       	ld	r20, X
    324c:	21 e0       	ldi	r18, 0x01	; 1
    324e:	30 e0       	ldi	r19, 0x00	; 0
    3250:	c9 01       	movw	r24, r18
    3252:	02 80       	ldd	r0, Z+2	; 0x02
    3254:	02 c0       	rjmp	.+4      	; 0x325a <spi_send_string+0x88>
    3256:	88 0f       	add	r24, r24
    3258:	99 1f       	adc	r25, r25
    325a:	0a 94       	dec	r0
    325c:	e2 f7       	brpl	.-8      	; 0x3256 <spi_send_string+0x84>
    325e:	84 2b       	or	r24, r20
    3260:	8c 93       	st	X, r24
    3262:	0e c0       	rjmp	.+28     	; 0x3280 <spi_send_string+0xae>
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
		}
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    3264:	a0 81       	ld	r26, Z
    3266:	b1 81       	ldd	r27, Z+1	; 0x01
    3268:	2c 91       	ld	r18, X
    326a:	81 e0       	ldi	r24, 0x01	; 1
    326c:	90 e0       	ldi	r25, 0x00	; 0
    326e:	02 80       	ldd	r0, Z+2	; 0x02
    3270:	02 c0       	rjmp	.+4      	; 0x3276 <spi_send_string+0xa4>
    3272:	88 0f       	add	r24, r24
    3274:	99 1f       	adc	r25, r25
    3276:	0a 94       	dec	r0
    3278:	e2 f7       	brpl	.-8      	; 0x3272 <spi_send_string+0xa0>
    327a:	80 95       	com	r24
    327c:	82 23       	and	r24, r18
    327e:	8c 93       	st	X, r24
			// If SPI in idle send the first byte
			if (!_spi_active) {
				_spi_active = 1;
				_set_cs(CS_ACTIVE);
				// Enable SPI interrupt
				SPCR |= _BV(SPIE);
    3280:	8c b5       	in	r24, 0x2c	; 44
    3282:	80 68       	ori	r24, 0x80	; 128
    3284:	8c bd       	out	0x2c, r24	; 44
				// Send first byte
				SPDR =buf[0];
    3286:	f8 01       	movw	r30, r16
    3288:	80 81       	ld	r24, Z
    328a:	8e bd       	out	0x2e, r24	; 46

				tmp = 1;
    328c:	dd 24       	eor	r13, r13
    328e:	d3 94       	inc	r13
    3290:	01 c0       	rjmp	.+2      	; 0x3294 <spi_send_string+0xc2>
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
	uint8_t tmp = 0;
    3292:	d1 2c       	mov	r13, r1
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    3294:	df 14       	cp	r13, r15
    3296:	80 f4       	brcc	.+32     	; 0x32b8 <spi_send_string+0xe6>
				buffer_put_item(spi->_tx_buf, buf[i]);
    3298:	f8 01       	movw	r30, r16
    329a:	ed 0d       	add	r30, r13
    329c:	f1 1d       	adc	r31, r1
    329e:	60 81       	ld	r22, Z
    32a0:	8e 81       	ldd	r24, Y+6	; 0x06
    32a2:	9f 81       	ldd	r25, Y+7	; 0x07
    32a4:	0e 94 82 04 	call	0x904	; 0x904 <buffer_put_item>
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    32a8:	d3 94       	inc	r13
    32aa:	df 14       	cp	r13, r15
    32ac:	a8 f3       	brcs	.-22     	; 0x3298 <spi_send_string+0xc6>
    32ae:	06 c0       	rjmp	.+12     	; 0x32bc <spi_send_string+0xea>
		uint8_t c_sreg = SREG;
		cli();

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
			result = SPI_NO_ROOM_IN_TX_BUFFER;
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	05 c0       	rjmp	.+10     	; 0x32be <spi_send_string+0xec>
    32b4:	81 e0       	ldi	r24, 0x01	; 1
    32b6:	03 c0       	rjmp	.+6      	; 0x32be <spi_send_string+0xec>
	// Select correct instance
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
    32b8:	80 e0       	ldi	r24, 0x00	; 0
    32ba:	01 c0       	rjmp	.+2      	; 0x32be <spi_send_string+0xec>
    32bc:	80 e0       	ldi	r24, 0x00	; 0
				buffer_put_item(spi->_tx_buf, buf[i]);
			}
		}

		// restore interrupt state
		SREG = c_sreg;
    32be:	ef be       	out	0x3f, r14	; 63
	}

	return result;
    32c0:	01 c0       	rjmp	.+2      	; 0x32c4 <spi_send_string+0xf2>
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
	if (spi == 0) {
		return SPI_ILLEGAL_INSTANCE;
    32c2:	83 e0       	ldi	r24, 0x03	; 3
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    32c4:	df 91       	pop	r29
    32c6:	cf 91       	pop	r28
    32c8:	1f 91       	pop	r17
    32ca:	0f 91       	pop	r16
    32cc:	ff 90       	pop	r15
    32ce:	ef 90       	pop	r14
    32d0:	df 90       	pop	r13
    32d2:	08 95       	ret

000032d4 <__vector_24>:

/* ======================================================================================================================= */
/**
@todo Documentation
*/
ISR(SPI_STC_vect) {
    32d4:	1f 92       	push	r1
    32d6:	0f 92       	push	r0
    32d8:	0f b6       	in	r0, 0x3f	; 63
    32da:	0f 92       	push	r0
    32dc:	11 24       	eor	r1, r1
    32de:	0b b6       	in	r0, 0x3b	; 59
    32e0:	0f 92       	push	r0
    32e2:	2f 93       	push	r18
    32e4:	3f 93       	push	r19
    32e6:	4f 93       	push	r20
    32e8:	5f 93       	push	r21
    32ea:	6f 93       	push	r22
    32ec:	7f 93       	push	r23
    32ee:	8f 93       	push	r24
    32f0:	9f 93       	push	r25
    32f2:	af 93       	push	r26
    32f4:	bf 93       	push	r27
    32f6:	ef 93       	push	r30
    32f8:	ff 93       	push	r31
    32fa:	cf 93       	push	r28
    32fc:	df 93       	push	r29
    32fe:	1f 92       	push	r1
    3300:	cd b7       	in	r28, 0x3d	; 61
    3302:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	#if SPI_USE_BUFFER == 1
	// store received byte if receive buffer available

	if (_this->_rx_buf != 0){
    3304:	e0 91 d0 1d 	lds	r30, 0x1DD0
    3308:	f0 91 d1 1d 	lds	r31, 0x1DD1
    330c:	80 85       	ldd	r24, Z+8	; 0x08
    330e:	91 85       	ldd	r25, Z+9	; 0x09
    3310:	00 97       	sbiw	r24, 0x00	; 0
    3312:	19 f0       	breq	.+6      	; 0x331a <__vector_24+0x46>
		buffer_put_item(_this->_rx_buf, SPDR);
    3314:	6e b5       	in	r22, 0x2e	; 46
    3316:	0e 94 82 04 	call	0x904	; 0x904 <buffer_put_item>
	}
	// more bytes to send?
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
    331a:	e0 91 d0 1d 	lds	r30, 0x1DD0
    331e:	f0 91 d1 1d 	lds	r31, 0x1DD1
    3322:	be 01       	movw	r22, r28
    3324:	6f 5f       	subi	r22, 0xFF	; 255
    3326:	7f 4f       	sbci	r23, 0xFF	; 255
    3328:	86 81       	ldd	r24, Z+6	; 0x06
    332a:	97 81       	ldd	r25, Z+7	; 0x07
    332c:	0e 94 68 04 	call	0x8d0	; 0x8d0 <buffer_get_item>
    3330:	81 11       	cpse	r24, r1
    3332:	03 c0       	rjmp	.+6      	; 0x333a <__vector_24+0x66>
		_spi_send_byte(item);
    3334:	89 81       	ldd	r24, Y+1	; 0x01
// Indexed by SPI_CLOCK_DIVIDER_xx defines
static const uint8_t _prescaler_mask [] = {0b00,0b01,0b10,0b11,0b00,0b01,0b10};

// Send a byte to the SPI-bus
static inline void _spi_send_byte(uint8_t byte) {
	SPDR = byte;
    3336:	8e bd       	out	0x2e, r24	; 46
    3338:	29 c0       	rjmp	.+82     	; 0x338c <__vector_24+0xb8>
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
		_spi_send_byte(item);
		} else {
		// No
		// Disable SPI interrupt
		SPCR &= ~_BV(SPIE);
    333a:	8c b5       	in	r24, 0x2c	; 44
    333c:	8f 77       	andi	r24, 0x7F	; 127
    333e:	8c bd       	out	0x2c, r24	; 44
		_spi_active = 0;
    3340:	10 92 d2 1d 	sts	0x1DD2, r1
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    3344:	e0 91 d0 1d 	lds	r30, 0x1DD0
    3348:	f0 91 d1 1d 	lds	r31, 0x1DD1
    334c:	83 81       	ldd	r24, Z+3	; 0x03
    334e:	81 30       	cpi	r24, 0x01	; 1
    3350:	79 f4       	brne	.+30     	; 0x3370 <__vector_24+0x9c>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    3352:	a0 81       	ld	r26, Z
    3354:	b1 81       	ldd	r27, Z+1	; 0x01
    3356:	2c 91       	ld	r18, X
    3358:	81 e0       	ldi	r24, 0x01	; 1
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	02 80       	ldd	r0, Z+2	; 0x02
    335e:	02 c0       	rjmp	.+4      	; 0x3364 <__vector_24+0x90>
    3360:	88 0f       	add	r24, r24
    3362:	99 1f       	adc	r25, r25
    3364:	0a 94       	dec	r0
    3366:	e2 f7       	brpl	.-8      	; 0x3360 <__vector_24+0x8c>
    3368:	80 95       	com	r24
    336a:	82 23       	and	r24, r18
    336c:	8c 93       	st	X, r24
    336e:	0e c0       	rjmp	.+28     	; 0x338c <__vector_24+0xb8>
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);

			} else {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    3370:	a0 81       	ld	r26, Z
    3372:	b1 81       	ldd	r27, Z+1	; 0x01
    3374:	4c 91       	ld	r20, X
    3376:	21 e0       	ldi	r18, 0x01	; 1
    3378:	30 e0       	ldi	r19, 0x00	; 0
    337a:	c9 01       	movw	r24, r18
    337c:	02 80       	ldd	r0, Z+2	; 0x02
    337e:	02 c0       	rjmp	.+4      	; 0x3384 <__vector_24+0xb0>
    3380:	88 0f       	add	r24, r24
    3382:	99 1f       	adc	r25, r25
    3384:	0a 94       	dec	r0
    3386:	e2 f7       	brpl	.-8      	; 0x3380 <__vector_24+0xac>
    3388:	84 2b       	or	r24, r20
    338a:	8c 93       	st	X, r24
	_spi_active = 0;
	_set_cs(CS_INACTIVE);
	#endif

	// If handler defined - call it with instance and received byte.
	if (_this->_call_back)
    338c:	80 91 d0 1d 	lds	r24, 0x1DD0
    3390:	90 91 d1 1d 	lds	r25, 0x1DD1
    3394:	dc 01       	movw	r26, r24
    3396:	1a 96       	adiw	r26, 0x0a	; 10
    3398:	ed 91       	ld	r30, X+
    339a:	fc 91       	ld	r31, X
    339c:	1b 97       	sbiw	r26, 0x0b	; 11
    339e:	30 97       	sbiw	r30, 0x00	; 0
    33a0:	11 f0       	breq	.+4      	; 0x33a6 <__vector_24+0xd2>
	{
		_this->_call_back(_this, item);
    33a2:	69 81       	ldd	r22, Y+1	; 0x01
    33a4:	19 95       	eicall
	}
    33a6:	0f 90       	pop	r0
    33a8:	df 91       	pop	r29
    33aa:	cf 91       	pop	r28
    33ac:	ff 91       	pop	r31
    33ae:	ef 91       	pop	r30
    33b0:	bf 91       	pop	r27
    33b2:	af 91       	pop	r26
    33b4:	9f 91       	pop	r25
    33b6:	8f 91       	pop	r24
    33b8:	7f 91       	pop	r23
    33ba:	6f 91       	pop	r22
    33bc:	5f 91       	pop	r21
    33be:	4f 91       	pop	r20
    33c0:	3f 91       	pop	r19
    33c2:	2f 91       	pop	r18
    33c4:	0f 90       	pop	r0
    33c6:	0b be       	out	0x3b, r0	; 59
    33c8:	0f 90       	pop	r0
    33ca:	0f be       	out	0x3f, r0	; 63
    33cc:	0f 90       	pop	r0
    33ce:	1f 90       	pop	r1
    33d0:	18 95       	reti

000033d2 <__divmodhi4>:
    33d2:	97 fb       	bst	r25, 7
    33d4:	07 2e       	mov	r0, r23
    33d6:	16 f4       	brtc	.+4      	; 0x33dc <__divmodhi4+0xa>
    33d8:	00 94       	com	r0
    33da:	06 d0       	rcall	.+12     	; 0x33e8 <__divmodhi4_neg1>
    33dc:	77 fd       	sbrc	r23, 7
    33de:	08 d0       	rcall	.+16     	; 0x33f0 <__divmodhi4_neg2>
    33e0:	5e d0       	rcall	.+188    	; 0x349e <__udivmodhi4>
    33e2:	07 fc       	sbrc	r0, 7
    33e4:	05 d0       	rcall	.+10     	; 0x33f0 <__divmodhi4_neg2>
    33e6:	3e f4       	brtc	.+14     	; 0x33f6 <__divmodhi4_exit>

000033e8 <__divmodhi4_neg1>:
    33e8:	90 95       	com	r25
    33ea:	81 95       	neg	r24
    33ec:	9f 4f       	sbci	r25, 0xFF	; 255
    33ee:	08 95       	ret

000033f0 <__divmodhi4_neg2>:
    33f0:	70 95       	com	r23
    33f2:	61 95       	neg	r22
    33f4:	7f 4f       	sbci	r23, 0xFF	; 255

000033f6 <__divmodhi4_exit>:
    33f6:	08 95       	ret

000033f8 <__udivmodsi4>:
    33f8:	a1 e2       	ldi	r26, 0x21	; 33
    33fa:	1a 2e       	mov	r1, r26
    33fc:	aa 1b       	sub	r26, r26
    33fe:	bb 1b       	sub	r27, r27
    3400:	fd 01       	movw	r30, r26
    3402:	0d c0       	rjmp	.+26     	; 0x341e <__udivmodsi4_ep>

00003404 <__udivmodsi4_loop>:
    3404:	aa 1f       	adc	r26, r26
    3406:	bb 1f       	adc	r27, r27
    3408:	ee 1f       	adc	r30, r30
    340a:	ff 1f       	adc	r31, r31
    340c:	a2 17       	cp	r26, r18
    340e:	b3 07       	cpc	r27, r19
    3410:	e4 07       	cpc	r30, r20
    3412:	f5 07       	cpc	r31, r21
    3414:	20 f0       	brcs	.+8      	; 0x341e <__udivmodsi4_ep>
    3416:	a2 1b       	sub	r26, r18
    3418:	b3 0b       	sbc	r27, r19
    341a:	e4 0b       	sbc	r30, r20
    341c:	f5 0b       	sbc	r31, r21

0000341e <__udivmodsi4_ep>:
    341e:	66 1f       	adc	r22, r22
    3420:	77 1f       	adc	r23, r23
    3422:	88 1f       	adc	r24, r24
    3424:	99 1f       	adc	r25, r25
    3426:	1a 94       	dec	r1
    3428:	69 f7       	brne	.-38     	; 0x3404 <__udivmodsi4_loop>
    342a:	60 95       	com	r22
    342c:	70 95       	com	r23
    342e:	80 95       	com	r24
    3430:	90 95       	com	r25
    3432:	9b 01       	movw	r18, r22
    3434:	ac 01       	movw	r20, r24
    3436:	bd 01       	movw	r22, r26
    3438:	cf 01       	movw	r24, r30
    343a:	08 95       	ret

0000343c <__divmodsi4>:
    343c:	05 2e       	mov	r0, r21
    343e:	97 fb       	bst	r25, 7
    3440:	16 f4       	brtc	.+4      	; 0x3446 <__divmodsi4+0xa>
    3442:	00 94       	com	r0
    3444:	0f d0       	rcall	.+30     	; 0x3464 <__negsi2>
    3446:	57 fd       	sbrc	r21, 7
    3448:	05 d0       	rcall	.+10     	; 0x3454 <__divmodsi4_neg2>
    344a:	d6 df       	rcall	.-84     	; 0x33f8 <__udivmodsi4>
    344c:	07 fc       	sbrc	r0, 7
    344e:	02 d0       	rcall	.+4      	; 0x3454 <__divmodsi4_neg2>
    3450:	46 f4       	brtc	.+16     	; 0x3462 <__divmodsi4_exit>
    3452:	08 c0       	rjmp	.+16     	; 0x3464 <__negsi2>

00003454 <__divmodsi4_neg2>:
    3454:	50 95       	com	r21
    3456:	40 95       	com	r20
    3458:	30 95       	com	r19
    345a:	21 95       	neg	r18
    345c:	3f 4f       	sbci	r19, 0xFF	; 255
    345e:	4f 4f       	sbci	r20, 0xFF	; 255
    3460:	5f 4f       	sbci	r21, 0xFF	; 255

00003462 <__divmodsi4_exit>:
    3462:	08 95       	ret

00003464 <__negsi2>:
    3464:	90 95       	com	r25
    3466:	80 95       	com	r24
    3468:	70 95       	com	r23
    346a:	61 95       	neg	r22
    346c:	7f 4f       	sbci	r23, 0xFF	; 255
    346e:	8f 4f       	sbci	r24, 0xFF	; 255
    3470:	9f 4f       	sbci	r25, 0xFF	; 255
    3472:	08 95       	ret

00003474 <__tablejump2__>:
    3474:	ee 0f       	add	r30, r30
    3476:	ff 1f       	adc	r31, r31

00003478 <__tablejump__>:
    3478:	05 90       	lpm	r0, Z+
    347a:	f4 91       	lpm	r31, Z
    347c:	e0 2d       	mov	r30, r0
    347e:	19 94       	eijmp

00003480 <__umulhisi3>:
    3480:	a2 9f       	mul	r26, r18
    3482:	b0 01       	movw	r22, r0
    3484:	b3 9f       	mul	r27, r19
    3486:	c0 01       	movw	r24, r0
    3488:	a3 9f       	mul	r26, r19
    348a:	70 0d       	add	r23, r0
    348c:	81 1d       	adc	r24, r1
    348e:	11 24       	eor	r1, r1
    3490:	91 1d       	adc	r25, r1
    3492:	b2 9f       	mul	r27, r18
    3494:	70 0d       	add	r23, r0
    3496:	81 1d       	adc	r24, r1
    3498:	11 24       	eor	r1, r1
    349a:	91 1d       	adc	r25, r1
    349c:	08 95       	ret

0000349e <__udivmodhi4>:
    349e:	aa 1b       	sub	r26, r26
    34a0:	bb 1b       	sub	r27, r27
    34a2:	51 e1       	ldi	r21, 0x11	; 17
    34a4:	07 c0       	rjmp	.+14     	; 0x34b4 <__udivmodhi4_ep>

000034a6 <__udivmodhi4_loop>:
    34a6:	aa 1f       	adc	r26, r26
    34a8:	bb 1f       	adc	r27, r27
    34aa:	a6 17       	cp	r26, r22
    34ac:	b7 07       	cpc	r27, r23
    34ae:	10 f0       	brcs	.+4      	; 0x34b4 <__udivmodhi4_ep>
    34b0:	a6 1b       	sub	r26, r22
    34b2:	b7 0b       	sbc	r27, r23

000034b4 <__udivmodhi4_ep>:
    34b4:	88 1f       	adc	r24, r24
    34b6:	99 1f       	adc	r25, r25
    34b8:	5a 95       	dec	r21
    34ba:	a9 f7       	brne	.-22     	; 0x34a6 <__udivmodhi4_loop>
    34bc:	80 95       	com	r24
    34be:	90 95       	com	r25
    34c0:	bc 01       	movw	r22, r24
    34c2:	cd 01       	movw	r24, r26
    34c4:	08 95       	ret

000034c6 <malloc>:
    34c6:	cf 93       	push	r28
    34c8:	df 93       	push	r29
    34ca:	82 30       	cpi	r24, 0x02	; 2
    34cc:	91 05       	cpc	r25, r1
    34ce:	10 f4       	brcc	.+4      	; 0x34d4 <malloc+0xe>
    34d0:	82 e0       	ldi	r24, 0x02	; 2
    34d2:	90 e0       	ldi	r25, 0x00	; 0
    34d4:	e0 91 d9 1d 	lds	r30, 0x1DD9
    34d8:	f0 91 da 1d 	lds	r31, 0x1DDA
    34dc:	20 e0       	ldi	r18, 0x00	; 0
    34de:	30 e0       	ldi	r19, 0x00	; 0
    34e0:	a0 e0       	ldi	r26, 0x00	; 0
    34e2:	b0 e0       	ldi	r27, 0x00	; 0
    34e4:	30 97       	sbiw	r30, 0x00	; 0
    34e6:	39 f1       	breq	.+78     	; 0x3536 <malloc+0x70>
    34e8:	40 81       	ld	r20, Z
    34ea:	51 81       	ldd	r21, Z+1	; 0x01
    34ec:	48 17       	cp	r20, r24
    34ee:	59 07       	cpc	r21, r25
    34f0:	b8 f0       	brcs	.+46     	; 0x3520 <malloc+0x5a>
    34f2:	48 17       	cp	r20, r24
    34f4:	59 07       	cpc	r21, r25
    34f6:	71 f4       	brne	.+28     	; 0x3514 <malloc+0x4e>
    34f8:	82 81       	ldd	r24, Z+2	; 0x02
    34fa:	93 81       	ldd	r25, Z+3	; 0x03
    34fc:	10 97       	sbiw	r26, 0x00	; 0
    34fe:	29 f0       	breq	.+10     	; 0x350a <malloc+0x44>
    3500:	13 96       	adiw	r26, 0x03	; 3
    3502:	9c 93       	st	X, r25
    3504:	8e 93       	st	-X, r24
    3506:	12 97       	sbiw	r26, 0x02	; 2
    3508:	2c c0       	rjmp	.+88     	; 0x3562 <malloc+0x9c>
    350a:	90 93 da 1d 	sts	0x1DDA, r25
    350e:	80 93 d9 1d 	sts	0x1DD9, r24
    3512:	27 c0       	rjmp	.+78     	; 0x3562 <malloc+0x9c>
    3514:	21 15       	cp	r18, r1
    3516:	31 05       	cpc	r19, r1
    3518:	31 f0       	breq	.+12     	; 0x3526 <malloc+0x60>
    351a:	42 17       	cp	r20, r18
    351c:	53 07       	cpc	r21, r19
    351e:	18 f0       	brcs	.+6      	; 0x3526 <malloc+0x60>
    3520:	a9 01       	movw	r20, r18
    3522:	db 01       	movw	r26, r22
    3524:	01 c0       	rjmp	.+2      	; 0x3528 <malloc+0x62>
    3526:	ef 01       	movw	r28, r30
    3528:	9a 01       	movw	r18, r20
    352a:	bd 01       	movw	r22, r26
    352c:	df 01       	movw	r26, r30
    352e:	02 80       	ldd	r0, Z+2	; 0x02
    3530:	f3 81       	ldd	r31, Z+3	; 0x03
    3532:	e0 2d       	mov	r30, r0
    3534:	d7 cf       	rjmp	.-82     	; 0x34e4 <malloc+0x1e>
    3536:	21 15       	cp	r18, r1
    3538:	31 05       	cpc	r19, r1
    353a:	f9 f0       	breq	.+62     	; 0x357a <malloc+0xb4>
    353c:	28 1b       	sub	r18, r24
    353e:	39 0b       	sbc	r19, r25
    3540:	24 30       	cpi	r18, 0x04	; 4
    3542:	31 05       	cpc	r19, r1
    3544:	80 f4       	brcc	.+32     	; 0x3566 <malloc+0xa0>
    3546:	8a 81       	ldd	r24, Y+2	; 0x02
    3548:	9b 81       	ldd	r25, Y+3	; 0x03
    354a:	61 15       	cp	r22, r1
    354c:	71 05       	cpc	r23, r1
    354e:	21 f0       	breq	.+8      	; 0x3558 <malloc+0x92>
    3550:	fb 01       	movw	r30, r22
    3552:	93 83       	std	Z+3, r25	; 0x03
    3554:	82 83       	std	Z+2, r24	; 0x02
    3556:	04 c0       	rjmp	.+8      	; 0x3560 <malloc+0x9a>
    3558:	90 93 da 1d 	sts	0x1DDA, r25
    355c:	80 93 d9 1d 	sts	0x1DD9, r24
    3560:	fe 01       	movw	r30, r28
    3562:	32 96       	adiw	r30, 0x02	; 2
    3564:	44 c0       	rjmp	.+136    	; 0x35ee <malloc+0x128>
    3566:	fe 01       	movw	r30, r28
    3568:	e2 0f       	add	r30, r18
    356a:	f3 1f       	adc	r31, r19
    356c:	81 93       	st	Z+, r24
    356e:	91 93       	st	Z+, r25
    3570:	22 50       	subi	r18, 0x02	; 2
    3572:	31 09       	sbc	r19, r1
    3574:	39 83       	std	Y+1, r19	; 0x01
    3576:	28 83       	st	Y, r18
    3578:	3a c0       	rjmp	.+116    	; 0x35ee <malloc+0x128>
    357a:	20 91 d7 1d 	lds	r18, 0x1DD7
    357e:	30 91 d8 1d 	lds	r19, 0x1DD8
    3582:	23 2b       	or	r18, r19
    3584:	41 f4       	brne	.+16     	; 0x3596 <malloc+0xd0>
    3586:	20 91 02 02 	lds	r18, 0x0202
    358a:	30 91 03 02 	lds	r19, 0x0203
    358e:	30 93 d8 1d 	sts	0x1DD8, r19
    3592:	20 93 d7 1d 	sts	0x1DD7, r18
    3596:	20 91 00 02 	lds	r18, 0x0200
    359a:	30 91 01 02 	lds	r19, 0x0201
    359e:	21 15       	cp	r18, r1
    35a0:	31 05       	cpc	r19, r1
    35a2:	41 f4       	brne	.+16     	; 0x35b4 <malloc+0xee>
    35a4:	2d b7       	in	r18, 0x3d	; 61
    35a6:	3e b7       	in	r19, 0x3e	; 62
    35a8:	40 91 04 02 	lds	r20, 0x0204
    35ac:	50 91 05 02 	lds	r21, 0x0205
    35b0:	24 1b       	sub	r18, r20
    35b2:	35 0b       	sbc	r19, r21
    35b4:	e0 91 d7 1d 	lds	r30, 0x1DD7
    35b8:	f0 91 d8 1d 	lds	r31, 0x1DD8
    35bc:	e2 17       	cp	r30, r18
    35be:	f3 07       	cpc	r31, r19
    35c0:	a0 f4       	brcc	.+40     	; 0x35ea <malloc+0x124>
    35c2:	2e 1b       	sub	r18, r30
    35c4:	3f 0b       	sbc	r19, r31
    35c6:	28 17       	cp	r18, r24
    35c8:	39 07       	cpc	r19, r25
    35ca:	78 f0       	brcs	.+30     	; 0x35ea <malloc+0x124>
    35cc:	ac 01       	movw	r20, r24
    35ce:	4e 5f       	subi	r20, 0xFE	; 254
    35d0:	5f 4f       	sbci	r21, 0xFF	; 255
    35d2:	24 17       	cp	r18, r20
    35d4:	35 07       	cpc	r19, r21
    35d6:	48 f0       	brcs	.+18     	; 0x35ea <malloc+0x124>
    35d8:	4e 0f       	add	r20, r30
    35da:	5f 1f       	adc	r21, r31
    35dc:	50 93 d8 1d 	sts	0x1DD8, r21
    35e0:	40 93 d7 1d 	sts	0x1DD7, r20
    35e4:	81 93       	st	Z+, r24
    35e6:	91 93       	st	Z+, r25
    35e8:	02 c0       	rjmp	.+4      	; 0x35ee <malloc+0x128>
    35ea:	e0 e0       	ldi	r30, 0x00	; 0
    35ec:	f0 e0       	ldi	r31, 0x00	; 0
    35ee:	cf 01       	movw	r24, r30
    35f0:	df 91       	pop	r29
    35f2:	cf 91       	pop	r28
    35f4:	08 95       	ret

000035f6 <free>:
    35f6:	cf 93       	push	r28
    35f8:	df 93       	push	r29
    35fa:	00 97       	sbiw	r24, 0x00	; 0
    35fc:	09 f4       	brne	.+2      	; 0x3600 <free+0xa>
    35fe:	87 c0       	rjmp	.+270    	; 0x370e <free+0x118>
    3600:	fc 01       	movw	r30, r24
    3602:	32 97       	sbiw	r30, 0x02	; 2
    3604:	13 82       	std	Z+3, r1	; 0x03
    3606:	12 82       	std	Z+2, r1	; 0x02
    3608:	c0 91 d9 1d 	lds	r28, 0x1DD9
    360c:	d0 91 da 1d 	lds	r29, 0x1DDA
    3610:	20 97       	sbiw	r28, 0x00	; 0
    3612:	81 f4       	brne	.+32     	; 0x3634 <free+0x3e>
    3614:	20 81       	ld	r18, Z
    3616:	31 81       	ldd	r19, Z+1	; 0x01
    3618:	28 0f       	add	r18, r24
    361a:	39 1f       	adc	r19, r25
    361c:	80 91 d7 1d 	lds	r24, 0x1DD7
    3620:	90 91 d8 1d 	lds	r25, 0x1DD8
    3624:	82 17       	cp	r24, r18
    3626:	93 07       	cpc	r25, r19
    3628:	79 f5       	brne	.+94     	; 0x3688 <free+0x92>
    362a:	f0 93 d8 1d 	sts	0x1DD8, r31
    362e:	e0 93 d7 1d 	sts	0x1DD7, r30
    3632:	6d c0       	rjmp	.+218    	; 0x370e <free+0x118>
    3634:	de 01       	movw	r26, r28
    3636:	20 e0       	ldi	r18, 0x00	; 0
    3638:	30 e0       	ldi	r19, 0x00	; 0
    363a:	ae 17       	cp	r26, r30
    363c:	bf 07       	cpc	r27, r31
    363e:	50 f4       	brcc	.+20     	; 0x3654 <free+0x5e>
    3640:	12 96       	adiw	r26, 0x02	; 2
    3642:	4d 91       	ld	r20, X+
    3644:	5c 91       	ld	r21, X
    3646:	13 97       	sbiw	r26, 0x03	; 3
    3648:	9d 01       	movw	r18, r26
    364a:	41 15       	cp	r20, r1
    364c:	51 05       	cpc	r21, r1
    364e:	09 f1       	breq	.+66     	; 0x3692 <free+0x9c>
    3650:	da 01       	movw	r26, r20
    3652:	f3 cf       	rjmp	.-26     	; 0x363a <free+0x44>
    3654:	b3 83       	std	Z+3, r27	; 0x03
    3656:	a2 83       	std	Z+2, r26	; 0x02
    3658:	40 81       	ld	r20, Z
    365a:	51 81       	ldd	r21, Z+1	; 0x01
    365c:	84 0f       	add	r24, r20
    365e:	95 1f       	adc	r25, r21
    3660:	8a 17       	cp	r24, r26
    3662:	9b 07       	cpc	r25, r27
    3664:	71 f4       	brne	.+28     	; 0x3682 <free+0x8c>
    3666:	8d 91       	ld	r24, X+
    3668:	9c 91       	ld	r25, X
    366a:	11 97       	sbiw	r26, 0x01	; 1
    366c:	84 0f       	add	r24, r20
    366e:	95 1f       	adc	r25, r21
    3670:	02 96       	adiw	r24, 0x02	; 2
    3672:	91 83       	std	Z+1, r25	; 0x01
    3674:	80 83       	st	Z, r24
    3676:	12 96       	adiw	r26, 0x02	; 2
    3678:	8d 91       	ld	r24, X+
    367a:	9c 91       	ld	r25, X
    367c:	13 97       	sbiw	r26, 0x03	; 3
    367e:	93 83       	std	Z+3, r25	; 0x03
    3680:	82 83       	std	Z+2, r24	; 0x02
    3682:	21 15       	cp	r18, r1
    3684:	31 05       	cpc	r19, r1
    3686:	29 f4       	brne	.+10     	; 0x3692 <free+0x9c>
    3688:	f0 93 da 1d 	sts	0x1DDA, r31
    368c:	e0 93 d9 1d 	sts	0x1DD9, r30
    3690:	3e c0       	rjmp	.+124    	; 0x370e <free+0x118>
    3692:	d9 01       	movw	r26, r18
    3694:	13 96       	adiw	r26, 0x03	; 3
    3696:	fc 93       	st	X, r31
    3698:	ee 93       	st	-X, r30
    369a:	12 97       	sbiw	r26, 0x02	; 2
    369c:	4d 91       	ld	r20, X+
    369e:	5d 91       	ld	r21, X+
    36a0:	a4 0f       	add	r26, r20
    36a2:	b5 1f       	adc	r27, r21
    36a4:	ea 17       	cp	r30, r26
    36a6:	fb 07       	cpc	r31, r27
    36a8:	79 f4       	brne	.+30     	; 0x36c8 <free+0xd2>
    36aa:	80 81       	ld	r24, Z
    36ac:	91 81       	ldd	r25, Z+1	; 0x01
    36ae:	84 0f       	add	r24, r20
    36b0:	95 1f       	adc	r25, r21
    36b2:	02 96       	adiw	r24, 0x02	; 2
    36b4:	d9 01       	movw	r26, r18
    36b6:	11 96       	adiw	r26, 0x01	; 1
    36b8:	9c 93       	st	X, r25
    36ba:	8e 93       	st	-X, r24
    36bc:	82 81       	ldd	r24, Z+2	; 0x02
    36be:	93 81       	ldd	r25, Z+3	; 0x03
    36c0:	13 96       	adiw	r26, 0x03	; 3
    36c2:	9c 93       	st	X, r25
    36c4:	8e 93       	st	-X, r24
    36c6:	12 97       	sbiw	r26, 0x02	; 2
    36c8:	e0 e0       	ldi	r30, 0x00	; 0
    36ca:	f0 e0       	ldi	r31, 0x00	; 0
    36cc:	8a 81       	ldd	r24, Y+2	; 0x02
    36ce:	9b 81       	ldd	r25, Y+3	; 0x03
    36d0:	00 97       	sbiw	r24, 0x00	; 0
    36d2:	19 f0       	breq	.+6      	; 0x36da <free+0xe4>
    36d4:	fe 01       	movw	r30, r28
    36d6:	ec 01       	movw	r28, r24
    36d8:	f9 cf       	rjmp	.-14     	; 0x36cc <free+0xd6>
    36da:	ce 01       	movw	r24, r28
    36dc:	02 96       	adiw	r24, 0x02	; 2
    36de:	28 81       	ld	r18, Y
    36e0:	39 81       	ldd	r19, Y+1	; 0x01
    36e2:	82 0f       	add	r24, r18
    36e4:	93 1f       	adc	r25, r19
    36e6:	20 91 d7 1d 	lds	r18, 0x1DD7
    36ea:	30 91 d8 1d 	lds	r19, 0x1DD8
    36ee:	28 17       	cp	r18, r24
    36f0:	39 07       	cpc	r19, r25
    36f2:	69 f4       	brne	.+26     	; 0x370e <free+0x118>
    36f4:	30 97       	sbiw	r30, 0x00	; 0
    36f6:	29 f4       	brne	.+10     	; 0x3702 <free+0x10c>
    36f8:	10 92 da 1d 	sts	0x1DDA, r1
    36fc:	10 92 d9 1d 	sts	0x1DD9, r1
    3700:	02 c0       	rjmp	.+4      	; 0x3706 <free+0x110>
    3702:	13 82       	std	Z+3, r1	; 0x03
    3704:	12 82       	std	Z+2, r1	; 0x02
    3706:	d0 93 d8 1d 	sts	0x1DD8, r29
    370a:	c0 93 d7 1d 	sts	0x1DD7, r28
    370e:	df 91       	pop	r29
    3710:	cf 91       	pop	r28
    3712:	08 95       	ret

00003714 <atoi>:
    3714:	fc 01       	movw	r30, r24
    3716:	88 27       	eor	r24, r24
    3718:	99 27       	eor	r25, r25
    371a:	e8 94       	clt
    371c:	21 91       	ld	r18, Z+
    371e:	20 32       	cpi	r18, 0x20	; 32
    3720:	e9 f3       	breq	.-6      	; 0x371c <atoi+0x8>
    3722:	29 30       	cpi	r18, 0x09	; 9
    3724:	10 f0       	brcs	.+4      	; 0x372a <atoi+0x16>
    3726:	2e 30       	cpi	r18, 0x0E	; 14
    3728:	c8 f3       	brcs	.-14     	; 0x371c <atoi+0x8>
    372a:	2b 32       	cpi	r18, 0x2B	; 43
    372c:	39 f0       	breq	.+14     	; 0x373c <atoi+0x28>
    372e:	2d 32       	cpi	r18, 0x2D	; 45
    3730:	31 f4       	brne	.+12     	; 0x373e <atoi+0x2a>
    3732:	68 94       	set
    3734:	03 c0       	rjmp	.+6      	; 0x373c <atoi+0x28>
    3736:	14 d0       	rcall	.+40     	; 0x3760 <__mulhi_const_10>
    3738:	82 0f       	add	r24, r18
    373a:	91 1d       	adc	r25, r1
    373c:	21 91       	ld	r18, Z+
    373e:	20 53       	subi	r18, 0x30	; 48
    3740:	2a 30       	cpi	r18, 0x0A	; 10
    3742:	c8 f3       	brcs	.-14     	; 0x3736 <atoi+0x22>
    3744:	1e f4       	brtc	.+6      	; 0x374c <atoi+0x38>
    3746:	90 95       	com	r25
    3748:	81 95       	neg	r24
    374a:	9f 4f       	sbci	r25, 0xFF	; 255
    374c:	08 95       	ret

0000374e <memcpy>:
    374e:	fb 01       	movw	r30, r22
    3750:	dc 01       	movw	r26, r24
    3752:	02 c0       	rjmp	.+4      	; 0x3758 <memcpy+0xa>
    3754:	01 90       	ld	r0, Z+
    3756:	0d 92       	st	X+, r0
    3758:	41 50       	subi	r20, 0x01	; 1
    375a:	50 40       	sbci	r21, 0x00	; 0
    375c:	d8 f7       	brcc	.-10     	; 0x3754 <memcpy+0x6>
    375e:	08 95       	ret

00003760 <__mulhi_const_10>:
    3760:	7a e0       	ldi	r23, 0x0A	; 10
    3762:	97 9f       	mul	r25, r23
    3764:	90 2d       	mov	r25, r0
    3766:	87 9f       	mul	r24, r23
    3768:	80 2d       	mov	r24, r0
    376a:	91 0d       	add	r25, r1
    376c:	11 24       	eor	r1, r1
    376e:	08 95       	ret

00003770 <sprintf>:
    3770:	0f 93       	push	r16
    3772:	1f 93       	push	r17
    3774:	cf 93       	push	r28
    3776:	df 93       	push	r29
    3778:	cd b7       	in	r28, 0x3d	; 61
    377a:	de b7       	in	r29, 0x3e	; 62
    377c:	2e 97       	sbiw	r28, 0x0e	; 14
    377e:	0f b6       	in	r0, 0x3f	; 63
    3780:	f8 94       	cli
    3782:	de bf       	out	0x3e, r29	; 62
    3784:	0f be       	out	0x3f, r0	; 63
    3786:	cd bf       	out	0x3d, r28	; 61
    3788:	0e 89       	ldd	r16, Y+22	; 0x16
    378a:	1f 89       	ldd	r17, Y+23	; 0x17
    378c:	86 e0       	ldi	r24, 0x06	; 6
    378e:	8c 83       	std	Y+4, r24	; 0x04
    3790:	1a 83       	std	Y+2, r17	; 0x02
    3792:	09 83       	std	Y+1, r16	; 0x01
    3794:	8f ef       	ldi	r24, 0xFF	; 255
    3796:	9f e7       	ldi	r25, 0x7F	; 127
    3798:	9e 83       	std	Y+6, r25	; 0x06
    379a:	8d 83       	std	Y+5, r24	; 0x05
    379c:	ae 01       	movw	r20, r28
    379e:	46 5e       	subi	r20, 0xE6	; 230
    37a0:	5f 4f       	sbci	r21, 0xFF	; 255
    37a2:	68 8d       	ldd	r22, Y+24	; 0x18
    37a4:	79 8d       	ldd	r23, Y+25	; 0x19
    37a6:	ce 01       	movw	r24, r28
    37a8:	01 96       	adiw	r24, 0x01	; 1
    37aa:	10 d0       	rcall	.+32     	; 0x37cc <vfprintf>
    37ac:	ef 81       	ldd	r30, Y+7	; 0x07
    37ae:	f8 85       	ldd	r31, Y+8	; 0x08
    37b0:	e0 0f       	add	r30, r16
    37b2:	f1 1f       	adc	r31, r17
    37b4:	10 82       	st	Z, r1
    37b6:	2e 96       	adiw	r28, 0x0e	; 14
    37b8:	0f b6       	in	r0, 0x3f	; 63
    37ba:	f8 94       	cli
    37bc:	de bf       	out	0x3e, r29	; 62
    37be:	0f be       	out	0x3f, r0	; 63
    37c0:	cd bf       	out	0x3d, r28	; 61
    37c2:	df 91       	pop	r29
    37c4:	cf 91       	pop	r28
    37c6:	1f 91       	pop	r17
    37c8:	0f 91       	pop	r16
    37ca:	08 95       	ret

000037cc <vfprintf>:
    37cc:	2f 92       	push	r2
    37ce:	3f 92       	push	r3
    37d0:	4f 92       	push	r4
    37d2:	5f 92       	push	r5
    37d4:	6f 92       	push	r6
    37d6:	7f 92       	push	r7
    37d8:	8f 92       	push	r8
    37da:	9f 92       	push	r9
    37dc:	af 92       	push	r10
    37de:	bf 92       	push	r11
    37e0:	cf 92       	push	r12
    37e2:	df 92       	push	r13
    37e4:	ef 92       	push	r14
    37e6:	ff 92       	push	r15
    37e8:	0f 93       	push	r16
    37ea:	1f 93       	push	r17
    37ec:	cf 93       	push	r28
    37ee:	df 93       	push	r29
    37f0:	cd b7       	in	r28, 0x3d	; 61
    37f2:	de b7       	in	r29, 0x3e	; 62
    37f4:	2c 97       	sbiw	r28, 0x0c	; 12
    37f6:	0f b6       	in	r0, 0x3f	; 63
    37f8:	f8 94       	cli
    37fa:	de bf       	out	0x3e, r29	; 62
    37fc:	0f be       	out	0x3f, r0	; 63
    37fe:	cd bf       	out	0x3d, r28	; 61
    3800:	7c 01       	movw	r14, r24
    3802:	6b 01       	movw	r12, r22
    3804:	8a 01       	movw	r16, r20
    3806:	fc 01       	movw	r30, r24
    3808:	17 82       	std	Z+7, r1	; 0x07
    380a:	16 82       	std	Z+6, r1	; 0x06
    380c:	83 81       	ldd	r24, Z+3	; 0x03
    380e:	81 ff       	sbrs	r24, 1
    3810:	b0 c1       	rjmp	.+864    	; 0x3b72 <vfprintf+0x3a6>
    3812:	ce 01       	movw	r24, r28
    3814:	01 96       	adiw	r24, 0x01	; 1
    3816:	4c 01       	movw	r8, r24
    3818:	f7 01       	movw	r30, r14
    381a:	93 81       	ldd	r25, Z+3	; 0x03
    381c:	f6 01       	movw	r30, r12
    381e:	93 fd       	sbrc	r25, 3
    3820:	85 91       	lpm	r24, Z+
    3822:	93 ff       	sbrs	r25, 3
    3824:	81 91       	ld	r24, Z+
    3826:	6f 01       	movw	r12, r30
    3828:	88 23       	and	r24, r24
    382a:	09 f4       	brne	.+2      	; 0x382e <vfprintf+0x62>
    382c:	9e c1       	rjmp	.+828    	; 0x3b6a <vfprintf+0x39e>
    382e:	85 32       	cpi	r24, 0x25	; 37
    3830:	39 f4       	brne	.+14     	; 0x3840 <vfprintf+0x74>
    3832:	93 fd       	sbrc	r25, 3
    3834:	85 91       	lpm	r24, Z+
    3836:	93 ff       	sbrs	r25, 3
    3838:	81 91       	ld	r24, Z+
    383a:	6f 01       	movw	r12, r30
    383c:	85 32       	cpi	r24, 0x25	; 37
    383e:	21 f4       	brne	.+8      	; 0x3848 <vfprintf+0x7c>
    3840:	b7 01       	movw	r22, r14
    3842:	90 e0       	ldi	r25, 0x00	; 0
    3844:	c7 d1       	rcall	.+910    	; 0x3bd4 <fputc>
    3846:	e8 cf       	rjmp	.-48     	; 0x3818 <vfprintf+0x4c>
    3848:	51 2c       	mov	r5, r1
    384a:	31 2c       	mov	r3, r1
    384c:	20 e0       	ldi	r18, 0x00	; 0
    384e:	20 32       	cpi	r18, 0x20	; 32
    3850:	a0 f4       	brcc	.+40     	; 0x387a <vfprintf+0xae>
    3852:	8b 32       	cpi	r24, 0x2B	; 43
    3854:	69 f0       	breq	.+26     	; 0x3870 <vfprintf+0xa4>
    3856:	30 f4       	brcc	.+12     	; 0x3864 <vfprintf+0x98>
    3858:	80 32       	cpi	r24, 0x20	; 32
    385a:	59 f0       	breq	.+22     	; 0x3872 <vfprintf+0xa6>
    385c:	83 32       	cpi	r24, 0x23	; 35
    385e:	69 f4       	brne	.+26     	; 0x387a <vfprintf+0xae>
    3860:	20 61       	ori	r18, 0x10	; 16
    3862:	2c c0       	rjmp	.+88     	; 0x38bc <vfprintf+0xf0>
    3864:	8d 32       	cpi	r24, 0x2D	; 45
    3866:	39 f0       	breq	.+14     	; 0x3876 <vfprintf+0xaa>
    3868:	80 33       	cpi	r24, 0x30	; 48
    386a:	39 f4       	brne	.+14     	; 0x387a <vfprintf+0xae>
    386c:	21 60       	ori	r18, 0x01	; 1
    386e:	26 c0       	rjmp	.+76     	; 0x38bc <vfprintf+0xf0>
    3870:	22 60       	ori	r18, 0x02	; 2
    3872:	24 60       	ori	r18, 0x04	; 4
    3874:	23 c0       	rjmp	.+70     	; 0x38bc <vfprintf+0xf0>
    3876:	28 60       	ori	r18, 0x08	; 8
    3878:	21 c0       	rjmp	.+66     	; 0x38bc <vfprintf+0xf0>
    387a:	27 fd       	sbrc	r18, 7
    387c:	27 c0       	rjmp	.+78     	; 0x38cc <vfprintf+0x100>
    387e:	30 ed       	ldi	r19, 0xD0	; 208
    3880:	38 0f       	add	r19, r24
    3882:	3a 30       	cpi	r19, 0x0A	; 10
    3884:	78 f4       	brcc	.+30     	; 0x38a4 <vfprintf+0xd8>
    3886:	26 ff       	sbrs	r18, 6
    3888:	06 c0       	rjmp	.+12     	; 0x3896 <vfprintf+0xca>
    388a:	fa e0       	ldi	r31, 0x0A	; 10
    388c:	5f 9e       	mul	r5, r31
    388e:	30 0d       	add	r19, r0
    3890:	11 24       	eor	r1, r1
    3892:	53 2e       	mov	r5, r19
    3894:	13 c0       	rjmp	.+38     	; 0x38bc <vfprintf+0xf0>
    3896:	8a e0       	ldi	r24, 0x0A	; 10
    3898:	38 9e       	mul	r3, r24
    389a:	30 0d       	add	r19, r0
    389c:	11 24       	eor	r1, r1
    389e:	33 2e       	mov	r3, r19
    38a0:	20 62       	ori	r18, 0x20	; 32
    38a2:	0c c0       	rjmp	.+24     	; 0x38bc <vfprintf+0xf0>
    38a4:	8e 32       	cpi	r24, 0x2E	; 46
    38a6:	21 f4       	brne	.+8      	; 0x38b0 <vfprintf+0xe4>
    38a8:	26 fd       	sbrc	r18, 6
    38aa:	5f c1       	rjmp	.+702    	; 0x3b6a <vfprintf+0x39e>
    38ac:	20 64       	ori	r18, 0x40	; 64
    38ae:	06 c0       	rjmp	.+12     	; 0x38bc <vfprintf+0xf0>
    38b0:	8c 36       	cpi	r24, 0x6C	; 108
    38b2:	11 f4       	brne	.+4      	; 0x38b8 <vfprintf+0xec>
    38b4:	20 68       	ori	r18, 0x80	; 128
    38b6:	02 c0       	rjmp	.+4      	; 0x38bc <vfprintf+0xf0>
    38b8:	88 36       	cpi	r24, 0x68	; 104
    38ba:	41 f4       	brne	.+16     	; 0x38cc <vfprintf+0x100>
    38bc:	f6 01       	movw	r30, r12
    38be:	93 fd       	sbrc	r25, 3
    38c0:	85 91       	lpm	r24, Z+
    38c2:	93 ff       	sbrs	r25, 3
    38c4:	81 91       	ld	r24, Z+
    38c6:	6f 01       	movw	r12, r30
    38c8:	81 11       	cpse	r24, r1
    38ca:	c1 cf       	rjmp	.-126    	; 0x384e <vfprintf+0x82>
    38cc:	98 2f       	mov	r25, r24
    38ce:	9f 7d       	andi	r25, 0xDF	; 223
    38d0:	95 54       	subi	r25, 0x45	; 69
    38d2:	93 30       	cpi	r25, 0x03	; 3
    38d4:	28 f4       	brcc	.+10     	; 0x38e0 <vfprintf+0x114>
    38d6:	0c 5f       	subi	r16, 0xFC	; 252
    38d8:	1f 4f       	sbci	r17, 0xFF	; 255
    38da:	ff e3       	ldi	r31, 0x3F	; 63
    38dc:	f9 83       	std	Y+1, r31	; 0x01
    38de:	0d c0       	rjmp	.+26     	; 0x38fa <vfprintf+0x12e>
    38e0:	83 36       	cpi	r24, 0x63	; 99
    38e2:	31 f0       	breq	.+12     	; 0x38f0 <vfprintf+0x124>
    38e4:	83 37       	cpi	r24, 0x73	; 115
    38e6:	71 f0       	breq	.+28     	; 0x3904 <vfprintf+0x138>
    38e8:	83 35       	cpi	r24, 0x53	; 83
    38ea:	09 f0       	breq	.+2      	; 0x38ee <vfprintf+0x122>
    38ec:	57 c0       	rjmp	.+174    	; 0x399c <vfprintf+0x1d0>
    38ee:	21 c0       	rjmp	.+66     	; 0x3932 <vfprintf+0x166>
    38f0:	f8 01       	movw	r30, r16
    38f2:	80 81       	ld	r24, Z
    38f4:	89 83       	std	Y+1, r24	; 0x01
    38f6:	0e 5f       	subi	r16, 0xFE	; 254
    38f8:	1f 4f       	sbci	r17, 0xFF	; 255
    38fa:	44 24       	eor	r4, r4
    38fc:	43 94       	inc	r4
    38fe:	51 2c       	mov	r5, r1
    3900:	54 01       	movw	r10, r8
    3902:	14 c0       	rjmp	.+40     	; 0x392c <vfprintf+0x160>
    3904:	38 01       	movw	r6, r16
    3906:	f2 e0       	ldi	r31, 0x02	; 2
    3908:	6f 0e       	add	r6, r31
    390a:	71 1c       	adc	r7, r1
    390c:	f8 01       	movw	r30, r16
    390e:	a0 80       	ld	r10, Z
    3910:	b1 80       	ldd	r11, Z+1	; 0x01
    3912:	26 ff       	sbrs	r18, 6
    3914:	03 c0       	rjmp	.+6      	; 0x391c <vfprintf+0x150>
    3916:	65 2d       	mov	r22, r5
    3918:	70 e0       	ldi	r23, 0x00	; 0
    391a:	02 c0       	rjmp	.+4      	; 0x3920 <vfprintf+0x154>
    391c:	6f ef       	ldi	r22, 0xFF	; 255
    391e:	7f ef       	ldi	r23, 0xFF	; 255
    3920:	c5 01       	movw	r24, r10
    3922:	2c 87       	std	Y+12, r18	; 0x0c
    3924:	4c d1       	rcall	.+664    	; 0x3bbe <strnlen>
    3926:	2c 01       	movw	r4, r24
    3928:	83 01       	movw	r16, r6
    392a:	2c 85       	ldd	r18, Y+12	; 0x0c
    392c:	2f 77       	andi	r18, 0x7F	; 127
    392e:	22 2e       	mov	r2, r18
    3930:	16 c0       	rjmp	.+44     	; 0x395e <vfprintf+0x192>
    3932:	38 01       	movw	r6, r16
    3934:	f2 e0       	ldi	r31, 0x02	; 2
    3936:	6f 0e       	add	r6, r31
    3938:	71 1c       	adc	r7, r1
    393a:	f8 01       	movw	r30, r16
    393c:	a0 80       	ld	r10, Z
    393e:	b1 80       	ldd	r11, Z+1	; 0x01
    3940:	26 ff       	sbrs	r18, 6
    3942:	03 c0       	rjmp	.+6      	; 0x394a <vfprintf+0x17e>
    3944:	65 2d       	mov	r22, r5
    3946:	70 e0       	ldi	r23, 0x00	; 0
    3948:	02 c0       	rjmp	.+4      	; 0x394e <vfprintf+0x182>
    394a:	6f ef       	ldi	r22, 0xFF	; 255
    394c:	7f ef       	ldi	r23, 0xFF	; 255
    394e:	c5 01       	movw	r24, r10
    3950:	2c 87       	std	Y+12, r18	; 0x0c
    3952:	2a d1       	rcall	.+596    	; 0x3ba8 <strnlen_P>
    3954:	2c 01       	movw	r4, r24
    3956:	2c 85       	ldd	r18, Y+12	; 0x0c
    3958:	20 68       	ori	r18, 0x80	; 128
    395a:	22 2e       	mov	r2, r18
    395c:	83 01       	movw	r16, r6
    395e:	23 fc       	sbrc	r2, 3
    3960:	19 c0       	rjmp	.+50     	; 0x3994 <vfprintf+0x1c8>
    3962:	83 2d       	mov	r24, r3
    3964:	90 e0       	ldi	r25, 0x00	; 0
    3966:	48 16       	cp	r4, r24
    3968:	59 06       	cpc	r5, r25
    396a:	a0 f4       	brcc	.+40     	; 0x3994 <vfprintf+0x1c8>
    396c:	b7 01       	movw	r22, r14
    396e:	80 e2       	ldi	r24, 0x20	; 32
    3970:	90 e0       	ldi	r25, 0x00	; 0
    3972:	30 d1       	rcall	.+608    	; 0x3bd4 <fputc>
    3974:	3a 94       	dec	r3
    3976:	f5 cf       	rjmp	.-22     	; 0x3962 <vfprintf+0x196>
    3978:	f5 01       	movw	r30, r10
    397a:	27 fc       	sbrc	r2, 7
    397c:	85 91       	lpm	r24, Z+
    397e:	27 fe       	sbrs	r2, 7
    3980:	81 91       	ld	r24, Z+
    3982:	5f 01       	movw	r10, r30
    3984:	b7 01       	movw	r22, r14
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	25 d1       	rcall	.+586    	; 0x3bd4 <fputc>
    398a:	31 10       	cpse	r3, r1
    398c:	3a 94       	dec	r3
    398e:	f1 e0       	ldi	r31, 0x01	; 1
    3990:	4f 1a       	sub	r4, r31
    3992:	51 08       	sbc	r5, r1
    3994:	41 14       	cp	r4, r1
    3996:	51 04       	cpc	r5, r1
    3998:	79 f7       	brne	.-34     	; 0x3978 <vfprintf+0x1ac>
    399a:	de c0       	rjmp	.+444    	; 0x3b58 <vfprintf+0x38c>
    399c:	84 36       	cpi	r24, 0x64	; 100
    399e:	11 f0       	breq	.+4      	; 0x39a4 <vfprintf+0x1d8>
    39a0:	89 36       	cpi	r24, 0x69	; 105
    39a2:	31 f5       	brne	.+76     	; 0x39f0 <vfprintf+0x224>
    39a4:	f8 01       	movw	r30, r16
    39a6:	27 ff       	sbrs	r18, 7
    39a8:	07 c0       	rjmp	.+14     	; 0x39b8 <vfprintf+0x1ec>
    39aa:	60 81       	ld	r22, Z
    39ac:	71 81       	ldd	r23, Z+1	; 0x01
    39ae:	82 81       	ldd	r24, Z+2	; 0x02
    39b0:	93 81       	ldd	r25, Z+3	; 0x03
    39b2:	0c 5f       	subi	r16, 0xFC	; 252
    39b4:	1f 4f       	sbci	r17, 0xFF	; 255
    39b6:	08 c0       	rjmp	.+16     	; 0x39c8 <vfprintf+0x1fc>
    39b8:	60 81       	ld	r22, Z
    39ba:	71 81       	ldd	r23, Z+1	; 0x01
    39bc:	88 27       	eor	r24, r24
    39be:	77 fd       	sbrc	r23, 7
    39c0:	80 95       	com	r24
    39c2:	98 2f       	mov	r25, r24
    39c4:	0e 5f       	subi	r16, 0xFE	; 254
    39c6:	1f 4f       	sbci	r17, 0xFF	; 255
    39c8:	2f 76       	andi	r18, 0x6F	; 111
    39ca:	b2 2e       	mov	r11, r18
    39cc:	97 ff       	sbrs	r25, 7
    39ce:	09 c0       	rjmp	.+18     	; 0x39e2 <vfprintf+0x216>
    39d0:	90 95       	com	r25
    39d2:	80 95       	com	r24
    39d4:	70 95       	com	r23
    39d6:	61 95       	neg	r22
    39d8:	7f 4f       	sbci	r23, 0xFF	; 255
    39da:	8f 4f       	sbci	r24, 0xFF	; 255
    39dc:	9f 4f       	sbci	r25, 0xFF	; 255
    39de:	20 68       	ori	r18, 0x80	; 128
    39e0:	b2 2e       	mov	r11, r18
    39e2:	2a e0       	ldi	r18, 0x0A	; 10
    39e4:	30 e0       	ldi	r19, 0x00	; 0
    39e6:	a4 01       	movw	r20, r8
    39e8:	27 d1       	rcall	.+590    	; 0x3c38 <__ultoa_invert>
    39ea:	a8 2e       	mov	r10, r24
    39ec:	a8 18       	sub	r10, r8
    39ee:	43 c0       	rjmp	.+134    	; 0x3a76 <vfprintf+0x2aa>
    39f0:	85 37       	cpi	r24, 0x75	; 117
    39f2:	29 f4       	brne	.+10     	; 0x39fe <vfprintf+0x232>
    39f4:	2f 7e       	andi	r18, 0xEF	; 239
    39f6:	b2 2e       	mov	r11, r18
    39f8:	2a e0       	ldi	r18, 0x0A	; 10
    39fa:	30 e0       	ldi	r19, 0x00	; 0
    39fc:	25 c0       	rjmp	.+74     	; 0x3a48 <vfprintf+0x27c>
    39fe:	f2 2f       	mov	r31, r18
    3a00:	f9 7f       	andi	r31, 0xF9	; 249
    3a02:	bf 2e       	mov	r11, r31
    3a04:	8f 36       	cpi	r24, 0x6F	; 111
    3a06:	c1 f0       	breq	.+48     	; 0x3a38 <vfprintf+0x26c>
    3a08:	18 f4       	brcc	.+6      	; 0x3a10 <vfprintf+0x244>
    3a0a:	88 35       	cpi	r24, 0x58	; 88
    3a0c:	79 f0       	breq	.+30     	; 0x3a2c <vfprintf+0x260>
    3a0e:	ad c0       	rjmp	.+346    	; 0x3b6a <vfprintf+0x39e>
    3a10:	80 37       	cpi	r24, 0x70	; 112
    3a12:	19 f0       	breq	.+6      	; 0x3a1a <vfprintf+0x24e>
    3a14:	88 37       	cpi	r24, 0x78	; 120
    3a16:	21 f0       	breq	.+8      	; 0x3a20 <vfprintf+0x254>
    3a18:	a8 c0       	rjmp	.+336    	; 0x3b6a <vfprintf+0x39e>
    3a1a:	2f 2f       	mov	r18, r31
    3a1c:	20 61       	ori	r18, 0x10	; 16
    3a1e:	b2 2e       	mov	r11, r18
    3a20:	b4 fe       	sbrs	r11, 4
    3a22:	0d c0       	rjmp	.+26     	; 0x3a3e <vfprintf+0x272>
    3a24:	8b 2d       	mov	r24, r11
    3a26:	84 60       	ori	r24, 0x04	; 4
    3a28:	b8 2e       	mov	r11, r24
    3a2a:	09 c0       	rjmp	.+18     	; 0x3a3e <vfprintf+0x272>
    3a2c:	24 ff       	sbrs	r18, 4
    3a2e:	0a c0       	rjmp	.+20     	; 0x3a44 <vfprintf+0x278>
    3a30:	9f 2f       	mov	r25, r31
    3a32:	96 60       	ori	r25, 0x06	; 6
    3a34:	b9 2e       	mov	r11, r25
    3a36:	06 c0       	rjmp	.+12     	; 0x3a44 <vfprintf+0x278>
    3a38:	28 e0       	ldi	r18, 0x08	; 8
    3a3a:	30 e0       	ldi	r19, 0x00	; 0
    3a3c:	05 c0       	rjmp	.+10     	; 0x3a48 <vfprintf+0x27c>
    3a3e:	20 e1       	ldi	r18, 0x10	; 16
    3a40:	30 e0       	ldi	r19, 0x00	; 0
    3a42:	02 c0       	rjmp	.+4      	; 0x3a48 <vfprintf+0x27c>
    3a44:	20 e1       	ldi	r18, 0x10	; 16
    3a46:	32 e0       	ldi	r19, 0x02	; 2
    3a48:	f8 01       	movw	r30, r16
    3a4a:	b7 fe       	sbrs	r11, 7
    3a4c:	07 c0       	rjmp	.+14     	; 0x3a5c <vfprintf+0x290>
    3a4e:	60 81       	ld	r22, Z
    3a50:	71 81       	ldd	r23, Z+1	; 0x01
    3a52:	82 81       	ldd	r24, Z+2	; 0x02
    3a54:	93 81       	ldd	r25, Z+3	; 0x03
    3a56:	0c 5f       	subi	r16, 0xFC	; 252
    3a58:	1f 4f       	sbci	r17, 0xFF	; 255
    3a5a:	06 c0       	rjmp	.+12     	; 0x3a68 <vfprintf+0x29c>
    3a5c:	60 81       	ld	r22, Z
    3a5e:	71 81       	ldd	r23, Z+1	; 0x01
    3a60:	80 e0       	ldi	r24, 0x00	; 0
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	0e 5f       	subi	r16, 0xFE	; 254
    3a66:	1f 4f       	sbci	r17, 0xFF	; 255
    3a68:	a4 01       	movw	r20, r8
    3a6a:	e6 d0       	rcall	.+460    	; 0x3c38 <__ultoa_invert>
    3a6c:	a8 2e       	mov	r10, r24
    3a6e:	a8 18       	sub	r10, r8
    3a70:	fb 2d       	mov	r31, r11
    3a72:	ff 77       	andi	r31, 0x7F	; 127
    3a74:	bf 2e       	mov	r11, r31
    3a76:	b6 fe       	sbrs	r11, 6
    3a78:	0b c0       	rjmp	.+22     	; 0x3a90 <vfprintf+0x2c4>
    3a7a:	2b 2d       	mov	r18, r11
    3a7c:	2e 7f       	andi	r18, 0xFE	; 254
    3a7e:	a5 14       	cp	r10, r5
    3a80:	50 f4       	brcc	.+20     	; 0x3a96 <vfprintf+0x2ca>
    3a82:	b4 fe       	sbrs	r11, 4
    3a84:	0a c0       	rjmp	.+20     	; 0x3a9a <vfprintf+0x2ce>
    3a86:	b2 fc       	sbrc	r11, 2
    3a88:	08 c0       	rjmp	.+16     	; 0x3a9a <vfprintf+0x2ce>
    3a8a:	2b 2d       	mov	r18, r11
    3a8c:	2e 7e       	andi	r18, 0xEE	; 238
    3a8e:	05 c0       	rjmp	.+10     	; 0x3a9a <vfprintf+0x2ce>
    3a90:	7a 2c       	mov	r7, r10
    3a92:	2b 2d       	mov	r18, r11
    3a94:	03 c0       	rjmp	.+6      	; 0x3a9c <vfprintf+0x2d0>
    3a96:	7a 2c       	mov	r7, r10
    3a98:	01 c0       	rjmp	.+2      	; 0x3a9c <vfprintf+0x2d0>
    3a9a:	75 2c       	mov	r7, r5
    3a9c:	24 ff       	sbrs	r18, 4
    3a9e:	0d c0       	rjmp	.+26     	; 0x3aba <vfprintf+0x2ee>
    3aa0:	fe 01       	movw	r30, r28
    3aa2:	ea 0d       	add	r30, r10
    3aa4:	f1 1d       	adc	r31, r1
    3aa6:	80 81       	ld	r24, Z
    3aa8:	80 33       	cpi	r24, 0x30	; 48
    3aaa:	11 f4       	brne	.+4      	; 0x3ab0 <vfprintf+0x2e4>
    3aac:	29 7e       	andi	r18, 0xE9	; 233
    3aae:	09 c0       	rjmp	.+18     	; 0x3ac2 <vfprintf+0x2f6>
    3ab0:	22 ff       	sbrs	r18, 2
    3ab2:	06 c0       	rjmp	.+12     	; 0x3ac0 <vfprintf+0x2f4>
    3ab4:	73 94       	inc	r7
    3ab6:	73 94       	inc	r7
    3ab8:	04 c0       	rjmp	.+8      	; 0x3ac2 <vfprintf+0x2f6>
    3aba:	82 2f       	mov	r24, r18
    3abc:	86 78       	andi	r24, 0x86	; 134
    3abe:	09 f0       	breq	.+2      	; 0x3ac2 <vfprintf+0x2f6>
    3ac0:	73 94       	inc	r7
    3ac2:	23 fd       	sbrc	r18, 3
    3ac4:	12 c0       	rjmp	.+36     	; 0x3aea <vfprintf+0x31e>
    3ac6:	20 ff       	sbrs	r18, 0
    3ac8:	06 c0       	rjmp	.+12     	; 0x3ad6 <vfprintf+0x30a>
    3aca:	5a 2c       	mov	r5, r10
    3acc:	73 14       	cp	r7, r3
    3ace:	18 f4       	brcc	.+6      	; 0x3ad6 <vfprintf+0x30a>
    3ad0:	53 0c       	add	r5, r3
    3ad2:	57 18       	sub	r5, r7
    3ad4:	73 2c       	mov	r7, r3
    3ad6:	73 14       	cp	r7, r3
    3ad8:	60 f4       	brcc	.+24     	; 0x3af2 <vfprintf+0x326>
    3ada:	b7 01       	movw	r22, r14
    3adc:	80 e2       	ldi	r24, 0x20	; 32
    3ade:	90 e0       	ldi	r25, 0x00	; 0
    3ae0:	2c 87       	std	Y+12, r18	; 0x0c
    3ae2:	78 d0       	rcall	.+240    	; 0x3bd4 <fputc>
    3ae4:	73 94       	inc	r7
    3ae6:	2c 85       	ldd	r18, Y+12	; 0x0c
    3ae8:	f6 cf       	rjmp	.-20     	; 0x3ad6 <vfprintf+0x30a>
    3aea:	73 14       	cp	r7, r3
    3aec:	10 f4       	brcc	.+4      	; 0x3af2 <vfprintf+0x326>
    3aee:	37 18       	sub	r3, r7
    3af0:	01 c0       	rjmp	.+2      	; 0x3af4 <vfprintf+0x328>
    3af2:	31 2c       	mov	r3, r1
    3af4:	24 ff       	sbrs	r18, 4
    3af6:	11 c0       	rjmp	.+34     	; 0x3b1a <vfprintf+0x34e>
    3af8:	b7 01       	movw	r22, r14
    3afa:	80 e3       	ldi	r24, 0x30	; 48
    3afc:	90 e0       	ldi	r25, 0x00	; 0
    3afe:	2c 87       	std	Y+12, r18	; 0x0c
    3b00:	69 d0       	rcall	.+210    	; 0x3bd4 <fputc>
    3b02:	2c 85       	ldd	r18, Y+12	; 0x0c
    3b04:	22 ff       	sbrs	r18, 2
    3b06:	16 c0       	rjmp	.+44     	; 0x3b34 <vfprintf+0x368>
    3b08:	21 ff       	sbrs	r18, 1
    3b0a:	03 c0       	rjmp	.+6      	; 0x3b12 <vfprintf+0x346>
    3b0c:	88 e5       	ldi	r24, 0x58	; 88
    3b0e:	90 e0       	ldi	r25, 0x00	; 0
    3b10:	02 c0       	rjmp	.+4      	; 0x3b16 <vfprintf+0x34a>
    3b12:	88 e7       	ldi	r24, 0x78	; 120
    3b14:	90 e0       	ldi	r25, 0x00	; 0
    3b16:	b7 01       	movw	r22, r14
    3b18:	0c c0       	rjmp	.+24     	; 0x3b32 <vfprintf+0x366>
    3b1a:	82 2f       	mov	r24, r18
    3b1c:	86 78       	andi	r24, 0x86	; 134
    3b1e:	51 f0       	breq	.+20     	; 0x3b34 <vfprintf+0x368>
    3b20:	21 fd       	sbrc	r18, 1
    3b22:	02 c0       	rjmp	.+4      	; 0x3b28 <vfprintf+0x35c>
    3b24:	80 e2       	ldi	r24, 0x20	; 32
    3b26:	01 c0       	rjmp	.+2      	; 0x3b2a <vfprintf+0x35e>
    3b28:	8b e2       	ldi	r24, 0x2B	; 43
    3b2a:	27 fd       	sbrc	r18, 7
    3b2c:	8d e2       	ldi	r24, 0x2D	; 45
    3b2e:	b7 01       	movw	r22, r14
    3b30:	90 e0       	ldi	r25, 0x00	; 0
    3b32:	50 d0       	rcall	.+160    	; 0x3bd4 <fputc>
    3b34:	a5 14       	cp	r10, r5
    3b36:	30 f4       	brcc	.+12     	; 0x3b44 <vfprintf+0x378>
    3b38:	b7 01       	movw	r22, r14
    3b3a:	80 e3       	ldi	r24, 0x30	; 48
    3b3c:	90 e0       	ldi	r25, 0x00	; 0
    3b3e:	4a d0       	rcall	.+148    	; 0x3bd4 <fputc>
    3b40:	5a 94       	dec	r5
    3b42:	f8 cf       	rjmp	.-16     	; 0x3b34 <vfprintf+0x368>
    3b44:	aa 94       	dec	r10
    3b46:	f4 01       	movw	r30, r8
    3b48:	ea 0d       	add	r30, r10
    3b4a:	f1 1d       	adc	r31, r1
    3b4c:	80 81       	ld	r24, Z
    3b4e:	b7 01       	movw	r22, r14
    3b50:	90 e0       	ldi	r25, 0x00	; 0
    3b52:	40 d0       	rcall	.+128    	; 0x3bd4 <fputc>
    3b54:	a1 10       	cpse	r10, r1
    3b56:	f6 cf       	rjmp	.-20     	; 0x3b44 <vfprintf+0x378>
    3b58:	33 20       	and	r3, r3
    3b5a:	09 f4       	brne	.+2      	; 0x3b5e <vfprintf+0x392>
    3b5c:	5d ce       	rjmp	.-838    	; 0x3818 <vfprintf+0x4c>
    3b5e:	b7 01       	movw	r22, r14
    3b60:	80 e2       	ldi	r24, 0x20	; 32
    3b62:	90 e0       	ldi	r25, 0x00	; 0
    3b64:	37 d0       	rcall	.+110    	; 0x3bd4 <fputc>
    3b66:	3a 94       	dec	r3
    3b68:	f7 cf       	rjmp	.-18     	; 0x3b58 <vfprintf+0x38c>
    3b6a:	f7 01       	movw	r30, r14
    3b6c:	86 81       	ldd	r24, Z+6	; 0x06
    3b6e:	97 81       	ldd	r25, Z+7	; 0x07
    3b70:	02 c0       	rjmp	.+4      	; 0x3b76 <vfprintf+0x3aa>
    3b72:	8f ef       	ldi	r24, 0xFF	; 255
    3b74:	9f ef       	ldi	r25, 0xFF	; 255
    3b76:	2c 96       	adiw	r28, 0x0c	; 12
    3b78:	0f b6       	in	r0, 0x3f	; 63
    3b7a:	f8 94       	cli
    3b7c:	de bf       	out	0x3e, r29	; 62
    3b7e:	0f be       	out	0x3f, r0	; 63
    3b80:	cd bf       	out	0x3d, r28	; 61
    3b82:	df 91       	pop	r29
    3b84:	cf 91       	pop	r28
    3b86:	1f 91       	pop	r17
    3b88:	0f 91       	pop	r16
    3b8a:	ff 90       	pop	r15
    3b8c:	ef 90       	pop	r14
    3b8e:	df 90       	pop	r13
    3b90:	cf 90       	pop	r12
    3b92:	bf 90       	pop	r11
    3b94:	af 90       	pop	r10
    3b96:	9f 90       	pop	r9
    3b98:	8f 90       	pop	r8
    3b9a:	7f 90       	pop	r7
    3b9c:	6f 90       	pop	r6
    3b9e:	5f 90       	pop	r5
    3ba0:	4f 90       	pop	r4
    3ba2:	3f 90       	pop	r3
    3ba4:	2f 90       	pop	r2
    3ba6:	08 95       	ret

00003ba8 <strnlen_P>:
    3ba8:	fc 01       	movw	r30, r24
    3baa:	05 90       	lpm	r0, Z+
    3bac:	61 50       	subi	r22, 0x01	; 1
    3bae:	70 40       	sbci	r23, 0x00	; 0
    3bb0:	01 10       	cpse	r0, r1
    3bb2:	d8 f7       	brcc	.-10     	; 0x3baa <strnlen_P+0x2>
    3bb4:	80 95       	com	r24
    3bb6:	90 95       	com	r25
    3bb8:	8e 0f       	add	r24, r30
    3bba:	9f 1f       	adc	r25, r31
    3bbc:	08 95       	ret

00003bbe <strnlen>:
    3bbe:	fc 01       	movw	r30, r24
    3bc0:	61 50       	subi	r22, 0x01	; 1
    3bc2:	70 40       	sbci	r23, 0x00	; 0
    3bc4:	01 90       	ld	r0, Z+
    3bc6:	01 10       	cpse	r0, r1
    3bc8:	d8 f7       	brcc	.-10     	; 0x3bc0 <strnlen+0x2>
    3bca:	80 95       	com	r24
    3bcc:	90 95       	com	r25
    3bce:	8e 0f       	add	r24, r30
    3bd0:	9f 1f       	adc	r25, r31
    3bd2:	08 95       	ret

00003bd4 <fputc>:
    3bd4:	0f 93       	push	r16
    3bd6:	1f 93       	push	r17
    3bd8:	cf 93       	push	r28
    3bda:	df 93       	push	r29
    3bdc:	18 2f       	mov	r17, r24
    3bde:	09 2f       	mov	r16, r25
    3be0:	eb 01       	movw	r28, r22
    3be2:	8b 81       	ldd	r24, Y+3	; 0x03
    3be4:	81 fd       	sbrc	r24, 1
    3be6:	03 c0       	rjmp	.+6      	; 0x3bee <fputc+0x1a>
    3be8:	8f ef       	ldi	r24, 0xFF	; 255
    3bea:	9f ef       	ldi	r25, 0xFF	; 255
    3bec:	20 c0       	rjmp	.+64     	; 0x3c2e <fputc+0x5a>
    3bee:	82 ff       	sbrs	r24, 2
    3bf0:	10 c0       	rjmp	.+32     	; 0x3c12 <fputc+0x3e>
    3bf2:	4e 81       	ldd	r20, Y+6	; 0x06
    3bf4:	5f 81       	ldd	r21, Y+7	; 0x07
    3bf6:	2c 81       	ldd	r18, Y+4	; 0x04
    3bf8:	3d 81       	ldd	r19, Y+5	; 0x05
    3bfa:	42 17       	cp	r20, r18
    3bfc:	53 07       	cpc	r21, r19
    3bfe:	7c f4       	brge	.+30     	; 0x3c1e <fputc+0x4a>
    3c00:	e8 81       	ld	r30, Y
    3c02:	f9 81       	ldd	r31, Y+1	; 0x01
    3c04:	9f 01       	movw	r18, r30
    3c06:	2f 5f       	subi	r18, 0xFF	; 255
    3c08:	3f 4f       	sbci	r19, 0xFF	; 255
    3c0a:	39 83       	std	Y+1, r19	; 0x01
    3c0c:	28 83       	st	Y, r18
    3c0e:	10 83       	st	Z, r17
    3c10:	06 c0       	rjmp	.+12     	; 0x3c1e <fputc+0x4a>
    3c12:	e8 85       	ldd	r30, Y+8	; 0x08
    3c14:	f9 85       	ldd	r31, Y+9	; 0x09
    3c16:	81 2f       	mov	r24, r17
    3c18:	19 95       	eicall
    3c1a:	89 2b       	or	r24, r25
    3c1c:	29 f7       	brne	.-54     	; 0x3be8 <fputc+0x14>
    3c1e:	2e 81       	ldd	r18, Y+6	; 0x06
    3c20:	3f 81       	ldd	r19, Y+7	; 0x07
    3c22:	2f 5f       	subi	r18, 0xFF	; 255
    3c24:	3f 4f       	sbci	r19, 0xFF	; 255
    3c26:	3f 83       	std	Y+7, r19	; 0x07
    3c28:	2e 83       	std	Y+6, r18	; 0x06
    3c2a:	81 2f       	mov	r24, r17
    3c2c:	90 2f       	mov	r25, r16
    3c2e:	df 91       	pop	r29
    3c30:	cf 91       	pop	r28
    3c32:	1f 91       	pop	r17
    3c34:	0f 91       	pop	r16
    3c36:	08 95       	ret

00003c38 <__ultoa_invert>:
    3c38:	fa 01       	movw	r30, r20
    3c3a:	aa 27       	eor	r26, r26
    3c3c:	28 30       	cpi	r18, 0x08	; 8
    3c3e:	51 f1       	breq	.+84     	; 0x3c94 <__ultoa_invert+0x5c>
    3c40:	20 31       	cpi	r18, 0x10	; 16
    3c42:	81 f1       	breq	.+96     	; 0x3ca4 <__ultoa_invert+0x6c>
    3c44:	e8 94       	clt
    3c46:	6f 93       	push	r22
    3c48:	6e 7f       	andi	r22, 0xFE	; 254
    3c4a:	6e 5f       	subi	r22, 0xFE	; 254
    3c4c:	7f 4f       	sbci	r23, 0xFF	; 255
    3c4e:	8f 4f       	sbci	r24, 0xFF	; 255
    3c50:	9f 4f       	sbci	r25, 0xFF	; 255
    3c52:	af 4f       	sbci	r26, 0xFF	; 255
    3c54:	b1 e0       	ldi	r27, 0x01	; 1
    3c56:	3e d0       	rcall	.+124    	; 0x3cd4 <__ultoa_invert+0x9c>
    3c58:	b4 e0       	ldi	r27, 0x04	; 4
    3c5a:	3c d0       	rcall	.+120    	; 0x3cd4 <__ultoa_invert+0x9c>
    3c5c:	67 0f       	add	r22, r23
    3c5e:	78 1f       	adc	r23, r24
    3c60:	89 1f       	adc	r24, r25
    3c62:	9a 1f       	adc	r25, r26
    3c64:	a1 1d       	adc	r26, r1
    3c66:	68 0f       	add	r22, r24
    3c68:	79 1f       	adc	r23, r25
    3c6a:	8a 1f       	adc	r24, r26
    3c6c:	91 1d       	adc	r25, r1
    3c6e:	a1 1d       	adc	r26, r1
    3c70:	6a 0f       	add	r22, r26
    3c72:	71 1d       	adc	r23, r1
    3c74:	81 1d       	adc	r24, r1
    3c76:	91 1d       	adc	r25, r1
    3c78:	a1 1d       	adc	r26, r1
    3c7a:	20 d0       	rcall	.+64     	; 0x3cbc <__ultoa_invert+0x84>
    3c7c:	09 f4       	brne	.+2      	; 0x3c80 <__ultoa_invert+0x48>
    3c7e:	68 94       	set
    3c80:	3f 91       	pop	r19
    3c82:	2a e0       	ldi	r18, 0x0A	; 10
    3c84:	26 9f       	mul	r18, r22
    3c86:	11 24       	eor	r1, r1
    3c88:	30 19       	sub	r19, r0
    3c8a:	30 5d       	subi	r19, 0xD0	; 208
    3c8c:	31 93       	st	Z+, r19
    3c8e:	de f6       	brtc	.-74     	; 0x3c46 <__ultoa_invert+0xe>
    3c90:	cf 01       	movw	r24, r30
    3c92:	08 95       	ret
    3c94:	46 2f       	mov	r20, r22
    3c96:	47 70       	andi	r20, 0x07	; 7
    3c98:	40 5d       	subi	r20, 0xD0	; 208
    3c9a:	41 93       	st	Z+, r20
    3c9c:	b3 e0       	ldi	r27, 0x03	; 3
    3c9e:	0f d0       	rcall	.+30     	; 0x3cbe <__ultoa_invert+0x86>
    3ca0:	c9 f7       	brne	.-14     	; 0x3c94 <__ultoa_invert+0x5c>
    3ca2:	f6 cf       	rjmp	.-20     	; 0x3c90 <__ultoa_invert+0x58>
    3ca4:	46 2f       	mov	r20, r22
    3ca6:	4f 70       	andi	r20, 0x0F	; 15
    3ca8:	40 5d       	subi	r20, 0xD0	; 208
    3caa:	4a 33       	cpi	r20, 0x3A	; 58
    3cac:	18 f0       	brcs	.+6      	; 0x3cb4 <__ultoa_invert+0x7c>
    3cae:	49 5d       	subi	r20, 0xD9	; 217
    3cb0:	31 fd       	sbrc	r19, 1
    3cb2:	40 52       	subi	r20, 0x20	; 32
    3cb4:	41 93       	st	Z+, r20
    3cb6:	02 d0       	rcall	.+4      	; 0x3cbc <__ultoa_invert+0x84>
    3cb8:	a9 f7       	brne	.-22     	; 0x3ca4 <__ultoa_invert+0x6c>
    3cba:	ea cf       	rjmp	.-44     	; 0x3c90 <__ultoa_invert+0x58>
    3cbc:	b4 e0       	ldi	r27, 0x04	; 4
    3cbe:	a6 95       	lsr	r26
    3cc0:	97 95       	ror	r25
    3cc2:	87 95       	ror	r24
    3cc4:	77 95       	ror	r23
    3cc6:	67 95       	ror	r22
    3cc8:	ba 95       	dec	r27
    3cca:	c9 f7       	brne	.-14     	; 0x3cbe <__ultoa_invert+0x86>
    3ccc:	00 97       	sbiw	r24, 0x00	; 0
    3cce:	61 05       	cpc	r22, r1
    3cd0:	71 05       	cpc	r23, r1
    3cd2:	08 95       	ret
    3cd4:	9b 01       	movw	r18, r22
    3cd6:	ac 01       	movw	r20, r24
    3cd8:	0a 2e       	mov	r0, r26
    3cda:	06 94       	lsr	r0
    3cdc:	57 95       	ror	r21
    3cde:	47 95       	ror	r20
    3ce0:	37 95       	ror	r19
    3ce2:	27 95       	ror	r18
    3ce4:	ba 95       	dec	r27
    3ce6:	c9 f7       	brne	.-14     	; 0x3cda <__ultoa_invert+0xa2>
    3ce8:	62 0f       	add	r22, r18
    3cea:	73 1f       	adc	r23, r19
    3cec:	84 1f       	adc	r24, r20
    3cee:	95 1f       	adc	r25, r21
    3cf0:	a0 1d       	adc	r26, r0
    3cf2:	08 95       	ret

00003cf4 <_exit>:
    3cf4:	f8 94       	cli

00003cf6 <__stop_program>:
    3cf6:	ff cf       	rjmp	.-2      	; 0x3cf6 <__stop_program>
