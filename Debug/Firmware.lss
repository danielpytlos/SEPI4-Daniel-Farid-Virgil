
Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000bc  00800200  00002fd6  0000306a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002fd6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ab0  008002bc  008002bc  00003126  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003126  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004f0  00000000  00000000  00003182  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005e9c  00000000  00000000  00003672  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001648  00000000  00000000  0000950e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003625  00000000  00000000  0000ab56  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000010b8  00000000  00000000  0000e17c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001b49  00000000  00000000  0000f234  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000526a  00000000  00000000  00010d7d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004e0  00000000  00000000  00015fe7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	c3 c0       	rjmp	.+390    	; 0x188 <__ctors_end>
       2:	00 00       	nop
       4:	97 c3       	rjmp	.+1838   	; 0x734 <__vector_1>
       6:	00 00       	nop
       8:	e0 c0       	rjmp	.+448    	; 0x1ca <__bad_interrupt>
       a:	00 00       	nop
       c:	de c0       	rjmp	.+444    	; 0x1ca <__bad_interrupt>
       e:	00 00       	nop
      10:	dc c0       	rjmp	.+440    	; 0x1ca <__bad_interrupt>
      12:	00 00       	nop
      14:	da c0       	rjmp	.+436    	; 0x1ca <__bad_interrupt>
      16:	00 00       	nop
      18:	d8 c0       	rjmp	.+432    	; 0x1ca <__bad_interrupt>
      1a:	00 00       	nop
      1c:	d6 c0       	rjmp	.+428    	; 0x1ca <__bad_interrupt>
      1e:	00 00       	nop
      20:	d4 c0       	rjmp	.+424    	; 0x1ca <__bad_interrupt>
      22:	00 00       	nop
      24:	d2 c0       	rjmp	.+420    	; 0x1ca <__bad_interrupt>
      26:	00 00       	nop
      28:	d0 c0       	rjmp	.+416    	; 0x1ca <__bad_interrupt>
      2a:	00 00       	nop
      2c:	ce c0       	rjmp	.+412    	; 0x1ca <__bad_interrupt>
      2e:	00 00       	nop
      30:	cc c0       	rjmp	.+408    	; 0x1ca <__bad_interrupt>
      32:	00 00       	nop
      34:	b4 c3       	rjmp	.+1896   	; 0x79e <__vector_13>
      36:	00 00       	nop
      38:	c8 c0       	rjmp	.+400    	; 0x1ca <__bad_interrupt>
      3a:	00 00       	nop
      3c:	c6 c0       	rjmp	.+396    	; 0x1ca <__bad_interrupt>
      3e:	00 00       	nop
      40:	c4 c0       	rjmp	.+392    	; 0x1ca <__bad_interrupt>
      42:	00 00       	nop
      44:	c2 c0       	rjmp	.+388    	; 0x1ca <__bad_interrupt>
      46:	00 00       	nop
      48:	c0 c0       	rjmp	.+384    	; 0x1ca <__bad_interrupt>
      4a:	00 00       	nop
      4c:	be c0       	rjmp	.+380    	; 0x1ca <__bad_interrupt>
      4e:	00 00       	nop
      50:	bc c0       	rjmp	.+376    	; 0x1ca <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 5e 08 	jmp	0x10bc	; 0x10bc <__vector_21>
      58:	b8 c0       	rjmp	.+368    	; 0x1ca <__bad_interrupt>
      5a:	00 00       	nop
      5c:	b6 c0       	rjmp	.+364    	; 0x1ca <__bad_interrupt>
      5e:	00 00       	nop
      60:	0c 94 25 13 	jmp	0x264a	; 0x264a <__vector_24>
      64:	0c 94 c1 10 	jmp	0x2182	; 0x2182 <__vector_25>
      68:	0c 94 03 11 	jmp	0x2206	; 0x2206 <__vector_26>
      6c:	ae c0       	rjmp	.+348    	; 0x1ca <__bad_interrupt>
      6e:	00 00       	nop
      70:	ac c0       	rjmp	.+344    	; 0x1ca <__bad_interrupt>
      72:	00 00       	nop
      74:	aa c0       	rjmp	.+340    	; 0x1ca <__bad_interrupt>
      76:	00 00       	nop
      78:	a8 c0       	rjmp	.+336    	; 0x1ca <__bad_interrupt>
      7a:	00 00       	nop
      7c:	a6 c0       	rjmp	.+332    	; 0x1ca <__bad_interrupt>
      7e:	00 00       	nop
      80:	a4 c0       	rjmp	.+328    	; 0x1ca <__bad_interrupt>
      82:	00 00       	nop
      84:	a2 c0       	rjmp	.+324    	; 0x1ca <__bad_interrupt>
      86:	00 00       	nop
      88:	a0 c0       	rjmp	.+320    	; 0x1ca <__bad_interrupt>
      8a:	00 00       	nop
      8c:	9e c0       	rjmp	.+316    	; 0x1ca <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 4f 11 	jmp	0x229e	; 0x229e <__vector_36>
      94:	0c 94 91 11 	jmp	0x2322	; 0x2322 <__vector_37>
      98:	98 c0       	rjmp	.+304    	; 0x1ca <__bad_interrupt>
      9a:	00 00       	nop
      9c:	96 c0       	rjmp	.+300    	; 0x1ca <__bad_interrupt>
      9e:	00 00       	nop
      a0:	94 c0       	rjmp	.+296    	; 0x1ca <__bad_interrupt>
      a2:	00 00       	nop
      a4:	92 c0       	rjmp	.+292    	; 0x1ca <__bad_interrupt>
      a6:	00 00       	nop
      a8:	90 c0       	rjmp	.+288    	; 0x1ca <__bad_interrupt>
      aa:	00 00       	nop
      ac:	8e c0       	rjmp	.+284    	; 0x1ca <__bad_interrupt>
      ae:	00 00       	nop
      b0:	8c c0       	rjmp	.+280    	; 0x1ca <__bad_interrupt>
      b2:	00 00       	nop
      b4:	8a c0       	rjmp	.+276    	; 0x1ca <__bad_interrupt>
      b6:	00 00       	nop
      b8:	88 c0       	rjmp	.+272    	; 0x1ca <__bad_interrupt>
      ba:	00 00       	nop
      bc:	86 c0       	rjmp	.+268    	; 0x1ca <__bad_interrupt>
      be:	00 00       	nop
      c0:	84 c0       	rjmp	.+264    	; 0x1ca <__bad_interrupt>
      c2:	00 00       	nop
      c4:	82 c0       	rjmp	.+260    	; 0x1ca <__bad_interrupt>
      c6:	00 00       	nop
      c8:	80 c0       	rjmp	.+256    	; 0x1ca <__bad_interrupt>
      ca:	00 00       	nop
      cc:	1a 0f       	add	r17, r26
      ce:	22 0f       	add	r18, r18
      d0:	8d 0f       	add	r24, r29
      d2:	2a 0f       	add	r18, r26
      d4:	32 0f       	add	r19, r18
      d6:	36 0f       	add	r19, r22
      d8:	63 0f       	add	r22, r19
      da:	8d 0f       	add	r24, r29
      dc:	8d 0f       	add	r24, r29
      de:	8d 0f       	add	r24, r29
      e0:	8d 0f       	add	r24, r29
      e2:	8d 0f       	add	r24, r29
      e4:	8d 0f       	add	r24, r29
      e6:	8d 0f       	add	r24, r29
      e8:	8d 0f       	add	r24, r29
      ea:	8d 0f       	add	r24, r29
      ec:	8d 0f       	add	r24, r29
      ee:	8d 0f       	add	r24, r29
      f0:	8d 0f       	add	r24, r29
      f2:	8d 0f       	add	r24, r29
      f4:	8d 0f       	add	r24, r29
      f6:	8d 0f       	add	r24, r29
      f8:	8d 0f       	add	r24, r29
      fa:	8d 0f       	add	r24, r29
      fc:	8d 0f       	add	r24, r29
      fe:	8d 0f       	add	r24, r29
     100:	8d 0f       	add	r24, r29
     102:	8d 0f       	add	r24, r29
     104:	8d 0f       	add	r24, r29
     106:	8d 0f       	add	r24, r29
     108:	8d 0f       	add	r24, r29
     10a:	8d 0f       	add	r24, r29
     10c:	16 0f       	add	r17, r22
     10e:	1e 0f       	add	r17, r30
     110:	8d 0f       	add	r24, r29
     112:	26 0f       	add	r18, r22
     114:	2e 0f       	add	r18, r30
     116:	61 0f       	add	r22, r17

00000118 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     118:	0f 2e       	mov	r0, r31
     11a:	f5 e3       	ldi	r31, 0x35	; 53
     11c:	ef 2e       	mov	r14, r31
     11e:	fd e0       	ldi	r31, 0x0D	; 13
     120:	ff 2e       	mov	r15, r31
     122:	f0 2d       	mov	r31, r0
     124:	cd e0       	ldi	r28, 0x0D	; 13
     126:	dd e0       	ldi	r29, 0x0D	; 13
     128:	25 c0       	rjmp	.+74     	; 0x174 <prvIdleTask+0x5c>
     12a:	0e 94 13 0c 	call	0x1826	; 0x1826 <vTaskSuspendAll>
     12e:	18 81       	ld	r17, Y
     130:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xTaskResumeAll>
     134:	11 23       	and	r17, r17
     136:	f1 f0       	breq	.+60     	; 0x174 <prvIdleTask+0x5c>
     138:	0f b6       	in	r0, 0x3f	; 63
     13a:	f8 94       	cli
     13c:	0f 92       	push	r0
     13e:	e0 91 12 0d 	lds	r30, 0x0D12
     142:	f0 91 13 0d 	lds	r31, 0x0D13
     146:	06 81       	ldd	r16, Z+6	; 0x06
     148:	17 81       	ldd	r17, Z+7	; 0x07
     14a:	c8 01       	movw	r24, r16
     14c:	02 96       	adiw	r24, 0x02	; 2
     14e:	03 d6       	rcall	.+3078   	; 0xd56 <uxListRemove>
     150:	80 91 0b 0d 	lds	r24, 0x0D0B
     154:	81 50       	subi	r24, 0x01	; 1
     156:	80 93 0b 0d 	sts	0x0D0B, r24
     15a:	80 91 0c 0d 	lds	r24, 0x0D0C
     15e:	81 50       	subi	r24, 0x01	; 1
     160:	80 93 0c 0d 	sts	0x0D0C, r24
     164:	0f 90       	pop	r0
     166:	0f be       	out	0x3f, r0	; 63
     168:	f8 01       	movw	r30, r16
     16a:	87 89       	ldd	r24, Z+23	; 0x17
     16c:	90 8d       	ldd	r25, Z+24	; 0x18
     16e:	db d7       	rcall	.+4022   	; 0x1126 <vPortFree>
     170:	c8 01       	movw	r24, r16
     172:	d9 d7       	rcall	.+4018   	; 0x1126 <vPortFree>
     174:	80 91 0c 0d 	lds	r24, 0x0D0C
     178:	81 11       	cpse	r24, r1
     17a:	d7 cf       	rjmp	.-82     	; 0x12a <prvIdleTask+0x12>
     17c:	f7 01       	movw	r30, r14
     17e:	80 81       	ld	r24, Z
     180:	82 30       	cpi	r24, 0x02	; 2
     182:	c0 f3       	brcs	.-16     	; 0x174 <prvIdleTask+0x5c>
     184:	c6 d6       	rcall	.+3468   	; 0xf12 <vPortYield>
     186:	f6 cf       	rjmp	.-20     	; 0x174 <prvIdleTask+0x5c>

00000188 <__ctors_end>:
     188:	11 24       	eor	r1, r1
     18a:	1f be       	out	0x3f, r1	; 63
     18c:	cf ef       	ldi	r28, 0xFF	; 255
     18e:	d1 e2       	ldi	r29, 0x21	; 33
     190:	de bf       	out	0x3e, r29	; 62
     192:	cd bf       	out	0x3d, r28	; 61
     194:	00 e0       	ldi	r16, 0x00	; 0
     196:	0c bf       	out	0x3c, r16	; 60

00000198 <__do_copy_data>:
     198:	12 e0       	ldi	r17, 0x02	; 2
     19a:	a0 e0       	ldi	r26, 0x00	; 0
     19c:	b2 e0       	ldi	r27, 0x02	; 2
     19e:	e6 ed       	ldi	r30, 0xD6	; 214
     1a0:	ff e2       	ldi	r31, 0x2F	; 47
     1a2:	00 e0       	ldi	r16, 0x00	; 0
     1a4:	0b bf       	out	0x3b, r16	; 59
     1a6:	02 c0       	rjmp	.+4      	; 0x1ac <__do_copy_data+0x14>
     1a8:	07 90       	elpm	r0, Z+
     1aa:	0d 92       	st	X+, r0
     1ac:	ac 3b       	cpi	r26, 0xBC	; 188
     1ae:	b1 07       	cpc	r27, r17
     1b0:	d9 f7       	brne	.-10     	; 0x1a8 <__do_copy_data+0x10>

000001b2 <__do_clear_bss>:
     1b2:	2d e0       	ldi	r18, 0x0D	; 13
     1b4:	ac eb       	ldi	r26, 0xBC	; 188
     1b6:	b2 e0       	ldi	r27, 0x02	; 2
     1b8:	01 c0       	rjmp	.+2      	; 0x1bc <.do_clear_bss_start>

000001ba <.do_clear_bss_loop>:
     1ba:	1d 92       	st	X+, r1

000001bc <.do_clear_bss_start>:
     1bc:	ac 36       	cpi	r26, 0x6C	; 108
     1be:	b2 07       	cpc	r27, r18
     1c0:	e1 f7       	brne	.-8      	; 0x1ba <.do_clear_bss_loop>
     1c2:	0e 94 e6 0f 	call	0x1fcc	; 0x1fcc <main>
     1c6:	0c 94 e9 17 	jmp	0x2fd2	; 0x2fd2 <_exit>

000001ca <__bad_interrupt>:
     1ca:	1a cf       	rjmp	.-460    	; 0x0 <__vectors>

000001cc <_bt_status_call_back>:
}

// ----------------------------------------------------------------------------------------------------------------------
uint16_t get_tacho_count() {
	return 0;
}
     1cc:	10 92 ea 02 	sts	0x02EA, r1
     1d0:	e0 91 e8 02 	lds	r30, 0x02E8
     1d4:	f0 91 e9 02 	lds	r31, 0x02E9
     1d8:	30 97       	sbiw	r30, 0x00	; 0
     1da:	09 f0       	breq	.+2      	; 0x1de <_bt_status_call_back+0x12>
     1dc:	19 95       	eicall
     1de:	08 95       	ret

000001e0 <_bt_call_back>:
     1e0:	cf 93       	push	r28
     1e2:	df 93       	push	r29
     1e4:	1f 92       	push	r1
     1e6:	1f 92       	push	r1
     1e8:	cd b7       	in	r28, 0x3d	; 61
     1ea:	de b7       	in	r29, 0x3e	; 62
     1ec:	6a 83       	std	Y+2, r22	; 0x02
     1ee:	80 91 ea 02 	lds	r24, 0x02EA
     1f2:	88 23       	and	r24, r24
     1f4:	19 f0       	breq	.+6      	; 0x1fc <_bt_call_back+0x1c>
     1f6:	86 2f       	mov	r24, r22
     1f8:	57 d4       	rcall	.+2222   	; 0xaa8 <dialog_byte_received>
     1fa:	13 c0       	rjmp	.+38     	; 0x222 <_bt_call_back+0x42>
     1fc:	80 91 e6 02 	lds	r24, 0x02E6
     200:	90 91 e7 02 	lds	r25, 0x02E7
     204:	00 97       	sbiw	r24, 0x00	; 0
     206:	69 f0       	breq	.+26     	; 0x222 <_bt_call_back+0x42>
     208:	19 82       	std	Y+1, r1	; 0x01
     20a:	20 e0       	ldi	r18, 0x00	; 0
     20c:	ae 01       	movw	r20, r28
     20e:	4f 5f       	subi	r20, 0xFF	; 255
     210:	5f 4f       	sbci	r21, 0xFF	; 255
     212:	be 01       	movw	r22, r28
     214:	6e 5f       	subi	r22, 0xFE	; 254
     216:	7f 4f       	sbci	r23, 0xFF	; 255
     218:	0e 94 a5 09 	call	0x134a	; 0x134a <xQueueGenericSendFromISR>
     21c:	89 81       	ldd	r24, Y+1	; 0x01
     21e:	81 11       	cpse	r24, r1
     220:	78 d6       	rcall	.+3312   	; 0xf12 <vPortYield>
     222:	0f 90       	pop	r0
     224:	0f 90       	pop	r0
     226:	df 91       	pop	r29
     228:	cf 91       	pop	r28
     22a:	08 95       	ret

0000022c <_mpu9250_read_reg>:
     22c:	df 92       	push	r13
     22e:	ef 92       	push	r14
     230:	ff 92       	push	r15
     232:	0f 93       	push	r16
     234:	1f 93       	push	r17
     236:	cf 93       	push	r28
     238:	df 93       	push	r29
     23a:	cd b7       	in	r28, 0x3d	; 61
     23c:	de b7       	in	r29, 0x3e	; 62
     23e:	d6 2e       	mov	r13, r22
     240:	ed b6       	in	r14, 0x3d	; 61
     242:	fe b6       	in	r15, 0x3e	; 62
     244:	26 2f       	mov	r18, r22
     246:	30 e0       	ldi	r19, 0x00	; 0
     248:	2f 5f       	subi	r18, 0xFF	; 255
     24a:	3f 4f       	sbci	r19, 0xFF	; 255
     24c:	4d b7       	in	r20, 0x3d	; 61
     24e:	5e b7       	in	r21, 0x3e	; 62
     250:	42 1b       	sub	r20, r18
     252:	53 0b       	sbc	r21, r19
     254:	0f b6       	in	r0, 0x3f	; 63
     256:	f8 94       	cli
     258:	5e bf       	out	0x3e, r21	; 62
     25a:	0f be       	out	0x3f, r0	; 63
     25c:	4d bf       	out	0x3d, r20	; 61
     25e:	0d b7       	in	r16, 0x3d	; 61
     260:	1e b7       	in	r17, 0x3e	; 62
     262:	0f 5f       	subi	r16, 0xFF	; 255
     264:	1f 4f       	sbci	r17, 0xFF	; 255
     266:	98 01       	movw	r18, r16
     268:	80 68       	ori	r24, 0x80	; 128
     26a:	ed b7       	in	r30, 0x3d	; 61
     26c:	fe b7       	in	r31, 0x3e	; 62
     26e:	81 83       	std	Z+1, r24	; 0x01
     270:	66 23       	and	r22, r22
     272:	41 f0       	breq	.+16     	; 0x284 <_mpu9250_read_reg+0x58>
     274:	81 e0       	ldi	r24, 0x01	; 1
     276:	f9 01       	movw	r30, r18
     278:	e8 0f       	add	r30, r24
     27a:	f1 1d       	adc	r31, r1
     27c:	10 82       	st	Z, r1
     27e:	8f 5f       	subi	r24, 0xFF	; 255
     280:	d8 16       	cp	r13, r24
     282:	c8 f7       	brcc	.-14     	; 0x276 <_mpu9250_read_reg+0x4a>
     284:	8a e0       	ldi	r24, 0x0A	; 10
     286:	93 e0       	ldi	r25, 0x03	; 3
     288:	f4 d2       	rcall	.+1512   	; 0x872 <buffer_clear>
     28a:	41 e0       	ldi	r20, 0x01	; 1
     28c:	4d 0d       	add	r20, r13
     28e:	b8 01       	movw	r22, r16
     290:	80 91 1f 03 	lds	r24, 0x031F
     294:	90 91 20 03 	lds	r25, 0x0320
     298:	0e 94 a4 12 	call	0x2548	; 0x2548 <spi_send_string>
     29c:	0f b6       	in	r0, 0x3f	; 63
     29e:	f8 94       	cli
     2a0:	fe be       	out	0x3e, r15	; 62
     2a2:	0f be       	out	0x3f, r0	; 63
     2a4:	ed be       	out	0x3d, r14	; 61
     2a6:	df 91       	pop	r29
     2a8:	cf 91       	pop	r28
     2aa:	1f 91       	pop	r17
     2ac:	0f 91       	pop	r16
     2ae:	ff 90       	pop	r15
     2b0:	ef 90       	pop	r14
     2b2:	df 90       	pop	r13
     2b4:	08 95       	ret

000002b6 <_send_bytes_to_bt>:
     2b6:	46 2f       	mov	r20, r22
     2b8:	bc 01       	movw	r22, r24
     2ba:	80 91 1d 03 	lds	r24, 0x031D
     2be:	90 91 1e 03 	lds	r25, 0x031E
     2c2:	0c 94 82 10 	jmp	0x2104	; 0x2104 <serial_send_bytes>
     2c6:	08 95       	ret

000002c8 <_mpu9250_call_back>:
     2c8:	cf 93       	push	r28
     2ca:	df 93       	push	r29
     2cc:	00 d0       	rcall	.+0      	; 0x2ce <_mpu9250_call_back+0x6>
     2ce:	1f 92       	push	r1
     2d0:	cd b7       	in	r28, 0x3d	; 61
     2d2:	de b7       	in	r29, 0x3e	; 62
     2d4:	80 91 bd 02 	lds	r24, 0x02BD
     2d8:	82 30       	cpi	r24, 0x02	; 2
     2da:	c1 f1       	breq	.+112    	; 0x34c <_mpu9250_call_back+0x84>
     2dc:	28 f4       	brcc	.+10     	; 0x2e8 <_mpu9250_call_back+0x20>
     2de:	88 23       	and	r24, r24
     2e0:	51 f0       	breq	.+20     	; 0x2f6 <_mpu9250_call_back+0x2e>
     2e2:	81 30       	cpi	r24, 0x01	; 1
     2e4:	c9 f0       	breq	.+50     	; 0x318 <_mpu9250_call_back+0x50>
     2e6:	eb c0       	rjmp	.+470    	; 0x4be <_mpu9250_call_back+0x1f6>
     2e8:	83 30       	cpi	r24, 0x03	; 3
     2ea:	09 f4       	brne	.+2      	; 0x2ee <_mpu9250_call_back+0x26>
     2ec:	3f c0       	rjmp	.+126    	; 0x36c <_mpu9250_call_back+0xa4>
     2ee:	85 30       	cpi	r24, 0x05	; 5
     2f0:	09 f4       	brne	.+2      	; 0x2f4 <_mpu9250_call_back+0x2c>
     2f2:	91 c0       	rjmp	.+290    	; 0x416 <_mpu9250_call_back+0x14e>
     2f4:	e4 c0       	rjmp	.+456    	; 0x4be <_mpu9250_call_back+0x1f6>
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	80 93 bd 02 	sts	0x02BD, r24
     2fc:	8c e1       	ldi	r24, 0x1C	; 28
     2fe:	8b 83       	std	Y+3, r24	; 0x03
     300:	1c 82       	std	Y+4, r1	; 0x04
     302:	42 e0       	ldi	r20, 0x02	; 2
     304:	be 01       	movw	r22, r28
     306:	6d 5f       	subi	r22, 0xFD	; 253
     308:	7f 4f       	sbci	r23, 0xFF	; 255
     30a:	80 91 1f 03 	lds	r24, 0x031F
     30e:	90 91 20 03 	lds	r25, 0x0320
     312:	0e 94 a4 12 	call	0x2548	; 0x2548 <spi_send_string>
     316:	d3 c0       	rjmp	.+422    	; 0x4be <_mpu9250_call_back+0x1f6>
     318:	8a e0       	ldi	r24, 0x0A	; 10
     31a:	93 e0       	ldi	r25, 0x03	; 3
     31c:	a7 d2       	rcall	.+1358   	; 0x86c <buffer_no_of_items>
     31e:	82 30       	cpi	r24, 0x02	; 2
     320:	09 f0       	breq	.+2      	; 0x324 <_mpu9250_call_back+0x5c>
     322:	cd c0       	rjmp	.+410    	; 0x4be <_mpu9250_call_back+0x1f6>
     324:	80 93 bd 02 	sts	0x02BD, r24
     328:	8a e0       	ldi	r24, 0x0A	; 10
     32a:	93 e0       	ldi	r25, 0x03	; 3
     32c:	a2 d2       	rcall	.+1348   	; 0x872 <buffer_clear>
     32e:	8b e1       	ldi	r24, 0x1B	; 27
     330:	8b 83       	std	Y+3, r24	; 0x03
     332:	88 e0       	ldi	r24, 0x08	; 8
     334:	8c 83       	std	Y+4, r24	; 0x04
     336:	42 e0       	ldi	r20, 0x02	; 2
     338:	be 01       	movw	r22, r28
     33a:	6d 5f       	subi	r22, 0xFD	; 253
     33c:	7f 4f       	sbci	r23, 0xFF	; 255
     33e:	80 91 1f 03 	lds	r24, 0x031F
     342:	90 91 20 03 	lds	r25, 0x0320
     346:	0e 94 a4 12 	call	0x2548	; 0x2548 <spi_send_string>
     34a:	b9 c0       	rjmp	.+370    	; 0x4be <_mpu9250_call_back+0x1f6>
     34c:	8a e0       	ldi	r24, 0x0A	; 10
     34e:	93 e0       	ldi	r25, 0x03	; 3
     350:	8d d2       	rcall	.+1306   	; 0x86c <buffer_no_of_items>
     352:	82 30       	cpi	r24, 0x02	; 2
     354:	09 f0       	breq	.+2      	; 0x358 <_mpu9250_call_back+0x90>
     356:	b3 c0       	rjmp	.+358    	; 0x4be <_mpu9250_call_back+0x1f6>
     358:	83 e0       	ldi	r24, 0x03	; 3
     35a:	80 93 bd 02 	sts	0x02BD, r24
     35e:	8a e0       	ldi	r24, 0x0A	; 10
     360:	93 e0       	ldi	r25, 0x03	; 3
     362:	87 d2       	rcall	.+1294   	; 0x872 <buffer_clear>
     364:	66 e0       	ldi	r22, 0x06	; 6
     366:	8b e3       	ldi	r24, 0x3B	; 59
     368:	61 df       	rcall	.-318    	; 0x22c <_mpu9250_read_reg>
     36a:	a9 c0       	rjmp	.+338    	; 0x4be <_mpu9250_call_back+0x1f6>
     36c:	8a e0       	ldi	r24, 0x0A	; 10
     36e:	93 e0       	ldi	r25, 0x03	; 3
     370:	7d d2       	rcall	.+1274   	; 0x86c <buffer_no_of_items>
     372:	87 30       	cpi	r24, 0x07	; 7
     374:	09 f0       	breq	.+2      	; 0x378 <_mpu9250_call_back+0xb0>
     376:	a3 c0       	rjmp	.+326    	; 0x4be <_mpu9250_call_back+0x1f6>
     378:	be 01       	movw	r22, r28
     37a:	6f 5f       	subi	r22, 0xFF	; 255
     37c:	7f 4f       	sbci	r23, 0xFF	; 255
     37e:	8a e0       	ldi	r24, 0x0A	; 10
     380:	93 e0       	ldi	r25, 0x03	; 3
     382:	47 d2       	rcall	.+1166   	; 0x812 <buffer_get_item>
     384:	be 01       	movw	r22, r28
     386:	6e 5f       	subi	r22, 0xFE	; 254
     388:	7f 4f       	sbci	r23, 0xFF	; 255
     38a:	8a e0       	ldi	r24, 0x0A	; 10
     38c:	93 e0       	ldi	r25, 0x03	; 3
     38e:	41 d2       	rcall	.+1154   	; 0x812 <buffer_get_item>
     390:	be 01       	movw	r22, r28
     392:	6f 5f       	subi	r22, 0xFF	; 255
     394:	7f 4f       	sbci	r23, 0xFF	; 255
     396:	8a e0       	ldi	r24, 0x0A	; 10
     398:	93 e0       	ldi	r25, 0x03	; 3
     39a:	3b d2       	rcall	.+1142   	; 0x812 <buffer_get_item>
     39c:	8a 81       	ldd	r24, Y+2	; 0x02
     39e:	90 e0       	ldi	r25, 0x00	; 0
     3a0:	98 2f       	mov	r25, r24
     3a2:	88 27       	eor	r24, r24
     3a4:	29 81       	ldd	r18, Y+1	; 0x01
     3a6:	82 2b       	or	r24, r18
     3a8:	90 93 f6 02 	sts	0x02F6, r25
     3ac:	80 93 f5 02 	sts	0x02F5, r24
     3b0:	be 01       	movw	r22, r28
     3b2:	6e 5f       	subi	r22, 0xFE	; 254
     3b4:	7f 4f       	sbci	r23, 0xFF	; 255
     3b6:	8a e0       	ldi	r24, 0x0A	; 10
     3b8:	93 e0       	ldi	r25, 0x03	; 3
     3ba:	2b d2       	rcall	.+1110   	; 0x812 <buffer_get_item>
     3bc:	be 01       	movw	r22, r28
     3be:	6f 5f       	subi	r22, 0xFF	; 255
     3c0:	7f 4f       	sbci	r23, 0xFF	; 255
     3c2:	8a e0       	ldi	r24, 0x0A	; 10
     3c4:	93 e0       	ldi	r25, 0x03	; 3
     3c6:	25 d2       	rcall	.+1098   	; 0x812 <buffer_get_item>
     3c8:	8a 81       	ldd	r24, Y+2	; 0x02
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	98 2f       	mov	r25, r24
     3ce:	88 27       	eor	r24, r24
     3d0:	29 81       	ldd	r18, Y+1	; 0x01
     3d2:	82 2b       	or	r24, r18
     3d4:	90 93 f4 02 	sts	0x02F4, r25
     3d8:	80 93 f3 02 	sts	0x02F3, r24
     3dc:	be 01       	movw	r22, r28
     3de:	6e 5f       	subi	r22, 0xFE	; 254
     3e0:	7f 4f       	sbci	r23, 0xFF	; 255
     3e2:	8a e0       	ldi	r24, 0x0A	; 10
     3e4:	93 e0       	ldi	r25, 0x03	; 3
     3e6:	15 d2       	rcall	.+1066   	; 0x812 <buffer_get_item>
     3e8:	be 01       	movw	r22, r28
     3ea:	6f 5f       	subi	r22, 0xFF	; 255
     3ec:	7f 4f       	sbci	r23, 0xFF	; 255
     3ee:	8a e0       	ldi	r24, 0x0A	; 10
     3f0:	93 e0       	ldi	r25, 0x03	; 3
     3f2:	0f d2       	rcall	.+1054   	; 0x812 <buffer_get_item>
     3f4:	8a 81       	ldd	r24, Y+2	; 0x02
     3f6:	90 e0       	ldi	r25, 0x00	; 0
     3f8:	98 2f       	mov	r25, r24
     3fa:	88 27       	eor	r24, r24
     3fc:	29 81       	ldd	r18, Y+1	; 0x01
     3fe:	82 2b       	or	r24, r18
     400:	90 93 f2 02 	sts	0x02F2, r25
     404:	80 93 f1 02 	sts	0x02F1, r24
     408:	85 e0       	ldi	r24, 0x05	; 5
     40a:	80 93 bd 02 	sts	0x02BD, r24
     40e:	66 e0       	ldi	r22, 0x06	; 6
     410:	83 e4       	ldi	r24, 0x43	; 67
     412:	0c df       	rcall	.-488    	; 0x22c <_mpu9250_read_reg>
     414:	54 c0       	rjmp	.+168    	; 0x4be <_mpu9250_call_back+0x1f6>
     416:	8a e0       	ldi	r24, 0x0A	; 10
     418:	93 e0       	ldi	r25, 0x03	; 3
     41a:	28 d2       	rcall	.+1104   	; 0x86c <buffer_no_of_items>
     41c:	87 30       	cpi	r24, 0x07	; 7
     41e:	09 f0       	breq	.+2      	; 0x422 <_mpu9250_call_back+0x15a>
     420:	4e c0       	rjmp	.+156    	; 0x4be <_mpu9250_call_back+0x1f6>
     422:	be 01       	movw	r22, r28
     424:	6f 5f       	subi	r22, 0xFF	; 255
     426:	7f 4f       	sbci	r23, 0xFF	; 255
     428:	8a e0       	ldi	r24, 0x0A	; 10
     42a:	93 e0       	ldi	r25, 0x03	; 3
     42c:	f2 d1       	rcall	.+996    	; 0x812 <buffer_get_item>
     42e:	be 01       	movw	r22, r28
     430:	6e 5f       	subi	r22, 0xFE	; 254
     432:	7f 4f       	sbci	r23, 0xFF	; 255
     434:	8a e0       	ldi	r24, 0x0A	; 10
     436:	93 e0       	ldi	r25, 0x03	; 3
     438:	ec d1       	rcall	.+984    	; 0x812 <buffer_get_item>
     43a:	be 01       	movw	r22, r28
     43c:	6f 5f       	subi	r22, 0xFF	; 255
     43e:	7f 4f       	sbci	r23, 0xFF	; 255
     440:	8a e0       	ldi	r24, 0x0A	; 10
     442:	93 e0       	ldi	r25, 0x03	; 3
     444:	e6 d1       	rcall	.+972    	; 0x812 <buffer_get_item>
     446:	8a 81       	ldd	r24, Y+2	; 0x02
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	98 2f       	mov	r25, r24
     44c:	88 27       	eor	r24, r24
     44e:	29 81       	ldd	r18, Y+1	; 0x01
     450:	82 2b       	or	r24, r18
     452:	90 93 f0 02 	sts	0x02F0, r25
     456:	80 93 ef 02 	sts	0x02EF, r24
     45a:	be 01       	movw	r22, r28
     45c:	6e 5f       	subi	r22, 0xFE	; 254
     45e:	7f 4f       	sbci	r23, 0xFF	; 255
     460:	8a e0       	ldi	r24, 0x0A	; 10
     462:	93 e0       	ldi	r25, 0x03	; 3
     464:	d6 d1       	rcall	.+940    	; 0x812 <buffer_get_item>
     466:	be 01       	movw	r22, r28
     468:	6f 5f       	subi	r22, 0xFF	; 255
     46a:	7f 4f       	sbci	r23, 0xFF	; 255
     46c:	8a e0       	ldi	r24, 0x0A	; 10
     46e:	93 e0       	ldi	r25, 0x03	; 3
     470:	d0 d1       	rcall	.+928    	; 0x812 <buffer_get_item>
     472:	8a 81       	ldd	r24, Y+2	; 0x02
     474:	90 e0       	ldi	r25, 0x00	; 0
     476:	98 2f       	mov	r25, r24
     478:	88 27       	eor	r24, r24
     47a:	29 81       	ldd	r18, Y+1	; 0x01
     47c:	82 2b       	or	r24, r18
     47e:	90 93 ee 02 	sts	0x02EE, r25
     482:	80 93 ed 02 	sts	0x02ED, r24
     486:	be 01       	movw	r22, r28
     488:	6e 5f       	subi	r22, 0xFE	; 254
     48a:	7f 4f       	sbci	r23, 0xFF	; 255
     48c:	8a e0       	ldi	r24, 0x0A	; 10
     48e:	93 e0       	ldi	r25, 0x03	; 3
     490:	c0 d1       	rcall	.+896    	; 0x812 <buffer_get_item>
     492:	be 01       	movw	r22, r28
     494:	6f 5f       	subi	r22, 0xFF	; 255
     496:	7f 4f       	sbci	r23, 0xFF	; 255
     498:	8a e0       	ldi	r24, 0x0A	; 10
     49a:	93 e0       	ldi	r25, 0x03	; 3
     49c:	ba d1       	rcall	.+884    	; 0x812 <buffer_get_item>
     49e:	8a 81       	ldd	r24, Y+2	; 0x02
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	98 2f       	mov	r25, r24
     4a4:	88 27       	eor	r24, r24
     4a6:	29 81       	ldd	r18, Y+1	; 0x01
     4a8:	82 2b       	or	r24, r18
     4aa:	90 93 ec 02 	sts	0x02EC, r25
     4ae:	80 93 eb 02 	sts	0x02EB, r24
     4b2:	83 e0       	ldi	r24, 0x03	; 3
     4b4:	80 93 bd 02 	sts	0x02BD, r24
     4b8:	66 e0       	ldi	r22, 0x06	; 6
     4ba:	8b e3       	ldi	r24, 0x3B	; 59
     4bc:	b7 de       	rcall	.-658    	; 0x22c <_mpu9250_read_reg>
     4be:	0f 90       	pop	r0
     4c0:	0f 90       	pop	r0
     4c2:	0f 90       	pop	r0
     4c4:	0f 90       	pop	r0
     4c6:	df 91       	pop	r29
     4c8:	cf 91       	pop	r28
     4ca:	08 95       	ret

000004cc <set_head_light>:
     4cc:	88 23       	and	r24, r24
     4ce:	11 f0       	breq	.+4      	; 0x4d4 <set_head_light+0x8>
     4d0:	42 9a       	sbi	0x08, 2	; 8
     4d2:	08 95       	ret
     4d4:	42 98       	cbi	0x08, 2	; 8
     4d6:	08 95       	ret

000004d8 <set_brake_light>:
     4d8:	88 23       	and	r24, r24
     4da:	11 f0       	breq	.+4      	; 0x4e0 <set_brake_light+0x8>
     4dc:	41 9a       	sbi	0x08, 1	; 8
     4de:	08 95       	ret
     4e0:	41 98       	cbi	0x08, 1	; 8
     4e2:	08 95       	ret

000004e4 <set_motor_speed>:
     4e4:	85 36       	cpi	r24, 0x65	; 101
     4e6:	08 f0       	brcs	.+2      	; 0x4ea <set_motor_speed+0x6>
     4e8:	84 e6       	ldi	r24, 0x64	; 100
     4ea:	88 23       	and	r24, r24
     4ec:	a9 f0       	breq	.+42     	; 0x518 <set_motor_speed+0x34>
     4ee:	28 2f       	mov	r18, r24
     4f0:	30 e0       	ldi	r19, 0x00	; 0
     4f2:	af e7       	ldi	r26, 0x7F	; 127
     4f4:	bc e0       	ldi	r27, 0x0C	; 12
     4f6:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__umulhisi3>
     4fa:	24 e6       	ldi	r18, 0x64	; 100
     4fc:	30 e0       	ldi	r19, 0x00	; 0
     4fe:	40 e0       	ldi	r20, 0x00	; 0
     500:	50 e0       	ldi	r21, 0x00	; 0
     502:	0e 94 c6 13 	call	0x278c	; 0x278c <__divmodsi4>
     506:	30 93 99 00 	sts	0x0099, r19
     50a:	20 93 98 00 	sts	0x0098, r18
     50e:	30 93 9b 00 	sts	0x009B, r19
     512:	20 93 9a 00 	sts	0x009A, r18
     516:	08 95       	ret
     518:	10 92 99 00 	sts	0x0099, r1
     51c:	10 92 98 00 	sts	0x0098, r1
     520:	10 92 9b 00 	sts	0x009B, r1
     524:	10 92 9a 00 	sts	0x009A, r1
     528:	08 95       	ret

0000052a <init_main_board>:
     52a:	8f 92       	push	r8
     52c:	9f 92       	push	r9
     52e:	af 92       	push	r10
     530:	bf 92       	push	r11
     532:	cf 92       	push	r12
     534:	df 92       	push	r13
     536:	ef 92       	push	r14
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	3b 9a       	sbi	0x07, 3	; 7
     53e:	3a 9a       	sbi	0x07, 2	; 7
     540:	39 9a       	sbi	0x07, 1	; 7
     542:	38 9a       	sbi	0x07, 0	; 7
     544:	e0 e9       	ldi	r30, 0x90	; 144
     546:	f0 e0       	ldi	r31, 0x00	; 0
     548:	80 81       	ld	r24, Z
     54a:	82 60       	ori	r24, 0x02	; 2
     54c:	80 83       	st	Z, r24
     54e:	a1 e9       	ldi	r26, 0x91	; 145
     550:	b0 e0       	ldi	r27, 0x00	; 0
     552:	8c 91       	ld	r24, X
     554:	88 61       	ori	r24, 0x18	; 24
     556:	8c 93       	st	X, r24
     558:	8f e7       	ldi	r24, 0x7F	; 127
     55a:	9c e0       	ldi	r25, 0x0C	; 12
     55c:	90 93 99 00 	sts	0x0099, r25
     560:	80 93 98 00 	sts	0x0098, r24
     564:	20 81       	ld	r18, Z
     566:	20 6c       	ori	r18, 0xC0	; 192
     568:	20 83       	st	Z, r18
     56a:	6b 9a       	sbi	0x0d, 3	; 13
     56c:	90 93 9b 00 	sts	0x009B, r25
     570:	80 93 9a 00 	sts	0x009A, r24
     574:	20 81       	ld	r18, Z
     576:	20 63       	ori	r18, 0x30	; 48
     578:	20 83       	st	Z, r18
     57a:	6c 9a       	sbi	0x0d, 4	; 13
     57c:	90 93 97 00 	sts	0x0097, r25
     580:	80 93 96 00 	sts	0x0096, r24
     584:	8c 91       	ld	r24, X
     586:	81 60       	ori	r24, 0x01	; 1
     588:	8c 93       	st	X, r24
     58a:	80 e0       	ldi	r24, 0x00	; 0
     58c:	ab df       	rcall	.-170    	; 0x4e4 <set_motor_speed>
     58e:	6a 98       	cbi	0x0d, 2	; 13
     590:	6d 9a       	sbi	0x0d, 5	; 13
     592:	75 98       	cbi	0x0e, 5	; 14
     594:	08 9a       	sbi	0x01, 0	; 1
     596:	10 98       	cbi	0x02, 0	; 2
     598:	09 9a       	sbi	0x01, 1	; 1
     59a:	11 98       	cbi	0x02, 1	; 2
     59c:	0a 9a       	sbi	0x01, 2	; 1
     59e:	12 98       	cbi	0x02, 2	; 2
     5a0:	e9 e6       	ldi	r30, 0x69	; 105
     5a2:	f0 e0       	ldi	r31, 0x00	; 0
     5a4:	80 81       	ld	r24, Z
     5a6:	82 60       	ori	r24, 0x02	; 2
     5a8:	80 83       	st	Z, r24
     5aa:	e8 9a       	sbi	0x1d, 0	; 29
     5ac:	81 ed       	ldi	r24, 0xD1	; 209
     5ae:	92 e0       	ldi	r25, 0x02	; 2
     5b0:	2b d1       	rcall	.+598    	; 0x808 <buffer_init>
     5b2:	8e eb       	ldi	r24, 0xBE	; 190
     5b4:	92 e0       	ldi	r25, 0x02	; 2
     5b6:	28 d1       	rcall	.+592    	; 0x808 <buffer_init>
     5b8:	0f 2e       	mov	r0, r31
     5ba:	f0 ef       	ldi	r31, 0xF0	; 240
     5bc:	8f 2e       	mov	r8, r31
     5be:	f0 e0       	ldi	r31, 0x00	; 0
     5c0:	9f 2e       	mov	r9, r31
     5c2:	f0 2d       	mov	r31, r0
     5c4:	0f 2e       	mov	r0, r31
     5c6:	fe eb       	ldi	r31, 0xBE	; 190
     5c8:	af 2e       	mov	r10, r31
     5ca:	f2 e0       	ldi	r31, 0x02	; 2
     5cc:	bf 2e       	mov	r11, r31
     5ce:	f0 2d       	mov	r31, r0
     5d0:	0f 2e       	mov	r0, r31
     5d2:	f1 ed       	ldi	r31, 0xD1	; 209
     5d4:	cf 2e       	mov	r12, r31
     5d6:	f2 e0       	ldi	r31, 0x02	; 2
     5d8:	df 2e       	mov	r13, r31
     5da:	f0 2d       	mov	r31, r0
     5dc:	e1 2c       	mov	r14, r1
     5de:	00 e0       	ldi	r16, 0x00	; 0
     5e0:	23 e0       	ldi	r18, 0x03	; 3
     5e2:	40 e8       	ldi	r20, 0x80	; 128
     5e4:	55 e2       	ldi	r21, 0x25	; 37
     5e6:	60 e0       	ldi	r22, 0x00	; 0
     5e8:	70 e0       	ldi	r23, 0x00	; 0
     5ea:	80 e0       	ldi	r24, 0x00	; 0
     5ec:	0e 94 0b 10 	call	0x2016	; 0x2016 <serial_new_instance>
     5f0:	90 93 1e 03 	sts	0x031E, r25
     5f4:	80 93 1d 03 	sts	0x031D, r24
     5f8:	8a e0       	ldi	r24, 0x0A	; 10
     5fa:	93 e0       	ldi	r25, 0x03	; 3
     5fc:	05 d1       	rcall	.+522    	; 0x808 <buffer_init>
     5fe:	87 ef       	ldi	r24, 0xF7	; 247
     600:	92 e0       	ldi	r25, 0x02	; 2
     602:	02 d1       	rcall	.+516    	; 0x808 <buffer_init>
     604:	84 e6       	ldi	r24, 0x64	; 100
     606:	91 e0       	ldi	r25, 0x01	; 1
     608:	9f 93       	push	r25
     60a:	8f 93       	push	r24
     60c:	0f 2e       	mov	r0, r31
     60e:	f7 ef       	ldi	r31, 0xF7	; 247
     610:	8f 2e       	mov	r8, r31
     612:	f2 e0       	ldi	r31, 0x02	; 2
     614:	9f 2e       	mov	r9, r31
     616:	f0 2d       	mov	r31, r0
     618:	0f 2e       	mov	r0, r31
     61a:	fa e0       	ldi	r31, 0x0A	; 10
     61c:	af 2e       	mov	r10, r31
     61e:	f3 e0       	ldi	r31, 0x03	; 3
     620:	bf 2e       	mov	r11, r31
     622:	f0 2d       	mov	r31, r0
     624:	c1 2c       	mov	r12, r1
     626:	05 e2       	ldi	r16, 0x25	; 37
     628:	10 e0       	ldi	r17, 0x00	; 0
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	43 e0       	ldi	r20, 0x03	; 3
     62e:	63 e0       	ldi	r22, 0x03	; 3
     630:	80 e1       	ldi	r24, 0x10	; 16
     632:	0e 94 17 12 	call	0x242e	; 0x242e <spi_new_instance>
     636:	90 93 20 03 	sts	0x0320, r25
     63a:	80 93 1f 03 	sts	0x031F, r24
     63e:	60 e0       	ldi	r22, 0x00	; 0
     640:	80 e0       	ldi	r24, 0x00	; 0
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	41 de       	rcall	.-894    	; 0x2c8 <_mpu9250_call_back>
     646:	8b e9       	ldi	r24, 0x9B	; 155
     648:	80 93 b3 00 	sts	0x00B3, r24
     64c:	e1 eb       	ldi	r30, 0xB1	; 177
     64e:	f0 e0       	ldi	r31, 0x00	; 0
     650:	80 81       	ld	r24, Z
     652:	82 60       	ori	r24, 0x02	; 2
     654:	80 83       	st	Z, r24
     656:	a0 e7       	ldi	r26, 0x70	; 112
     658:	b0 e0       	ldi	r27, 0x00	; 0
     65a:	8c 91       	ld	r24, X
     65c:	82 60       	ori	r24, 0x02	; 2
     65e:	8c 93       	st	X, r24
     660:	80 81       	ld	r24, Z
     662:	85 60       	ori	r24, 0x05	; 5
     664:	80 83       	st	Z, r24
     666:	0f 90       	pop	r0
     668:	0f 90       	pop	r0
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	ef 90       	pop	r14
     670:	df 90       	pop	r13
     672:	cf 90       	pop	r12
     674:	bf 90       	pop	r11
     676:	af 90       	pop	r10
     678:	9f 90       	pop	r9
     67a:	8f 90       	pop	r8
     67c:	08 95       	ret

0000067e <set_brake>:
     67e:	85 36       	cpi	r24, 0x65	; 101
     680:	08 f0       	brcs	.+2      	; 0x684 <set_brake+0x6>
     682:	84 e6       	ldi	r24, 0x64	; 100
     684:	88 23       	and	r24, r24
     686:	a9 f0       	breq	.+42     	; 0x6b2 <set_brake+0x34>
     688:	28 2f       	mov	r18, r24
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	af e7       	ldi	r26, 0x7F	; 127
     68e:	bc e0       	ldi	r27, 0x0C	; 12
     690:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__umulhisi3>
     694:	24 e6       	ldi	r18, 0x64	; 100
     696:	30 e0       	ldi	r19, 0x00	; 0
     698:	40 e0       	ldi	r20, 0x00	; 0
     69a:	50 e0       	ldi	r21, 0x00	; 0
     69c:	0e 94 c6 13 	call	0x278c	; 0x278c <__divmodsi4>
     6a0:	30 93 99 00 	sts	0x0099, r19
     6a4:	20 93 98 00 	sts	0x0098, r18
     6a8:	10 92 9b 00 	sts	0x009B, r1
     6ac:	10 92 9a 00 	sts	0x009A, r1
     6b0:	08 95       	ret
     6b2:	10 92 99 00 	sts	0x0099, r1
     6b6:	10 92 98 00 	sts	0x0098, r1
     6ba:	10 92 9b 00 	sts	0x009B, r1
     6be:	10 92 9a 00 	sts	0x009A, r1
     6c2:	08 95       	ret

000006c4 <get_raw_x_accel>:
     6c4:	80 91 f5 02 	lds	r24, 0x02F5
     6c8:	90 91 f6 02 	lds	r25, 0x02F6
     6cc:	08 95       	ret

000006ce <get_raw_y_accel>:
     6ce:	80 91 f3 02 	lds	r24, 0x02F3
     6d2:	90 91 f4 02 	lds	r25, 0x02F4
     6d6:	08 95       	ret

000006d8 <get_raw_z_accel>:
     6d8:	80 91 f1 02 	lds	r24, 0x02F1
     6dc:	90 91 f2 02 	lds	r25, 0x02F2
     6e0:	08 95       	ret

000006e2 <set_bt_reset>:

// ----------------------------------------------------------------------------------------------------------------------
void set_bt_reset(uint8_t state) {
	if (state) {
     6e2:	88 23       	and	r24, r24
     6e4:	11 f0       	breq	.+4      	; 0x6ea <set_bt_reset+0x8>
		BT_RESET_PORT &= ~_BV(BT_RESET_PIN); // Set RESET low/active
     6e6:	10 98       	cbi	0x02, 0	; 2
     6e8:	08 95       	ret
		} else {
		BT_RESET_PORT |= _BV(BT_RESET_PIN); // Set RESET high/in-active
     6ea:	10 9a       	sbi	0x02, 0	; 2
     6ec:	08 95       	ret

000006ee <bt_send_bytes>:
static void _send_bytes_to_bt(uint8_t *bytes, uint8_t len) {
	serial_send_bytes(_bt_serial_instance, bytes, len);
}

// ----------------------------------------------------------------------------------------------------------------------
void bt_send_bytes(uint8_t *bytes, uint8_t len) {
     6ee:	46 2f       	mov	r20, r22
	serial_send_bytes(_bt_serial_instance, bytes, len);
     6f0:	bc 01       	movw	r22, r24
     6f2:	80 91 1d 03 	lds	r24, 0x031D
     6f6:	90 91 1e 03 	lds	r25, 0x031E
     6fa:	0c 94 82 10 	jmp	0x2104	; 0x2104 <serial_send_bytes>
     6fe:	08 95       	ret

00000700 <init_bt_module>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void init_bt_module(void (*bt_status_call_back)(uint8_t result), QueueHandle_t RX_Que) {
	_xRxedCharsQ = RX_Que;
     700:	70 93 e7 02 	sts	0x02E7, r23
     704:	60 93 e6 02 	sts	0x02E6, r22
	_app_bt_status_call_back = bt_status_call_back;
     708:	90 93 e9 02 	sts	0x02E9, r25
     70c:	80 93 e8 02 	sts	0x02E8, r24
	_bt_dialog_active = 1;
     710:	81 e0       	ldi	r24, 0x01	; 1
     712:	80 93 ea 02 	sts	0x02EA, r24
	dialog_start(_dialog_bt_init_seq, _send_bytes_to_bt, _bt_status_call_back);
     716:	46 ee       	ldi	r20, 0xE6	; 230
     718:	50 e0       	ldi	r21, 0x00	; 0
     71a:	6b e5       	ldi	r22, 0x5B	; 91
     71c:	71 e0       	ldi	r23, 0x01	; 1
     71e:	87 e0       	ldi	r24, 0x07	; 7
     720:	92 e0       	ldi	r25, 0x02	; 2
     722:	9a c1       	rjmp	.+820    	; 0xa58 <dialog_start>
     724:	08 95       	ret

00000726 <set_goal_line_semaphore>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void set_goal_line_semaphore(SemaphoreHandle_t goal_line_semaphore) {
	if (goal_line_semaphore) {
     726:	00 97       	sbiw	r24, 0x00	; 0
     728:	21 f0       	breq	.+8      	; 0x732 <set_goal_line_semaphore+0xc>
		_goal_line_semaphore = goal_line_semaphore;
     72a:	90 93 e5 02 	sts	0x02E5, r25
     72e:	80 93 e4 02 	sts	0x02E4, r24
     732:	08 95       	ret

00000734 <__vector_1>:
	}
}

ISR(INT0_vect) {
     734:	1f 92       	push	r1
     736:	0f 92       	push	r0
     738:	0f b6       	in	r0, 0x3f	; 63
     73a:	0f 92       	push	r0
     73c:	11 24       	eor	r1, r1
     73e:	0b b6       	in	r0, 0x3b	; 59
     740:	0f 92       	push	r0
     742:	2f 93       	push	r18
     744:	3f 93       	push	r19
     746:	4f 93       	push	r20
     748:	5f 93       	push	r21
     74a:	6f 93       	push	r22
     74c:	7f 93       	push	r23
     74e:	8f 93       	push	r24
     750:	9f 93       	push	r25
     752:	af 93       	push	r26
     754:	bf 93       	push	r27
     756:	ef 93       	push	r30
     758:	ff 93       	push	r31
	static signed portBASE_TYPE _higher_priority_task_woken;
	if (_goal_line_semaphore) {
     75a:	80 91 e4 02 	lds	r24, 0x02E4
     75e:	90 91 e5 02 	lds	r25, 0x02E5
     762:	00 97       	sbiw	r24, 0x00	; 0
     764:	49 f0       	breq	.+18     	; 0x778 <__vector_1+0x44>
		_higher_priority_task_woken = pdFALSE;
     766:	10 92 bc 02 	sts	0x02BC, r1

		xSemaphoreGiveFromISR(_goal_line_semaphore, &_higher_priority_task_woken);
     76a:	6c eb       	ldi	r22, 0xBC	; 188
     76c:	72 e0       	ldi	r23, 0x02	; 2
     76e:	1f d6       	rcall	.+3134   	; 0x13ae <xQueueGiveFromISR>
		
		if (_higher_priority_task_woken != pdFALSE) {
     770:	80 91 bc 02 	lds	r24, 0x02BC
     774:	81 11       	cpse	r24, r1
			portYIELD();
     776:	cd d3       	rcall	.+1946   	; 0xf12 <vPortYield>
		}
	}
}
     778:	ff 91       	pop	r31
     77a:	ef 91       	pop	r30
     77c:	bf 91       	pop	r27
     77e:	af 91       	pop	r26
     780:	9f 91       	pop	r25
     782:	8f 91       	pop	r24
     784:	7f 91       	pop	r23
     786:	6f 91       	pop	r22
     788:	5f 91       	pop	r21
     78a:	4f 91       	pop	r20
     78c:	3f 91       	pop	r19
     78e:	2f 91       	pop	r18
     790:	0f 90       	pop	r0
     792:	0b be       	out	0x3b, r0	; 59
     794:	0f 90       	pop	r0
     796:	0f be       	out	0x3f, r0	; 63
     798:	0f 90       	pop	r0
     79a:	1f 90       	pop	r1
     79c:	18 95       	reti

0000079e <__vector_13>:
	#elif ((DIALOG_HANDLER_PRESCALER == 1024))
	DIALOG_HANDLER_TCCRB_reg |= _BV(DIALOG_HANDLER_CS0_bit) | _BV(DIALOG_HANDLER_CS2_bit); ;    // Prescaler 1024 and Start Timer
	#endif
}

ISR(TIMER2_COMPA_vect) {
     79e:	1f 92       	push	r1
     7a0:	0f 92       	push	r0
     7a2:	0f b6       	in	r0, 0x3f	; 63
     7a4:	0f 92       	push	r0
     7a6:	11 24       	eor	r1, r1
     7a8:	0b b6       	in	r0, 0x3b	; 59
     7aa:	0f 92       	push	r0
     7ac:	2f 93       	push	r18
     7ae:	3f 93       	push	r19
     7b0:	4f 93       	push	r20
     7b2:	5f 93       	push	r21
     7b4:	6f 93       	push	r22
     7b6:	7f 93       	push	r23
     7b8:	8f 93       	push	r24
     7ba:	9f 93       	push	r25
     7bc:	af 93       	push	r26
     7be:	bf 93       	push	r27
     7c0:	ef 93       	push	r30
     7c2:	ff 93       	push	r31
	static uint8_t _count = 10;
	if (_bt_dialog_active) {
     7c4:	80 91 ea 02 	lds	r24, 0x02EA
     7c8:	88 23       	and	r24, r24
     7ca:	59 f0       	breq	.+22     	; 0x7e2 <__vector_13+0x44>
		if (--_count == 0) {
     7cc:	80 91 06 02 	lds	r24, 0x0206
     7d0:	81 50       	subi	r24, 0x01	; 1
     7d2:	19 f0       	breq	.+6      	; 0x7da <__vector_13+0x3c>
     7d4:	80 93 06 02 	sts	0x0206, r24
     7d8:	04 c0       	rjmp	.+8      	; 0x7e2 <__vector_13+0x44>
			_count = 10;
     7da:	8a e0       	ldi	r24, 0x0A	; 10
     7dc:	80 93 06 02 	sts	0x0206, r24
			dialog_tick();
     7e0:	4c d1       	rcall	.+664    	; 0xa7a <dialog_tick>
		}
	}
}
     7e2:	ff 91       	pop	r31
     7e4:	ef 91       	pop	r30
     7e6:	bf 91       	pop	r27
     7e8:	af 91       	pop	r26
     7ea:	9f 91       	pop	r25
     7ec:	8f 91       	pop	r24
     7ee:	7f 91       	pop	r23
     7f0:	6f 91       	pop	r22
     7f2:	5f 91       	pop	r21
     7f4:	4f 91       	pop	r20
     7f6:	3f 91       	pop	r19
     7f8:	2f 91       	pop	r18
     7fa:	0f 90       	pop	r0
     7fc:	0b be       	out	0x3b, r0	; 59
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
     802:	0f 90       	pop	r0
     804:	1f 90       	pop	r1
     806:	18 95       	reti

00000808 <buffer_init>:
 @return true if buffer is empty.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_is_empty(buffer_struct_t *buffer) {
	return (buffer->no_in_buffer == 0);
}
     808:	fc 01       	movw	r30, r24
     80a:	10 8a       	std	Z+16, r1	; 0x10
     80c:	11 8a       	std	Z+17, r1	; 0x11
     80e:	12 8a       	std	Z+18, r1	; 0x12
     810:	08 95       	ret

00000812 <buffer_get_item>:
     812:	fc 01       	movw	r30, r24
     814:	82 89       	ldd	r24, Z+18	; 0x12
     816:	88 23       	and	r24, r24
     818:	91 f0       	breq	.+36     	; 0x83e <buffer_get_item+0x2c>
     81a:	81 89       	ldd	r24, Z+17	; 0x11
     81c:	df 01       	movw	r26, r30
     81e:	a8 0f       	add	r26, r24
     820:	b1 1d       	adc	r27, r1
     822:	8c 91       	ld	r24, X
     824:	db 01       	movw	r26, r22
     826:	8c 93       	st	X, r24
     828:	81 89       	ldd	r24, Z+17	; 0x11
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	01 96       	adiw	r24, 0x01	; 1
     82e:	8f 70       	andi	r24, 0x0F	; 15
     830:	90 78       	andi	r25, 0x80	; 128
     832:	81 8b       	std	Z+17, r24	; 0x11
     834:	82 89       	ldd	r24, Z+18	; 0x12
     836:	81 50       	subi	r24, 0x01	; 1
     838:	82 8b       	std	Z+18, r24	; 0x12
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	08 95       	ret
     83e:	81 e0       	ldi	r24, 0x01	; 1
     840:	08 95       	ret

00000842 <buffer_put_item>:
     842:	fc 01       	movw	r30, r24
     844:	42 89       	ldd	r20, Z+18	; 0x12
     846:	40 31       	cpi	r20, 0x10	; 16
     848:	78 f4       	brcc	.+30     	; 0x868 <buffer_put_item+0x26>
     84a:	20 89       	ldd	r18, Z+16	; 0x10
     84c:	30 e0       	ldi	r19, 0x00	; 0
     84e:	e2 0f       	add	r30, r18
     850:	f3 1f       	adc	r31, r19
     852:	60 83       	st	Z, r22
     854:	2f 5f       	subi	r18, 0xFF	; 255
     856:	3f 4f       	sbci	r19, 0xFF	; 255
     858:	2f 70       	andi	r18, 0x0F	; 15
     85a:	30 78       	andi	r19, 0x80	; 128
     85c:	fc 01       	movw	r30, r24
     85e:	20 8b       	std	Z+16, r18	; 0x10
     860:	4f 5f       	subi	r20, 0xFF	; 255
     862:	42 8b       	std	Z+18, r20	; 0x12
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	08 95       	ret
     868:	82 e0       	ldi	r24, 0x02	; 2
     86a:	08 95       	ret

0000086c <buffer_no_of_items>:
 @return no of items in the buffer.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_no_of_items(buffer_struct_t *buffer) {
	return buffer->no_in_buffer;
}
     86c:	fc 01       	movw	r30, r24
     86e:	82 89       	ldd	r24, Z+18	; 0x12
     870:	08 95       	ret

00000872 <buffer_clear>:
 @ingroup buffer_function
 @brief Clear the content of the buffer.

 @param *buffer pointer to the buffer structure.
 **********************************************************************/
void buffer_clear(buffer_struct_t *buffer) {
     872:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     874:	10 8a       	std	Z+16, r1	; 0x10
	buffer->out_i = 0;
     876:	11 8a       	std	Z+17, r1	; 0x11
	buffer->no_in_buffer = 0;
     878:	12 8a       	std	Z+18, r1	; 0x12
     87a:	08 95       	ret

0000087c <_dialog_prepare_for_next_byte>:

 When the function returns it has setup the state variable _dialog_await_state that will be used in dialog_char_received(), and the needed argument counters etc.
 */
static void _dialog_prepare_for_next_byte() {
  // esc char?
  if (*(_dialog_format.response_p) == '%') {
     87c:	e0 91 2e 03 	lds	r30, 0x032E
     880:	f0 91 2f 03 	lds	r31, 0x032F
     884:	80 81       	ld	r24, Z
     886:	85 32       	cpi	r24, 0x25	; 37
     888:	09 f0       	breq	.+2      	; 0x88c <_dialog_prepare_for_next_byte+0x10>
     88a:	85 c0       	rjmp	.+266    	; 0x996 <_dialog_prepare_for_next_byte+0x11a>
    _dialog_format.response_p++;
     88c:	cf 01       	movw	r24, r30
     88e:	01 96       	adiw	r24, 0x01	; 1
     890:	90 93 2f 03 	sts	0x032F, r25
     894:	80 93 2e 03 	sts	0x032E, r24

    if (*(_dialog_format.response_p) == '%') {
     898:	81 81       	ldd	r24, Z+1	; 0x01
     89a:	85 32       	cpi	r24, 0x25	; 37
     89c:	19 f4       	brne	.+6      	; 0x8a4 <_dialog_prepare_for_next_byte+0x28>
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
     89e:	10 92 25 03 	sts	0x0325, r1
     8a2:	08 95       	ret
    } else if (*_dialog_format.response_p == '*') {
     8a4:	8a 32       	cpi	r24, 0x2A	; 42
     8a6:	e1 f5       	brne	.+120    	; 0x920 <_dialog_prepare_for_next_byte+0xa4>
      // Max args: %*nnB
      _dialog_format.response_p++;
     8a8:	cf 01       	movw	r24, r30
     8aa:	02 96       	adiw	r24, 0x02	; 2
     8ac:	90 93 2f 03 	sts	0x032F, r25
     8b0:	80 93 2e 03 	sts	0x032E, r24
     8b4:	33 96       	adiw	r30, 0x03	; 3
     8b6:	20 e0       	ldi	r18, 0x00	; 0
     8b8:	dc 01       	movw	r26, r24
     8ba:	01 96       	adiw	r24, 0x01	; 1
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     8bc:	22 0f       	add	r18, r18
     8be:	32 2f       	mov	r19, r18
     8c0:	33 0f       	add	r19, r19
     8c2:	33 0f       	add	r19, r19
     8c4:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     8c6:	20 53       	subi	r18, 0x30	; 48
     8c8:	3c 91       	ld	r19, X
     8ca:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     8cc:	31 91       	ld	r19, Z+
     8ce:	32 34       	cpi	r19, 0x42	; 66
     8d0:	99 f7       	brne	.-26     	; 0x8b8 <_dialog_prepare_for_next_byte+0x3c>
     8d2:	20 93 30 03 	sts	0x0330, r18
      _dialog_format.response_p++;
     8d6:	12 96       	adiw	r26, 0x02	; 2
     8d8:	b0 93 2f 03 	sts	0x032F, r27
     8dc:	a0 93 2e 03 	sts	0x032E, r26
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     8e0:	80 91 32 03 	lds	r24, 0x0332
     8e4:	90 91 33 03 	lds	r25, 0x0333
     8e8:	00 97       	sbiw	r24, 0x00	; 0
     8ea:	b1 f0       	breq	.+44     	; 0x918 <_dialog_prepare_for_next_byte+0x9c>
        _dialog_format.arg_index++;
     8ec:	e1 e3       	ldi	r30, 0x31	; 49
     8ee:	f3 e0       	ldi	r31, 0x03	; 3
     8f0:	20 81       	ld	r18, Z
     8f2:	2f 5f       	subi	r18, 0xFF	; 255
     8f4:	20 83       	st	Z, r18
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     8f6:	33 27       	eor	r19, r19
     8f8:	27 fd       	sbrc	r18, 7
     8fa:	30 95       	com	r19
     8fc:	f9 01       	movw	r30, r18
     8fe:	ee 0f       	add	r30, r30
     900:	ff 1f       	adc	r31, r31
     902:	e2 0f       	add	r30, r18
     904:	f3 1f       	adc	r31, r19
     906:	e8 0f       	add	r30, r24
     908:	f9 1f       	adc	r31, r25
     90a:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     90c:	80 81       	ld	r24, Z
     90e:	91 81       	ldd	r25, Z+1	; 0x01
     910:	90 93 35 03 	sts	0x0335, r25
     914:	80 93 34 03 	sts	0x0334, r24
      }
      _dialog_await_state = ARG_MAX_STATE;
     918:	82 e0       	ldi	r24, 0x02	; 2
     91a:	80 93 25 03 	sts	0x0325, r24
     91e:	08 95       	ret
     920:	80 91 2e 03 	lds	r24, 0x032E
     924:	90 91 2f 03 	lds	r25, 0x032F
     928:	dc 01       	movw	r26, r24
     92a:	11 96       	adiw	r26, 0x01	; 1
    _dialog_format.response_p++;

    if (*(_dialog_format.response_p) == '%') {
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
    } else if (*_dialog_format.response_p == '*') {
     92c:	20 e0       	ldi	r18, 0x00	; 0
     92e:	fc 01       	movw	r30, r24
     930:	01 96       	adiw	r24, 0x01	; 1
    } else {
      // args: %nnB
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     932:	22 0f       	add	r18, r18
     934:	32 2f       	mov	r19, r18
     936:	33 0f       	add	r19, r19
     938:	33 0f       	add	r19, r19
     93a:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     93c:	20 53       	subi	r18, 0x30	; 48
     93e:	30 81       	ld	r19, Z
     940:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     942:	3d 91       	ld	r19, X+
     944:	32 34       	cpi	r19, 0x42	; 66
     946:	99 f7       	brne	.-26     	; 0x92e <_dialog_prepare_for_next_byte+0xb2>
     948:	20 93 30 03 	sts	0x0330, r18
      _dialog_format.response_p++;
     94c:	32 96       	adiw	r30, 0x02	; 2
     94e:	f0 93 2f 03 	sts	0x032F, r31
     952:	e0 93 2e 03 	sts	0x032E, r30
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     956:	80 91 32 03 	lds	r24, 0x0332
     95a:	90 91 33 03 	lds	r25, 0x0333
     95e:	00 97       	sbiw	r24, 0x00	; 0
     960:	b1 f0       	breq	.+44     	; 0x98e <_dialog_prepare_for_next_byte+0x112>
        _dialog_format.arg_index++;
     962:	a1 e3       	ldi	r26, 0x31	; 49
     964:	b3 e0       	ldi	r27, 0x03	; 3
     966:	ec 91       	ld	r30, X
     968:	ef 5f       	subi	r30, 0xFF	; 255
     96a:	ec 93       	st	X, r30
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     96c:	ff 27       	eor	r31, r31
     96e:	e7 fd       	sbrc	r30, 7
     970:	f0 95       	com	r31
     972:	9f 01       	movw	r18, r30
     974:	22 0f       	add	r18, r18
     976:	33 1f       	adc	r19, r19
     978:	e2 0f       	add	r30, r18
     97a:	f3 1f       	adc	r31, r19
     97c:	e8 0f       	add	r30, r24
     97e:	f9 1f       	adc	r31, r25
     980:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     982:	80 81       	ld	r24, Z
     984:	91 81       	ldd	r25, Z+1	; 0x01
     986:	90 93 35 03 	sts	0x0335, r25
     98a:	80 93 34 03 	sts	0x0334, r24
      }
      _dialog_await_state = ARG_STATE;
     98e:	81 e0       	ldi	r24, 0x01	; 1
     990:	80 93 25 03 	sts	0x0325, r24
     994:	08 95       	ret
    }
  } else {
    _dialog_await_state = NORMAL_STATE;
     996:	10 92 25 03 	sts	0x0325, r1
     99a:	08 95       	ret

0000099c <_dialog_goto_state>:
 IF the new state is either DIALOG_OK_STOP or DIALOG_ERROR_STOP then the call_back function will be called.
 ELSE the new State will be setup.

 @param[in] new_state the new state to goto.
 */
static void _dialog_goto_state(const uint8_t new_state) {
     99c:	cf 93       	push	r28
     99e:	df 93       	push	r29
  _dialog_second_counter = 0;
     9a0:	10 92 29 03 	sts	0x0329, r1
  _dialog_current_state = new_state;
     9a4:	80 93 28 03 	sts	0x0328, r24
  if (new_state == DIALOG_ERROR_STOP || new_state == DIALOG_OK_STOP) {
     9a8:	92 e0       	ldi	r25, 0x02	; 2
     9aa:	98 0f       	add	r25, r24
     9ac:	92 30       	cpi	r25, 0x02	; 2
     9ae:	30 f4       	brcc	.+12     	; 0x9bc <_dialog_goto_state+0x20>
    (*_dialog_pf_call_back)(new_state);
     9b0:	e0 91 21 03 	lds	r30, 0x0321
     9b4:	f0 91 22 03 	lds	r31, 0x0322
     9b8:	19 95       	eicall
     9ba:	4b c0       	rjmp	.+150    	; 0xa52 <_dialog_goto_state+0xb6>
  } else {
    // Send command if any
    if (_dialog_seq[new_state].command_length != 0) {
     9bc:	9b e0       	ldi	r25, 0x0B	; 11
     9be:	89 9f       	mul	r24, r25
     9c0:	e0 01       	movw	r28, r0
     9c2:	11 24       	eor	r1, r1
     9c4:	a0 91 26 03 	lds	r26, 0x0326
     9c8:	b0 91 27 03 	lds	r27, 0x0327
     9cc:	ac 0f       	add	r26, r28
     9ce:	bd 1f       	adc	r27, r29
     9d0:	12 96       	adiw	r26, 0x02	; 2
     9d2:	6c 91       	ld	r22, X
     9d4:	12 97       	sbiw	r26, 0x02	; 2
     9d6:	66 23       	and	r22, r22
     9d8:	39 f0       	breq	.+14     	; 0x9e8 <_dialog_goto_state+0x4c>
      (*_dialog_pf_send)(_dialog_seq[new_state].command,
     9da:	e0 91 23 03 	lds	r30, 0x0323
     9de:	f0 91 24 03 	lds	r31, 0x0324
     9e2:	8d 91       	ld	r24, X+
     9e4:	9c 91       	ld	r25, X
     9e6:	19 95       	eicall
      _dialog_seq[new_state].command_length);
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
     9e8:	80 91 26 03 	lds	r24, 0x0326
     9ec:	90 91 27 03 	lds	r25, 0x0327
     9f0:	c8 0f       	add	r28, r24
     9f2:	d9 1f       	adc	r29, r25
     9f4:	2d 81       	ldd	r18, Y+5	; 0x05
     9f6:	22 23       	and	r18, r18
     9f8:	51 f1       	breq	.+84     	; 0xa4e <_dialog_goto_state+0xb2>
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
                  _dialog_seq[new_state].responce_format;
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
     9fc:	9c 81       	ldd	r25, Y+4	; 0x04
 @param[in] response_format to be waited for..
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
     9fe:	90 93 2b 03 	sts	0x032B, r25
     a02:	80 93 2a 03 	sts	0x032A, r24
     a06:	90 93 2f 03 	sts	0x032F, r25
     a0a:	80 93 2e 03 	sts	0x032E, r24
                  _dialog_seq[new_state].responce_format;
  _dialog_format.arg_buffers = _dialog_seq[new_state].arg_buffers;
     a0e:	e9 85       	ldd	r30, Y+9	; 0x09
     a10:	fa 85       	ldd	r31, Y+10	; 0x0a
     a12:	f0 93 33 03 	sts	0x0333, r31
     a16:	e0 93 32 03 	sts	0x0332, r30
  _dialog_format.arg_index = -1;
     a1a:	3f ef       	ldi	r19, 0xFF	; 255
     a1c:	30 93 31 03 	sts	0x0331, r19
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
     a20:	30 97       	sbiw	r30, 0x00	; 0
     a22:	31 f0       	breq	.+12     	; 0xa30 <_dialog_goto_state+0x94>
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
     a24:	40 81       	ld	r20, Z
     a26:	51 81       	ldd	r21, Z+1	; 0x01
     a28:	50 93 35 03 	sts	0x0335, r21
     a2c:	40 93 34 03 	sts	0x0334, r20
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
                  + _dialog_seq[new_state].responce_format_length - 1;
     a30:	30 e0       	ldi	r19, 0x00	; 0
     a32:	21 50       	subi	r18, 0x01	; 1
     a34:	31 09       	sbc	r19, r1
     a36:	82 0f       	add	r24, r18
     a38:	93 1f       	adc	r25, r19
  _dialog_format.arg_index = -1;
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
     a3a:	90 93 2d 03 	sts	0x032D, r25
     a3e:	80 93 2c 03 	sts	0x032C, r24
                  + _dialog_seq[new_state].responce_format_length - 1;
  _dialog_prepare_for_next_byte();
     a42:	1c df       	rcall	.-456    	; 0x87c <_dialog_prepare_for_next_byte>
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
      _dialog_await(new_state);
      _dialog_second_counter = _dialog_seq[new_state].max_response_time
     a44:	8e 81       	ldd	r24, Y+6	; 0x06
     a46:	8f 5f       	subi	r24, 0xFF	; 255
     a48:	80 93 29 03 	sts	0x0329, r24
     a4c:	02 c0       	rjmp	.+4      	; 0xa52 <_dialog_goto_state+0xb6>
                      + 1; // add one because of 1 sec jitter in second timer
    } else {
      _dialog_goto_state(_dialog_seq[new_state].ok_state);
     a4e:	8f 81       	ldd	r24, Y+7	; 0x07
     a50:	a5 df       	rcall	.-182    	; 0x99c <_dialog_goto_state>
    }
  }
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <dialog_start>:
 @endcode
 */
void dialog_start(dialog_seq_t *p_seq,
		void (*pf_send)(uint8_t *command, uint8_t command_length),
		void (*pf_call_back)(uint8_t result)) {
  _dialog_seq = p_seq;
     a58:	90 93 27 03 	sts	0x0327, r25
     a5c:	80 93 26 03 	sts	0x0326, r24
  _dialog_pf_send = pf_send;
     a60:	70 93 24 03 	sts	0x0324, r23
     a64:	60 93 23 03 	sts	0x0323, r22
  _dialog_pf_call_back = pf_call_back;
     a68:	50 93 22 03 	sts	0x0322, r21
     a6c:	40 93 21 03 	sts	0x0321, r20
  _dialog_current_state = 0;
     a70:	10 92 28 03 	sts	0x0328, r1
  _dialog_goto_state(0);
     a74:	80 e0       	ldi	r24, 0x00	; 0
     a76:	92 cf       	rjmp	.-220    	; 0x99c <_dialog_goto_state>
     a78:	08 95       	ret

00000a7a <dialog_tick>:
 @brief Housekeeping function that must be called every second when a dialog is active.

 If the maximum wait time is exceeded the the dialog will change to error state.
 */
void dialog_tick() {
  if (_dialog_second_counter) {
     a7a:	80 91 29 03 	lds	r24, 0x0329
     a7e:	88 23       	and	r24, r24
     a80:	91 f0       	breq	.+36     	; 0xaa6 <dialog_tick+0x2c>
    if (--_dialog_second_counter == 0) {
     a82:	81 50       	subi	r24, 0x01	; 1
     a84:	80 93 29 03 	sts	0x0329, r24
     a88:	81 11       	cpse	r24, r1
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <dialog_tick+0x2c>
      _dialog_goto_state(_dialog_seq[_dialog_current_state].error_state);
     a8c:	80 91 28 03 	lds	r24, 0x0328
     a90:	e0 91 26 03 	lds	r30, 0x0326
     a94:	f0 91 27 03 	lds	r31, 0x0327
     a98:	9b e0       	ldi	r25, 0x0B	; 11
     a9a:	89 9f       	mul	r24, r25
     a9c:	e0 0d       	add	r30, r0
     a9e:	f1 1d       	adc	r31, r1
     aa0:	11 24       	eor	r1, r1
     aa2:	80 85       	ldd	r24, Z+8	; 0x08
     aa4:	7b cf       	rjmp	.-266    	; 0x99c <_dialog_goto_state>
     aa6:	08 95       	ret

00000aa8 <dialog_byte_received>:
If there are specified a pointer to an argument buffer in the current state of the dialog_seq, the received argument bytes will be stored in this buffer, else the argument values will be thrown away.

 When/If the expected response string is received the dialog state is changed to the current dialog states OK state.
 @param[in] byte received from device we are communication with.
 */
void dialog_byte_received(const uint8_t byte) {
     aa8:	6f 92       	push	r6
     aaa:	7f 92       	push	r7
     aac:	8f 92       	push	r8
     aae:	9f 92       	push	r9
     ab0:	af 92       	push	r10
     ab2:	bf 92       	push	r11
     ab4:	cf 92       	push	r12
     ab6:	df 92       	push	r13
     ab8:	ef 92       	push	r14
     aba:	ff 92       	push	r15
     abc:	0f 93       	push	r16
     abe:	1f 93       	push	r17
     ac0:	cf 93       	push	r28
     ac2:	df 93       	push	r29
     ac4:	98 2e       	mov	r9, r24
  uint8_t _retry;
  
  switch (_dialog_await_state) {
     ac6:	80 91 25 03 	lds	r24, 0x0325
     aca:	81 30       	cpi	r24, 0x01	; 1
     acc:	09 f4       	brne	.+2      	; 0xad0 <dialog_byte_received+0x28>
     ace:	42 c0       	rjmp	.+132    	; 0xb54 <dialog_byte_received+0xac>
     ad0:	20 f0       	brcs	.+8      	; 0xada <dialog_byte_received+0x32>
     ad2:	82 30       	cpi	r24, 0x02	; 2
     ad4:	09 f4       	brne	.+2      	; 0xad8 <dialog_byte_received+0x30>
     ad6:	70 c0       	rjmp	.+224    	; 0xbb8 <dialog_byte_received+0x110>
     ad8:	af c0       	rjmp	.+350    	; 0xc38 <dialog_byte_received+0x190>
     ada:	81 2c       	mov	r8, r1
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     adc:	ce e2       	ldi	r28, 0x2E	; 46
     ade:	d3 e0       	ldi	r29, 0x03	; 3
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     ae0:	0f 2e       	mov	r0, r31
     ae2:	fa e2       	ldi	r31, 0x2A	; 42
     ae4:	cf 2e       	mov	r12, r31
     ae6:	f3 e0       	ldi	r31, 0x03	; 3
     ae8:	df 2e       	mov	r13, r31
     aea:	f0 2d       	mov	r31, r0

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     aec:	0f 2e       	mov	r0, r31
     aee:	f1 e3       	ldi	r31, 0x31	; 49
     af0:	ef 2e       	mov	r14, r31
     af2:	f3 e0       	ldi	r31, 0x03	; 3
     af4:	ff 2e       	mov	r15, r31
     af6:	f0 2d       	mov	r31, r0
        if (_dialog_format.arg_buffers != 0) {
     af8:	02 e3       	ldi	r16, 0x32	; 50
     afa:	13 e0       	ldi	r17, 0x03	; 3
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
        }

        if (!_retry) {
     afc:	77 24       	eor	r7, r7
     afe:	73 94       	inc	r7
     b00:	61 2c       	mov	r6, r1
        _dialog_format.response_p = _dialog_format.response;

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
        if (_dialog_format.arg_buffers != 0) {
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     b02:	0f 2e       	mov	r0, r31
     b04:	f4 e3       	ldi	r31, 0x34	; 52
     b06:	af 2e       	mov	r10, r31
     b08:	f3 e0       	ldi	r31, 0x03	; 3
     b0a:	bf 2e       	mov	r11, r31
     b0c:	f0 2d       	mov	r31, r0
  
  switch (_dialog_await_state) {
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     b0e:	e8 81       	ld	r30, Y
     b10:	f9 81       	ldd	r31, Y+1	; 0x01
     b12:	9f 01       	movw	r18, r30
     b14:	2f 5f       	subi	r18, 0xFF	; 255
     b16:	3f 4f       	sbci	r19, 0xFF	; 255
     b18:	39 83       	std	Y+1, r19	; 0x01
     b1a:	28 83       	st	Y, r18
     b1c:	80 81       	ld	r24, Z
     b1e:	89 15       	cp	r24, r9
     b20:	a9 f0       	breq	.+42     	; 0xb4c <dialog_byte_received+0xa4>
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     b22:	d6 01       	movw	r26, r12
     b24:	8d 91       	ld	r24, X+
     b26:	9c 91       	ld	r25, X
     b28:	99 83       	std	Y+1, r25	; 0x01
     b2a:	88 83       	st	Y, r24

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     b2c:	f7 01       	movw	r30, r14
     b2e:	10 82       	st	Z, r1
        if (_dialog_format.arg_buffers != 0) {
     b30:	d8 01       	movw	r26, r16
     b32:	ed 91       	ld	r30, X+
     b34:	fc 91       	ld	r31, X
     b36:	30 97       	sbiw	r30, 0x00	; 0
     b38:	29 f0       	breq	.+10     	; 0xb44 <dialog_byte_received+0x9c>
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     b3a:	80 81       	ld	r24, Z
     b3c:	91 81       	ldd	r25, Z+1	; 0x01
     b3e:	f5 01       	movw	r30, r10
     b40:	91 83       	std	Z+1, r25	; 0x01
     b42:	80 83       	st	Z, r24
        }

        if (!_retry) {
     b44:	87 2d       	mov	r24, r7
     b46:	81 10       	cpse	r8, r1
     b48:	86 2d       	mov	r24, r6
          _retry = 1;
     b4a:	88 2e       	mov	r8, r24
        } else {
          _retry = 0;
        }
      }
      _dialog_prepare_for_next_byte();
     b4c:	97 de       	rcall	.-722    	; 0x87c <_dialog_prepare_for_next_byte>
    } while (_retry);
     b4e:	81 10       	cpse	r8, r1
     b50:	de cf       	rjmp	.-68     	; 0xb0e <dialog_byte_received+0x66>
     b52:	72 c0       	rjmp	.+228    	; 0xc38 <dialog_byte_received+0x190>
    break;

  case ARG_STATE:
    // Test if buffer is specified
    if (_dialog_format.arg_buffers != 0) {
     b54:	20 91 32 03 	lds	r18, 0x0332
     b58:	30 91 33 03 	lds	r19, 0x0333
     b5c:	21 15       	cp	r18, r1
     b5e:	31 05       	cpc	r19, r1
     b60:	11 f1       	breq	.+68     	; 0xba6 <dialog_byte_received+0xfe>
      *_dialog_format.arg_buf_p++ = byte;
     b62:	a4 e3       	ldi	r26, 0x34	; 52
     b64:	b3 e0       	ldi	r27, 0x03	; 3
     b66:	ed 91       	ld	r30, X+
     b68:	fc 91       	ld	r31, X
     b6a:	11 97       	sbiw	r26, 0x01	; 1
     b6c:	cf 01       	movw	r24, r30
     b6e:	01 96       	adiw	r24, 0x01	; 1
     b70:	8d 93       	st	X+, r24
     b72:	9c 93       	st	X, r25
     b74:	90 82       	st	Z, r9
      // Update length of received argument in arg_buffers
      _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     b76:	e0 91 31 03 	lds	r30, 0x0331
     b7a:	ff 27       	eor	r31, r31
     b7c:	e7 fd       	sbrc	r30, 7
     b7e:	f0 95       	com	r31
     b80:	cf 01       	movw	r24, r30
     b82:	88 0f       	add	r24, r24
     b84:	99 1f       	adc	r25, r25
     b86:	e8 0f       	add	r30, r24
     b88:	f9 1f       	adc	r31, r25
     b8a:	e2 0f       	add	r30, r18
     b8c:	f3 1f       	adc	r31, r19
     b8e:	82 81       	ldd	r24, Z+2	; 0x02
     b90:	8f 5f       	subi	r24, 0xFF	; 255
     b92:	82 83       	std	Z+2, r24	; 0x02

      // have we got all the bytes in the this argument
      if (--(_dialog_format.arg_cnt) == 0) {
     b94:	e0 e3       	ldi	r30, 0x30	; 48
     b96:	f3 e0       	ldi	r31, 0x03	; 3
     b98:	80 81       	ld	r24, Z
     b9a:	81 50       	subi	r24, 0x01	; 1
     b9c:	80 83       	st	Z, r24
     b9e:	81 11       	cpse	r24, r1
     ba0:	4b c0       	rjmp	.+150    	; 0xc38 <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     ba2:	6c de       	rcall	.-808    	; 0x87c <_dialog_prepare_for_next_byte>
     ba4:	49 c0       	rjmp	.+146    	; 0xc38 <dialog_byte_received+0x190>
      }
    } else if (--(_dialog_format.arg_cnt) == 0) {
     ba6:	e0 e3       	ldi	r30, 0x30	; 48
     ba8:	f3 e0       	ldi	r31, 0x03	; 3
     baa:	80 81       	ld	r24, Z
     bac:	81 50       	subi	r24, 0x01	; 1
     bae:	80 83       	st	Z, r24
     bb0:	81 11       	cpse	r24, r1
     bb2:	42 c0       	rjmp	.+132    	; 0xc38 <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     bb4:	63 de       	rcall	.-826    	; 0x87c <_dialog_prepare_for_next_byte>
     bb6:	40 c0       	rjmp	.+128    	; 0xc38 <dialog_byte_received+0x190>
    }
    break;

  case ARG_MAX_STATE:
    // Test if we still are receiving argument bytes
    if (byte != *_dialog_format.response_p) {
     bb8:	e0 91 2e 03 	lds	r30, 0x032E
     bbc:	f0 91 2f 03 	lds	r31, 0x032F
     bc0:	80 81       	ld	r24, Z
     bc2:	89 15       	cp	r24, r9
     bc4:	51 f1       	breq	.+84     	; 0xc1a <dialog_byte_received+0x172>
      // Test if buffer is specified
      if (_dialog_format.arg_buffers != 0) {
     bc6:	80 91 32 03 	lds	r24, 0x0332
     bca:	90 91 33 03 	lds	r25, 0x0333
     bce:	00 97       	sbiw	r24, 0x00	; 0
     bd0:	09 f4       	brne	.+2      	; 0xbd4 <dialog_byte_received+0x12c>
     bd2:	4e c0       	rjmp	.+156    	; 0xc70 <dialog_byte_received+0x1c8>
        *_dialog_format.arg_buf_p++ = byte;
     bd4:	a4 e3       	ldi	r26, 0x34	; 52
     bd6:	b3 e0       	ldi	r27, 0x03	; 3
     bd8:	ed 91       	ld	r30, X+
     bda:	fc 91       	ld	r31, X
     bdc:	11 97       	sbiw	r26, 0x01	; 1
     bde:	9f 01       	movw	r18, r30
     be0:	2f 5f       	subi	r18, 0xFF	; 255
     be2:	3f 4f       	sbci	r19, 0xFF	; 255
     be4:	2d 93       	st	X+, r18
     be6:	3c 93       	st	X, r19
     be8:	90 82       	st	Z, r9
        // Update length of received argument in arg_buffers
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     bea:	20 91 31 03 	lds	r18, 0x0331
     bee:	33 27       	eor	r19, r19
     bf0:	27 fd       	sbrc	r18, 7
     bf2:	30 95       	com	r19
     bf4:	f9 01       	movw	r30, r18
     bf6:	ee 0f       	add	r30, r30
     bf8:	ff 1f       	adc	r31, r31
     bfa:	e2 0f       	add	r30, r18
     bfc:	f3 1f       	adc	r31, r19
     bfe:	e8 0f       	add	r30, r24
     c00:	f9 1f       	adc	r31, r25
     c02:	82 81       	ldd	r24, Z+2	; 0x02
     c04:	8f 5f       	subi	r24, 0xFF	; 255
     c06:	82 83       	std	Z+2, r24	; 0x02

        // Have we received the maximum number of bytes in argument?
        if (--(_dialog_format.arg_cnt) == 0) {
     c08:	e0 e3       	ldi	r30, 0x30	; 48
     c0a:	f3 e0       	ldi	r31, 0x03	; 3
     c0c:	80 81       	ld	r24, Z
     c0e:	81 50       	subi	r24, 0x01	; 1
     c10:	80 83       	st	Z, r24
     c12:	81 11       	cpse	r24, r1
     c14:	11 c0       	rjmp	.+34     	; 0xc38 <dialog_byte_received+0x190>
          _dialog_prepare_for_next_byte();
     c16:	32 de       	rcall	.-924    	; 0x87c <_dialog_prepare_for_next_byte>
     c18:	0f c0       	rjmp	.+30     	; 0xc38 <dialog_byte_received+0x190>
        }
      }
    } else if (--(_dialog_format.arg_cnt) == 0) { // or have we received the maximum allowed no of bytes in the argument?
     c1a:	a0 e3       	ldi	r26, 0x30	; 48
     c1c:	b3 e0       	ldi	r27, 0x03	; 3
     c1e:	8c 91       	ld	r24, X
     c20:	81 50       	subi	r24, 0x01	; 1
     c22:	8c 93       	st	X, r24
     c24:	81 11       	cpse	r24, r1
     c26:	02 c0       	rjmp	.+4      	; 0xc2c <dialog_byte_received+0x184>
      _dialog_prepare_for_next_byte();
     c28:	29 de       	rcall	.-942    	; 0x87c <_dialog_prepare_for_next_byte>
     c2a:	06 c0       	rjmp	.+12     	; 0xc38 <dialog_byte_received+0x190>
    } else {
      // Next byte in normal response is received
      _dialog_format.response_p++;
     c2c:	31 96       	adiw	r30, 0x01	; 1
     c2e:	f0 93 2f 03 	sts	0x032F, r31
     c32:	e0 93 2e 03 	sts	0x032E, r30
      _dialog_prepare_for_next_byte();
     c36:	22 de       	rcall	.-956    	; 0x87c <_dialog_prepare_for_next_byte>
  default:
    break;
  }

  // Test if we are done - have received all bytes in this state of the dialog_seq
  if ((_dialog_await_state == NORMAL_STATE) && (_dialog_format.response_p > _dialog_format.last)) {
     c38:	80 91 25 03 	lds	r24, 0x0325
     c3c:	81 11       	cpse	r24, r1
     c3e:	18 c0       	rjmp	.+48     	; 0xc70 <dialog_byte_received+0x1c8>
     c40:	20 91 2e 03 	lds	r18, 0x032E
     c44:	30 91 2f 03 	lds	r19, 0x032F
     c48:	80 91 2c 03 	lds	r24, 0x032C
     c4c:	90 91 2d 03 	lds	r25, 0x032D
     c50:	82 17       	cp	r24, r18
     c52:	93 07       	cpc	r25, r19
     c54:	68 f4       	brcc	.+26     	; 0xc70 <dialog_byte_received+0x1c8>
    // OK - goto OK state
    _dialog_goto_state(_dialog_seq[_dialog_current_state].ok_state);
     c56:	80 91 28 03 	lds	r24, 0x0328
     c5a:	e0 91 26 03 	lds	r30, 0x0326
     c5e:	f0 91 27 03 	lds	r31, 0x0327
     c62:	9b e0       	ldi	r25, 0x0B	; 11
     c64:	89 9f       	mul	r24, r25
     c66:	e0 0d       	add	r30, r0
     c68:	f1 1d       	adc	r31, r1
     c6a:	11 24       	eor	r1, r1
     c6c:	87 81       	ldd	r24, Z+7	; 0x07
     c6e:	96 de       	rcall	.-724    	; 0x99c <_dialog_goto_state>
  }
}
     c70:	df 91       	pop	r29
     c72:	cf 91       	pop	r28
     c74:	1f 91       	pop	r17
     c76:	0f 91       	pop	r16
     c78:	ff 90       	pop	r15
     c7a:	ef 90       	pop	r14
     c7c:	df 90       	pop	r13
     c7e:	cf 90       	pop	r12
     c80:	bf 90       	pop	r11
     c82:	af 90       	pop	r10
     c84:	9f 90       	pop	r9
     c86:	8f 90       	pop	r8
     c88:	7f 90       	pop	r7
     c8a:	6f 90       	pop	r6
     c8c:	08 95       	ret

00000c8e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     c8e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c90:	03 96       	adiw	r24, 0x03	; 3
     c92:	92 83       	std	Z+2, r25	; 0x02
     c94:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c96:	2f ef       	ldi	r18, 0xFF	; 255
     c98:	3f ef       	ldi	r19, 0xFF	; 255
     c9a:	34 83       	std	Z+4, r19	; 0x04
     c9c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c9e:	96 83       	std	Z+6, r25	; 0x06
     ca0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ca2:	90 87       	std	Z+8, r25	; 0x08
     ca4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     ca6:	10 82       	st	Z, r1
     ca8:	08 95       	ret

00000caa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     caa:	fc 01       	movw	r30, r24
     cac:	11 86       	std	Z+9, r1	; 0x09
     cae:	10 86       	std	Z+8, r1	; 0x08
     cb0:	08 95       	ret

00000cb2 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     cb2:	cf 93       	push	r28
     cb4:	df 93       	push	r29
     cb6:	9c 01       	movw	r18, r24
     cb8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     cba:	dc 01       	movw	r26, r24
     cbc:	11 96       	adiw	r26, 0x01	; 1
     cbe:	cd 91       	ld	r28, X+
     cc0:	dc 91       	ld	r29, X
     cc2:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     cc4:	d3 83       	std	Z+3, r29	; 0x03
     cc6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     cc8:	8c 81       	ldd	r24, Y+4	; 0x04
     cca:	9d 81       	ldd	r25, Y+5	; 0x05
     ccc:	95 83       	std	Z+5, r25	; 0x05
     cce:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     cd0:	8c 81       	ldd	r24, Y+4	; 0x04
     cd2:	9d 81       	ldd	r25, Y+5	; 0x05
     cd4:	dc 01       	movw	r26, r24
     cd6:	13 96       	adiw	r26, 0x03	; 3
     cd8:	7c 93       	st	X, r23
     cda:	6e 93       	st	-X, r22
     cdc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     cde:	7d 83       	std	Y+5, r23	; 0x05
     ce0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     ce2:	31 87       	std	Z+9, r19	; 0x09
     ce4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     ce6:	f9 01       	movw	r30, r18
     ce8:	80 81       	ld	r24, Z
     cea:	8f 5f       	subi	r24, 0xFF	; 255
     cec:	80 83       	st	Z, r24
}
     cee:	df 91       	pop	r29
     cf0:	cf 91       	pop	r28
     cf2:	08 95       	ret

00000cf4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     cf4:	cf 93       	push	r28
     cf6:	df 93       	push	r29
     cf8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     cfa:	48 81       	ld	r20, Y
     cfc:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     cfe:	4f 3f       	cpi	r20, 0xFF	; 255
     d00:	2f ef       	ldi	r18, 0xFF	; 255
     d02:	52 07       	cpc	r21, r18
     d04:	21 f4       	brne	.+8      	; 0xd0e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d06:	fc 01       	movw	r30, r24
     d08:	a7 81       	ldd	r26, Z+7	; 0x07
     d0a:	b0 85       	ldd	r27, Z+8	; 0x08
     d0c:	0d c0       	rjmp	.+26     	; 0xd28 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d0e:	dc 01       	movw	r26, r24
     d10:	13 96       	adiw	r26, 0x03	; 3
     d12:	12 96       	adiw	r26, 0x02	; 2
     d14:	ed 91       	ld	r30, X+
     d16:	fc 91       	ld	r31, X
     d18:	13 97       	sbiw	r26, 0x03	; 3
     d1a:	20 81       	ld	r18, Z
     d1c:	31 81       	ldd	r19, Z+1	; 0x01
     d1e:	42 17       	cp	r20, r18
     d20:	53 07       	cpc	r21, r19
     d22:	10 f0       	brcs	.+4      	; 0xd28 <vListInsert+0x34>
     d24:	df 01       	movw	r26, r30
     d26:	f5 cf       	rjmp	.-22     	; 0xd12 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     d28:	12 96       	adiw	r26, 0x02	; 2
     d2a:	ed 91       	ld	r30, X+
     d2c:	fc 91       	ld	r31, X
     d2e:	13 97       	sbiw	r26, 0x03	; 3
     d30:	fb 83       	std	Y+3, r31	; 0x03
     d32:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     d34:	d5 83       	std	Z+5, r29	; 0x05
     d36:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     d38:	bd 83       	std	Y+5, r27	; 0x05
     d3a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     d3c:	13 96       	adiw	r26, 0x03	; 3
     d3e:	dc 93       	st	X, r29
     d40:	ce 93       	st	-X, r28
     d42:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d44:	99 87       	std	Y+9, r25	; 0x09
     d46:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     d48:	fc 01       	movw	r30, r24
     d4a:	20 81       	ld	r18, Z
     d4c:	2f 5f       	subi	r18, 0xFF	; 255
     d4e:	20 83       	st	Z, r18
}
     d50:	df 91       	pop	r29
     d52:	cf 91       	pop	r28
     d54:	08 95       	ret

00000d56 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     d56:	cf 93       	push	r28
     d58:	df 93       	push	r29
     d5a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     d5c:	a0 85       	ldd	r26, Z+8	; 0x08
     d5e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     d60:	c2 81       	ldd	r28, Z+2	; 0x02
     d62:	d3 81       	ldd	r29, Z+3	; 0x03
     d64:	84 81       	ldd	r24, Z+4	; 0x04
     d66:	95 81       	ldd	r25, Z+5	; 0x05
     d68:	9d 83       	std	Y+5, r25	; 0x05
     d6a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     d6c:	c4 81       	ldd	r28, Z+4	; 0x04
     d6e:	d5 81       	ldd	r29, Z+5	; 0x05
     d70:	82 81       	ldd	r24, Z+2	; 0x02
     d72:	93 81       	ldd	r25, Z+3	; 0x03
     d74:	9b 83       	std	Y+3, r25	; 0x03
     d76:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     d78:	11 96       	adiw	r26, 0x01	; 1
     d7a:	cd 91       	ld	r28, X+
     d7c:	dc 91       	ld	r29, X
     d7e:	12 97       	sbiw	r26, 0x02	; 2
     d80:	ce 17       	cp	r28, r30
     d82:	df 07       	cpc	r29, r31
     d84:	31 f4       	brne	.+12     	; 0xd92 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     d86:	8c 81       	ldd	r24, Y+4	; 0x04
     d88:	9d 81       	ldd	r25, Y+5	; 0x05
     d8a:	12 96       	adiw	r26, 0x02	; 2
     d8c:	9c 93       	st	X, r25
     d8e:	8e 93       	st	-X, r24
     d90:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     d92:	11 86       	std	Z+9, r1	; 0x09
     d94:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     d96:	8c 91       	ld	r24, X
     d98:	81 50       	subi	r24, 0x01	; 1
     d9a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     d9c:	df 91       	pop	r29
     d9e:	cf 91       	pop	r28
     da0:	08 95       	ret

00000da2 <pxPortInitialiseStack>:
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */

#if defined( portUSE_TIMER0 )
   /* Setup clock source and compare match behaviour. Assuming 328p*/
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     da2:	31 e1       	ldi	r19, 0x11	; 17
     da4:	fc 01       	movw	r30, r24
     da6:	30 83       	st	Z, r19
     da8:	31 97       	sbiw	r30, 0x01	; 1
     daa:	22 e2       	ldi	r18, 0x22	; 34
     dac:	20 83       	st	Z, r18
     dae:	31 97       	sbiw	r30, 0x01	; 1
     db0:	a3 e3       	ldi	r26, 0x33	; 51
     db2:	a0 83       	st	Z, r26
     db4:	31 97       	sbiw	r30, 0x01	; 1
     db6:	60 83       	st	Z, r22
     db8:	31 97       	sbiw	r30, 0x01	; 1
     dba:	70 83       	st	Z, r23
     dbc:	31 97       	sbiw	r30, 0x01	; 1
     dbe:	10 82       	st	Z, r1
     dc0:	31 97       	sbiw	r30, 0x01	; 1
     dc2:	10 82       	st	Z, r1
     dc4:	31 97       	sbiw	r30, 0x01	; 1
     dc6:	60 e8       	ldi	r22, 0x80	; 128
     dc8:	60 83       	st	Z, r22
     dca:	31 97       	sbiw	r30, 0x01	; 1
     dcc:	10 82       	st	Z, r1
     dce:	31 97       	sbiw	r30, 0x01	; 1
     dd0:	10 82       	st	Z, r1
     dd2:	31 97       	sbiw	r30, 0x01	; 1
     dd4:	10 82       	st	Z, r1
     dd6:	31 97       	sbiw	r30, 0x01	; 1
     dd8:	62 e0       	ldi	r22, 0x02	; 2
     dda:	60 83       	st	Z, r22
     ddc:	31 97       	sbiw	r30, 0x01	; 1
     dde:	63 e0       	ldi	r22, 0x03	; 3
     de0:	60 83       	st	Z, r22
     de2:	31 97       	sbiw	r30, 0x01	; 1
     de4:	64 e0       	ldi	r22, 0x04	; 4
     de6:	60 83       	st	Z, r22
     de8:	31 97       	sbiw	r30, 0x01	; 1
     dea:	65 e0       	ldi	r22, 0x05	; 5
     dec:	60 83       	st	Z, r22
     dee:	31 97       	sbiw	r30, 0x01	; 1
     df0:	66 e0       	ldi	r22, 0x06	; 6
     df2:	60 83       	st	Z, r22
     df4:	31 97       	sbiw	r30, 0x01	; 1
     df6:	67 e0       	ldi	r22, 0x07	; 7
     df8:	60 83       	st	Z, r22
     dfa:	31 97       	sbiw	r30, 0x01	; 1
     dfc:	68 e0       	ldi	r22, 0x08	; 8
     dfe:	60 83       	st	Z, r22
     e00:	31 97       	sbiw	r30, 0x01	; 1
     e02:	69 e0       	ldi	r22, 0x09	; 9
     e04:	60 83       	st	Z, r22
     e06:	31 97       	sbiw	r30, 0x01	; 1
     e08:	60 e1       	ldi	r22, 0x10	; 16
     e0a:	60 83       	st	Z, r22
     e0c:	31 97       	sbiw	r30, 0x01	; 1
     e0e:	30 83       	st	Z, r19
     e10:	31 97       	sbiw	r30, 0x01	; 1
     e12:	32 e1       	ldi	r19, 0x12	; 18
     e14:	30 83       	st	Z, r19
     e16:	31 97       	sbiw	r30, 0x01	; 1
     e18:	33 e1       	ldi	r19, 0x13	; 19
     e1a:	30 83       	st	Z, r19
     e1c:	31 97       	sbiw	r30, 0x01	; 1
     e1e:	34 e1       	ldi	r19, 0x14	; 20
     e20:	30 83       	st	Z, r19
     e22:	31 97       	sbiw	r30, 0x01	; 1
     e24:	35 e1       	ldi	r19, 0x15	; 21
     e26:	30 83       	st	Z, r19
     e28:	31 97       	sbiw	r30, 0x01	; 1
     e2a:	36 e1       	ldi	r19, 0x16	; 22
     e2c:	30 83       	st	Z, r19
     e2e:	31 97       	sbiw	r30, 0x01	; 1
     e30:	37 e1       	ldi	r19, 0x17	; 23
     e32:	30 83       	st	Z, r19
     e34:	31 97       	sbiw	r30, 0x01	; 1
     e36:	38 e1       	ldi	r19, 0x18	; 24
     e38:	30 83       	st	Z, r19
     e3a:	31 97       	sbiw	r30, 0x01	; 1
     e3c:	39 e1       	ldi	r19, 0x19	; 25
     e3e:	30 83       	st	Z, r19
     e40:	31 97       	sbiw	r30, 0x01	; 1
     e42:	30 e2       	ldi	r19, 0x20	; 32
     e44:	30 83       	st	Z, r19
     e46:	31 97       	sbiw	r30, 0x01	; 1
     e48:	31 e2       	ldi	r19, 0x21	; 33
     e4a:	30 83       	st	Z, r19
     e4c:	31 97       	sbiw	r30, 0x01	; 1
     e4e:	20 83       	st	Z, r18
     e50:	31 97       	sbiw	r30, 0x01	; 1
     e52:	23 e2       	ldi	r18, 0x23	; 35
     e54:	20 83       	st	Z, r18
     e56:	31 97       	sbiw	r30, 0x01	; 1
     e58:	40 83       	st	Z, r20
     e5a:	31 97       	sbiw	r30, 0x01	; 1
     e5c:	50 83       	st	Z, r21
     e5e:	31 97       	sbiw	r30, 0x01	; 1
     e60:	26 e2       	ldi	r18, 0x26	; 38
     e62:	20 83       	st	Z, r18
     e64:	31 97       	sbiw	r30, 0x01	; 1
     e66:	27 e2       	ldi	r18, 0x27	; 39
     e68:	20 83       	st	Z, r18
     e6a:	31 97       	sbiw	r30, 0x01	; 1
     e6c:	28 e2       	ldi	r18, 0x28	; 40
     e6e:	20 83       	st	Z, r18
     e70:	31 97       	sbiw	r30, 0x01	; 1
     e72:	29 e2       	ldi	r18, 0x29	; 41
     e74:	20 83       	st	Z, r18
     e76:	31 97       	sbiw	r30, 0x01	; 1
     e78:	20 e3       	ldi	r18, 0x30	; 48
     e7a:	20 83       	st	Z, r18
     e7c:	31 97       	sbiw	r30, 0x01	; 1
     e7e:	21 e3       	ldi	r18, 0x31	; 49
     e80:	20 83       	st	Z, r18
     e82:	89 97       	sbiw	r24, 0x29	; 41
     e84:	08 95       	ret

00000e86 <xPortStartScheduler>:
     e86:	88 ee       	ldi	r24, 0xE8	; 232
     e88:	93 e0       	ldi	r25, 0x03	; 3
     e8a:	90 93 39 03 	sts	0x0339, r25
     e8e:	80 93 38 03 	sts	0x0338, r24
     e92:	90 93 37 03 	sts	0x0337, r25
     e96:	80 93 36 03 	sts	0x0336, r24
     e9a:	89 ef       	ldi	r24, 0xF9	; 249
     e9c:	87 bd       	out	0x27, r24	; 39
     e9e:	82 e0       	ldi	r24, 0x02	; 2
     ea0:	84 bd       	out	0x24, r24	; 36
     ea2:	83 e0       	ldi	r24, 0x03	; 3
     ea4:	85 bd       	out	0x25, r24	; 37
     ea6:	ee e6       	ldi	r30, 0x6E	; 110
     ea8:	f0 e0       	ldi	r31, 0x00	; 0
     eaa:	80 81       	ld	r24, Z
     eac:	82 60       	ori	r24, 0x02	; 2
     eae:	80 83       	st	Z, r24
     eb0:	a0 91 59 0d 	lds	r26, 0x0D59
     eb4:	b0 91 5a 0d 	lds	r27, 0x0D5A
     eb8:	cd 91       	ld	r28, X+
     eba:	cd bf       	out	0x3d, r28	; 61
     ebc:	dd 91       	ld	r29, X+
     ebe:	de bf       	out	0x3e, r29	; 62
     ec0:	ff 91       	pop	r31
     ec2:	ef 91       	pop	r30
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	bf 91       	pop	r27
     eca:	af 91       	pop	r26
     ecc:	9f 91       	pop	r25
     ece:	8f 91       	pop	r24
     ed0:	7f 91       	pop	r23
     ed2:	6f 91       	pop	r22
     ed4:	5f 91       	pop	r21
     ed6:	4f 91       	pop	r20
     ed8:	3f 91       	pop	r19
     eda:	2f 91       	pop	r18
     edc:	1f 91       	pop	r17
     ede:	0f 91       	pop	r16
     ee0:	ff 90       	pop	r15
     ee2:	ef 90       	pop	r14
     ee4:	df 90       	pop	r13
     ee6:	cf 90       	pop	r12
     ee8:	bf 90       	pop	r11
     eea:	af 90       	pop	r10
     eec:	9f 90       	pop	r9
     eee:	8f 90       	pop	r8
     ef0:	7f 90       	pop	r7
     ef2:	6f 90       	pop	r6
     ef4:	5f 90       	pop	r5
     ef6:	4f 90       	pop	r4
     ef8:	3f 90       	pop	r3
     efa:	2f 90       	pop	r2
     efc:	1f 90       	pop	r1
     efe:	0f 90       	pop	r0
     f00:	0c be       	out	0x3c, r0	; 60
     f02:	0f 90       	pop	r0
     f04:	0b be       	out	0x3b, r0	; 59
     f06:	0f 90       	pop	r0
     f08:	0f be       	out	0x3f, r0	; 63
     f0a:	0f 90       	pop	r0
     f0c:	08 95       	ret
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	08 95       	ret

00000f12 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f12:	0f 92       	push	r0
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	f8 94       	cli
     f18:	0f 92       	push	r0
     f1a:	0b b6       	in	r0, 0x3b	; 59
     f1c:	0f 92       	push	r0
     f1e:	0c b6       	in	r0, 0x3c	; 60
     f20:	0f 92       	push	r0
     f22:	1f 92       	push	r1
     f24:	11 24       	eor	r1, r1
     f26:	2f 92       	push	r2
     f28:	3f 92       	push	r3
     f2a:	4f 92       	push	r4
     f2c:	5f 92       	push	r5
     f2e:	6f 92       	push	r6
     f30:	7f 92       	push	r7
     f32:	8f 92       	push	r8
     f34:	9f 92       	push	r9
     f36:	af 92       	push	r10
     f38:	bf 92       	push	r11
     f3a:	cf 92       	push	r12
     f3c:	df 92       	push	r13
     f3e:	ef 92       	push	r14
     f40:	ff 92       	push	r15
     f42:	0f 93       	push	r16
     f44:	1f 93       	push	r17
     f46:	2f 93       	push	r18
     f48:	3f 93       	push	r19
     f4a:	4f 93       	push	r20
     f4c:	5f 93       	push	r21
     f4e:	6f 93       	push	r22
     f50:	7f 93       	push	r23
     f52:	8f 93       	push	r24
     f54:	9f 93       	push	r25
     f56:	af 93       	push	r26
     f58:	bf 93       	push	r27
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
     f5e:	ef 93       	push	r30
     f60:	ff 93       	push	r31
     f62:	a0 91 59 0d 	lds	r26, 0x0D59
     f66:	b0 91 5a 0d 	lds	r27, 0x0D5A
     f6a:	0d b6       	in	r0, 0x3d	; 61
     f6c:	0d 92       	st	X+, r0
     f6e:	0e b6       	in	r0, 0x3e	; 62
     f70:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f72:	b3 d5       	rcall	.+2918   	; 0x1ada <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f74:	a0 91 59 0d 	lds	r26, 0x0D59
     f78:	b0 91 5a 0d 	lds	r27, 0x0D5A
     f7c:	cd 91       	ld	r28, X+
     f7e:	cd bf       	out	0x3d, r28	; 61
     f80:	dd 91       	ld	r29, X+
     f82:	de bf       	out	0x3e, r29	; 62
     f84:	ff 91       	pop	r31
     f86:	ef 91       	pop	r30
     f88:	df 91       	pop	r29
     f8a:	cf 91       	pop	r28
     f8c:	bf 91       	pop	r27
     f8e:	af 91       	pop	r26
     f90:	9f 91       	pop	r25
     f92:	8f 91       	pop	r24
     f94:	7f 91       	pop	r23
     f96:	6f 91       	pop	r22
     f98:	5f 91       	pop	r21
     f9a:	4f 91       	pop	r20
     f9c:	3f 91       	pop	r19
     f9e:	2f 91       	pop	r18
     fa0:	1f 91       	pop	r17
     fa2:	0f 91       	pop	r16
     fa4:	ff 90       	pop	r15
     fa6:	ef 90       	pop	r14
     fa8:	df 90       	pop	r13
     faa:	cf 90       	pop	r12
     fac:	bf 90       	pop	r11
     fae:	af 90       	pop	r10
     fb0:	9f 90       	pop	r9
     fb2:	8f 90       	pop	r8
     fb4:	7f 90       	pop	r7
     fb6:	6f 90       	pop	r6
     fb8:	5f 90       	pop	r5
     fba:	4f 90       	pop	r4
     fbc:	3f 90       	pop	r3
     fbe:	2f 90       	pop	r2
     fc0:	1f 90       	pop	r1
     fc2:	0f 90       	pop	r0
     fc4:	0c be       	out	0x3c, r0	; 60
     fc6:	0f 90       	pop	r0
     fc8:	0b be       	out	0x3b, r0	; 59
     fca:	0f 90       	pop	r0
     fcc:	0f be       	out	0x3f, r0	; 63
     fce:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     fd0:	08 95       	ret

00000fd2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     fd2:	0f 92       	push	r0
     fd4:	0f b6       	in	r0, 0x3f	; 63
     fd6:	f8 94       	cli
     fd8:	0f 92       	push	r0
     fda:	0b b6       	in	r0, 0x3b	; 59
     fdc:	0f 92       	push	r0
     fde:	0c b6       	in	r0, 0x3c	; 60
     fe0:	0f 92       	push	r0
     fe2:	1f 92       	push	r1
     fe4:	11 24       	eor	r1, r1
     fe6:	2f 92       	push	r2
     fe8:	3f 92       	push	r3
     fea:	4f 92       	push	r4
     fec:	5f 92       	push	r5
     fee:	6f 92       	push	r6
     ff0:	7f 92       	push	r7
     ff2:	8f 92       	push	r8
     ff4:	9f 92       	push	r9
     ff6:	af 92       	push	r10
     ff8:	bf 92       	push	r11
     ffa:	cf 92       	push	r12
     ffc:	df 92       	push	r13
     ffe:	ef 92       	push	r14
    1000:	ff 92       	push	r15
    1002:	0f 93       	push	r16
    1004:	1f 93       	push	r17
    1006:	2f 93       	push	r18
    1008:	3f 93       	push	r19
    100a:	4f 93       	push	r20
    100c:	5f 93       	push	r21
    100e:	6f 93       	push	r22
    1010:	7f 93       	push	r23
    1012:	8f 93       	push	r24
    1014:	9f 93       	push	r25
    1016:	af 93       	push	r26
    1018:	bf 93       	push	r27
    101a:	cf 93       	push	r28
    101c:	df 93       	push	r29
    101e:	ef 93       	push	r30
    1020:	ff 93       	push	r31
    1022:	a0 91 59 0d 	lds	r26, 0x0D59
    1026:	b0 91 5a 0d 	lds	r27, 0x0D5A
    102a:	0d b6       	in	r0, 0x3d	; 61
    102c:	0d 92       	st	X+, r0
    102e:	0e b6       	in	r0, 0x3e	; 62
    1030:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
    1032:	80 91 36 03 	lds	r24, 0x0336
    1036:	90 91 37 03 	lds	r25, 0x0337
    103a:	01 97       	sbiw	r24, 0x01	; 1
    103c:	90 93 37 03 	sts	0x0337, r25
    1040:	80 93 36 03 	sts	0x0336, r24
    1044:	89 2b       	or	r24, r25
    1046:	41 f4       	brne	.+16     	; 0x1058 <vPortYieldFromTick+0x86>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
    1048:	80 91 38 03 	lds	r24, 0x0338
    104c:	90 91 39 03 	lds	r25, 0x0339
    1050:	90 93 37 03 	sts	0x0337, r25
    1054:	80 93 36 03 	sts	0x0336, r24
	}

	if( xTaskIncrementTick() != pdFALSE )
    1058:	ec d3       	rcall	.+2008   	; 0x1832 <xTaskIncrementTick>
    105a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    105c:	3e d5       	rcall	.+2684   	; 0x1ada <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    105e:	a0 91 59 0d 	lds	r26, 0x0D59
    1062:	b0 91 5a 0d 	lds	r27, 0x0D5A
    1066:	cd 91       	ld	r28, X+
    1068:	cd bf       	out	0x3d, r28	; 61
    106a:	dd 91       	ld	r29, X+
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	ff 91       	pop	r31
    1070:	ef 91       	pop	r30
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	bf 91       	pop	r27
    1078:	af 91       	pop	r26
    107a:	9f 91       	pop	r25
    107c:	8f 91       	pop	r24
    107e:	7f 91       	pop	r23
    1080:	6f 91       	pop	r22
    1082:	5f 91       	pop	r21
    1084:	4f 91       	pop	r20
    1086:	3f 91       	pop	r19
    1088:	2f 91       	pop	r18
    108a:	1f 91       	pop	r17
    108c:	0f 91       	pop	r16
    108e:	ff 90       	pop	r15
    1090:	ef 90       	pop	r14
    1092:	df 90       	pop	r13
    1094:	cf 90       	pop	r12
    1096:	bf 90       	pop	r11
    1098:	af 90       	pop	r10
    109a:	9f 90       	pop	r9
    109c:	8f 90       	pop	r8
    109e:	7f 90       	pop	r7
    10a0:	6f 90       	pop	r6
    10a2:	5f 90       	pop	r5
    10a4:	4f 90       	pop	r4
    10a6:	3f 90       	pop	r3
    10a8:	2f 90       	pop	r2
    10aa:	1f 90       	pop	r1
    10ac:	0f 90       	pop	r0
    10ae:	0c be       	out	0x3c, r0	; 60
    10b0:	0f 90       	pop	r0
    10b2:	0b be       	out	0x3b, r0	; 59
    10b4:	0f 90       	pop	r0
    10b6:	0f be       	out	0x3f, r0	; 63
    10b8:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    10ba:	08 95       	ret

000010bc <__vector_21>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
    10bc:	8a df       	rcall	.-236    	; 0xfd2 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    10be:	18 95       	reti

000010c0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10c0:	cf 93       	push	r28
    10c2:	df 93       	push	r29
    10c4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    10c6:	af d3       	rcall	.+1886   	; 0x1826 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    10c8:	80 91 3a 03 	lds	r24, 0x033A
    10cc:	90 91 3b 03 	lds	r25, 0x033B
    10d0:	89 2b       	or	r24, r25
    10d2:	31 f4       	brne	.+12     	; 0x10e0 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    10d4:	8f e3       	ldi	r24, 0x3F	; 63
    10d6:	93 e0       	ldi	r25, 0x03	; 3
    10d8:	90 93 3b 03 	sts	0x033B, r25
    10dc:	80 93 3a 03 	sts	0x033A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    10e0:	40 91 3c 03 	lds	r20, 0x033C
    10e4:	50 91 3d 03 	lds	r21, 0x033D
    10e8:	9e 01       	movw	r18, r28
    10ea:	24 0f       	add	r18, r20
    10ec:	35 1f       	adc	r19, r21
    10ee:	23 3c       	cpi	r18, 0xC3	; 195
    10f0:	89 e0       	ldi	r24, 0x09	; 9
    10f2:	38 07       	cpc	r19, r24
    10f4:	70 f4       	brcc	.+28     	; 0x1112 <pvPortMalloc+0x52>
    10f6:	42 17       	cp	r20, r18
    10f8:	53 07       	cpc	r21, r19
    10fa:	70 f4       	brcc	.+28     	; 0x1118 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    10fc:	c0 91 3a 03 	lds	r28, 0x033A
    1100:	d0 91 3b 03 	lds	r29, 0x033B
    1104:	c4 0f       	add	r28, r20
    1106:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    1108:	30 93 3d 03 	sts	0x033D, r19
    110c:	20 93 3c 03 	sts	0x033C, r18
    1110:	05 c0       	rjmp	.+10     	; 0x111c <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1112:	c0 e0       	ldi	r28, 0x00	; 0
    1114:	d0 e0       	ldi	r29, 0x00	; 0
    1116:	02 c0       	rjmp	.+4      	; 0x111c <pvPortMalloc+0x5c>
    1118:	c0 e0       	ldi	r28, 0x00	; 0
    111a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    111c:	45 d4       	rcall	.+2186   	; 0x19a8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    111e:	ce 01       	movw	r24, r28
    1120:	df 91       	pop	r29
    1122:	cf 91       	pop	r28
    1124:	08 95       	ret

00001126 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1126:	08 95       	ret

00001128 <prvCopyDataToQueue>:
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1128:	1f 93       	push	r17
    112a:	cf 93       	push	r28
    112c:	df 93       	push	r29
    112e:	ec 01       	movw	r28, r24
    1130:	14 2f       	mov	r17, r20
    1132:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1134:	88 23       	and	r24, r24
    1136:	e9 f1       	breq	.+122    	; 0x11b2 <prvCopyDataToQueue+0x8a>
    1138:	41 11       	cpse	r20, r1
    113a:	17 c0       	rjmp	.+46     	; 0x116a <prvCopyDataToQueue+0x42>
    113c:	48 2f       	mov	r20, r24
    113e:	50 e0       	ldi	r21, 0x00	; 0
    1140:	8c 81       	ldd	r24, Y+4	; 0x04
    1142:	9d 81       	ldd	r25, Y+5	; 0x05
    1144:	0e 94 1e 15 	call	0x2a3c	; 0x2a3c <memcpy>
    1148:	2c 8d       	ldd	r18, Y+28	; 0x1c
    114a:	8c 81       	ldd	r24, Y+4	; 0x04
    114c:	9d 81       	ldd	r25, Y+5	; 0x05
    114e:	82 0f       	add	r24, r18
    1150:	91 1d       	adc	r25, r1
    1152:	9d 83       	std	Y+5, r25	; 0x05
    1154:	8c 83       	std	Y+4, r24	; 0x04
    1156:	2a 81       	ldd	r18, Y+2	; 0x02
    1158:	3b 81       	ldd	r19, Y+3	; 0x03
    115a:	82 17       	cp	r24, r18
    115c:	93 07       	cpc	r25, r19
    115e:	48 f1       	brcs	.+82     	; 0x11b2 <prvCopyDataToQueue+0x8a>
    1160:	88 81       	ld	r24, Y
    1162:	99 81       	ldd	r25, Y+1	; 0x01
    1164:	9d 83       	std	Y+5, r25	; 0x05
    1166:	8c 83       	std	Y+4, r24	; 0x04
    1168:	24 c0       	rjmp	.+72     	; 0x11b2 <prvCopyDataToQueue+0x8a>
    116a:	48 2f       	mov	r20, r24
    116c:	50 e0       	ldi	r21, 0x00	; 0
    116e:	8e 81       	ldd	r24, Y+6	; 0x06
    1170:	9f 81       	ldd	r25, Y+7	; 0x07
    1172:	0e 94 1e 15 	call	0x2a3c	; 0x2a3c <memcpy>
    1176:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1178:	30 e0       	ldi	r19, 0x00	; 0
    117a:	31 95       	neg	r19
    117c:	21 95       	neg	r18
    117e:	31 09       	sbc	r19, r1
    1180:	8e 81       	ldd	r24, Y+6	; 0x06
    1182:	9f 81       	ldd	r25, Y+7	; 0x07
    1184:	82 0f       	add	r24, r18
    1186:	93 1f       	adc	r25, r19
    1188:	9f 83       	std	Y+7, r25	; 0x07
    118a:	8e 83       	std	Y+6, r24	; 0x06
    118c:	68 81       	ld	r22, Y
    118e:	79 81       	ldd	r23, Y+1	; 0x01
    1190:	86 17       	cp	r24, r22
    1192:	97 07       	cpc	r25, r23
    1194:	30 f4       	brcc	.+12     	; 0x11a2 <prvCopyDataToQueue+0x7a>
    1196:	8a 81       	ldd	r24, Y+2	; 0x02
    1198:	9b 81       	ldd	r25, Y+3	; 0x03
    119a:	28 0f       	add	r18, r24
    119c:	39 1f       	adc	r19, r25
    119e:	3f 83       	std	Y+7, r19	; 0x07
    11a0:	2e 83       	std	Y+6, r18	; 0x06
    11a2:	12 30       	cpi	r17, 0x02	; 2
    11a4:	31 f4       	brne	.+12     	; 0x11b2 <prvCopyDataToQueue+0x8a>
    11a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11a8:	88 23       	and	r24, r24
    11aa:	19 f0       	breq	.+6      	; 0x11b2 <prvCopyDataToQueue+0x8a>
    11ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11ae:	81 50       	subi	r24, 0x01	; 1
    11b0:	8a 8f       	std	Y+26, r24	; 0x1a
    11b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11b4:	8f 5f       	subi	r24, 0xFF	; 255
    11b6:	8a 8f       	std	Y+26, r24	; 0x1a
    11b8:	80 e0       	ldi	r24, 0x00	; 0
    11ba:	df 91       	pop	r29
    11bc:	cf 91       	pop	r28
    11be:	1f 91       	pop	r17
    11c0:	08 95       	ret

000011c2 <prvCopyDataFromQueue>:
    11c2:	fc 01       	movw	r30, r24
    11c4:	cb 01       	movw	r24, r22
    11c6:	44 8d       	ldd	r20, Z+28	; 0x1c
    11c8:	44 23       	and	r20, r20
    11ca:	a1 f0       	breq	.+40     	; 0x11f4 <prvCopyDataFromQueue+0x32>
    11cc:	50 e0       	ldi	r21, 0x00	; 0
    11ce:	26 81       	ldd	r18, Z+6	; 0x06
    11d0:	37 81       	ldd	r19, Z+7	; 0x07
    11d2:	24 0f       	add	r18, r20
    11d4:	35 1f       	adc	r19, r21
    11d6:	37 83       	std	Z+7, r19	; 0x07
    11d8:	26 83       	std	Z+6, r18	; 0x06
    11da:	62 81       	ldd	r22, Z+2	; 0x02
    11dc:	73 81       	ldd	r23, Z+3	; 0x03
    11de:	26 17       	cp	r18, r22
    11e0:	37 07       	cpc	r19, r23
    11e2:	20 f0       	brcs	.+8      	; 0x11ec <prvCopyDataFromQueue+0x2a>
    11e4:	20 81       	ld	r18, Z
    11e6:	31 81       	ldd	r19, Z+1	; 0x01
    11e8:	37 83       	std	Z+7, r19	; 0x07
    11ea:	26 83       	std	Z+6, r18	; 0x06
    11ec:	66 81       	ldd	r22, Z+6	; 0x06
    11ee:	77 81       	ldd	r23, Z+7	; 0x07
    11f0:	0c 94 1e 15 	jmp	0x2a3c	; 0x2a3c <memcpy>
    11f4:	08 95       	ret

000011f6 <prvUnlockQueue>:
    11f6:	0f 93       	push	r16
    11f8:	1f 93       	push	r17
    11fa:	cf 93       	push	r28
    11fc:	df 93       	push	r29
    11fe:	ec 01       	movw	r28, r24
    1200:	0f b6       	in	r0, 0x3f	; 63
    1202:	f8 94       	cli
    1204:	0f 92       	push	r0
    1206:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1208:	18 16       	cp	r1, r24
    120a:	a4 f4       	brge	.+40     	; 0x1234 <prvUnlockQueue+0x3e>
    120c:	89 89       	ldd	r24, Y+17	; 0x11
    120e:	88 23       	and	r24, r24
    1210:	89 f0       	breq	.+34     	; 0x1234 <prvUnlockQueue+0x3e>
    1212:	8e 01       	movw	r16, r28
    1214:	0f 5e       	subi	r16, 0xEF	; 239
    1216:	1f 4f       	sbci	r17, 0xFF	; 255
    1218:	03 c0       	rjmp	.+6      	; 0x1220 <prvUnlockQueue+0x2a>
    121a:	89 89       	ldd	r24, Y+17	; 0x11
    121c:	88 23       	and	r24, r24
    121e:	51 f0       	breq	.+20     	; 0x1234 <prvUnlockQueue+0x3e>
    1220:	c8 01       	movw	r24, r16
    1222:	ed d4       	rcall	.+2522   	; 0x1bfe <xTaskRemoveFromEventList>
    1224:	81 11       	cpse	r24, r1
    1226:	6c d5       	rcall	.+2776   	; 0x1d00 <vTaskMissedYield>
    1228:	8e 8d       	ldd	r24, Y+30	; 0x1e
    122a:	81 50       	subi	r24, 0x01	; 1
    122c:	8e 8f       	std	Y+30, r24	; 0x1e
    122e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1230:	18 16       	cp	r1, r24
    1232:	9c f3       	brlt	.-26     	; 0x121a <prvUnlockQueue+0x24>
    1234:	8f ef       	ldi	r24, 0xFF	; 255
    1236:	8e 8f       	std	Y+30, r24	; 0x1e
    1238:	0f 90       	pop	r0
    123a:	0f be       	out	0x3f, r0	; 63
    123c:	0f b6       	in	r0, 0x3f	; 63
    123e:	f8 94       	cli
    1240:	0f 92       	push	r0
    1242:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1244:	18 16       	cp	r1, r24
    1246:	a4 f4       	brge	.+40     	; 0x1270 <prvUnlockQueue+0x7a>
    1248:	88 85       	ldd	r24, Y+8	; 0x08
    124a:	88 23       	and	r24, r24
    124c:	89 f0       	breq	.+34     	; 0x1270 <prvUnlockQueue+0x7a>
    124e:	8e 01       	movw	r16, r28
    1250:	08 5f       	subi	r16, 0xF8	; 248
    1252:	1f 4f       	sbci	r17, 0xFF	; 255
    1254:	03 c0       	rjmp	.+6      	; 0x125c <prvUnlockQueue+0x66>
    1256:	88 85       	ldd	r24, Y+8	; 0x08
    1258:	88 23       	and	r24, r24
    125a:	51 f0       	breq	.+20     	; 0x1270 <prvUnlockQueue+0x7a>
    125c:	c8 01       	movw	r24, r16
    125e:	cf d4       	rcall	.+2462   	; 0x1bfe <xTaskRemoveFromEventList>
    1260:	81 11       	cpse	r24, r1
    1262:	4e d5       	rcall	.+2716   	; 0x1d00 <vTaskMissedYield>
    1264:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1266:	81 50       	subi	r24, 0x01	; 1
    1268:	8d 8f       	std	Y+29, r24	; 0x1d
    126a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    126c:	18 16       	cp	r1, r24
    126e:	9c f3       	brlt	.-26     	; 0x1256 <prvUnlockQueue+0x60>
    1270:	8f ef       	ldi	r24, 0xFF	; 255
    1272:	8d 8f       	std	Y+29, r24	; 0x1d
    1274:	0f 90       	pop	r0
    1276:	0f be       	out	0x3f, r0	; 63
    1278:	df 91       	pop	r29
    127a:	cf 91       	pop	r28
    127c:	1f 91       	pop	r17
    127e:	0f 91       	pop	r16
    1280:	08 95       	ret

00001282 <xQueueGenericReset>:
    1282:	cf 93       	push	r28
    1284:	df 93       	push	r29
    1286:	ec 01       	movw	r28, r24
    1288:	0f b6       	in	r0, 0x3f	; 63
    128a:	f8 94       	cli
    128c:	0f 92       	push	r0
    128e:	88 81       	ld	r24, Y
    1290:	99 81       	ldd	r25, Y+1	; 0x01
    1292:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1294:	30 e0       	ldi	r19, 0x00	; 0
    1296:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1298:	72 9f       	mul	r23, r18
    129a:	a0 01       	movw	r20, r0
    129c:	73 9f       	mul	r23, r19
    129e:	50 0d       	add	r21, r0
    12a0:	11 24       	eor	r1, r1
    12a2:	fc 01       	movw	r30, r24
    12a4:	e4 0f       	add	r30, r20
    12a6:	f5 1f       	adc	r31, r21
    12a8:	fb 83       	std	Y+3, r31	; 0x03
    12aa:	ea 83       	std	Y+2, r30	; 0x02
    12ac:	1a 8e       	std	Y+26, r1	; 0x1a
    12ae:	9d 83       	std	Y+5, r25	; 0x05
    12b0:	8c 83       	std	Y+4, r24	; 0x04
    12b2:	42 1b       	sub	r20, r18
    12b4:	53 0b       	sbc	r21, r19
    12b6:	84 0f       	add	r24, r20
    12b8:	95 1f       	adc	r25, r21
    12ba:	9f 83       	std	Y+7, r25	; 0x07
    12bc:	8e 83       	std	Y+6, r24	; 0x06
    12be:	8f ef       	ldi	r24, 0xFF	; 255
    12c0:	8d 8f       	std	Y+29, r24	; 0x1d
    12c2:	8e 8f       	std	Y+30, r24	; 0x1e
    12c4:	61 11       	cpse	r22, r1
    12c6:	0a c0       	rjmp	.+20     	; 0x12dc <xQueueGenericReset+0x5a>
    12c8:	88 85       	ldd	r24, Y+8	; 0x08
    12ca:	88 23       	and	r24, r24
    12cc:	69 f0       	breq	.+26     	; 0x12e8 <xQueueGenericReset+0x66>
    12ce:	ce 01       	movw	r24, r28
    12d0:	08 96       	adiw	r24, 0x08	; 8
    12d2:	95 d4       	rcall	.+2346   	; 0x1bfe <xTaskRemoveFromEventList>
    12d4:	81 30       	cpi	r24, 0x01	; 1
    12d6:	41 f4       	brne	.+16     	; 0x12e8 <xQueueGenericReset+0x66>
    12d8:	1c de       	rcall	.-968    	; 0xf12 <vPortYield>
    12da:	06 c0       	rjmp	.+12     	; 0x12e8 <xQueueGenericReset+0x66>
    12dc:	ce 01       	movw	r24, r28
    12de:	08 96       	adiw	r24, 0x08	; 8
    12e0:	d6 dc       	rcall	.-1620   	; 0xc8e <vListInitialise>
    12e2:	ce 01       	movw	r24, r28
    12e4:	41 96       	adiw	r24, 0x11	; 17
    12e6:	d3 dc       	rcall	.-1626   	; 0xc8e <vListInitialise>
    12e8:	0f 90       	pop	r0
    12ea:	0f be       	out	0x3f, r0	; 63
    12ec:	81 e0       	ldi	r24, 0x01	; 1
    12ee:	df 91       	pop	r29
    12f0:	cf 91       	pop	r28
    12f2:	08 95       	ret

000012f4 <xQueueGenericCreate>:
    12f4:	0f 93       	push	r16
    12f6:	1f 93       	push	r17
    12f8:	cf 93       	push	r28
    12fa:	df 93       	push	r29
    12fc:	08 2f       	mov	r16, r24
    12fe:	16 2f       	mov	r17, r22
    1300:	66 23       	and	r22, r22
    1302:	b9 f0       	breq	.+46     	; 0x1332 <xQueueGenericCreate+0x3e>
    1304:	86 9f       	mul	r24, r22
    1306:	c0 01       	movw	r24, r0
    1308:	11 24       	eor	r1, r1
    130a:	80 96       	adiw	r24, 0x20	; 32
    130c:	d9 de       	rcall	.-590    	; 0x10c0 <pvPortMalloc>
    130e:	ec 01       	movw	r28, r24
    1310:	00 97       	sbiw	r24, 0x00	; 0
    1312:	21 f4       	brne	.+8      	; 0x131c <xQueueGenericCreate+0x28>
    1314:	14 c0       	rjmp	.+40     	; 0x133e <xQueueGenericCreate+0x4a>
    1316:	d9 83       	std	Y+1, r29	; 0x01
    1318:	c8 83       	st	Y, r28
    131a:	05 c0       	rjmp	.+10     	; 0x1326 <xQueueGenericCreate+0x32>
    131c:	9c 01       	movw	r18, r24
    131e:	21 5e       	subi	r18, 0xE1	; 225
    1320:	3f 4f       	sbci	r19, 0xFF	; 255
    1322:	39 83       	std	Y+1, r19	; 0x01
    1324:	28 83       	st	Y, r18
    1326:	0b 8f       	std	Y+27, r16	; 0x1b
    1328:	1c 8f       	std	Y+28, r17	; 0x1c
    132a:	61 e0       	ldi	r22, 0x01	; 1
    132c:	ce 01       	movw	r24, r28
    132e:	a9 df       	rcall	.-174    	; 0x1282 <xQueueGenericReset>
    1330:	06 c0       	rjmp	.+12     	; 0x133e <xQueueGenericCreate+0x4a>
    1332:	8f e1       	ldi	r24, 0x1F	; 31
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	c4 de       	rcall	.-632    	; 0x10c0 <pvPortMalloc>
    1338:	ec 01       	movw	r28, r24
    133a:	00 97       	sbiw	r24, 0x00	; 0
    133c:	61 f7       	brne	.-40     	; 0x1316 <xQueueGenericCreate+0x22>
    133e:	ce 01       	movw	r24, r28
    1340:	df 91       	pop	r29
    1342:	cf 91       	pop	r28
    1344:	1f 91       	pop	r17
    1346:	0f 91       	pop	r16
    1348:	08 95       	ret

0000134a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    134a:	0f 93       	push	r16
    134c:	1f 93       	push	r17
    134e:	cf 93       	push	r28
    1350:	df 93       	push	r29
    1352:	ec 01       	movw	r28, r24
    1354:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1356:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1358:	8b 8d       	ldd	r24, Y+27	; 0x1b
    135a:	98 17       	cp	r25, r24
    135c:	10 f0       	brcs	.+4      	; 0x1362 <xQueueGenericSendFromISR+0x18>
    135e:	22 30       	cpi	r18, 0x02	; 2
    1360:	d1 f4       	brne	.+52     	; 0x1396 <xQueueGenericSendFromISR+0x4c>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1362:	42 2f       	mov	r20, r18
    1364:	ce 01       	movw	r24, r28
    1366:	e0 de       	rcall	.-576    	; 0x1128 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1368:	8e 8d       	ldd	r24, Y+30	; 0x1e
    136a:	8f 3f       	cpi	r24, 0xFF	; 255
    136c:	79 f4       	brne	.+30     	; 0x138c <xQueueGenericSendFromISR+0x42>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    136e:	89 89       	ldd	r24, Y+17	; 0x11
    1370:	88 23       	and	r24, r24
    1372:	99 f0       	breq	.+38     	; 0x139a <xQueueGenericSendFromISR+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1374:	ce 01       	movw	r24, r28
    1376:	41 96       	adiw	r24, 0x11	; 17
    1378:	42 d4       	rcall	.+2180   	; 0x1bfe <xTaskRemoveFromEventList>
    137a:	88 23       	and	r24, r24
    137c:	81 f0       	breq	.+32     	; 0x139e <xQueueGenericSendFromISR+0x54>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    137e:	01 15       	cp	r16, r1
    1380:	11 05       	cpc	r17, r1
    1382:	79 f0       	breq	.+30     	; 0x13a2 <xQueueGenericSendFromISR+0x58>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	f8 01       	movw	r30, r16
    1388:	80 83       	st	Z, r24
    138a:	0c c0       	rjmp	.+24     	; 0x13a4 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    138c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    138e:	8f 5f       	subi	r24, 0xFF	; 255
    1390:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	07 c0       	rjmp	.+14     	; 0x13a4 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1396:	80 e0       	ldi	r24, 0x00	; 0
    1398:	05 c0       	rjmp	.+10     	; 0x13a4 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    139a:	81 e0       	ldi	r24, 0x01	; 1
    139c:	03 c0       	rjmp	.+6      	; 0x13a4 <xQueueGenericSendFromISR+0x5a>
    139e:	81 e0       	ldi	r24, 0x01	; 1
    13a0:	01 c0       	rjmp	.+2      	; 0x13a4 <xQueueGenericSendFromISR+0x5a>
    13a2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13a4:	df 91       	pop	r29
    13a6:	cf 91       	pop	r28
    13a8:	1f 91       	pop	r17
    13aa:	0f 91       	pop	r16
    13ac:	08 95       	ret

000013ae <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    13ae:	cf 93       	push	r28
    13b0:	df 93       	push	r29
    13b2:	fc 01       	movw	r30, r24
    13b4:	eb 01       	movw	r28, r22
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    13b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    13b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    13ba:	98 17       	cp	r25, r24
    13bc:	c0 f4       	brcc	.+48     	; 0x13ee <xQueueGiveFromISR+0x40>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    13be:	82 8d       	ldd	r24, Z+26	; 0x1a
    13c0:	8f 5f       	subi	r24, 0xFF	; 255
    13c2:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    13c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    13c6:	8f 3f       	cpi	r24, 0xFF	; 255
    13c8:	69 f4       	brne	.+26     	; 0x13e4 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13ca:	81 89       	ldd	r24, Z+17	; 0x11
    13cc:	88 23       	and	r24, r24
    13ce:	89 f0       	breq	.+34     	; 0x13f2 <xQueueGiveFromISR+0x44>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13d0:	cf 01       	movw	r24, r30
    13d2:	41 96       	adiw	r24, 0x11	; 17
    13d4:	14 d4       	rcall	.+2088   	; 0x1bfe <xTaskRemoveFromEventList>
    13d6:	88 23       	and	r24, r24
    13d8:	71 f0       	breq	.+28     	; 0x13f6 <xQueueGiveFromISR+0x48>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    13da:	20 97       	sbiw	r28, 0x00	; 0
    13dc:	71 f0       	breq	.+28     	; 0x13fa <xQueueGiveFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	88 83       	st	Y, r24
    13e2:	0c c0       	rjmp	.+24     	; 0x13fc <xQueueGiveFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    13e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    13e6:	8f 5f       	subi	r24, 0xFF	; 255
    13e8:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    13ea:	81 e0       	ldi	r24, 0x01	; 1
    13ec:	07 c0       	rjmp	.+14     	; 0x13fc <xQueueGiveFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13ee:	80 e0       	ldi	r24, 0x00	; 0
    13f0:	05 c0       	rjmp	.+10     	; 0x13fc <xQueueGiveFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    13f2:	81 e0       	ldi	r24, 0x01	; 1
    13f4:	03 c0       	rjmp	.+6      	; 0x13fc <xQueueGiveFromISR+0x4e>
    13f6:	81 e0       	ldi	r24, 0x01	; 1
    13f8:	01 c0       	rjmp	.+2      	; 0x13fc <xQueueGiveFromISR+0x4e>
    13fa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	08 95       	ret

00001402 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1402:	9f 92       	push	r9
    1404:	af 92       	push	r10
    1406:	bf 92       	push	r11
    1408:	cf 92       	push	r12
    140a:	df 92       	push	r13
    140c:	ef 92       	push	r14
    140e:	ff 92       	push	r15
    1410:	0f 93       	push	r16
    1412:	1f 93       	push	r17
    1414:	cf 93       	push	r28
    1416:	df 93       	push	r29
    1418:	00 d0       	rcall	.+0      	; 0x141a <xQueueGenericReceive+0x18>
    141a:	1f 92       	push	r1
    141c:	1f 92       	push	r1
    141e:	cd b7       	in	r28, 0x3d	; 61
    1420:	de b7       	in	r29, 0x3e	; 62
    1422:	8c 01       	movw	r16, r24
    1424:	6b 01       	movw	r12, r22
    1426:	5d 83       	std	Y+5, r21	; 0x05
    1428:	4c 83       	std	Y+4, r20	; 0x04
    142a:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    142c:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    142e:	99 24       	eor	r9, r9
    1430:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1432:	7c 01       	movw	r14, r24
    1434:	81 e1       	ldi	r24, 0x11	; 17
    1436:	e8 0e       	add	r14, r24
    1438:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    143a:	0f b6       	in	r0, 0x3f	; 63
    143c:	f8 94       	cli
    143e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1440:	f8 01       	movw	r30, r16
    1442:	82 8d       	ldd	r24, Z+26	; 0x1a
    1444:	88 23       	and	r24, r24
    1446:	21 f1       	breq	.+72     	; 0x1490 <xQueueGenericReceive+0x8e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1448:	e6 80       	ldd	r14, Z+6	; 0x06
    144a:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    144c:	b6 01       	movw	r22, r12
    144e:	c8 01       	movw	r24, r16
    1450:	b8 de       	rcall	.-656    	; 0x11c2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1452:	b1 10       	cpse	r11, r1
    1454:	0e c0       	rjmp	.+28     	; 0x1472 <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1456:	f8 01       	movw	r30, r16
    1458:	82 8d       	ldd	r24, Z+26	; 0x1a
    145a:	81 50       	subi	r24, 0x01	; 1
    145c:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    145e:	80 85       	ldd	r24, Z+8	; 0x08
    1460:	88 23       	and	r24, r24
    1462:	91 f0       	breq	.+36     	; 0x1488 <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1464:	c8 01       	movw	r24, r16
    1466:	08 96       	adiw	r24, 0x08	; 8
    1468:	ca d3       	rcall	.+1940   	; 0x1bfe <xTaskRemoveFromEventList>
    146a:	81 30       	cpi	r24, 0x01	; 1
    146c:	69 f4       	brne	.+26     	; 0x1488 <xQueueGenericReceive+0x86>
						{
							queueYIELD_IF_USING_PREEMPTION();
    146e:	51 dd       	rcall	.-1374   	; 0xf12 <vPortYield>
    1470:	0b c0       	rjmp	.+22     	; 0x1488 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1472:	f8 01       	movw	r30, r16
    1474:	f7 82       	std	Z+7, r15	; 0x07
    1476:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1478:	81 89       	ldd	r24, Z+17	; 0x11
    147a:	88 23       	and	r24, r24
    147c:	29 f0       	breq	.+10     	; 0x1488 <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    147e:	c8 01       	movw	r24, r16
    1480:	41 96       	adiw	r24, 0x11	; 17
    1482:	bd d3       	rcall	.+1914   	; 0x1bfe <xTaskRemoveFromEventList>
    1484:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1486:	45 dd       	rcall	.-1398   	; 0xf12 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1488:	0f 90       	pop	r0
    148a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	44 c0       	rjmp	.+136    	; 0x1518 <xQueueGenericReceive+0x116>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1490:	4c 81       	ldd	r20, Y+4	; 0x04
    1492:	5d 81       	ldd	r21, Y+5	; 0x05
    1494:	45 2b       	or	r20, r21
    1496:	21 f4       	brne	.+8      	; 0x14a0 <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1498:	0f 90       	pop	r0
    149a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    149c:	80 e0       	ldi	r24, 0x00	; 0
    149e:	3c c0       	rjmp	.+120    	; 0x1518 <xQueueGenericReceive+0x116>
				}
				else if( xEntryTimeSet == pdFALSE )
    14a0:	a1 10       	cpse	r10, r1
    14a2:	04 c0       	rjmp	.+8      	; 0x14ac <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14a4:	ce 01       	movw	r24, r28
    14a6:	01 96       	adiw	r24, 0x01	; 1
    14a8:	ee d3       	rcall	.+2012   	; 0x1c86 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14aa:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    14ac:	0f 90       	pop	r0
    14ae:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14b0:	ba d1       	rcall	.+884    	; 0x1826 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14b2:	0f b6       	in	r0, 0x3f	; 63
    14b4:	f8 94       	cli
    14b6:	0f 92       	push	r0
    14b8:	f8 01       	movw	r30, r16
    14ba:	85 8d       	ldd	r24, Z+29	; 0x1d
    14bc:	8f 3f       	cpi	r24, 0xFF	; 255
    14be:	09 f4       	brne	.+2      	; 0x14c2 <xQueueGenericReceive+0xc0>
    14c0:	15 8e       	std	Z+29, r1	; 0x1d
    14c2:	f8 01       	movw	r30, r16
    14c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    14c6:	8f 3f       	cpi	r24, 0xFF	; 255
    14c8:	09 f4       	brne	.+2      	; 0x14cc <xQueueGenericReceive+0xca>
    14ca:	16 8e       	std	Z+30, r1	; 0x1e
    14cc:	0f 90       	pop	r0
    14ce:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14d0:	be 01       	movw	r22, r28
    14d2:	6c 5f       	subi	r22, 0xFC	; 252
    14d4:	7f 4f       	sbci	r23, 0xFF	; 255
    14d6:	ce 01       	movw	r24, r28
    14d8:	01 96       	adiw	r24, 0x01	; 1
    14da:	e0 d3       	rcall	.+1984   	; 0x1c9c <xTaskCheckForTimeOut>
    14dc:	81 11       	cpse	r24, r1
    14de:	18 c0       	rjmp	.+48     	; 0x1510 <xQueueGenericReceive+0x10e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14e0:	0f b6       	in	r0, 0x3f	; 63
    14e2:	f8 94       	cli
    14e4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    14e6:	f8 01       	movw	r30, r16
    14e8:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14ea:	0f 90       	pop	r0
    14ec:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    14ee:	81 11       	cpse	r24, r1
    14f0:	0b c0       	rjmp	.+22     	; 0x1508 <xQueueGenericReceive+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14f2:	6c 81       	ldd	r22, Y+4	; 0x04
    14f4:	7d 81       	ldd	r23, Y+5	; 0x05
    14f6:	c7 01       	movw	r24, r14
    14f8:	68 d3       	rcall	.+1744   	; 0x1bca <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    14fa:	c8 01       	movw	r24, r16
    14fc:	7c de       	rcall	.-776    	; 0x11f6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    14fe:	54 d2       	rcall	.+1192   	; 0x19a8 <xTaskResumeAll>
    1500:	81 11       	cpse	r24, r1
    1502:	9b cf       	rjmp	.-202    	; 0x143a <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1504:	06 dd       	rcall	.-1524   	; 0xf12 <vPortYield>
    1506:	99 cf       	rjmp	.-206    	; 0x143a <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1508:	c8 01       	movw	r24, r16
    150a:	75 de       	rcall	.-790    	; 0x11f6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    150c:	4d d2       	rcall	.+1178   	; 0x19a8 <xTaskResumeAll>
    150e:	95 cf       	rjmp	.-214    	; 0x143a <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1510:	c8 01       	movw	r24, r16
    1512:	71 de       	rcall	.-798    	; 0x11f6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1514:	49 d2       	rcall	.+1170   	; 0x19a8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1516:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1518:	0f 90       	pop	r0
    151a:	0f 90       	pop	r0
    151c:	0f 90       	pop	r0
    151e:	0f 90       	pop	r0
    1520:	0f 90       	pop	r0
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	1f 91       	pop	r17
    1528:	0f 91       	pop	r16
    152a:	ff 90       	pop	r15
    152c:	ef 90       	pop	r14
    152e:	df 90       	pop	r13
    1530:	cf 90       	pop	r12
    1532:	bf 90       	pop	r11
    1534:	af 90       	pop	r10
    1536:	9f 90       	pop	r9
    1538:	08 95       	ret

0000153a <prvResetNextTaskUnblockTime>:
    153a:	e0 91 21 0d 	lds	r30, 0x0D21
    153e:	f0 91 22 0d 	lds	r31, 0x0D22
    1542:	80 81       	ld	r24, Z
    1544:	81 11       	cpse	r24, r1
    1546:	07 c0       	rjmp	.+14     	; 0x1556 <prvResetNextTaskUnblockTime+0x1c>
    1548:	8f ef       	ldi	r24, 0xFF	; 255
    154a:	9f ef       	ldi	r25, 0xFF	; 255
    154c:	90 93 4a 02 	sts	0x024A, r25
    1550:	80 93 49 02 	sts	0x0249, r24
    1554:	08 95       	ret
    1556:	e0 91 21 0d 	lds	r30, 0x0D21
    155a:	f0 91 22 0d 	lds	r31, 0x0D22
    155e:	05 80       	ldd	r0, Z+5	; 0x05
    1560:	f6 81       	ldd	r31, Z+6	; 0x06
    1562:	e0 2d       	mov	r30, r0
    1564:	06 80       	ldd	r0, Z+6	; 0x06
    1566:	f7 81       	ldd	r31, Z+7	; 0x07
    1568:	e0 2d       	mov	r30, r0
    156a:	82 81       	ldd	r24, Z+2	; 0x02
    156c:	93 81       	ldd	r25, Z+3	; 0x03
    156e:	90 93 4a 02 	sts	0x024A, r25
    1572:	80 93 49 02 	sts	0x0249, r24
    1576:	08 95       	ret

00001578 <prvAddCurrentTaskToDelayedList>:
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	ec 01       	movw	r28, r24
    157e:	e0 91 59 0d 	lds	r30, 0x0D59
    1582:	f0 91 5a 0d 	lds	r31, 0x0D5A
    1586:	93 83       	std	Z+3, r25	; 0x03
    1588:	82 83       	std	Z+2, r24	; 0x02
    158a:	80 91 09 0d 	lds	r24, 0x0D09
    158e:	90 91 0a 0d 	lds	r25, 0x0D0A
    1592:	c8 17       	cp	r28, r24
    1594:	d9 07       	cpc	r29, r25
    1596:	60 f4       	brcc	.+24     	; 0x15b0 <prvAddCurrentTaskToDelayedList+0x38>
    1598:	60 91 59 0d 	lds	r22, 0x0D59
    159c:	70 91 5a 0d 	lds	r23, 0x0D5A
    15a0:	80 91 1f 0d 	lds	r24, 0x0D1F
    15a4:	90 91 20 0d 	lds	r25, 0x0D20
    15a8:	6e 5f       	subi	r22, 0xFE	; 254
    15aa:	7f 4f       	sbci	r23, 0xFF	; 255
    15ac:	a3 db       	rcall	.-2234   	; 0xcf4 <vListInsert>
    15ae:	16 c0       	rjmp	.+44     	; 0x15dc <prvAddCurrentTaskToDelayedList+0x64>
    15b0:	60 91 59 0d 	lds	r22, 0x0D59
    15b4:	70 91 5a 0d 	lds	r23, 0x0D5A
    15b8:	80 91 21 0d 	lds	r24, 0x0D21
    15bc:	90 91 22 0d 	lds	r25, 0x0D22
    15c0:	6e 5f       	subi	r22, 0xFE	; 254
    15c2:	7f 4f       	sbci	r23, 0xFF	; 255
    15c4:	97 db       	rcall	.-2258   	; 0xcf4 <vListInsert>
    15c6:	80 91 49 02 	lds	r24, 0x0249
    15ca:	90 91 4a 02 	lds	r25, 0x024A
    15ce:	c8 17       	cp	r28, r24
    15d0:	d9 07       	cpc	r29, r25
    15d2:	20 f4       	brcc	.+8      	; 0x15dc <prvAddCurrentTaskToDelayedList+0x64>
    15d4:	d0 93 4a 02 	sts	0x024A, r29
    15d8:	c0 93 49 02 	sts	0x0249, r28
    15dc:	df 91       	pop	r29
    15de:	cf 91       	pop	r28
    15e0:	08 95       	ret

000015e2 <xTaskGenericCreate>:
    15e2:	4f 92       	push	r4
    15e4:	5f 92       	push	r5
    15e6:	6f 92       	push	r6
    15e8:	7f 92       	push	r7
    15ea:	8f 92       	push	r8
    15ec:	9f 92       	push	r9
    15ee:	af 92       	push	r10
    15f0:	bf 92       	push	r11
    15f2:	cf 92       	push	r12
    15f4:	df 92       	push	r13
    15f6:	ef 92       	push	r14
    15f8:	ff 92       	push	r15
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	4c 01       	movw	r8, r24
    1604:	5b 01       	movw	r10, r22
    1606:	2a 01       	movw	r4, r20
    1608:	39 01       	movw	r6, r18
    160a:	c1 14       	cp	r12, r1
    160c:	d1 04       	cpc	r13, r1
    160e:	31 f4       	brne	.+12     	; 0x161c <xTaskGenericCreate+0x3a>
    1610:	ca 01       	movw	r24, r20
    1612:	56 dd       	rcall	.-1364   	; 0x10c0 <pvPortMalloc>
    1614:	6c 01       	movw	r12, r24
    1616:	00 97       	sbiw	r24, 0x00	; 0
    1618:	09 f4       	brne	.+2      	; 0x161c <xTaskGenericCreate+0x3a>
    161a:	ca c0       	rjmp	.+404    	; 0x17b0 <xTaskGenericCreate+0x1ce>
    161c:	86 e2       	ldi	r24, 0x26	; 38
    161e:	90 e0       	ldi	r25, 0x00	; 0
    1620:	4f dd       	rcall	.-1378   	; 0x10c0 <pvPortMalloc>
    1622:	ec 01       	movw	r28, r24
    1624:	00 97       	sbiw	r24, 0x00	; 0
    1626:	71 f0       	breq	.+28     	; 0x1644 <xTaskGenericCreate+0x62>
    1628:	d8 8e       	std	Y+24, r13	; 0x18
    162a:	cf 8a       	std	Y+23, r12	; 0x17
    162c:	81 e0       	ldi	r24, 0x01	; 1
    162e:	48 1a       	sub	r4, r24
    1630:	51 08       	sbc	r5, r1
    1632:	c4 0c       	add	r12, r4
    1634:	d5 1c       	adc	r13, r5
    1636:	d5 01       	movw	r26, r10
    1638:	8c 91       	ld	r24, X
    163a:	89 8f       	std	Y+25, r24	; 0x19
    163c:	8c 91       	ld	r24, X
    163e:	81 11       	cpse	r24, r1
    1640:	04 c0       	rjmp	.+8      	; 0x164a <xTaskGenericCreate+0x68>
    1642:	14 c0       	rjmp	.+40     	; 0x166c <xTaskGenericCreate+0x8a>
    1644:	c6 01       	movw	r24, r12
    1646:	6f dd       	rcall	.-1314   	; 0x1126 <vPortFree>
    1648:	b3 c0       	rjmp	.+358    	; 0x17b0 <xTaskGenericCreate+0x1ce>
    164a:	ae 01       	movw	r20, r28
    164c:	46 5e       	subi	r20, 0xE6	; 230
    164e:	5f 4f       	sbci	r21, 0xFF	; 255
    1650:	f5 01       	movw	r30, r10
    1652:	31 96       	adiw	r30, 0x01	; 1
    1654:	27 e0       	ldi	r18, 0x07	; 7
    1656:	cf 01       	movw	r24, r30
    1658:	31 91       	ld	r19, Z+
    165a:	da 01       	movw	r26, r20
    165c:	3d 93       	st	X+, r19
    165e:	ad 01       	movw	r20, r26
    1660:	dc 01       	movw	r26, r24
    1662:	8c 91       	ld	r24, X
    1664:	88 23       	and	r24, r24
    1666:	11 f0       	breq	.+4      	; 0x166c <xTaskGenericCreate+0x8a>
    1668:	21 50       	subi	r18, 0x01	; 1
    166a:	a9 f7       	brne	.-22     	; 0x1656 <xTaskGenericCreate+0x74>
    166c:	18 a2       	std	Y+32, r1	; 0x20
    166e:	10 2f       	mov	r17, r16
    1670:	04 30       	cpi	r16, 0x04	; 4
    1672:	08 f0       	brcs	.+2      	; 0x1676 <xTaskGenericCreate+0x94>
    1674:	13 e0       	ldi	r17, 0x03	; 3
    1676:	1e 8b       	std	Y+22, r17	; 0x16
    1678:	5e 01       	movw	r10, r28
    167a:	b2 e0       	ldi	r27, 0x02	; 2
    167c:	ab 0e       	add	r10, r27
    167e:	b1 1c       	adc	r11, r1
    1680:	c5 01       	movw	r24, r10
    1682:	13 db       	rcall	.-2522   	; 0xcaa <vListInitialiseItem>
    1684:	ce 01       	movw	r24, r28
    1686:	0c 96       	adiw	r24, 0x0c	; 12
    1688:	10 db       	rcall	.-2528   	; 0xcaa <vListInitialiseItem>
    168a:	d9 87       	std	Y+9, r29	; 0x09
    168c:	c8 87       	std	Y+8, r28	; 0x08
    168e:	84 e0       	ldi	r24, 0x04	; 4
    1690:	90 e0       	ldi	r25, 0x00	; 0
    1692:	81 1b       	sub	r24, r17
    1694:	91 09       	sbc	r25, r1
    1696:	9d 87       	std	Y+13, r25	; 0x0d
    1698:	8c 87       	std	Y+12, r24	; 0x0c
    169a:	db 8b       	std	Y+19, r29	; 0x13
    169c:	ca 8b       	std	Y+18, r28	; 0x12
    169e:	19 a2       	std	Y+33, r1	; 0x21
    16a0:	1a a2       	std	Y+34, r1	; 0x22
    16a2:	1b a2       	std	Y+35, r1	; 0x23
    16a4:	1c a2       	std	Y+36, r1	; 0x24
    16a6:	1d a2       	std	Y+37, r1	; 0x25
    16a8:	a3 01       	movw	r20, r6
    16aa:	b4 01       	movw	r22, r8
    16ac:	c6 01       	movw	r24, r12
    16ae:	79 db       	rcall	.-2318   	; 0xda2 <pxPortInitialiseStack>
    16b0:	99 83       	std	Y+1, r25	; 0x01
    16b2:	88 83       	st	Y, r24
    16b4:	e1 14       	cp	r14, r1
    16b6:	f1 04       	cpc	r15, r1
    16b8:	19 f0       	breq	.+6      	; 0x16c0 <xTaskGenericCreate+0xde>
    16ba:	f7 01       	movw	r30, r14
    16bc:	d1 83       	std	Z+1, r29	; 0x01
    16be:	c0 83       	st	Z, r28
    16c0:	0f b6       	in	r0, 0x3f	; 63
    16c2:	f8 94       	cli
    16c4:	0f 92       	push	r0
    16c6:	80 91 0b 0d 	lds	r24, 0x0D0B
    16ca:	8f 5f       	subi	r24, 0xFF	; 255
    16cc:	80 93 0b 0d 	sts	0x0D0B, r24
    16d0:	80 91 59 0d 	lds	r24, 0x0D59
    16d4:	90 91 5a 0d 	lds	r25, 0x0D5A
    16d8:	89 2b       	or	r24, r25
    16da:	69 f5       	brne	.+90     	; 0x1736 <xTaskGenericCreate+0x154>
    16dc:	d0 93 5a 0d 	sts	0x0D5A, r29
    16e0:	c0 93 59 0d 	sts	0x0D59, r28
    16e4:	80 91 0b 0d 	lds	r24, 0x0D0B
    16e8:	81 30       	cpi	r24, 0x01	; 1
    16ea:	a1 f5       	brne	.+104    	; 0x1754 <xTaskGenericCreate+0x172>
    16ec:	85 e3       	ldi	r24, 0x35	; 53
    16ee:	9d e0       	ldi	r25, 0x0D	; 13
    16f0:	ce da       	rcall	.-2660   	; 0xc8e <vListInitialise>
    16f2:	8e e3       	ldi	r24, 0x3E	; 62
    16f4:	9d e0       	ldi	r25, 0x0D	; 13
    16f6:	cb da       	rcall	.-2666   	; 0xc8e <vListInitialise>
    16f8:	87 e4       	ldi	r24, 0x47	; 71
    16fa:	9d e0       	ldi	r25, 0x0D	; 13
    16fc:	c8 da       	rcall	.-2672   	; 0xc8e <vListInitialise>
    16fe:	80 e5       	ldi	r24, 0x50	; 80
    1700:	9d e0       	ldi	r25, 0x0D	; 13
    1702:	c5 da       	rcall	.-2678   	; 0xc8e <vListInitialise>
    1704:	8c e2       	ldi	r24, 0x2C	; 44
    1706:	9d e0       	ldi	r25, 0x0D	; 13
    1708:	c2 da       	rcall	.-2684   	; 0xc8e <vListInitialise>
    170a:	83 e2       	ldi	r24, 0x23	; 35
    170c:	9d e0       	ldi	r25, 0x0D	; 13
    170e:	bf da       	rcall	.-2690   	; 0xc8e <vListInitialise>
    1710:	86 e1       	ldi	r24, 0x16	; 22
    1712:	9d e0       	ldi	r25, 0x0D	; 13
    1714:	bc da       	rcall	.-2696   	; 0xc8e <vListInitialise>
    1716:	8d e0       	ldi	r24, 0x0D	; 13
    1718:	9d e0       	ldi	r25, 0x0D	; 13
    171a:	b9 da       	rcall	.-2702   	; 0xc8e <vListInitialise>
    171c:	8c e2       	ldi	r24, 0x2C	; 44
    171e:	9d e0       	ldi	r25, 0x0D	; 13
    1720:	90 93 22 0d 	sts	0x0D22, r25
    1724:	80 93 21 0d 	sts	0x0D21, r24
    1728:	83 e2       	ldi	r24, 0x23	; 35
    172a:	9d e0       	ldi	r25, 0x0D	; 13
    172c:	90 93 20 0d 	sts	0x0D20, r25
    1730:	80 93 1f 0d 	sts	0x0D1F, r24
    1734:	0f c0       	rjmp	.+30     	; 0x1754 <xTaskGenericCreate+0x172>
    1736:	80 91 07 0d 	lds	r24, 0x0D07
    173a:	81 11       	cpse	r24, r1
    173c:	0b c0       	rjmp	.+22     	; 0x1754 <xTaskGenericCreate+0x172>
    173e:	e0 91 59 0d 	lds	r30, 0x0D59
    1742:	f0 91 5a 0d 	lds	r31, 0x0D5A
    1746:	86 89       	ldd	r24, Z+22	; 0x16
    1748:	08 17       	cp	r16, r24
    174a:	20 f0       	brcs	.+8      	; 0x1754 <xTaskGenericCreate+0x172>
    174c:	d0 93 5a 0d 	sts	0x0D5A, r29
    1750:	c0 93 59 0d 	sts	0x0D59, r28
    1754:	80 91 03 0d 	lds	r24, 0x0D03
    1758:	8f 5f       	subi	r24, 0xFF	; 255
    175a:	80 93 03 0d 	sts	0x0D03, r24
    175e:	8e 89       	ldd	r24, Y+22	; 0x16
    1760:	90 91 08 0d 	lds	r25, 0x0D08
    1764:	98 17       	cp	r25, r24
    1766:	10 f4       	brcc	.+4      	; 0x176c <xTaskGenericCreate+0x18a>
    1768:	80 93 08 0d 	sts	0x0D08, r24
    176c:	90 e0       	ldi	r25, 0x00	; 0
    176e:	9c 01       	movw	r18, r24
    1770:	22 0f       	add	r18, r18
    1772:	33 1f       	adc	r19, r19
    1774:	22 0f       	add	r18, r18
    1776:	33 1f       	adc	r19, r19
    1778:	22 0f       	add	r18, r18
    177a:	33 1f       	adc	r19, r19
    177c:	82 0f       	add	r24, r18
    177e:	93 1f       	adc	r25, r19
    1780:	b5 01       	movw	r22, r10
    1782:	8b 5c       	subi	r24, 0xCB	; 203
    1784:	92 4f       	sbci	r25, 0xF2	; 242
    1786:	95 da       	rcall	.-2774   	; 0xcb2 <vListInsertEnd>
    1788:	0f 90       	pop	r0
    178a:	0f be       	out	0x3f, r0	; 63
    178c:	80 91 07 0d 	lds	r24, 0x0D07
    1790:	88 23       	and	r24, r24
    1792:	51 f0       	breq	.+20     	; 0x17a8 <xTaskGenericCreate+0x1c6>
    1794:	e0 91 59 0d 	lds	r30, 0x0D59
    1798:	f0 91 5a 0d 	lds	r31, 0x0D5A
    179c:	86 89       	ldd	r24, Z+22	; 0x16
    179e:	80 17       	cp	r24, r16
    17a0:	28 f4       	brcc	.+10     	; 0x17ac <xTaskGenericCreate+0x1ca>
    17a2:	b7 db       	rcall	.-2194   	; 0xf12 <vPortYield>
    17a4:	81 e0       	ldi	r24, 0x01	; 1
    17a6:	05 c0       	rjmp	.+10     	; 0x17b2 <xTaskGenericCreate+0x1d0>
    17a8:	81 e0       	ldi	r24, 0x01	; 1
    17aa:	03 c0       	rjmp	.+6      	; 0x17b2 <xTaskGenericCreate+0x1d0>
    17ac:	81 e0       	ldi	r24, 0x01	; 1
    17ae:	01 c0       	rjmp	.+2      	; 0x17b2 <xTaskGenericCreate+0x1d0>
    17b0:	8f ef       	ldi	r24, 0xFF	; 255
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	1f 91       	pop	r17
    17b8:	0f 91       	pop	r16
    17ba:	ff 90       	pop	r15
    17bc:	ef 90       	pop	r14
    17be:	df 90       	pop	r13
    17c0:	cf 90       	pop	r12
    17c2:	bf 90       	pop	r11
    17c4:	af 90       	pop	r10
    17c6:	9f 90       	pop	r9
    17c8:	8f 90       	pop	r8
    17ca:	7f 90       	pop	r7
    17cc:	6f 90       	pop	r6
    17ce:	5f 90       	pop	r5
    17d0:	4f 90       	pop	r4
    17d2:	08 95       	ret

000017d4 <vTaskStartScheduler>:
    17d4:	af 92       	push	r10
    17d6:	bf 92       	push	r11
    17d8:	cf 92       	push	r12
    17da:	df 92       	push	r13
    17dc:	ef 92       	push	r14
    17de:	ff 92       	push	r15
    17e0:	0f 93       	push	r16
    17e2:	a1 2c       	mov	r10, r1
    17e4:	b1 2c       	mov	r11, r1
    17e6:	c1 2c       	mov	r12, r1
    17e8:	d1 2c       	mov	r13, r1
    17ea:	e1 2c       	mov	r14, r1
    17ec:	f1 2c       	mov	r15, r1
    17ee:	00 e0       	ldi	r16, 0x00	; 0
    17f0:	20 e0       	ldi	r18, 0x00	; 0
    17f2:	30 e0       	ldi	r19, 0x00	; 0
    17f4:	49 eb       	ldi	r20, 0xB9	; 185
    17f6:	50 e0       	ldi	r21, 0x00	; 0
    17f8:	66 e8       	ldi	r22, 0x86	; 134
    17fa:	72 e0       	ldi	r23, 0x02	; 2
    17fc:	8c e8       	ldi	r24, 0x8C	; 140
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	f0 de       	rcall	.-544    	; 0x15e2 <xTaskGenericCreate>
    1802:	81 30       	cpi	r24, 0x01	; 1
    1804:	41 f4       	brne	.+16     	; 0x1816 <vTaskStartScheduler+0x42>
    1806:	f8 94       	cli
    1808:	80 93 07 0d 	sts	0x0D07, r24
    180c:	10 92 0a 0d 	sts	0x0D0A, r1
    1810:	10 92 09 0d 	sts	0x0D09, r1
    1814:	38 db       	rcall	.-2448   	; 0xe86 <xPortStartScheduler>
    1816:	0f 91       	pop	r16
    1818:	ff 90       	pop	r15
    181a:	ef 90       	pop	r14
    181c:	df 90       	pop	r13
    181e:	cf 90       	pop	r12
    1820:	bf 90       	pop	r11
    1822:	af 90       	pop	r10
    1824:	08 95       	ret

00001826 <vTaskSuspendAll>:
    1826:	80 91 02 0d 	lds	r24, 0x0D02
    182a:	8f 5f       	subi	r24, 0xFF	; 255
    182c:	80 93 02 0d 	sts	0x0D02, r24
    1830:	08 95       	ret

00001832 <xTaskIncrementTick>:
    1832:	cf 92       	push	r12
    1834:	df 92       	push	r13
    1836:	ef 92       	push	r14
    1838:	ff 92       	push	r15
    183a:	0f 93       	push	r16
    183c:	1f 93       	push	r17
    183e:	cf 93       	push	r28
    1840:	df 93       	push	r29
    1842:	80 91 02 0d 	lds	r24, 0x0D02
    1846:	81 11       	cpse	r24, r1
    1848:	96 c0       	rjmp	.+300    	; 0x1976 <xTaskIncrementTick+0x144>
    184a:	80 91 09 0d 	lds	r24, 0x0D09
    184e:	90 91 0a 0d 	lds	r25, 0x0D0A
    1852:	01 96       	adiw	r24, 0x01	; 1
    1854:	90 93 0a 0d 	sts	0x0D0A, r25
    1858:	80 93 09 0d 	sts	0x0D09, r24
    185c:	e0 90 09 0d 	lds	r14, 0x0D09
    1860:	f0 90 0a 0d 	lds	r15, 0x0D0A
    1864:	e1 14       	cp	r14, r1
    1866:	f1 04       	cpc	r15, r1
    1868:	b1 f4       	brne	.+44     	; 0x1896 <xTaskIncrementTick+0x64>
    186a:	80 91 21 0d 	lds	r24, 0x0D21
    186e:	90 91 22 0d 	lds	r25, 0x0D22
    1872:	20 91 1f 0d 	lds	r18, 0x0D1F
    1876:	30 91 20 0d 	lds	r19, 0x0D20
    187a:	30 93 22 0d 	sts	0x0D22, r19
    187e:	20 93 21 0d 	sts	0x0D21, r18
    1882:	90 93 20 0d 	sts	0x0D20, r25
    1886:	80 93 1f 0d 	sts	0x0D1F, r24
    188a:	80 91 04 0d 	lds	r24, 0x0D04
    188e:	8f 5f       	subi	r24, 0xFF	; 255
    1890:	80 93 04 0d 	sts	0x0D04, r24
    1894:	52 de       	rcall	.-860    	; 0x153a <prvResetNextTaskUnblockTime>
    1896:	80 91 49 02 	lds	r24, 0x0249
    189a:	90 91 4a 02 	lds	r25, 0x024A
    189e:	e8 16       	cp	r14, r24
    18a0:	f9 06       	cpc	r15, r25
    18a2:	08 f4       	brcc	.+2      	; 0x18a6 <xTaskIncrementTick+0x74>
    18a4:	51 c0       	rjmp	.+162    	; 0x1948 <xTaskIncrementTick+0x116>
    18a6:	d1 2c       	mov	r13, r1
    18a8:	cc 24       	eor	r12, r12
    18aa:	c3 94       	inc	r12
    18ac:	01 c0       	rjmp	.+2      	; 0x18b0 <xTaskIncrementTick+0x7e>
    18ae:	dc 2c       	mov	r13, r12
    18b0:	e0 91 21 0d 	lds	r30, 0x0D21
    18b4:	f0 91 22 0d 	lds	r31, 0x0D22
    18b8:	80 81       	ld	r24, Z
    18ba:	81 11       	cpse	r24, r1
    18bc:	07 c0       	rjmp	.+14     	; 0x18cc <xTaskIncrementTick+0x9a>
    18be:	8f ef       	ldi	r24, 0xFF	; 255
    18c0:	9f ef       	ldi	r25, 0xFF	; 255
    18c2:	90 93 4a 02 	sts	0x024A, r25
    18c6:	80 93 49 02 	sts	0x0249, r24
    18ca:	3f c0       	rjmp	.+126    	; 0x194a <xTaskIncrementTick+0x118>
    18cc:	e0 91 21 0d 	lds	r30, 0x0D21
    18d0:	f0 91 22 0d 	lds	r31, 0x0D22
    18d4:	05 80       	ldd	r0, Z+5	; 0x05
    18d6:	f6 81       	ldd	r31, Z+6	; 0x06
    18d8:	e0 2d       	mov	r30, r0
    18da:	c6 81       	ldd	r28, Z+6	; 0x06
    18dc:	d7 81       	ldd	r29, Z+7	; 0x07
    18de:	2a 81       	ldd	r18, Y+2	; 0x02
    18e0:	3b 81       	ldd	r19, Y+3	; 0x03
    18e2:	e2 16       	cp	r14, r18
    18e4:	f3 06       	cpc	r15, r19
    18e6:	28 f4       	brcc	.+10     	; 0x18f2 <xTaskIncrementTick+0xc0>
    18e8:	30 93 4a 02 	sts	0x024A, r19
    18ec:	20 93 49 02 	sts	0x0249, r18
    18f0:	2c c0       	rjmp	.+88     	; 0x194a <xTaskIncrementTick+0x118>
    18f2:	8e 01       	movw	r16, r28
    18f4:	0e 5f       	subi	r16, 0xFE	; 254
    18f6:	1f 4f       	sbci	r17, 0xFF	; 255
    18f8:	c8 01       	movw	r24, r16
    18fa:	2d da       	rcall	.-2982   	; 0xd56 <uxListRemove>
    18fc:	8c 89       	ldd	r24, Y+20	; 0x14
    18fe:	9d 89       	ldd	r25, Y+21	; 0x15
    1900:	89 2b       	or	r24, r25
    1902:	19 f0       	breq	.+6      	; 0x190a <xTaskIncrementTick+0xd8>
    1904:	ce 01       	movw	r24, r28
    1906:	0c 96       	adiw	r24, 0x0c	; 12
    1908:	26 da       	rcall	.-2996   	; 0xd56 <uxListRemove>
    190a:	2e 89       	ldd	r18, Y+22	; 0x16
    190c:	80 91 08 0d 	lds	r24, 0x0D08
    1910:	82 17       	cp	r24, r18
    1912:	10 f4       	brcc	.+4      	; 0x1918 <xTaskIncrementTick+0xe6>
    1914:	20 93 08 0d 	sts	0x0D08, r18
    1918:	30 e0       	ldi	r19, 0x00	; 0
    191a:	c9 01       	movw	r24, r18
    191c:	88 0f       	add	r24, r24
    191e:	99 1f       	adc	r25, r25
    1920:	88 0f       	add	r24, r24
    1922:	99 1f       	adc	r25, r25
    1924:	88 0f       	add	r24, r24
    1926:	99 1f       	adc	r25, r25
    1928:	82 0f       	add	r24, r18
    192a:	93 1f       	adc	r25, r19
    192c:	b8 01       	movw	r22, r16
    192e:	8b 5c       	subi	r24, 0xCB	; 203
    1930:	92 4f       	sbci	r25, 0xF2	; 242
    1932:	bf d9       	rcall	.-3202   	; 0xcb2 <vListInsertEnd>
    1934:	e0 91 59 0d 	lds	r30, 0x0D59
    1938:	f0 91 5a 0d 	lds	r31, 0x0D5A
    193c:	9e 89       	ldd	r25, Y+22	; 0x16
    193e:	86 89       	ldd	r24, Z+22	; 0x16
    1940:	98 17       	cp	r25, r24
    1942:	08 f0       	brcs	.+2      	; 0x1946 <xTaskIncrementTick+0x114>
    1944:	b4 cf       	rjmp	.-152    	; 0x18ae <xTaskIncrementTick+0x7c>
    1946:	b4 cf       	rjmp	.-152    	; 0x18b0 <xTaskIncrementTick+0x7e>
    1948:	d1 2c       	mov	r13, r1
    194a:	e0 91 59 0d 	lds	r30, 0x0D59
    194e:	f0 91 5a 0d 	lds	r31, 0x0D5A
    1952:	86 89       	ldd	r24, Z+22	; 0x16
    1954:	90 e0       	ldi	r25, 0x00	; 0
    1956:	fc 01       	movw	r30, r24
    1958:	ee 0f       	add	r30, r30
    195a:	ff 1f       	adc	r31, r31
    195c:	ee 0f       	add	r30, r30
    195e:	ff 1f       	adc	r31, r31
    1960:	ee 0f       	add	r30, r30
    1962:	ff 1f       	adc	r31, r31
    1964:	8e 0f       	add	r24, r30
    1966:	9f 1f       	adc	r25, r31
    1968:	fc 01       	movw	r30, r24
    196a:	eb 5c       	subi	r30, 0xCB	; 203
    196c:	f2 4f       	sbci	r31, 0xF2	; 242
    196e:	80 81       	ld	r24, Z
    1970:	82 30       	cpi	r24, 0x02	; 2
    1972:	40 f4       	brcc	.+16     	; 0x1984 <xTaskIncrementTick+0x152>
    1974:	09 c0       	rjmp	.+18     	; 0x1988 <xTaskIncrementTick+0x156>
    1976:	80 91 06 0d 	lds	r24, 0x0D06
    197a:	8f 5f       	subi	r24, 0xFF	; 255
    197c:	80 93 06 0d 	sts	0x0D06, r24
    1980:	d1 2c       	mov	r13, r1
    1982:	02 c0       	rjmp	.+4      	; 0x1988 <xTaskIncrementTick+0x156>
    1984:	dd 24       	eor	r13, r13
    1986:	d3 94       	inc	r13
    1988:	80 91 05 0d 	lds	r24, 0x0D05
    198c:	88 23       	and	r24, r24
    198e:	11 f0       	breq	.+4      	; 0x1994 <xTaskIncrementTick+0x162>
    1990:	dd 24       	eor	r13, r13
    1992:	d3 94       	inc	r13
    1994:	8d 2d       	mov	r24, r13
    1996:	df 91       	pop	r29
    1998:	cf 91       	pop	r28
    199a:	1f 91       	pop	r17
    199c:	0f 91       	pop	r16
    199e:	ff 90       	pop	r15
    19a0:	ef 90       	pop	r14
    19a2:	df 90       	pop	r13
    19a4:	cf 90       	pop	r12
    19a6:	08 95       	ret

000019a8 <xTaskResumeAll>:
    19a8:	df 92       	push	r13
    19aa:	ef 92       	push	r14
    19ac:	ff 92       	push	r15
    19ae:	0f 93       	push	r16
    19b0:	1f 93       	push	r17
    19b2:	cf 93       	push	r28
    19b4:	df 93       	push	r29
    19b6:	0f b6       	in	r0, 0x3f	; 63
    19b8:	f8 94       	cli
    19ba:	0f 92       	push	r0
    19bc:	80 91 02 0d 	lds	r24, 0x0D02
    19c0:	81 50       	subi	r24, 0x01	; 1
    19c2:	80 93 02 0d 	sts	0x0D02, r24
    19c6:	80 91 02 0d 	lds	r24, 0x0D02
    19ca:	81 11       	cpse	r24, r1
    19cc:	5c c0       	rjmp	.+184    	; 0x1a86 <xTaskResumeAll+0xde>
    19ce:	80 91 0b 0d 	lds	r24, 0x0D0B
    19d2:	88 23       	and	r24, r24
    19d4:	09 f4       	brne	.+2      	; 0x19d8 <xTaskResumeAll+0x30>
    19d6:	59 c0       	rjmp	.+178    	; 0x1a8a <xTaskResumeAll+0xe2>
    19d8:	0f 2e       	mov	r0, r31
    19da:	f6 e1       	ldi	r31, 0x16	; 22
    19dc:	ef 2e       	mov	r14, r31
    19de:	fd e0       	ldi	r31, 0x0D	; 13
    19e0:	ff 2e       	mov	r15, r31
    19e2:	f0 2d       	mov	r31, r0
    19e4:	dd 24       	eor	r13, r13
    19e6:	d3 94       	inc	r13
    19e8:	2d c0       	rjmp	.+90     	; 0x1a44 <xTaskResumeAll+0x9c>
    19ea:	e0 91 1b 0d 	lds	r30, 0x0D1B
    19ee:	f0 91 1c 0d 	lds	r31, 0x0D1C
    19f2:	c6 81       	ldd	r28, Z+6	; 0x06
    19f4:	d7 81       	ldd	r29, Z+7	; 0x07
    19f6:	ce 01       	movw	r24, r28
    19f8:	0c 96       	adiw	r24, 0x0c	; 12
    19fa:	ad d9       	rcall	.-3238   	; 0xd56 <uxListRemove>
    19fc:	8e 01       	movw	r16, r28
    19fe:	0e 5f       	subi	r16, 0xFE	; 254
    1a00:	1f 4f       	sbci	r17, 0xFF	; 255
    1a02:	c8 01       	movw	r24, r16
    1a04:	a8 d9       	rcall	.-3248   	; 0xd56 <uxListRemove>
    1a06:	8e 89       	ldd	r24, Y+22	; 0x16
    1a08:	90 91 08 0d 	lds	r25, 0x0D08
    1a0c:	98 17       	cp	r25, r24
    1a0e:	10 f4       	brcc	.+4      	; 0x1a14 <xTaskResumeAll+0x6c>
    1a10:	80 93 08 0d 	sts	0x0D08, r24
    1a14:	90 e0       	ldi	r25, 0x00	; 0
    1a16:	9c 01       	movw	r18, r24
    1a18:	22 0f       	add	r18, r18
    1a1a:	33 1f       	adc	r19, r19
    1a1c:	22 0f       	add	r18, r18
    1a1e:	33 1f       	adc	r19, r19
    1a20:	22 0f       	add	r18, r18
    1a22:	33 1f       	adc	r19, r19
    1a24:	82 0f       	add	r24, r18
    1a26:	93 1f       	adc	r25, r19
    1a28:	b8 01       	movw	r22, r16
    1a2a:	8b 5c       	subi	r24, 0xCB	; 203
    1a2c:	92 4f       	sbci	r25, 0xF2	; 242
    1a2e:	41 d9       	rcall	.-3454   	; 0xcb2 <vListInsertEnd>
    1a30:	e0 91 59 0d 	lds	r30, 0x0D59
    1a34:	f0 91 5a 0d 	lds	r31, 0x0D5A
    1a38:	9e 89       	ldd	r25, Y+22	; 0x16
    1a3a:	86 89       	ldd	r24, Z+22	; 0x16
    1a3c:	98 17       	cp	r25, r24
    1a3e:	10 f0       	brcs	.+4      	; 0x1a44 <xTaskResumeAll+0x9c>
    1a40:	d0 92 05 0d 	sts	0x0D05, r13
    1a44:	f7 01       	movw	r30, r14
    1a46:	80 81       	ld	r24, Z
    1a48:	81 11       	cpse	r24, r1
    1a4a:	cf cf       	rjmp	.-98     	; 0x19ea <xTaskResumeAll+0x42>
    1a4c:	80 91 06 0d 	lds	r24, 0x0D06
    1a50:	88 23       	and	r24, r24
    1a52:	91 f0       	breq	.+36     	; 0x1a78 <xTaskResumeAll+0xd0>
    1a54:	80 91 06 0d 	lds	r24, 0x0D06
    1a58:	88 23       	and	r24, r24
    1a5a:	71 f0       	breq	.+28     	; 0x1a78 <xTaskResumeAll+0xd0>
    1a5c:	c1 e0       	ldi	r28, 0x01	; 1
    1a5e:	e9 de       	rcall	.-558    	; 0x1832 <xTaskIncrementTick>
    1a60:	81 11       	cpse	r24, r1
    1a62:	c0 93 05 0d 	sts	0x0D05, r28
    1a66:	80 91 06 0d 	lds	r24, 0x0D06
    1a6a:	81 50       	subi	r24, 0x01	; 1
    1a6c:	80 93 06 0d 	sts	0x0D06, r24
    1a70:	80 91 06 0d 	lds	r24, 0x0D06
    1a74:	81 11       	cpse	r24, r1
    1a76:	f3 cf       	rjmp	.-26     	; 0x1a5e <xTaskResumeAll+0xb6>
    1a78:	80 91 05 0d 	lds	r24, 0x0D05
    1a7c:	81 30       	cpi	r24, 0x01	; 1
    1a7e:	39 f4       	brne	.+14     	; 0x1a8e <xTaskResumeAll+0xe6>
    1a80:	48 da       	rcall	.-2928   	; 0xf12 <vPortYield>
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	05 c0       	rjmp	.+10     	; 0x1a90 <xTaskResumeAll+0xe8>
    1a86:	80 e0       	ldi	r24, 0x00	; 0
    1a88:	03 c0       	rjmp	.+6      	; 0x1a90 <xTaskResumeAll+0xe8>
    1a8a:	80 e0       	ldi	r24, 0x00	; 0
    1a8c:	01 c0       	rjmp	.+2      	; 0x1a90 <xTaskResumeAll+0xe8>
    1a8e:	80 e0       	ldi	r24, 0x00	; 0
    1a90:	0f 90       	pop	r0
    1a92:	0f be       	out	0x3f, r0	; 63
    1a94:	df 91       	pop	r29
    1a96:	cf 91       	pop	r28
    1a98:	1f 91       	pop	r17
    1a9a:	0f 91       	pop	r16
    1a9c:	ff 90       	pop	r15
    1a9e:	ef 90       	pop	r14
    1aa0:	df 90       	pop	r13
    1aa2:	08 95       	ret

00001aa4 <vTaskDelay>:
    1aa4:	cf 93       	push	r28
    1aa6:	df 93       	push	r29
    1aa8:	ec 01       	movw	r28, r24
    1aaa:	00 97       	sbiw	r24, 0x00	; 0
    1aac:	91 f0       	breq	.+36     	; 0x1ad2 <vTaskDelay+0x2e>
    1aae:	bb de       	rcall	.-650    	; 0x1826 <vTaskSuspendAll>
    1ab0:	80 91 09 0d 	lds	r24, 0x0D09
    1ab4:	90 91 0a 0d 	lds	r25, 0x0D0A
    1ab8:	c8 0f       	add	r28, r24
    1aba:	d9 1f       	adc	r29, r25
    1abc:	80 91 59 0d 	lds	r24, 0x0D59
    1ac0:	90 91 5a 0d 	lds	r25, 0x0D5A
    1ac4:	02 96       	adiw	r24, 0x02	; 2
    1ac6:	47 d9       	rcall	.-3442   	; 0xd56 <uxListRemove>
    1ac8:	ce 01       	movw	r24, r28
    1aca:	56 dd       	rcall	.-1364   	; 0x1578 <prvAddCurrentTaskToDelayedList>
    1acc:	6d df       	rcall	.-294    	; 0x19a8 <xTaskResumeAll>
    1ace:	81 11       	cpse	r24, r1
    1ad0:	01 c0       	rjmp	.+2      	; 0x1ad4 <vTaskDelay+0x30>
    1ad2:	1f da       	rcall	.-3010   	; 0xf12 <vPortYield>
    1ad4:	df 91       	pop	r29
    1ad6:	cf 91       	pop	r28
    1ad8:	08 95       	ret

00001ada <vTaskSwitchContext>:
    1ada:	80 91 02 0d 	lds	r24, 0x0D02
    1ade:	88 23       	and	r24, r24
    1ae0:	21 f0       	breq	.+8      	; 0x1aea <vTaskSwitchContext+0x10>
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	80 93 05 0d 	sts	0x0D05, r24
    1ae8:	08 95       	ret
    1aea:	10 92 05 0d 	sts	0x0D05, r1
    1aee:	a0 91 59 0d 	lds	r26, 0x0D59
    1af2:	b0 91 5a 0d 	lds	r27, 0x0D5A
    1af6:	e0 91 59 0d 	lds	r30, 0x0D59
    1afa:	f0 91 5a 0d 	lds	r31, 0x0D5A
    1afe:	2d 91       	ld	r18, X+
    1b00:	3c 91       	ld	r19, X
    1b02:	87 89       	ldd	r24, Z+23	; 0x17
    1b04:	90 8d       	ldd	r25, Z+24	; 0x18
    1b06:	82 17       	cp	r24, r18
    1b08:	93 07       	cpc	r25, r19
    1b0a:	58 f0       	brcs	.+22     	; 0x1b22 <vTaskSwitchContext+0x48>
    1b0c:	60 91 59 0d 	lds	r22, 0x0D59
    1b10:	70 91 5a 0d 	lds	r23, 0x0D5A
    1b14:	80 91 59 0d 	lds	r24, 0x0D59
    1b18:	90 91 5a 0d 	lds	r25, 0x0D5A
    1b1c:	67 5e       	subi	r22, 0xE7	; 231
    1b1e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b20:	79 d2       	rcall	.+1266   	; 0x2014 <vApplicationStackOverflowHook>
    1b22:	80 91 08 0d 	lds	r24, 0x0D08
    1b26:	90 e0       	ldi	r25, 0x00	; 0
    1b28:	fc 01       	movw	r30, r24
    1b2a:	ee 0f       	add	r30, r30
    1b2c:	ff 1f       	adc	r31, r31
    1b2e:	ee 0f       	add	r30, r30
    1b30:	ff 1f       	adc	r31, r31
    1b32:	ee 0f       	add	r30, r30
    1b34:	ff 1f       	adc	r31, r31
    1b36:	8e 0f       	add	r24, r30
    1b38:	9f 1f       	adc	r25, r31
    1b3a:	fc 01       	movw	r30, r24
    1b3c:	eb 5c       	subi	r30, 0xCB	; 203
    1b3e:	f2 4f       	sbci	r31, 0xF2	; 242
    1b40:	80 81       	ld	r24, Z
    1b42:	81 11       	cpse	r24, r1
    1b44:	17 c0       	rjmp	.+46     	; 0x1b74 <vTaskSwitchContext+0x9a>
    1b46:	80 91 08 0d 	lds	r24, 0x0D08
    1b4a:	81 50       	subi	r24, 0x01	; 1
    1b4c:	80 93 08 0d 	sts	0x0D08, r24
    1b50:	80 91 08 0d 	lds	r24, 0x0D08
    1b54:	90 e0       	ldi	r25, 0x00	; 0
    1b56:	fc 01       	movw	r30, r24
    1b58:	ee 0f       	add	r30, r30
    1b5a:	ff 1f       	adc	r31, r31
    1b5c:	ee 0f       	add	r30, r30
    1b5e:	ff 1f       	adc	r31, r31
    1b60:	ee 0f       	add	r30, r30
    1b62:	ff 1f       	adc	r31, r31
    1b64:	8e 0f       	add	r24, r30
    1b66:	9f 1f       	adc	r25, r31
    1b68:	fc 01       	movw	r30, r24
    1b6a:	eb 5c       	subi	r30, 0xCB	; 203
    1b6c:	f2 4f       	sbci	r31, 0xF2	; 242
    1b6e:	80 81       	ld	r24, Z
    1b70:	88 23       	and	r24, r24
    1b72:	49 f3       	breq	.-46     	; 0x1b46 <vTaskSwitchContext+0x6c>
    1b74:	e0 91 08 0d 	lds	r30, 0x0D08
    1b78:	f0 e0       	ldi	r31, 0x00	; 0
    1b7a:	cf 01       	movw	r24, r30
    1b7c:	88 0f       	add	r24, r24
    1b7e:	99 1f       	adc	r25, r25
    1b80:	88 0f       	add	r24, r24
    1b82:	99 1f       	adc	r25, r25
    1b84:	88 0f       	add	r24, r24
    1b86:	99 1f       	adc	r25, r25
    1b88:	e8 0f       	add	r30, r24
    1b8a:	f9 1f       	adc	r31, r25
    1b8c:	eb 5c       	subi	r30, 0xCB	; 203
    1b8e:	f2 4f       	sbci	r31, 0xF2	; 242
    1b90:	a1 81       	ldd	r26, Z+1	; 0x01
    1b92:	b2 81       	ldd	r27, Z+2	; 0x02
    1b94:	12 96       	adiw	r26, 0x02	; 2
    1b96:	0d 90       	ld	r0, X+
    1b98:	bc 91       	ld	r27, X
    1b9a:	a0 2d       	mov	r26, r0
    1b9c:	b2 83       	std	Z+2, r27	; 0x02
    1b9e:	a1 83       	std	Z+1, r26	; 0x01
    1ba0:	cf 01       	movw	r24, r30
    1ba2:	03 96       	adiw	r24, 0x03	; 3
    1ba4:	a8 17       	cp	r26, r24
    1ba6:	b9 07       	cpc	r27, r25
    1ba8:	31 f4       	brne	.+12     	; 0x1bb6 <vTaskSwitchContext+0xdc>
    1baa:	12 96       	adiw	r26, 0x02	; 2
    1bac:	8d 91       	ld	r24, X+
    1bae:	9c 91       	ld	r25, X
    1bb0:	13 97       	sbiw	r26, 0x03	; 3
    1bb2:	92 83       	std	Z+2, r25	; 0x02
    1bb4:	81 83       	std	Z+1, r24	; 0x01
    1bb6:	01 80       	ldd	r0, Z+1	; 0x01
    1bb8:	f2 81       	ldd	r31, Z+2	; 0x02
    1bba:	e0 2d       	mov	r30, r0
    1bbc:	86 81       	ldd	r24, Z+6	; 0x06
    1bbe:	97 81       	ldd	r25, Z+7	; 0x07
    1bc0:	90 93 5a 0d 	sts	0x0D5A, r25
    1bc4:	80 93 59 0d 	sts	0x0D59, r24
    1bc8:	08 95       	ret

00001bca <vTaskPlaceOnEventList>:
    1bca:	cf 93       	push	r28
    1bcc:	df 93       	push	r29
    1bce:	eb 01       	movw	r28, r22
    1bd0:	60 91 59 0d 	lds	r22, 0x0D59
    1bd4:	70 91 5a 0d 	lds	r23, 0x0D5A
    1bd8:	64 5f       	subi	r22, 0xF4	; 244
    1bda:	7f 4f       	sbci	r23, 0xFF	; 255
    1bdc:	8b d8       	rcall	.-3818   	; 0xcf4 <vListInsert>
    1bde:	80 91 59 0d 	lds	r24, 0x0D59
    1be2:	90 91 5a 0d 	lds	r25, 0x0D5A
    1be6:	02 96       	adiw	r24, 0x02	; 2
    1be8:	b6 d8       	rcall	.-3732   	; 0xd56 <uxListRemove>
    1bea:	80 91 09 0d 	lds	r24, 0x0D09
    1bee:	90 91 0a 0d 	lds	r25, 0x0D0A
    1bf2:	8c 0f       	add	r24, r28
    1bf4:	9d 1f       	adc	r25, r29
    1bf6:	c0 dc       	rcall	.-1664   	; 0x1578 <prvAddCurrentTaskToDelayedList>
    1bf8:	df 91       	pop	r29
    1bfa:	cf 91       	pop	r28
    1bfc:	08 95       	ret

00001bfe <xTaskRemoveFromEventList>:
    1bfe:	0f 93       	push	r16
    1c00:	1f 93       	push	r17
    1c02:	cf 93       	push	r28
    1c04:	df 93       	push	r29
    1c06:	dc 01       	movw	r26, r24
    1c08:	15 96       	adiw	r26, 0x05	; 5
    1c0a:	ed 91       	ld	r30, X+
    1c0c:	fc 91       	ld	r31, X
    1c0e:	16 97       	sbiw	r26, 0x06	; 6
    1c10:	c6 81       	ldd	r28, Z+6	; 0x06
    1c12:	d7 81       	ldd	r29, Z+7	; 0x07
    1c14:	8e 01       	movw	r16, r28
    1c16:	04 5f       	subi	r16, 0xF4	; 244
    1c18:	1f 4f       	sbci	r17, 0xFF	; 255
    1c1a:	c8 01       	movw	r24, r16
    1c1c:	9c d8       	rcall	.-3784   	; 0xd56 <uxListRemove>
    1c1e:	80 91 02 0d 	lds	r24, 0x0D02
    1c22:	81 11       	cpse	r24, r1
    1c24:	1a c0       	rjmp	.+52     	; 0x1c5a <xTaskRemoveFromEventList+0x5c>
    1c26:	0a 50       	subi	r16, 0x0A	; 10
    1c28:	11 09       	sbc	r17, r1
    1c2a:	c8 01       	movw	r24, r16
    1c2c:	94 d8       	rcall	.-3800   	; 0xd56 <uxListRemove>
    1c2e:	8e 89       	ldd	r24, Y+22	; 0x16
    1c30:	90 91 08 0d 	lds	r25, 0x0D08
    1c34:	98 17       	cp	r25, r24
    1c36:	10 f4       	brcc	.+4      	; 0x1c3c <xTaskRemoveFromEventList+0x3e>
    1c38:	80 93 08 0d 	sts	0x0D08, r24
    1c3c:	90 e0       	ldi	r25, 0x00	; 0
    1c3e:	9c 01       	movw	r18, r24
    1c40:	22 0f       	add	r18, r18
    1c42:	33 1f       	adc	r19, r19
    1c44:	22 0f       	add	r18, r18
    1c46:	33 1f       	adc	r19, r19
    1c48:	22 0f       	add	r18, r18
    1c4a:	33 1f       	adc	r19, r19
    1c4c:	82 0f       	add	r24, r18
    1c4e:	93 1f       	adc	r25, r19
    1c50:	b8 01       	movw	r22, r16
    1c52:	8b 5c       	subi	r24, 0xCB	; 203
    1c54:	92 4f       	sbci	r25, 0xF2	; 242
    1c56:	2d d8       	rcall	.-4006   	; 0xcb2 <vListInsertEnd>
    1c58:	04 c0       	rjmp	.+8      	; 0x1c62 <xTaskRemoveFromEventList+0x64>
    1c5a:	b8 01       	movw	r22, r16
    1c5c:	86 e1       	ldi	r24, 0x16	; 22
    1c5e:	9d e0       	ldi	r25, 0x0D	; 13
    1c60:	28 d8       	rcall	.-4016   	; 0xcb2 <vListInsertEnd>
    1c62:	e0 91 59 0d 	lds	r30, 0x0D59
    1c66:	f0 91 5a 0d 	lds	r31, 0x0D5A
    1c6a:	9e 89       	ldd	r25, Y+22	; 0x16
    1c6c:	86 89       	ldd	r24, Z+22	; 0x16
    1c6e:	89 17       	cp	r24, r25
    1c70:	20 f4       	brcc	.+8      	; 0x1c7a <xTaskRemoveFromEventList+0x7c>
    1c72:	81 e0       	ldi	r24, 0x01	; 1
    1c74:	80 93 05 0d 	sts	0x0D05, r24
    1c78:	01 c0       	rjmp	.+2      	; 0x1c7c <xTaskRemoveFromEventList+0x7e>
    1c7a:	80 e0       	ldi	r24, 0x00	; 0
    1c7c:	df 91       	pop	r29
    1c7e:	cf 91       	pop	r28
    1c80:	1f 91       	pop	r17
    1c82:	0f 91       	pop	r16
    1c84:	08 95       	ret

00001c86 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1c86:	20 91 04 0d 	lds	r18, 0x0D04
    1c8a:	fc 01       	movw	r30, r24
    1c8c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1c8e:	20 91 09 0d 	lds	r18, 0x0D09
    1c92:	30 91 0a 0d 	lds	r19, 0x0D0A
    1c96:	32 83       	std	Z+2, r19	; 0x02
    1c98:	21 83       	std	Z+1, r18	; 0x01
    1c9a:	08 95       	ret

00001c9c <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1c9c:	0f b6       	in	r0, 0x3f	; 63
    1c9e:	f8 94       	cli
    1ca0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1ca2:	20 91 09 0d 	lds	r18, 0x0D09
    1ca6:	30 91 0a 0d 	lds	r19, 0x0D0A
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1caa:	40 91 04 0d 	lds	r20, 0x0D04
    1cae:	dc 01       	movw	r26, r24
    1cb0:	5c 91       	ld	r21, X
    1cb2:	54 17       	cp	r21, r20
    1cb4:	39 f0       	breq	.+14     	; 0x1cc4 <xTaskCheckForTimeOut+0x28>
    1cb6:	11 96       	adiw	r26, 0x01	; 1
    1cb8:	4d 91       	ld	r20, X+
    1cba:	5c 91       	ld	r21, X
    1cbc:	12 97       	sbiw	r26, 0x02	; 2
    1cbe:	24 17       	cp	r18, r20
    1cc0:	35 07       	cpc	r19, r21
    1cc2:	c0 f4       	brcc	.+48     	; 0x1cf4 <xTaskCheckForTimeOut+0x58>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    1cc4:	dc 01       	movw	r26, r24
    1cc6:	11 96       	adiw	r26, 0x01	; 1
    1cc8:	ed 91       	ld	r30, X+
    1cca:	fc 91       	ld	r31, X
    1ccc:	12 97       	sbiw	r26, 0x02	; 2
    1cce:	db 01       	movw	r26, r22
    1cd0:	4d 91       	ld	r20, X+
    1cd2:	5c 91       	ld	r21, X
    1cd4:	d9 01       	movw	r26, r18
    1cd6:	ae 1b       	sub	r26, r30
    1cd8:	bf 0b       	sbc	r27, r31
    1cda:	a4 17       	cp	r26, r20
    1cdc:	b5 07       	cpc	r27, r21
    1cde:	60 f4       	brcc	.+24     	; 0x1cf8 <xTaskCheckForTimeOut+0x5c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    1ce0:	e2 1b       	sub	r30, r18
    1ce2:	f3 0b       	sbc	r31, r19
    1ce4:	4e 0f       	add	r20, r30
    1ce6:	5f 1f       	adc	r21, r31
    1ce8:	fb 01       	movw	r30, r22
    1cea:	51 83       	std	Z+1, r21	; 0x01
    1cec:	40 83       	st	Z, r20
			vTaskSetTimeOutState( pxTimeOut );
    1cee:	cb df       	rcall	.-106    	; 0x1c86 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1cf0:	80 e0       	ldi	r24, 0x00	; 0
    1cf2:	03 c0       	rjmp	.+6      	; 0x1cfa <xTaskCheckForTimeOut+0x5e>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	01 c0       	rjmp	.+2      	; 0x1cfa <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1cf8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1cfa:	0f 90       	pop	r0
    1cfc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1cfe:	08 95       	ret

00001d00 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1d00:	81 e0       	ldi	r24, 0x01	; 1
    1d02:	80 93 05 0d 	sts	0x0D05, r24
    1d06:	08 95       	ret

00001d08 <bt_status_call_back>:


uint8_t bt_initialised = 0;

void bt_status_call_back(uint8_t status) {
	if (status == DIALOG_OK_STOP) {
    1d08:	8f 3f       	cpi	r24, 0xFF	; 255
    1d0a:	19 f4       	brne	.+6      	; 0x1d12 <bt_status_call_back+0xa>
		bt_initialised = 1;
    1d0c:	81 e0       	ldi	r24, 0x01	; 1
    1d0e:	80 93 5b 0d 	sts	0x0D5B, r24
    1d12:	08 95       	ret

00001d14 <vjustATask>:

	/* Cycle for ever, one cycle each time the goal line is passed. */
	for( ;; )
	{
		// Wait for goal line is passed
		xSemaphoreTake(goal_line_semaphore, portMAX_DELAY);
    1d14:	20 e0       	ldi	r18, 0x00	; 0
    1d16:	4f ef       	ldi	r20, 0xFF	; 255
    1d18:	5f ef       	ldi	r21, 0xFF	; 255
    1d1a:	60 e0       	ldi	r22, 0x00	; 0
    1d1c:	70 e0       	ldi	r23, 0x00	; 0
    1d1e:	80 91 5e 0d 	lds	r24, 0x0D5E
    1d22:	90 91 5f 0d 	lds	r25, 0x0D5F
    1d26:	6d db       	rcall	.-2342   	; 0x1402 <xQueueGenericReceive>
    1d28:	f5 cf       	rjmp	.-22     	; 0x1d14 <vjustATask>

00001d2a <learn>:
			default:;
		}
	}
}

void learn() {
    1d2a:	8f 92       	push	r8
    1d2c:	9f 92       	push	r9
    1d2e:	af 92       	push	r10
    1d30:	bf 92       	push	r11
    1d32:	cf 92       	push	r12
    1d34:	df 92       	push	r13
    1d36:	ef 92       	push	r14
    1d38:	ff 92       	push	r15
    1d3a:	0f 93       	push	r16
    1d3c:	1f 93       	push	r17
    1d3e:	cf 93       	push	r28
    1d40:	df 93       	push	r29
    1d42:	cd b7       	in	r28, 0x3d	; 61
    1d44:	de b7       	in	r29, 0x3e	; 62
    1d46:	64 97       	sbiw	r28, 0x14	; 20
    1d48:	0f b6       	in	r0, 0x3f	; 63
    1d4a:	f8 94       	cli
    1d4c:	de bf       	out	0x3e, r29	; 62
    1d4e:	0f be       	out	0x3f, r0	; 63
    1d50:	cd bf       	out	0x3d, r28	; 61
    1d52:	0f 2e       	mov	r0, r31
    1d54:	f4 e6       	ldi	r31, 0x64	; 100
    1d56:	ef 2e       	mov	r14, r31
    1d58:	f1 2c       	mov	r15, r1
    1d5a:	f0 2d       	mov	r31, r0
			uint16_t raw_x = get_raw_x_accel();
			uint16_t raw_y = get_raw_y_accel();
			uint16_t raw_z = get_raw_z_accel();
			//uint16_t raw_rx = get_raw_x_rotation();
			//uint16_t raw_ry = get_raw_y_rotation();
			sprintf(buf, "%4d %4d %4d %4d %4d", raw_x, raw_y, raw_z);
    1d5c:	0f 2e       	mov	r0, r31
    1d5e:	fb e8       	ldi	r31, 0x8B	; 139
    1d60:	cf 2e       	mov	r12, r31
    1d62:	f2 e0       	ldi	r31, 0x02	; 2
    1d64:	df 2e       	mov	r13, r31
    1d66:	f0 2d       	mov	r31, r0
    1d68:	8e 01       	movw	r16, r28
    1d6a:	0f 5f       	subi	r16, 0xFF	; 255
    1d6c:	1f 4f       	sbci	r17, 0xFF	; 255
void learn() {
	int i;
	char buf[20];
	for (i= 0; i<100; i++)
	{
			uint16_t raw_x = get_raw_x_accel();
    1d6e:	0e 94 62 03 	call	0x6c4	; 0x6c4 <get_raw_x_accel>
    1d72:	b8 2e       	mov	r11, r24
    1d74:	a9 2e       	mov	r10, r25
			uint16_t raw_y = get_raw_y_accel();
    1d76:	0e 94 67 03 	call	0x6ce	; 0x6ce <get_raw_y_accel>
    1d7a:	98 2e       	mov	r9, r24
    1d7c:	89 2e       	mov	r8, r25
			uint16_t raw_z = get_raw_z_accel();
    1d7e:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <get_raw_z_accel>
			//uint16_t raw_rx = get_raw_x_rotation();
			//uint16_t raw_ry = get_raw_y_rotation();
			sprintf(buf, "%4d %4d %4d %4d %4d", raw_x, raw_y, raw_z);
    1d82:	9f 93       	push	r25
    1d84:	8f 93       	push	r24
    1d86:	8f 92       	push	r8
    1d88:	9f 92       	push	r9
    1d8a:	af 92       	push	r10
    1d8c:	bf 92       	push	r11
    1d8e:	df 92       	push	r13
    1d90:	cf 92       	push	r12
    1d92:	1f 93       	push	r17
    1d94:	0f 93       	push	r16
    1d96:	5b d6       	rcall	.+3254   	; 0x2a4e <sprintf>
			bt_send_bytes((uint8_t *)buf, strlen(buf));
    1d98:	f8 01       	movw	r30, r16
    1d9a:	01 90       	ld	r0, Z+
    1d9c:	00 20       	and	r0, r0
    1d9e:	e9 f7       	brne	.-6      	; 0x1d9a <learn+0x70>
    1da0:	31 97       	sbiw	r30, 0x01	; 1
    1da2:	bf 01       	movw	r22, r30
    1da4:	60 1b       	sub	r22, r16
    1da6:	71 0b       	sbc	r23, r17
    1da8:	c8 01       	movw	r24, r16
    1daa:	0e 94 77 03 	call	0x6ee	; 0x6ee <bt_send_bytes>
			vTaskDelay( 100/ portTICK_PERIOD_MS);
    1dae:	84 e6       	ldi	r24, 0x64	; 100
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	78 de       	rcall	.-784    	; 0x1aa4 <vTaskDelay>
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	e8 1a       	sub	r14, r24
    1db8:	f1 08       	sbc	r15, r1
}

void learn() {
	int i;
	char buf[20];
	for (i= 0; i<100; i++)
    1dba:	0f b6       	in	r0, 0x3f	; 63
    1dbc:	f8 94       	cli
    1dbe:	de bf       	out	0x3e, r29	; 62
    1dc0:	0f be       	out	0x3f, r0	; 63
    1dc2:	cd bf       	out	0x3d, r28	; 61
    1dc4:	e1 14       	cp	r14, r1
    1dc6:	f1 04       	cpc	r15, r1
    1dc8:	91 f6       	brne	.-92     	; 0x1d6e <learn+0x44>
			//uint16_t raw_ry = get_raw_y_rotation();
			sprintf(buf, "%4d %4d %4d %4d %4d", raw_x, raw_y, raw_z);
			bt_send_bytes((uint8_t *)buf, strlen(buf));
			vTaskDelay( 100/ portTICK_PERIOD_MS);
	}
}
    1dca:	64 96       	adiw	r28, 0x14	; 20
    1dcc:	0f b6       	in	r0, 0x3f	; 63
    1dce:	f8 94       	cli
    1dd0:	de bf       	out	0x3e, r29	; 62
    1dd2:	0f be       	out	0x3f, r0	; 63
    1dd4:	cd bf       	out	0x3d, r28	; 61
    1dd6:	df 91       	pop	r29
    1dd8:	cf 91       	pop	r28
    1dda:	1f 91       	pop	r17
    1ddc:	0f 91       	pop	r16
    1dde:	ff 90       	pop	r15
    1de0:	ef 90       	pop	r14
    1de2:	df 90       	pop	r13
    1de4:	cf 90       	pop	r12
    1de6:	bf 90       	pop	r11
    1de8:	af 90       	pop	r10
    1dea:	9f 90       	pop	r9
    1dec:	8f 90       	pop	r8
    1dee:	08 95       	ret

00001df0 <bt_com_call_back>:
		} else if (status == DIALOG_ERROR_STOP) {
		// What to do??
	}
}

void bt_com_call_back(uint8_t byte) {
    1df0:	ef 92       	push	r14
    1df2:	ff 92       	push	r15
    1df4:	0f 93       	push	r16
    1df6:	1f 93       	push	r17
    1df8:	cf 93       	push	r28
    1dfa:	df 93       	push	r29
    1dfc:	cd b7       	in	r28, 0x3d	; 61
    1dfe:	de b7       	in	r29, 0x3e	; 62
    1e00:	64 97       	sbiw	r28, 0x14	; 20
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	f8 94       	cli
    1e06:	de bf       	out	0x3e, r29	; 62
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	cd bf       	out	0x3d, r28	; 61
	char buf[20];
	
	if (bt_initialised) {
    1e0c:	90 91 5b 0d 	lds	r25, 0x0D5B
    1e10:	99 23       	and	r25, r25
    1e12:	09 f4       	brne	.+2      	; 0x1e16 <bt_com_call_back+0x26>
    1e14:	82 c0       	rjmp	.+260    	; 0x1f1a <bt_com_call_back+0x12a>
		switch (byte) {
    1e16:	90 e0       	ldi	r25, 0x00	; 0
    1e18:	fc 01       	movw	r30, r24
    1e1a:	e1 54       	subi	r30, 0x41	; 65
    1e1c:	f1 09       	sbc	r31, r1
    1e1e:	e6 32       	cpi	r30, 0x26	; 38
    1e20:	f1 05       	cpc	r31, r1
    1e22:	08 f0       	brcs	.+2      	; 0x1e26 <bt_com_call_back+0x36>
    1e24:	7a c0       	rjmp	.+244    	; 0x1f1a <bt_com_call_back+0x12a>
    1e26:	ea 59       	subi	r30, 0x9A	; 154
    1e28:	ff 4f       	sbci	r31, 0xFF	; 255
    1e2a:	cc c4       	rjmp	.+2456   	; 0x27c4 <__tablejump2__>
			case 'a': {
				set_head_light(0);
    1e2c:	80 e0       	ldi	r24, 0x00	; 0
    1e2e:	0e 94 66 02 	call	0x4cc	; 0x4cc <set_head_light>
				break;
    1e32:	73 c0       	rjmp	.+230    	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			case 'A': {
				set_head_light(1);
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	0e 94 66 02 	call	0x4cc	; 0x4cc <set_head_light>
				break;
    1e3a:	6f c0       	rjmp	.+222    	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			case 'b': {
				set_brake_light(0);
    1e3c:	80 e0       	ldi	r24, 0x00	; 0
    1e3e:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <set_brake_light>
				break;
    1e42:	6b c0       	rjmp	.+214    	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			case 'B': {
				set_brake_light(1);
    1e44:	81 e0       	ldi	r24, 0x01	; 1
    1e46:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <set_brake_light>
				break;
    1e4a:	67 c0       	rjmp	.+206    	; 0x1f1a <bt_com_call_back+0x12a>
				//set_horn(1);
				//break;
			//}
			
			case 'd': {
				set_motor_speed(0);
    1e4c:	80 e0       	ldi	r24, 0x00	; 0
    1e4e:	0e 94 72 02 	call	0x4e4	; 0x4e4 <set_motor_speed>
				break;
    1e52:	63 c0       	rjmp	.+198    	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			case 'D': {
				set_motor_speed(75);
    1e54:	8b e4       	ldi	r24, 0x4B	; 75
    1e56:	0e 94 72 02 	call	0x4e4	; 0x4e4 <set_motor_speed>
				break;
    1e5a:	5f c0       	rjmp	.+190    	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			
			case 'e': {
				set_brake(0);
    1e5c:	80 e0       	ldi	r24, 0x00	; 0
    1e5e:	0e 94 3f 03 	call	0x67e	; 0x67e <set_brake>
				break;
    1e62:	5b c0       	rjmp	.+182    	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			case 'E': {
				set_brake(100);
    1e64:	84 e6       	ldi	r24, 0x64	; 100
    1e66:	0e 94 3f 03 	call	0x67e	; 0x67e <set_brake>
				break;
    1e6a:	57 c0       	rjmp	.+174    	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			case 'F': {
				uint16_t raw_x = get_raw_x_accel();
    1e6c:	0e 94 62 03 	call	0x6c4	; 0x6c4 <get_raw_x_accel>
    1e70:	18 2f       	mov	r17, r24
    1e72:	09 2f       	mov	r16, r25
				uint16_t raw_y = get_raw_y_accel();
    1e74:	0e 94 67 03 	call	0x6ce	; 0x6ce <get_raw_y_accel>
    1e78:	f8 2e       	mov	r15, r24
    1e7a:	e9 2e       	mov	r14, r25
				uint16_t raw_z = get_raw_z_accel();
    1e7c:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <get_raw_z_accel>
				sprintf(buf, "%4d %4d %4d", raw_x, raw_y, raw_z);
    1e80:	9f 93       	push	r25
    1e82:	8f 93       	push	r24
    1e84:	ef 92       	push	r14
    1e86:	ff 92       	push	r15
    1e88:	0f 93       	push	r16
    1e8a:	1f 93       	push	r17
    1e8c:	83 e9       	ldi	r24, 0x93	; 147
    1e8e:	92 e0       	ldi	r25, 0x02	; 2
    1e90:	9f 93       	push	r25
    1e92:	8f 93       	push	r24
    1e94:	8e 01       	movw	r16, r28
    1e96:	0f 5f       	subi	r16, 0xFF	; 255
    1e98:	1f 4f       	sbci	r17, 0xFF	; 255
    1e9a:	1f 93       	push	r17
    1e9c:	0f 93       	push	r16
    1e9e:	d7 d5       	rcall	.+2990   	; 0x2a4e <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    1ea0:	f8 01       	movw	r30, r16
    1ea2:	01 90       	ld	r0, Z+
    1ea4:	00 20       	and	r0, r0
    1ea6:	e9 f7       	brne	.-6      	; 0x1ea2 <bt_com_call_back+0xb2>
    1ea8:	31 97       	sbiw	r30, 0x01	; 1
    1eaa:	bf 01       	movw	r22, r30
    1eac:	60 1b       	sub	r22, r16
    1eae:	71 0b       	sbc	r23, r17
    1eb0:	c8 01       	movw	r24, r16
    1eb2:	0e 94 77 03 	call	0x6ee	; 0x6ee <bt_send_bytes>
				break;
    1eb6:	0f b6       	in	r0, 0x3f	; 63
    1eb8:	f8 94       	cli
    1eba:	de bf       	out	0x3e, r29	; 62
    1ebc:	0f be       	out	0x3f, r0	; 63
    1ebe:	cd bf       	out	0x3d, r28	; 61
    1ec0:	2c c0       	rjmp	.+88     	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			case 'f': {
				learn();
    1ec2:	33 df       	rcall	.-410    	; 0x1d2a <learn>
				break;
    1ec4:	2a c0       	rjmp	.+84     	; 0x1f1a <bt_com_call_back+0x12a>
			}
			
			case 'G': {
				uint16_t raw_x = get_raw_x_accel();
    1ec6:	0e 94 62 03 	call	0x6c4	; 0x6c4 <get_raw_x_accel>
    1eca:	18 2f       	mov	r17, r24
    1ecc:	09 2f       	mov	r16, r25
				uint16_t raw_y = get_raw_y_accel();
    1ece:	0e 94 67 03 	call	0x6ce	; 0x6ce <get_raw_y_accel>
    1ed2:	f8 2e       	mov	r15, r24
    1ed4:	e9 2e       	mov	r14, r25
				uint16_t raw_z = get_raw_z_accel();
    1ed6:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <get_raw_z_accel>
				sprintf(buf, "%4d %4d %4d", raw_x, raw_y, raw_z);
    1eda:	9f 93       	push	r25
    1edc:	8f 93       	push	r24
    1ede:	ef 92       	push	r14
    1ee0:	ff 92       	push	r15
    1ee2:	0f 93       	push	r16
    1ee4:	1f 93       	push	r17
    1ee6:	83 e9       	ldi	r24, 0x93	; 147
    1ee8:	92 e0       	ldi	r25, 0x02	; 2
    1eea:	9f 93       	push	r25
    1eec:	8f 93       	push	r24
    1eee:	8e 01       	movw	r16, r28
    1ef0:	0f 5f       	subi	r16, 0xFF	; 255
    1ef2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ef4:	1f 93       	push	r17
    1ef6:	0f 93       	push	r16
    1ef8:	aa d5       	rcall	.+2900   	; 0x2a4e <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    1efa:	f8 01       	movw	r30, r16
    1efc:	01 90       	ld	r0, Z+
    1efe:	00 20       	and	r0, r0
    1f00:	e9 f7       	brne	.-6      	; 0x1efc <bt_com_call_back+0x10c>
    1f02:	31 97       	sbiw	r30, 0x01	; 1
    1f04:	bf 01       	movw	r22, r30
    1f06:	60 1b       	sub	r22, r16
    1f08:	71 0b       	sbc	r23, r17
    1f0a:	c8 01       	movw	r24, r16
    1f0c:	0e 94 77 03 	call	0x6ee	; 0x6ee <bt_send_bytes>
				break;
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	de bf       	out	0x3e, r29	; 62
    1f16:	0f be       	out	0x3f, r0	; 63
    1f18:	cd bf       	out	0x3d, r28	; 61
			
			
			default:;
		}
	}
}
    1f1a:	64 96       	adiw	r28, 0x14	; 20
    1f1c:	0f b6       	in	r0, 0x3f	; 63
    1f1e:	f8 94       	cli
    1f20:	de bf       	out	0x3e, r29	; 62
    1f22:	0f be       	out	0x3f, r0	; 63
    1f24:	cd bf       	out	0x3d, r28	; 61
    1f26:	df 91       	pop	r29
    1f28:	cf 91       	pop	r28
    1f2a:	1f 91       	pop	r17
    1f2c:	0f 91       	pop	r16
    1f2e:	ff 90       	pop	r15
    1f30:	ef 90       	pop	r14
    1f32:	08 95       	ret

00001f34 <vstartupTask>:
		// Wait for goal line is passed
		xSemaphoreTake(goal_line_semaphore, portMAX_DELAY);
	}
}

static void vstartupTask( void *pvParameters ) {
    1f34:	cf 93       	push	r28
    1f36:	df 93       	push	r29
    1f38:	1f 92       	push	r1
    1f3a:	cd b7       	in	r28, 0x3d	; 61
    1f3c:	de b7       	in	r29, 0x3e	; 62
	/* The parameters are not used. */
	( void ) pvParameters;
	
	goal_line_semaphore = xSemaphoreCreateBinary();
    1f3e:	43 e0       	ldi	r20, 0x03	; 3
    1f40:	60 e0       	ldi	r22, 0x00	; 0
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	d7 d9       	rcall	.-3154   	; 0x12f4 <xQueueGenericCreate>
    1f46:	90 93 5f 0d 	sts	0x0D5F, r25
    1f4a:	80 93 5e 0d 	sts	0x0D5E, r24
	_xBT_received_chars_queue = xQueueCreate( _BT_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
    1f4e:	40 e0       	ldi	r20, 0x00	; 0
    1f50:	61 e0       	ldi	r22, 0x01	; 1
    1f52:	8e e1       	ldi	r24, 0x1E	; 30
    1f54:	cf d9       	rcall	.-3170   	; 0x12f4 <xQueueGenericCreate>
    1f56:	90 93 5d 0d 	sts	0x0D5D, r25
    1f5a:	80 93 5c 0d 	sts	0x0D5C, r24
	
	if( goal_line_semaphore == NULL ) {
    1f5e:	80 91 5e 0d 	lds	r24, 0x0D5E
    1f62:	90 91 5f 0d 	lds	r25, 0x0D5F
    1f66:	00 97       	sbiw	r24, 0x00	; 0
    1f68:	11 f0       	breq	.+4      	; 0x1f6e <vstartupTask+0x3a>
		/* There was insufficient OpenRTOS heap available for the semaphore to
		be created successfully. */
		// What to do here ?????????????????????????????????
		} else {
		set_goal_line_semaphore(goal_line_semaphore);
    1f6a:	0e 94 93 03 	call	0x726	; 0x726 <set_goal_line_semaphore>
	}
	
	// Initialize Bluetooth Module
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    1f6e:	88 ee       	ldi	r24, 0xE8	; 232
    1f70:	93 e0       	ldi	r25, 0x03	; 3
    1f72:	98 dd       	rcall	.-1232   	; 0x1aa4 <vTaskDelay>
	set_bt_reset(0);  // Disable reset line of Blue tooth module
    1f74:	80 e0       	ldi	r24, 0x00	; 0
    1f76:	0e 94 71 03 	call	0x6e2	; 0x6e2 <set_bt_reset>
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    1f7a:	88 ee       	ldi	r24, 0xE8	; 232
    1f7c:	93 e0       	ldi	r25, 0x03	; 3
    1f7e:	92 dd       	rcall	.-1244   	; 0x1aa4 <vTaskDelay>
	init_bt_module(bt_status_call_back, _xBT_received_chars_queue);
    1f80:	60 91 5c 0d 	lds	r22, 0x0D5C
    1f84:	70 91 5d 0d 	lds	r23, 0x0D5D
    1f88:	84 e8       	ldi	r24, 0x84	; 132
    1f8a:	9e e0       	ldi	r25, 0x0E	; 14
    1f8c:	0e 94 80 03 	call	0x700	; 0x700 <init_bt_module>
	
	xTaskCreate( vjustATask, "JustATask", configMINIMAL_STACK_SIZE, NULL, just_a_task_TASK_PRIORITY, NULL );
    1f90:	a1 2c       	mov	r10, r1
    1f92:	b1 2c       	mov	r11, r1
    1f94:	c1 2c       	mov	r12, r1
    1f96:	d1 2c       	mov	r13, r1
    1f98:	e1 2c       	mov	r14, r1
    1f9a:	f1 2c       	mov	r15, r1
    1f9c:	01 e0       	ldi	r16, 0x01	; 1
    1f9e:	20 e0       	ldi	r18, 0x00	; 0
    1fa0:	30 e0       	ldi	r19, 0x00	; 0
    1fa2:	49 eb       	ldi	r20, 0xB9	; 185
    1fa4:	50 e0       	ldi	r21, 0x00	; 0
    1fa6:	6f e9       	ldi	r22, 0x9F	; 159
    1fa8:	72 e0       	ldi	r23, 0x02	; 2
    1faa:	8a e8       	ldi	r24, 0x8A	; 138
    1fac:	9e e0       	ldi	r25, 0x0E	; 14
    1fae:	19 db       	rcall	.-2510   	; 0x15e2 <xTaskGenericCreate>
	uint8_t _byte;
	
	for( ;; ) {
		xQueueReceive( _xBT_received_chars_queue, &_byte, portMAX_DELAY );
    1fb0:	20 e0       	ldi	r18, 0x00	; 0
    1fb2:	4f ef       	ldi	r20, 0xFF	; 255
    1fb4:	5f ef       	ldi	r21, 0xFF	; 255
    1fb6:	be 01       	movw	r22, r28
    1fb8:	6f 5f       	subi	r22, 0xFF	; 255
    1fba:	7f 4f       	sbci	r23, 0xFF	; 255
    1fbc:	80 91 5c 0d 	lds	r24, 0x0D5C
    1fc0:	90 91 5d 0d 	lds	r25, 0x0D5D
    1fc4:	1e da       	rcall	.-3012   	; 0x1402 <xQueueGenericReceive>
		bt_com_call_back(_byte);
    1fc6:	89 81       	ldd	r24, Y+1	; 0x01
    1fc8:	13 df       	rcall	.-474    	; 0x1df0 <bt_com_call_back>
    1fca:	f2 cf       	rjmp	.-28     	; 0x1fb0 <vstartupTask+0x7c>

00001fcc <main>:
	}
}

int main(void)
{
    1fcc:	af 92       	push	r10
    1fce:	bf 92       	push	r11
    1fd0:	cf 92       	push	r12
    1fd2:	df 92       	push	r13
    1fd4:	ef 92       	push	r14
    1fd6:	ff 92       	push	r15
    1fd8:	0f 93       	push	r16
	init_main_board();
    1fda:	0e 94 95 02 	call	0x52a	; 0x52a <init_main_board>
	xTaskCreate( vstartupTask, "StartupTask", configMINIMAL_STACK_SIZE, NULL, startup_TASK_PRIORITY, NULL );
    1fde:	a1 2c       	mov	r10, r1
    1fe0:	b1 2c       	mov	r11, r1
    1fe2:	c1 2c       	mov	r12, r1
    1fe4:	d1 2c       	mov	r13, r1
    1fe6:	e1 2c       	mov	r14, r1
    1fe8:	f1 2c       	mov	r15, r1
    1fea:	00 e0       	ldi	r16, 0x00	; 0
    1fec:	20 e0       	ldi	r18, 0x00	; 0
    1fee:	30 e0       	ldi	r19, 0x00	; 0
    1ff0:	49 eb       	ldi	r20, 0xB9	; 185
    1ff2:	50 e0       	ldi	r21, 0x00	; 0
    1ff4:	69 ea       	ldi	r22, 0xA9	; 169
    1ff6:	72 e0       	ldi	r23, 0x02	; 2
    1ff8:	8a e9       	ldi	r24, 0x9A	; 154
    1ffa:	9f e0       	ldi	r25, 0x0F	; 15
    1ffc:	f2 da       	rcall	.-2588   	; 0x15e2 <xTaskGenericCreate>
	vTaskStartScheduler();
    1ffe:	ea db       	rcall	.-2092   	; 0x17d4 <vTaskStartScheduler>
}
    2000:	80 e0       	ldi	r24, 0x00	; 0
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	0f 91       	pop	r16
    2006:	ff 90       	pop	r15
    2008:	ef 90       	pop	r14
    200a:	df 90       	pop	r13
    200c:	cf 90       	pop	r12
    200e:	bf 90       	pop	r11
    2010:	af 90       	pop	r10
    2012:	08 95       	ret

00002014 <vApplicationStackOverflowHook>:


// Called is TASK Stack overflows
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
    2014:	08 95       	ret

00002016 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
    2016:	4f 92       	push	r4
    2018:	5f 92       	push	r5
    201a:	6f 92       	push	r6
    201c:	7f 92       	push	r7
    201e:	8f 92       	push	r8
    2020:	9f 92       	push	r9
    2022:	af 92       	push	r10
    2024:	bf 92       	push	r11
    2026:	cf 92       	push	r12
    2028:	df 92       	push	r13
    202a:	ff 92       	push	r15
    202c:	0f 93       	push	r16
    202e:	1f 93       	push	r17
    2030:	cf 93       	push	r28
    2032:	df 93       	push	r29
    2034:	cd b7       	in	r28, 0x3d	; 61
    2036:	de b7       	in	r29, 0x3e	; 62
    2038:	f8 2e       	mov	r15, r24
    203a:	2a 01       	movw	r4, r20
    203c:	3b 01       	movw	r6, r22
    203e:	88 e0       	ldi	r24, 0x08	; 8
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	d5 d3       	rcall	.+1962   	; 0x27ee <malloc>
    2044:	8c 01       	movw	r16, r24
    2046:	8f 2d       	mov	r24, r15
    2048:	90 e0       	ldi	r25, 0x00	; 0
    204a:	88 0f       	add	r24, r24
    204c:	99 1f       	adc	r25, r25
    204e:	fc 01       	movw	r30, r24
    2050:	e0 5a       	subi	r30, 0xA0	; 160
    2052:	f2 4f       	sbci	r31, 0xF2	; 242
    2054:	11 83       	std	Z+1, r17	; 0x01
    2056:	00 83       	st	Z, r16
    2058:	fc 01       	movw	r30, r24
    205a:	e5 5b       	subi	r30, 0xB5	; 181
    205c:	fd 4f       	sbci	r31, 0xFD	; 253
    205e:	80 81       	ld	r24, Z
    2060:	91 81       	ldd	r25, Z+1	; 0x01
    2062:	d8 01       	movw	r26, r16
    2064:	11 96       	adiw	r26, 0x01	; 1
    2066:	9c 93       	st	X, r25
    2068:	8e 93       	st	-X, r24
    206a:	13 96       	adiw	r26, 0x03	; 3
    206c:	bc 92       	st	X, r11
    206e:	ae 92       	st	-X, r10
    2070:	12 97       	sbiw	r26, 0x02	; 2
    2072:	15 96       	adiw	r26, 0x05	; 5
    2074:	dc 92       	st	X, r13
    2076:	ce 92       	st	-X, r12
    2078:	14 97       	sbiw	r26, 0x04	; 4
    207a:	17 96       	adiw	r26, 0x07	; 7
    207c:	9c 92       	st	X, r9
    207e:	8e 92       	st	-X, r8
    2080:	16 97       	sbiw	r26, 0x06	; 6
    2082:	ff b6       	in	r15, 0x3f	; 63
    2084:	f8 94       	cli
    2086:	d8 01       	movw	r26, r16
    2088:	ed 91       	ld	r30, X+
    208a:	fc 91       	ld	r31, X
    208c:	11 97       	sbiw	r26, 0x01	; 1
    208e:	36 97       	sbiw	r30, 0x06	; 6
    2090:	80 81       	ld	r24, Z
    2092:	82 60       	ori	r24, 0x02	; 2
    2094:	80 83       	st	Z, r24
    2096:	cd 90       	ld	r12, X+
    2098:	dc 90       	ld	r13, X
    209a:	44 0c       	add	r4, r4
    209c:	55 1c       	adc	r5, r5
    209e:	66 1c       	adc	r6, r6
    20a0:	77 1c       	adc	r7, r7
    20a2:	44 0c       	add	r4, r4
    20a4:	55 1c       	adc	r5, r5
    20a6:	66 1c       	adc	r6, r6
    20a8:	77 1c       	adc	r7, r7
    20aa:	a3 01       	movw	r20, r6
    20ac:	92 01       	movw	r18, r4
    20ae:	22 0f       	add	r18, r18
    20b0:	33 1f       	adc	r19, r19
    20b2:	44 1f       	adc	r20, r20
    20b4:	55 1f       	adc	r21, r21
    20b6:	60 e0       	ldi	r22, 0x00	; 0
    20b8:	74 e2       	ldi	r23, 0x24	; 36
    20ba:	84 ef       	ldi	r24, 0xF4	; 244
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	44 d3       	rcall	.+1672   	; 0x2748 <__udivmodsi4>
    20c0:	21 50       	subi	r18, 0x01	; 1
    20c2:	f6 01       	movw	r30, r12
    20c4:	32 97       	sbiw	r30, 0x02	; 2
    20c6:	20 83       	st	Z, r18
    20c8:	d8 01       	movw	r26, r16
    20ca:	ed 91       	ld	r30, X+
    20cc:	fc 91       	ld	r31, X
    20ce:	11 97       	sbiw	r26, 0x01	; 1
    20d0:	35 97       	sbiw	r30, 0x05	; 5
    20d2:	88 e9       	ldi	r24, 0x98	; 152
    20d4:	80 83       	st	Z, r24
    20d6:	ed 91       	ld	r30, X+
    20d8:	fc 91       	ld	r31, X
    20da:	34 97       	sbiw	r30, 0x04	; 4
    20dc:	86 e0       	ldi	r24, 0x06	; 6
    20de:	80 83       	st	Z, r24
    20e0:	ff be       	out	0x3f, r15	; 63
    20e2:	c8 01       	movw	r24, r16
    20e4:	df 91       	pop	r29
    20e6:	cf 91       	pop	r28
    20e8:	1f 91       	pop	r17
    20ea:	0f 91       	pop	r16
    20ec:	ff 90       	pop	r15
    20ee:	df 90       	pop	r13
    20f0:	cf 90       	pop	r12
    20f2:	bf 90       	pop	r11
    20f4:	af 90       	pop	r10
    20f6:	9f 90       	pop	r9
    20f8:	8f 90       	pop	r8
    20fa:	7f 90       	pop	r7
    20fc:	6f 90       	pop	r6
    20fe:	5f 90       	pop	r5
    2100:	4f 90       	pop	r4
    2102:	08 95       	ret

00002104 <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
    2104:	ef 92       	push	r14
    2106:	ff 92       	push	r15
    2108:	0f 93       	push	r16
    210a:	1f 93       	push	r17
    210c:	cf 93       	push	r28
    210e:	df 93       	push	r29
    2110:	8c 01       	movw	r16, r24
    2112:	e4 2e       	mov	r14, r20
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    2114:	dc 01       	movw	r26, r24
    2116:	12 96       	adiw	r26, 0x02	; 2
    2118:	ed 91       	ld	r30, X+
    211a:	fc 91       	ld	r31, X
    211c:	13 97       	sbiw	r26, 0x03	; 3
    211e:	30 97       	sbiw	r30, 0x00	; 0
    2120:	69 f0       	breq	.+26     	; 0x213c <serial_send_bytes+0x38>
    2122:	24 2f       	mov	r18, r20
    2124:	30 e0       	ldi	r19, 0x00	; 0
    2126:	42 89       	ldd	r20, Z+18	; 0x12
    2128:	80 e1       	ldi	r24, 0x10	; 16
    212a:	90 e0       	ldi	r25, 0x00	; 0
    212c:	84 1b       	sub	r24, r20
    212e:	91 09       	sbc	r25, r1
    2130:	82 17       	cp	r24, r18
    2132:	93 07       	cpc	r25, r19
    2134:	e4 f0       	brlt	.+56     	; 0x216e <serial_send_bytes+0x6a>
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2136:	e1 10       	cpse	r14, r1
    2138:	05 c0       	rjmp	.+10     	; 0x2144 <serial_send_bytes+0x40>
    213a:	10 c0       	rjmp	.+32     	; 0x215c <serial_send_bytes+0x58>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    213c:	b1 e0       	ldi	r27, 0x01	; 1
    213e:	b4 17       	cp	r27, r20
    2140:	c0 f0       	brcs	.+48     	; 0x2172 <serial_send_bytes+0x6e>
    2142:	f9 cf       	rjmp	.-14     	; 0x2136 <serial_send_bytes+0x32>
    2144:	c6 2f       	mov	r28, r22
    2146:	d7 2f       	mov	r29, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2148:	f1 2c       	mov	r15, r1
		buffer_put_item(handle->_tx_buf, buf[i]);
    214a:	69 91       	ld	r22, Y+
    214c:	f8 01       	movw	r30, r16
    214e:	82 81       	ldd	r24, Z+2	; 0x02
    2150:	93 81       	ldd	r25, Z+3	; 0x03
    2152:	0e 94 21 04 	call	0x842	; 0x842 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2156:	f3 94       	inc	r15
    2158:	fe 10       	cpse	r15, r14
    215a:	f7 cf       	rjmp	.-18     	; 0x214a <serial_send_bytes+0x46>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
    215c:	d8 01       	movw	r26, r16
    215e:	ed 91       	ld	r30, X+
    2160:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
    2162:	35 97       	sbiw	r30, 0x05	; 5
    2164:	80 81       	ld	r24, Z
    2166:	80 62       	ori	r24, 0x20	; 32
    2168:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
    216a:	80 e0       	ldi	r24, 0x00	; 0
    216c:	03 c0       	rjmp	.+6      	; 0x2174 <serial_send_bytes+0x70>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
    216e:	82 e0       	ldi	r24, 0x02	; 2
    2170:	01 c0       	rjmp	.+2      	; 0x2174 <serial_send_bytes+0x70>
    2172:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
    2174:	df 91       	pop	r29
    2176:	cf 91       	pop	r28
    2178:	1f 91       	pop	r17
    217a:	0f 91       	pop	r16
    217c:	ff 90       	pop	r15
    217e:	ef 90       	pop	r14
    2180:	08 95       	ret

00002182 <__vector_25>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    2182:	1f 92       	push	r1
    2184:	0f 92       	push	r0
    2186:	0f b6       	in	r0, 0x3f	; 63
    2188:	0f 92       	push	r0
    218a:	11 24       	eor	r1, r1
    218c:	0b b6       	in	r0, 0x3b	; 59
    218e:	0f 92       	push	r0
    2190:	2f 93       	push	r18
    2192:	3f 93       	push	r19
    2194:	4f 93       	push	r20
    2196:	5f 93       	push	r21
    2198:	6f 93       	push	r22
    219a:	7f 93       	push	r23
    219c:	8f 93       	push	r24
    219e:	9f 93       	push	r25
    21a0:	af 93       	push	r26
    21a2:	bf 93       	push	r27
    21a4:	cf 93       	push	r28
    21a6:	ef 93       	push	r30
    21a8:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    21aa:	e0 91 60 0d 	lds	r30, 0x0D60
    21ae:	f0 91 61 0d 	lds	r31, 0x0D61
    21b2:	30 97       	sbiw	r30, 0x00	; 0
    21b4:	a1 f0       	breq	.+40     	; 0x21de <__vector_25+0x5c>
		item = UDR0;
    21b6:	c0 91 c6 00 	lds	r28, 0x00C6
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
    21ba:	6c 2f       	mov	r22, r28
    21bc:	84 81       	ldd	r24, Z+4	; 0x04
    21be:	95 81       	ldd	r25, Z+5	; 0x05
    21c0:	0e 94 21 04 	call	0x842	; 0x842 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
    21c4:	80 91 60 0d 	lds	r24, 0x0D60
    21c8:	90 91 61 0d 	lds	r25, 0x0D61
    21cc:	dc 01       	movw	r26, r24
    21ce:	16 96       	adiw	r26, 0x06	; 6
    21d0:	ed 91       	ld	r30, X+
    21d2:	fc 91       	ld	r31, X
    21d4:	17 97       	sbiw	r26, 0x07	; 7
    21d6:	30 97       	sbiw	r30, 0x00	; 0
    21d8:	11 f0       	breq	.+4      	; 0x21de <__vector_25+0x5c>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
    21da:	6c 2f       	mov	r22, r28
    21dc:	19 95       	eicall
		}
	}
}
    21de:	ff 91       	pop	r31
    21e0:	ef 91       	pop	r30
    21e2:	cf 91       	pop	r28
    21e4:	bf 91       	pop	r27
    21e6:	af 91       	pop	r26
    21e8:	9f 91       	pop	r25
    21ea:	8f 91       	pop	r24
    21ec:	7f 91       	pop	r23
    21ee:	6f 91       	pop	r22
    21f0:	5f 91       	pop	r21
    21f2:	4f 91       	pop	r20
    21f4:	3f 91       	pop	r19
    21f6:	2f 91       	pop	r18
    21f8:	0f 90       	pop	r0
    21fa:	0b be       	out	0x3b, r0	; 59
    21fc:	0f 90       	pop	r0
    21fe:	0f be       	out	0x3f, r0	; 63
    2200:	0f 90       	pop	r0
    2202:	1f 90       	pop	r1
    2204:	18 95       	reti

00002206 <__vector_26>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
    2206:	1f 92       	push	r1
    2208:	0f 92       	push	r0
    220a:	0f b6       	in	r0, 0x3f	; 63
    220c:	0f 92       	push	r0
    220e:	11 24       	eor	r1, r1
    2210:	0b b6       	in	r0, 0x3b	; 59
    2212:	0f 92       	push	r0
    2214:	2f 93       	push	r18
    2216:	3f 93       	push	r19
    2218:	4f 93       	push	r20
    221a:	5f 93       	push	r21
    221c:	6f 93       	push	r22
    221e:	7f 93       	push	r23
    2220:	8f 93       	push	r24
    2222:	9f 93       	push	r25
    2224:	af 93       	push	r26
    2226:	bf 93       	push	r27
    2228:	ef 93       	push	r30
    222a:	ff 93       	push	r31
    222c:	cf 93       	push	r28
    222e:	df 93       	push	r29
    2230:	1f 92       	push	r1
    2232:	cd b7       	in	r28, 0x3d	; 61
    2234:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    2236:	e0 91 60 0d 	lds	r30, 0x0D60
    223a:	f0 91 61 0d 	lds	r31, 0x0D61
    223e:	30 97       	sbiw	r30, 0x00	; 0
    2240:	99 f0       	breq	.+38     	; 0x2268 <__vector_26+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
    2242:	be 01       	movw	r22, r28
    2244:	6f 5f       	subi	r22, 0xFF	; 255
    2246:	7f 4f       	sbci	r23, 0xFF	; 255
    2248:	82 81       	ldd	r24, Z+2	; 0x02
    224a:	93 81       	ldd	r25, Z+3	; 0x03
    224c:	0e 94 09 04 	call	0x812	; 0x812 <buffer_get_item>
    2250:	81 11       	cpse	r24, r1
    2252:	04 c0       	rjmp	.+8      	; 0x225c <__vector_26+0x56>
			UDR0 = item;
    2254:	89 81       	ldd	r24, Y+1	; 0x01
    2256:	80 93 c6 00 	sts	0x00C6, r24
    225a:	0b c0       	rjmp	.+22     	; 0x2272 <__vector_26+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
    225c:	e1 ec       	ldi	r30, 0xC1	; 193
    225e:	f0 e0       	ldi	r31, 0x00	; 0
    2260:	80 81       	ld	r24, Z
    2262:	8f 7d       	andi	r24, 0xDF	; 223
    2264:	80 83       	st	Z, r24
    2266:	05 c0       	rjmp	.+10     	; 0x2272 <__vector_26+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    2268:	e1 ec       	ldi	r30, 0xC1	; 193
    226a:	f0 e0       	ldi	r31, 0x00	; 0
    226c:	80 81       	ld	r24, Z
    226e:	8f 7d       	andi	r24, 0xDF	; 223
    2270:	80 83       	st	Z, r24
	}
}
    2272:	0f 90       	pop	r0
    2274:	df 91       	pop	r29
    2276:	cf 91       	pop	r28
    2278:	ff 91       	pop	r31
    227a:	ef 91       	pop	r30
    227c:	bf 91       	pop	r27
    227e:	af 91       	pop	r26
    2280:	9f 91       	pop	r25
    2282:	8f 91       	pop	r24
    2284:	7f 91       	pop	r23
    2286:	6f 91       	pop	r22
    2288:	5f 91       	pop	r21
    228a:	4f 91       	pop	r20
    228c:	3f 91       	pop	r19
    228e:	2f 91       	pop	r18
    2290:	0f 90       	pop	r0
    2292:	0b be       	out	0x3b, r0	; 59
    2294:	0f 90       	pop	r0
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	0f 90       	pop	r0
    229a:	1f 90       	pop	r1
    229c:	18 95       	reti

0000229e <__vector_36>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    229e:	1f 92       	push	r1
    22a0:	0f 92       	push	r0
    22a2:	0f b6       	in	r0, 0x3f	; 63
    22a4:	0f 92       	push	r0
    22a6:	11 24       	eor	r1, r1
    22a8:	0b b6       	in	r0, 0x3b	; 59
    22aa:	0f 92       	push	r0
    22ac:	2f 93       	push	r18
    22ae:	3f 93       	push	r19
    22b0:	4f 93       	push	r20
    22b2:	5f 93       	push	r21
    22b4:	6f 93       	push	r22
    22b6:	7f 93       	push	r23
    22b8:	8f 93       	push	r24
    22ba:	9f 93       	push	r25
    22bc:	af 93       	push	r26
    22be:	bf 93       	push	r27
    22c0:	cf 93       	push	r28
    22c2:	ef 93       	push	r30
    22c4:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    22c6:	e0 91 62 0d 	lds	r30, 0x0D62
    22ca:	f0 91 63 0d 	lds	r31, 0x0D63
    22ce:	30 97       	sbiw	r30, 0x00	; 0
    22d0:	a1 f0       	breq	.+40     	; 0x22fa <__vector_36+0x5c>
		item = UDR1;
    22d2:	c0 91 ce 00 	lds	r28, 0x00CE
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    22d6:	6c 2f       	mov	r22, r28
    22d8:	84 81       	ldd	r24, Z+4	; 0x04
    22da:	95 81       	ldd	r25, Z+5	; 0x05
    22dc:	0e 94 21 04 	call	0x842	; 0x842 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    22e0:	80 91 62 0d 	lds	r24, 0x0D62
    22e4:	90 91 63 0d 	lds	r25, 0x0D63
    22e8:	dc 01       	movw	r26, r24
    22ea:	16 96       	adiw	r26, 0x06	; 6
    22ec:	ed 91       	ld	r30, X+
    22ee:	fc 91       	ld	r31, X
    22f0:	17 97       	sbiw	r26, 0x07	; 7
    22f2:	30 97       	sbiw	r30, 0x00	; 0
    22f4:	11 f0       	breq	.+4      	; 0x22fa <__vector_36+0x5c>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    22f6:	6c 2f       	mov	r22, r28
    22f8:	19 95       	eicall
		}
	}
}
    22fa:	ff 91       	pop	r31
    22fc:	ef 91       	pop	r30
    22fe:	cf 91       	pop	r28
    2300:	bf 91       	pop	r27
    2302:	af 91       	pop	r26
    2304:	9f 91       	pop	r25
    2306:	8f 91       	pop	r24
    2308:	7f 91       	pop	r23
    230a:	6f 91       	pop	r22
    230c:	5f 91       	pop	r21
    230e:	4f 91       	pop	r20
    2310:	3f 91       	pop	r19
    2312:	2f 91       	pop	r18
    2314:	0f 90       	pop	r0
    2316:	0b be       	out	0x3b, r0	; 59
    2318:	0f 90       	pop	r0
    231a:	0f be       	out	0x3f, r0	; 63
    231c:	0f 90       	pop	r0
    231e:	1f 90       	pop	r1
    2320:	18 95       	reti

00002322 <__vector_37>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    2322:	1f 92       	push	r1
    2324:	0f 92       	push	r0
    2326:	0f b6       	in	r0, 0x3f	; 63
    2328:	0f 92       	push	r0
    232a:	11 24       	eor	r1, r1
    232c:	0b b6       	in	r0, 0x3b	; 59
    232e:	0f 92       	push	r0
    2330:	2f 93       	push	r18
    2332:	3f 93       	push	r19
    2334:	4f 93       	push	r20
    2336:	5f 93       	push	r21
    2338:	6f 93       	push	r22
    233a:	7f 93       	push	r23
    233c:	8f 93       	push	r24
    233e:	9f 93       	push	r25
    2340:	af 93       	push	r26
    2342:	bf 93       	push	r27
    2344:	ef 93       	push	r30
    2346:	ff 93       	push	r31
    2348:	cf 93       	push	r28
    234a:	df 93       	push	r29
    234c:	1f 92       	push	r1
    234e:	cd b7       	in	r28, 0x3d	; 61
    2350:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    2352:	e0 91 62 0d 	lds	r30, 0x0D62
    2356:	f0 91 63 0d 	lds	r31, 0x0D63
    235a:	30 97       	sbiw	r30, 0x00	; 0
    235c:	99 f0       	breq	.+38     	; 0x2384 <__vector_37+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    235e:	be 01       	movw	r22, r28
    2360:	6f 5f       	subi	r22, 0xFF	; 255
    2362:	7f 4f       	sbci	r23, 0xFF	; 255
    2364:	82 81       	ldd	r24, Z+2	; 0x02
    2366:	93 81       	ldd	r25, Z+3	; 0x03
    2368:	0e 94 09 04 	call	0x812	; 0x812 <buffer_get_item>
    236c:	81 11       	cpse	r24, r1
    236e:	04 c0       	rjmp	.+8      	; 0x2378 <__vector_37+0x56>
			UDR1 = item;
    2370:	89 81       	ldd	r24, Y+1	; 0x01
    2372:	80 93 ce 00 	sts	0x00CE, r24
    2376:	0b c0       	rjmp	.+22     	; 0x238e <__vector_37+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    2378:	e9 ec       	ldi	r30, 0xC9	; 201
    237a:	f0 e0       	ldi	r31, 0x00	; 0
    237c:	80 81       	ld	r24, Z
    237e:	8f 7d       	andi	r24, 0xDF	; 223
    2380:	80 83       	st	Z, r24
    2382:	05 c0       	rjmp	.+10     	; 0x238e <__vector_37+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    2384:	e9 ec       	ldi	r30, 0xC9	; 201
    2386:	f0 e0       	ldi	r31, 0x00	; 0
    2388:	80 81       	ld	r24, Z
    238a:	8f 7d       	andi	r24, 0xDF	; 223
    238c:	80 83       	st	Z, r24
	}
}
    238e:	0f 90       	pop	r0
    2390:	df 91       	pop	r29
    2392:	cf 91       	pop	r28
    2394:	ff 91       	pop	r31
    2396:	ef 91       	pop	r30
    2398:	bf 91       	pop	r27
    239a:	af 91       	pop	r26
    239c:	9f 91       	pop	r25
    239e:	8f 91       	pop	r24
    23a0:	7f 91       	pop	r23
    23a2:	6f 91       	pop	r22
    23a4:	5f 91       	pop	r21
    23a6:	4f 91       	pop	r20
    23a8:	3f 91       	pop	r19
    23aa:	2f 91       	pop	r18
    23ac:	0f 90       	pop	r0
    23ae:	0b be       	out	0x3b, r0	; 59
    23b0:	0f 90       	pop	r0
    23b2:	0f be       	out	0x3f, r0	; 63
    23b4:	0f 90       	pop	r0
    23b6:	1f 90       	pop	r1
    23b8:	18 95       	reti

000023ba <_select_instance>:
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    23ba:	e0 91 65 0d 	lds	r30, 0x0D65
    23be:	f0 91 66 0d 	lds	r31, 0x0D66
    23c2:	30 97       	sbiw	r30, 0x00	; 0
    23c4:	01 f1       	breq	.+64     	; 0x2406 <_select_instance+0x4c>
    23c6:	23 81       	ldd	r18, Z+3	; 0x03
    23c8:	21 30       	cpi	r18, 0x01	; 1
    23ca:	79 f4       	brne	.+30     	; 0x23ea <_select_instance+0x30>
    23cc:	a0 81       	ld	r26, Z
    23ce:	b1 81       	ldd	r27, Z+1	; 0x01
    23d0:	4c 91       	ld	r20, X
    23d2:	21 e0       	ldi	r18, 0x01	; 1
    23d4:	30 e0       	ldi	r19, 0x00	; 0
    23d6:	02 80       	ldd	r0, Z+2	; 0x02
    23d8:	02 c0       	rjmp	.+4      	; 0x23de <_select_instance+0x24>
    23da:	22 0f       	add	r18, r18
    23dc:	33 1f       	adc	r19, r19
    23de:	0a 94       	dec	r0
    23e0:	e2 f7       	brpl	.-8      	; 0x23da <_select_instance+0x20>
    23e2:	20 95       	com	r18
    23e4:	24 23       	and	r18, r20
    23e6:	2c 93       	st	X, r18
    23e8:	0e c0       	rjmp	.+28     	; 0x2406 <_select_instance+0x4c>
    23ea:	a0 81       	ld	r26, Z
    23ec:	b1 81       	ldd	r27, Z+1	; 0x01
    23ee:	6c 91       	ld	r22, X
    23f0:	41 e0       	ldi	r20, 0x01	; 1
    23f2:	50 e0       	ldi	r21, 0x00	; 0
    23f4:	9a 01       	movw	r18, r20
    23f6:	02 80       	ldd	r0, Z+2	; 0x02
    23f8:	02 c0       	rjmp	.+4      	; 0x23fe <_select_instance+0x44>
    23fa:	22 0f       	add	r18, r18
    23fc:	33 1f       	adc	r19, r19
    23fe:	0a 94       	dec	r0
    2400:	e2 f7       	brpl	.-8      	; 0x23fa <_select_instance+0x40>
    2402:	26 2b       	or	r18, r22
    2404:	2c 93       	st	X, r18
    2406:	90 93 66 0d 	sts	0x0D66, r25
    240a:	80 93 65 0d 	sts	0x0D65, r24
    240e:	00 97       	sbiw	r24, 0x00	; 0
    2410:	69 f0       	breq	.+26     	; 0x242c <_select_instance+0x72>
    2412:	10 92 67 0d 	sts	0x0D67, r1
    2416:	2c b5       	in	r18, 0x2c	; 44
    2418:	2f 73       	andi	r18, 0x3F	; 63
    241a:	2c bd       	out	0x2c, r18	; 44
    241c:	fc 01       	movw	r30, r24
    241e:	24 81       	ldd	r18, Z+4	; 0x04
    2420:	2c bd       	out	0x2c, r18	; 44
    2422:	85 81       	ldd	r24, Z+5	; 0x05
    2424:	8d bd       	out	0x2d, r24	; 45
    2426:	8c b5       	in	r24, 0x2c	; 44
    2428:	80 64       	ori	r24, 0x40	; 64
    242a:	8c bd       	out	0x2c, r24	; 44
    242c:	08 95       	ret

0000242e <spi_new_instance>:
    242e:	6f 92       	push	r6
    2430:	7f 92       	push	r7
    2432:	8f 92       	push	r8
    2434:	9f 92       	push	r9
    2436:	af 92       	push	r10
    2438:	bf 92       	push	r11
    243a:	cf 92       	push	r12
    243c:	df 92       	push	r13
    243e:	ef 92       	push	r14
    2440:	ff 92       	push	r15
    2442:	0f 93       	push	r16
    2444:	1f 93       	push	r17
    2446:	cf 93       	push	r28
    2448:	df 93       	push	r29
    244a:	cd b7       	in	r28, 0x3d	; 61
    244c:	de b7       	in	r29, 0x3e	; 62
    244e:	d8 2e       	mov	r13, r24
    2450:	f6 2e       	mov	r15, r22
    2452:	64 2e       	mov	r6, r20
    2454:	72 2e       	mov	r7, r18
    2456:	80 91 64 0d 	lds	r24, 0x0D64
    245a:	81 11       	cpse	r24, r1
    245c:	06 c0       	rjmp	.+12     	; 0x246a <spi_new_instance+0x3c>
    245e:	84 b1       	in	r24, 0x04	; 4
    2460:	87 60       	ori	r24, 0x07	; 7
    2462:	84 b9       	out	0x04, r24	; 4
    2464:	81 e0       	ldi	r24, 0x01	; 1
    2466:	80 93 64 0d 	sts	0x0D64, r24
    246a:	8c e0       	ldi	r24, 0x0C	; 12
    246c:	90 e0       	ldi	r25, 0x00	; 0
    246e:	bf d1       	rcall	.+894    	; 0x27ee <malloc>
    2470:	fc 01       	movw	r30, r24
    2472:	00 83       	st	Z, r16
    2474:	11 83       	std	Z+1, r17	; 0x01
    2476:	e2 82       	std	Z+2, r14	; 0x02
    2478:	a0 2f       	mov	r26, r16
    247a:	b1 2f       	mov	r27, r17
    247c:	4e 91       	ld	r20, -X
    247e:	21 e0       	ldi	r18, 0x01	; 1
    2480:	30 e0       	ldi	r19, 0x00	; 0
    2482:	c9 01       	movw	r24, r18
    2484:	02 c0       	rjmp	.+4      	; 0x248a <spi_new_instance+0x5c>
    2486:	88 0f       	add	r24, r24
    2488:	99 1f       	adc	r25, r25
    248a:	ea 94       	dec	r14
    248c:	e2 f7       	brpl	.-8      	; 0x2486 <spi_new_instance+0x58>
    248e:	84 2b       	or	r24, r20
    2490:	8c 93       	st	X, r24
    2492:	c3 82       	std	Z+3, r12	; 0x03
    2494:	66 0c       	add	r6, r6
    2496:	66 0c       	add	r6, r6
    2498:	76 28       	or	r7, r6
    249a:	af 2d       	mov	r26, r15
    249c:	bb 27       	eor	r27, r27
    249e:	a7 fd       	sbrc	r26, 7
    24a0:	b0 95       	com	r27
    24a2:	ab 54       	subi	r26, 0x4B	; 75
    24a4:	bd 4f       	sbci	r27, 0xFD	; 253
    24a6:	6c 90       	ld	r6, X
    24a8:	d6 28       	or	r13, r6
    24aa:	d7 28       	or	r13, r7
    24ac:	d4 82       	std	Z+4, r13	; 0x04
    24ae:	83 e0       	ldi	r24, 0x03	; 3
    24b0:	8f 15       	cp	r24, r15
    24b2:	14 f4       	brge	.+4      	; 0x24b8 <spi_new_instance+0x8a>
    24b4:	81 e0       	ldi	r24, 0x01	; 1
    24b6:	85 83       	std	Z+5, r24	; 0x05
    24b8:	97 82       	std	Z+7, r9	; 0x07
    24ba:	86 82       	std	Z+6, r8	; 0x06
    24bc:	b1 86       	std	Z+9, r11	; 0x09
    24be:	a0 86       	std	Z+8, r10	; 0x08
    24c0:	8a 89       	ldd	r24, Y+18	; 0x12
    24c2:	9b 89       	ldd	r25, Y+19	; 0x13
    24c4:	93 87       	std	Z+11, r25	; 0x0b
    24c6:	82 87       	std	Z+10, r24	; 0x0a
    24c8:	6f b7       	in	r22, 0x3f	; 63
    24ca:	f8 94       	cli
    24cc:	80 91 65 0d 	lds	r24, 0x0D65
    24d0:	90 91 66 0d 	lds	r25, 0x0D66
    24d4:	f0 93 66 0d 	sts	0x0D66, r31
    24d8:	e0 93 65 0d 	sts	0x0D65, r30
    24dc:	23 81       	ldd	r18, Z+3	; 0x03
    24de:	21 30       	cpi	r18, 0x01	; 1
    24e0:	81 f4       	brne	.+32     	; 0x2502 <spi_new_instance+0xd4>
    24e2:	a0 81       	ld	r26, Z
    24e4:	b1 81       	ldd	r27, Z+1	; 0x01
    24e6:	7c 91       	ld	r23, X
    24e8:	41 e0       	ldi	r20, 0x01	; 1
    24ea:	50 e0       	ldi	r21, 0x00	; 0
    24ec:	9a 01       	movw	r18, r20
    24ee:	02 80       	ldd	r0, Z+2	; 0x02
    24f0:	02 c0       	rjmp	.+4      	; 0x24f6 <spi_new_instance+0xc8>
    24f2:	22 0f       	add	r18, r18
    24f4:	33 1f       	adc	r19, r19
    24f6:	0a 94       	dec	r0
    24f8:	e2 f7       	brpl	.-8      	; 0x24f2 <spi_new_instance+0xc4>
    24fa:	20 95       	com	r18
    24fc:	27 23       	and	r18, r23
    24fe:	2c 93       	st	X, r18
    2500:	0e c0       	rjmp	.+28     	; 0x251e <spi_new_instance+0xf0>
    2502:	a0 81       	ld	r26, Z
    2504:	b1 81       	ldd	r27, Z+1	; 0x01
    2506:	7c 91       	ld	r23, X
    2508:	41 e0       	ldi	r20, 0x01	; 1
    250a:	50 e0       	ldi	r21, 0x00	; 0
    250c:	9a 01       	movw	r18, r20
    250e:	02 80       	ldd	r0, Z+2	; 0x02
    2510:	02 c0       	rjmp	.+4      	; 0x2516 <spi_new_instance+0xe8>
    2512:	22 0f       	add	r18, r18
    2514:	33 1f       	adc	r19, r19
    2516:	0a 94       	dec	r0
    2518:	e2 f7       	brpl	.-8      	; 0x2512 <spi_new_instance+0xe4>
    251a:	27 2b       	or	r18, r23
    251c:	2c 93       	st	X, r18
    251e:	90 93 66 0d 	sts	0x0D66, r25
    2522:	80 93 65 0d 	sts	0x0D65, r24
    2526:	6f bf       	out	0x3f, r22	; 63
    2528:	cf 01       	movw	r24, r30
    252a:	df 91       	pop	r29
    252c:	cf 91       	pop	r28
    252e:	1f 91       	pop	r17
    2530:	0f 91       	pop	r16
    2532:	ff 90       	pop	r15
    2534:	ef 90       	pop	r14
    2536:	df 90       	pop	r13
    2538:	cf 90       	pop	r12
    253a:	bf 90       	pop	r11
    253c:	af 90       	pop	r10
    253e:	9f 90       	pop	r9
    2540:	8f 90       	pop	r8
    2542:	7f 90       	pop	r7
    2544:	6f 90       	pop	r6
    2546:	08 95       	ret

00002548 <spi_send_string>:
SPI_ILLEGAL_INSTANCE: instance is null.
@param spi to send to.
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
    2548:	df 92       	push	r13
    254a:	ef 92       	push	r14
    254c:	ff 92       	push	r15
    254e:	0f 93       	push	r16
    2550:	1f 93       	push	r17
    2552:	cf 93       	push	r28
    2554:	df 93       	push	r29
    2556:	ec 01       	movw	r28, r24
    2558:	8b 01       	movw	r16, r22
    255a:	f4 2e       	mov	r15, r20
	if (spi == 0) {
    255c:	00 97       	sbiw	r24, 0x00	; 0
    255e:	09 f4       	brne	.+2      	; 0x2562 <spi_send_string+0x1a>
    2560:	6b c0       	rjmp	.+214    	; 0x2638 <spi_send_string+0xf0>
		return SPI_ILLEGAL_INSTANCE;
	}

	// Select correct instance
	if (_this != spi ) {
    2562:	80 91 65 0d 	lds	r24, 0x0D65
    2566:	90 91 66 0d 	lds	r25, 0x0D66
    256a:	8c 17       	cp	r24, r28
    256c:	9d 07       	cpc	r25, r29
    256e:	11 f0       	breq	.+4      	; 0x2574 <spi_send_string+0x2c>
		_select_instance(spi);
    2570:	ce 01       	movw	r24, r28
    2572:	23 df       	rcall	.-442    	; 0x23ba <_select_instance>
	uint8_t tmp = 0;

	// Critical section
	{
		// disable interrupt
		uint8_t c_sreg = SREG;
    2574:	ef b6       	in	r14, 0x3f	; 63
		cli();
    2576:	f8 94       	cli

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
    2578:	ee 81       	ldd	r30, Y+6	; 0x06
    257a:	ff 81       	ldd	r31, Y+7	; 0x07
    257c:	30 97       	sbiw	r30, 0x00	; 0
    257e:	61 f0       	breq	.+24     	; 0x2598 <spi_send_string+0x50>
    2580:	2f 2d       	mov	r18, r15
    2582:	30 e0       	ldi	r19, 0x00	; 0
    2584:	42 89       	ldd	r20, Z+18	; 0x12
    2586:	80 e1       	ldi	r24, 0x10	; 16
    2588:	90 e0       	ldi	r25, 0x00	; 0
    258a:	84 1b       	sub	r24, r20
    258c:	91 09       	sbc	r25, r1
    258e:	82 17       	cp	r24, r18
    2590:	93 07       	cpc	r25, r19
    2592:	0c f4       	brge	.+2      	; 0x2596 <spi_send_string+0x4e>
    2594:	48 c0       	rjmp	.+144    	; 0x2626 <spi_send_string+0xde>
    2596:	04 c0       	rjmp	.+8      	; 0x25a0 <spi_send_string+0x58>
    2598:	81 e0       	ldi	r24, 0x01	; 1
    259a:	8f 15       	cp	r24, r15
    259c:	08 f4       	brcc	.+2      	; 0x25a0 <spi_send_string+0x58>
    259e:	45 c0       	rjmp	.+138    	; 0x262a <spi_send_string+0xe2>
			result = SPI_NO_ROOM_IN_TX_BUFFER;
			} else {
			// If SPI in idle send the first byte
			if (!_spi_active) {
    25a0:	80 91 67 0d 	lds	r24, 0x0D67
    25a4:	81 11       	cpse	r24, r1
    25a6:	30 c0       	rjmp	.+96     	; 0x2608 <spi_send_string+0xc0>
				_spi_active = 1;
    25a8:	81 e0       	ldi	r24, 0x01	; 1
    25aa:	80 93 67 0d 	sts	0x0D67, r24
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    25ae:	e0 91 65 0d 	lds	r30, 0x0D65
    25b2:	f0 91 66 0d 	lds	r31, 0x0D66
    25b6:	83 81       	ldd	r24, Z+3	; 0x03
    25b8:	81 30       	cpi	r24, 0x01	; 1
    25ba:	79 f4       	brne	.+30     	; 0x25da <spi_send_string+0x92>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    25bc:	a0 81       	ld	r26, Z
    25be:	b1 81       	ldd	r27, Z+1	; 0x01
    25c0:	4c 91       	ld	r20, X
    25c2:	21 e0       	ldi	r18, 0x01	; 1
    25c4:	30 e0       	ldi	r19, 0x00	; 0
    25c6:	c9 01       	movw	r24, r18
    25c8:	02 80       	ldd	r0, Z+2	; 0x02
    25ca:	02 c0       	rjmp	.+4      	; 0x25d0 <spi_send_string+0x88>
    25cc:	88 0f       	add	r24, r24
    25ce:	99 1f       	adc	r25, r25
    25d0:	0a 94       	dec	r0
    25d2:	e2 f7       	brpl	.-8      	; 0x25cc <spi_send_string+0x84>
    25d4:	84 2b       	or	r24, r20
    25d6:	8c 93       	st	X, r24
    25d8:	0e c0       	rjmp	.+28     	; 0x25f6 <spi_send_string+0xae>
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
		}
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    25da:	a0 81       	ld	r26, Z
    25dc:	b1 81       	ldd	r27, Z+1	; 0x01
    25de:	2c 91       	ld	r18, X
    25e0:	81 e0       	ldi	r24, 0x01	; 1
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	02 80       	ldd	r0, Z+2	; 0x02
    25e6:	02 c0       	rjmp	.+4      	; 0x25ec <spi_send_string+0xa4>
    25e8:	88 0f       	add	r24, r24
    25ea:	99 1f       	adc	r25, r25
    25ec:	0a 94       	dec	r0
    25ee:	e2 f7       	brpl	.-8      	; 0x25e8 <spi_send_string+0xa0>
    25f0:	80 95       	com	r24
    25f2:	82 23       	and	r24, r18
    25f4:	8c 93       	st	X, r24
			// If SPI in idle send the first byte
			if (!_spi_active) {
				_spi_active = 1;
				_set_cs(CS_ACTIVE);
				// Enable SPI interrupt
				SPCR |= _BV(SPIE);
    25f6:	8c b5       	in	r24, 0x2c	; 44
    25f8:	80 68       	ori	r24, 0x80	; 128
    25fa:	8c bd       	out	0x2c, r24	; 44
				// Send first byte
				SPDR =buf[0];
    25fc:	f8 01       	movw	r30, r16
    25fe:	80 81       	ld	r24, Z
    2600:	8e bd       	out	0x2e, r24	; 46

				tmp = 1;
    2602:	dd 24       	eor	r13, r13
    2604:	d3 94       	inc	r13
    2606:	01 c0       	rjmp	.+2      	; 0x260a <spi_send_string+0xc2>
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
	uint8_t tmp = 0;
    2608:	d1 2c       	mov	r13, r1
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    260a:	df 14       	cp	r13, r15
    260c:	80 f4       	brcc	.+32     	; 0x262e <spi_send_string+0xe6>
				buffer_put_item(spi->_tx_buf, buf[i]);
    260e:	f8 01       	movw	r30, r16
    2610:	ed 0d       	add	r30, r13
    2612:	f1 1d       	adc	r31, r1
    2614:	60 81       	ld	r22, Z
    2616:	8e 81       	ldd	r24, Y+6	; 0x06
    2618:	9f 81       	ldd	r25, Y+7	; 0x07
    261a:	0e 94 21 04 	call	0x842	; 0x842 <buffer_put_item>
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    261e:	d3 94       	inc	r13
    2620:	df 14       	cp	r13, r15
    2622:	a8 f3       	brcs	.-22     	; 0x260e <spi_send_string+0xc6>
    2624:	06 c0       	rjmp	.+12     	; 0x2632 <spi_send_string+0xea>
		uint8_t c_sreg = SREG;
		cli();

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
			result = SPI_NO_ROOM_IN_TX_BUFFER;
    2626:	81 e0       	ldi	r24, 0x01	; 1
    2628:	05 c0       	rjmp	.+10     	; 0x2634 <spi_send_string+0xec>
    262a:	81 e0       	ldi	r24, 0x01	; 1
    262c:	03 c0       	rjmp	.+6      	; 0x2634 <spi_send_string+0xec>
	// Select correct instance
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
    262e:	80 e0       	ldi	r24, 0x00	; 0
    2630:	01 c0       	rjmp	.+2      	; 0x2634 <spi_send_string+0xec>
    2632:	80 e0       	ldi	r24, 0x00	; 0
				buffer_put_item(spi->_tx_buf, buf[i]);
			}
		}

		// restore interrupt state
		SREG = c_sreg;
    2634:	ef be       	out	0x3f, r14	; 63
	}

	return result;
    2636:	01 c0       	rjmp	.+2      	; 0x263a <spi_send_string+0xf2>
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
	if (spi == 0) {
		return SPI_ILLEGAL_INSTANCE;
    2638:	83 e0       	ldi	r24, 0x03	; 3
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    263a:	df 91       	pop	r29
    263c:	cf 91       	pop	r28
    263e:	1f 91       	pop	r17
    2640:	0f 91       	pop	r16
    2642:	ff 90       	pop	r15
    2644:	ef 90       	pop	r14
    2646:	df 90       	pop	r13
    2648:	08 95       	ret

0000264a <__vector_24>:

/* ======================================================================================================================= */
/**
@todo Documentation
*/
ISR(SPI_STC_vect) {
    264a:	1f 92       	push	r1
    264c:	0f 92       	push	r0
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	0f 92       	push	r0
    2652:	11 24       	eor	r1, r1
    2654:	0b b6       	in	r0, 0x3b	; 59
    2656:	0f 92       	push	r0
    2658:	2f 93       	push	r18
    265a:	3f 93       	push	r19
    265c:	4f 93       	push	r20
    265e:	5f 93       	push	r21
    2660:	6f 93       	push	r22
    2662:	7f 93       	push	r23
    2664:	8f 93       	push	r24
    2666:	9f 93       	push	r25
    2668:	af 93       	push	r26
    266a:	bf 93       	push	r27
    266c:	ef 93       	push	r30
    266e:	ff 93       	push	r31
    2670:	cf 93       	push	r28
    2672:	df 93       	push	r29
    2674:	1f 92       	push	r1
    2676:	cd b7       	in	r28, 0x3d	; 61
    2678:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	#if SPI_USE_BUFFER == 1
	// store received byte if receive buffer available

	if (_this->_rx_buf != 0){
    267a:	e0 91 65 0d 	lds	r30, 0x0D65
    267e:	f0 91 66 0d 	lds	r31, 0x0D66
    2682:	80 85       	ldd	r24, Z+8	; 0x08
    2684:	91 85       	ldd	r25, Z+9	; 0x09
    2686:	00 97       	sbiw	r24, 0x00	; 0
    2688:	19 f0       	breq	.+6      	; 0x2690 <__vector_24+0x46>
		buffer_put_item(_this->_rx_buf, SPDR);
    268a:	6e b5       	in	r22, 0x2e	; 46
    268c:	0e 94 21 04 	call	0x842	; 0x842 <buffer_put_item>
	}
	// more bytes to send?
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
    2690:	e0 91 65 0d 	lds	r30, 0x0D65
    2694:	f0 91 66 0d 	lds	r31, 0x0D66
    2698:	be 01       	movw	r22, r28
    269a:	6f 5f       	subi	r22, 0xFF	; 255
    269c:	7f 4f       	sbci	r23, 0xFF	; 255
    269e:	86 81       	ldd	r24, Z+6	; 0x06
    26a0:	97 81       	ldd	r25, Z+7	; 0x07
    26a2:	0e 94 09 04 	call	0x812	; 0x812 <buffer_get_item>
    26a6:	81 11       	cpse	r24, r1
    26a8:	03 c0       	rjmp	.+6      	; 0x26b0 <__vector_24+0x66>
		_spi_send_byte(item);
    26aa:	89 81       	ldd	r24, Y+1	; 0x01
// Indexed by SPI_CLOCK_DIVIDER_xx defines
static const uint8_t _prescaler_mask [] = {0b00,0b01,0b10,0b11,0b00,0b01,0b10};

// Send a byte to the SPI-bus
static inline void _spi_send_byte(uint8_t byte) {
	SPDR = byte;
    26ac:	8e bd       	out	0x2e, r24	; 46
    26ae:	29 c0       	rjmp	.+82     	; 0x2702 <__vector_24+0xb8>
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
		_spi_send_byte(item);
		} else {
		// No
		// Disable SPI interrupt
		SPCR &= ~_BV(SPIE);
    26b0:	8c b5       	in	r24, 0x2c	; 44
    26b2:	8f 77       	andi	r24, 0x7F	; 127
    26b4:	8c bd       	out	0x2c, r24	; 44
		_spi_active = 0;
    26b6:	10 92 67 0d 	sts	0x0D67, r1
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    26ba:	e0 91 65 0d 	lds	r30, 0x0D65
    26be:	f0 91 66 0d 	lds	r31, 0x0D66
    26c2:	83 81       	ldd	r24, Z+3	; 0x03
    26c4:	81 30       	cpi	r24, 0x01	; 1
    26c6:	79 f4       	brne	.+30     	; 0x26e6 <__vector_24+0x9c>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    26c8:	a0 81       	ld	r26, Z
    26ca:	b1 81       	ldd	r27, Z+1	; 0x01
    26cc:	2c 91       	ld	r18, X
    26ce:	81 e0       	ldi	r24, 0x01	; 1
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	02 80       	ldd	r0, Z+2	; 0x02
    26d4:	02 c0       	rjmp	.+4      	; 0x26da <__vector_24+0x90>
    26d6:	88 0f       	add	r24, r24
    26d8:	99 1f       	adc	r25, r25
    26da:	0a 94       	dec	r0
    26dc:	e2 f7       	brpl	.-8      	; 0x26d6 <__vector_24+0x8c>
    26de:	80 95       	com	r24
    26e0:	82 23       	and	r24, r18
    26e2:	8c 93       	st	X, r24
    26e4:	0e c0       	rjmp	.+28     	; 0x2702 <__vector_24+0xb8>
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);

			} else {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    26e6:	a0 81       	ld	r26, Z
    26e8:	b1 81       	ldd	r27, Z+1	; 0x01
    26ea:	4c 91       	ld	r20, X
    26ec:	21 e0       	ldi	r18, 0x01	; 1
    26ee:	30 e0       	ldi	r19, 0x00	; 0
    26f0:	c9 01       	movw	r24, r18
    26f2:	02 80       	ldd	r0, Z+2	; 0x02
    26f4:	02 c0       	rjmp	.+4      	; 0x26fa <__vector_24+0xb0>
    26f6:	88 0f       	add	r24, r24
    26f8:	99 1f       	adc	r25, r25
    26fa:	0a 94       	dec	r0
    26fc:	e2 f7       	brpl	.-8      	; 0x26f6 <__vector_24+0xac>
    26fe:	84 2b       	or	r24, r20
    2700:	8c 93       	st	X, r24
	_spi_active = 0;
	_set_cs(CS_INACTIVE);
	#endif

	// If handler defined - call it with instance and received byte.
	if (_this->_call_back)
    2702:	80 91 65 0d 	lds	r24, 0x0D65
    2706:	90 91 66 0d 	lds	r25, 0x0D66
    270a:	dc 01       	movw	r26, r24
    270c:	1a 96       	adiw	r26, 0x0a	; 10
    270e:	ed 91       	ld	r30, X+
    2710:	fc 91       	ld	r31, X
    2712:	1b 97       	sbiw	r26, 0x0b	; 11
    2714:	30 97       	sbiw	r30, 0x00	; 0
    2716:	11 f0       	breq	.+4      	; 0x271c <__vector_24+0xd2>
	{
		_this->_call_back(_this, item);
    2718:	69 81       	ldd	r22, Y+1	; 0x01
    271a:	19 95       	eicall
	}
    271c:	0f 90       	pop	r0
    271e:	df 91       	pop	r29
    2720:	cf 91       	pop	r28
    2722:	ff 91       	pop	r31
    2724:	ef 91       	pop	r30
    2726:	bf 91       	pop	r27
    2728:	af 91       	pop	r26
    272a:	9f 91       	pop	r25
    272c:	8f 91       	pop	r24
    272e:	7f 91       	pop	r23
    2730:	6f 91       	pop	r22
    2732:	5f 91       	pop	r21
    2734:	4f 91       	pop	r20
    2736:	3f 91       	pop	r19
    2738:	2f 91       	pop	r18
    273a:	0f 90       	pop	r0
    273c:	0b be       	out	0x3b, r0	; 59
    273e:	0f 90       	pop	r0
    2740:	0f be       	out	0x3f, r0	; 63
    2742:	0f 90       	pop	r0
    2744:	1f 90       	pop	r1
    2746:	18 95       	reti

00002748 <__udivmodsi4>:
    2748:	a1 e2       	ldi	r26, 0x21	; 33
    274a:	1a 2e       	mov	r1, r26
    274c:	aa 1b       	sub	r26, r26
    274e:	bb 1b       	sub	r27, r27
    2750:	fd 01       	movw	r30, r26
    2752:	0d c0       	rjmp	.+26     	; 0x276e <__udivmodsi4_ep>

00002754 <__udivmodsi4_loop>:
    2754:	aa 1f       	adc	r26, r26
    2756:	bb 1f       	adc	r27, r27
    2758:	ee 1f       	adc	r30, r30
    275a:	ff 1f       	adc	r31, r31
    275c:	a2 17       	cp	r26, r18
    275e:	b3 07       	cpc	r27, r19
    2760:	e4 07       	cpc	r30, r20
    2762:	f5 07       	cpc	r31, r21
    2764:	20 f0       	brcs	.+8      	; 0x276e <__udivmodsi4_ep>
    2766:	a2 1b       	sub	r26, r18
    2768:	b3 0b       	sbc	r27, r19
    276a:	e4 0b       	sbc	r30, r20
    276c:	f5 0b       	sbc	r31, r21

0000276e <__udivmodsi4_ep>:
    276e:	66 1f       	adc	r22, r22
    2770:	77 1f       	adc	r23, r23
    2772:	88 1f       	adc	r24, r24
    2774:	99 1f       	adc	r25, r25
    2776:	1a 94       	dec	r1
    2778:	69 f7       	brne	.-38     	; 0x2754 <__udivmodsi4_loop>
    277a:	60 95       	com	r22
    277c:	70 95       	com	r23
    277e:	80 95       	com	r24
    2780:	90 95       	com	r25
    2782:	9b 01       	movw	r18, r22
    2784:	ac 01       	movw	r20, r24
    2786:	bd 01       	movw	r22, r26
    2788:	cf 01       	movw	r24, r30
    278a:	08 95       	ret

0000278c <__divmodsi4>:
    278c:	05 2e       	mov	r0, r21
    278e:	97 fb       	bst	r25, 7
    2790:	16 f4       	brtc	.+4      	; 0x2796 <__divmodsi4+0xa>
    2792:	00 94       	com	r0
    2794:	0f d0       	rcall	.+30     	; 0x27b4 <__negsi2>
    2796:	57 fd       	sbrc	r21, 7
    2798:	05 d0       	rcall	.+10     	; 0x27a4 <__divmodsi4_neg2>
    279a:	d6 df       	rcall	.-84     	; 0x2748 <__udivmodsi4>
    279c:	07 fc       	sbrc	r0, 7
    279e:	02 d0       	rcall	.+4      	; 0x27a4 <__divmodsi4_neg2>
    27a0:	46 f4       	brtc	.+16     	; 0x27b2 <__divmodsi4_exit>
    27a2:	08 c0       	rjmp	.+16     	; 0x27b4 <__negsi2>

000027a4 <__divmodsi4_neg2>:
    27a4:	50 95       	com	r21
    27a6:	40 95       	com	r20
    27a8:	30 95       	com	r19
    27aa:	21 95       	neg	r18
    27ac:	3f 4f       	sbci	r19, 0xFF	; 255
    27ae:	4f 4f       	sbci	r20, 0xFF	; 255
    27b0:	5f 4f       	sbci	r21, 0xFF	; 255

000027b2 <__divmodsi4_exit>:
    27b2:	08 95       	ret

000027b4 <__negsi2>:
    27b4:	90 95       	com	r25
    27b6:	80 95       	com	r24
    27b8:	70 95       	com	r23
    27ba:	61 95       	neg	r22
    27bc:	7f 4f       	sbci	r23, 0xFF	; 255
    27be:	8f 4f       	sbci	r24, 0xFF	; 255
    27c0:	9f 4f       	sbci	r25, 0xFF	; 255
    27c2:	08 95       	ret

000027c4 <__tablejump2__>:
    27c4:	ee 0f       	add	r30, r30
    27c6:	ff 1f       	adc	r31, r31

000027c8 <__tablejump__>:
    27c8:	05 90       	lpm	r0, Z+
    27ca:	f4 91       	lpm	r31, Z
    27cc:	e0 2d       	mov	r30, r0
    27ce:	19 94       	eijmp

000027d0 <__umulhisi3>:
    27d0:	a2 9f       	mul	r26, r18
    27d2:	b0 01       	movw	r22, r0
    27d4:	b3 9f       	mul	r27, r19
    27d6:	c0 01       	movw	r24, r0
    27d8:	a3 9f       	mul	r26, r19
    27da:	70 0d       	add	r23, r0
    27dc:	81 1d       	adc	r24, r1
    27de:	11 24       	eor	r1, r1
    27e0:	91 1d       	adc	r25, r1
    27e2:	b2 9f       	mul	r27, r18
    27e4:	70 0d       	add	r23, r0
    27e6:	81 1d       	adc	r24, r1
    27e8:	11 24       	eor	r1, r1
    27ea:	91 1d       	adc	r25, r1
    27ec:	08 95       	ret

000027ee <malloc>:
    27ee:	cf 93       	push	r28
    27f0:	df 93       	push	r29
    27f2:	82 30       	cpi	r24, 0x02	; 2
    27f4:	91 05       	cpc	r25, r1
    27f6:	10 f4       	brcc	.+4      	; 0x27fc <malloc+0xe>
    27f8:	82 e0       	ldi	r24, 0x02	; 2
    27fa:	90 e0       	ldi	r25, 0x00	; 0
    27fc:	e0 91 6a 0d 	lds	r30, 0x0D6A
    2800:	f0 91 6b 0d 	lds	r31, 0x0D6B
    2804:	20 e0       	ldi	r18, 0x00	; 0
    2806:	30 e0       	ldi	r19, 0x00	; 0
    2808:	a0 e0       	ldi	r26, 0x00	; 0
    280a:	b0 e0       	ldi	r27, 0x00	; 0
    280c:	30 97       	sbiw	r30, 0x00	; 0
    280e:	39 f1       	breq	.+78     	; 0x285e <malloc+0x70>
    2810:	40 81       	ld	r20, Z
    2812:	51 81       	ldd	r21, Z+1	; 0x01
    2814:	48 17       	cp	r20, r24
    2816:	59 07       	cpc	r21, r25
    2818:	b8 f0       	brcs	.+46     	; 0x2848 <malloc+0x5a>
    281a:	48 17       	cp	r20, r24
    281c:	59 07       	cpc	r21, r25
    281e:	71 f4       	brne	.+28     	; 0x283c <malloc+0x4e>
    2820:	82 81       	ldd	r24, Z+2	; 0x02
    2822:	93 81       	ldd	r25, Z+3	; 0x03
    2824:	10 97       	sbiw	r26, 0x00	; 0
    2826:	29 f0       	breq	.+10     	; 0x2832 <malloc+0x44>
    2828:	13 96       	adiw	r26, 0x03	; 3
    282a:	9c 93       	st	X, r25
    282c:	8e 93       	st	-X, r24
    282e:	12 97       	sbiw	r26, 0x02	; 2
    2830:	2c c0       	rjmp	.+88     	; 0x288a <malloc+0x9c>
    2832:	90 93 6b 0d 	sts	0x0D6B, r25
    2836:	80 93 6a 0d 	sts	0x0D6A, r24
    283a:	27 c0       	rjmp	.+78     	; 0x288a <malloc+0x9c>
    283c:	21 15       	cp	r18, r1
    283e:	31 05       	cpc	r19, r1
    2840:	31 f0       	breq	.+12     	; 0x284e <malloc+0x60>
    2842:	42 17       	cp	r20, r18
    2844:	53 07       	cpc	r21, r19
    2846:	18 f0       	brcs	.+6      	; 0x284e <malloc+0x60>
    2848:	a9 01       	movw	r20, r18
    284a:	db 01       	movw	r26, r22
    284c:	01 c0       	rjmp	.+2      	; 0x2850 <malloc+0x62>
    284e:	ef 01       	movw	r28, r30
    2850:	9a 01       	movw	r18, r20
    2852:	bd 01       	movw	r22, r26
    2854:	df 01       	movw	r26, r30
    2856:	02 80       	ldd	r0, Z+2	; 0x02
    2858:	f3 81       	ldd	r31, Z+3	; 0x03
    285a:	e0 2d       	mov	r30, r0
    285c:	d7 cf       	rjmp	.-82     	; 0x280c <malloc+0x1e>
    285e:	21 15       	cp	r18, r1
    2860:	31 05       	cpc	r19, r1
    2862:	f9 f0       	breq	.+62     	; 0x28a2 <malloc+0xb4>
    2864:	28 1b       	sub	r18, r24
    2866:	39 0b       	sbc	r19, r25
    2868:	24 30       	cpi	r18, 0x04	; 4
    286a:	31 05       	cpc	r19, r1
    286c:	80 f4       	brcc	.+32     	; 0x288e <malloc+0xa0>
    286e:	8a 81       	ldd	r24, Y+2	; 0x02
    2870:	9b 81       	ldd	r25, Y+3	; 0x03
    2872:	61 15       	cp	r22, r1
    2874:	71 05       	cpc	r23, r1
    2876:	21 f0       	breq	.+8      	; 0x2880 <malloc+0x92>
    2878:	fb 01       	movw	r30, r22
    287a:	93 83       	std	Z+3, r25	; 0x03
    287c:	82 83       	std	Z+2, r24	; 0x02
    287e:	04 c0       	rjmp	.+8      	; 0x2888 <malloc+0x9a>
    2880:	90 93 6b 0d 	sts	0x0D6B, r25
    2884:	80 93 6a 0d 	sts	0x0D6A, r24
    2888:	fe 01       	movw	r30, r28
    288a:	32 96       	adiw	r30, 0x02	; 2
    288c:	44 c0       	rjmp	.+136    	; 0x2916 <malloc+0x128>
    288e:	fe 01       	movw	r30, r28
    2890:	e2 0f       	add	r30, r18
    2892:	f3 1f       	adc	r31, r19
    2894:	81 93       	st	Z+, r24
    2896:	91 93       	st	Z+, r25
    2898:	22 50       	subi	r18, 0x02	; 2
    289a:	31 09       	sbc	r19, r1
    289c:	39 83       	std	Y+1, r19	; 0x01
    289e:	28 83       	st	Y, r18
    28a0:	3a c0       	rjmp	.+116    	; 0x2916 <malloc+0x128>
    28a2:	20 91 68 0d 	lds	r18, 0x0D68
    28a6:	30 91 69 0d 	lds	r19, 0x0D69
    28aa:	23 2b       	or	r18, r19
    28ac:	41 f4       	brne	.+16     	; 0x28be <malloc+0xd0>
    28ae:	20 91 02 02 	lds	r18, 0x0202
    28b2:	30 91 03 02 	lds	r19, 0x0203
    28b6:	30 93 69 0d 	sts	0x0D69, r19
    28ba:	20 93 68 0d 	sts	0x0D68, r18
    28be:	20 91 00 02 	lds	r18, 0x0200
    28c2:	30 91 01 02 	lds	r19, 0x0201
    28c6:	21 15       	cp	r18, r1
    28c8:	31 05       	cpc	r19, r1
    28ca:	41 f4       	brne	.+16     	; 0x28dc <malloc+0xee>
    28cc:	2d b7       	in	r18, 0x3d	; 61
    28ce:	3e b7       	in	r19, 0x3e	; 62
    28d0:	40 91 04 02 	lds	r20, 0x0204
    28d4:	50 91 05 02 	lds	r21, 0x0205
    28d8:	24 1b       	sub	r18, r20
    28da:	35 0b       	sbc	r19, r21
    28dc:	e0 91 68 0d 	lds	r30, 0x0D68
    28e0:	f0 91 69 0d 	lds	r31, 0x0D69
    28e4:	e2 17       	cp	r30, r18
    28e6:	f3 07       	cpc	r31, r19
    28e8:	a0 f4       	brcc	.+40     	; 0x2912 <malloc+0x124>
    28ea:	2e 1b       	sub	r18, r30
    28ec:	3f 0b       	sbc	r19, r31
    28ee:	28 17       	cp	r18, r24
    28f0:	39 07       	cpc	r19, r25
    28f2:	78 f0       	brcs	.+30     	; 0x2912 <malloc+0x124>
    28f4:	ac 01       	movw	r20, r24
    28f6:	4e 5f       	subi	r20, 0xFE	; 254
    28f8:	5f 4f       	sbci	r21, 0xFF	; 255
    28fa:	24 17       	cp	r18, r20
    28fc:	35 07       	cpc	r19, r21
    28fe:	48 f0       	brcs	.+18     	; 0x2912 <malloc+0x124>
    2900:	4e 0f       	add	r20, r30
    2902:	5f 1f       	adc	r21, r31
    2904:	50 93 69 0d 	sts	0x0D69, r21
    2908:	40 93 68 0d 	sts	0x0D68, r20
    290c:	81 93       	st	Z+, r24
    290e:	91 93       	st	Z+, r25
    2910:	02 c0       	rjmp	.+4      	; 0x2916 <malloc+0x128>
    2912:	e0 e0       	ldi	r30, 0x00	; 0
    2914:	f0 e0       	ldi	r31, 0x00	; 0
    2916:	cf 01       	movw	r24, r30
    2918:	df 91       	pop	r29
    291a:	cf 91       	pop	r28
    291c:	08 95       	ret

0000291e <free>:
    291e:	cf 93       	push	r28
    2920:	df 93       	push	r29
    2922:	00 97       	sbiw	r24, 0x00	; 0
    2924:	09 f4       	brne	.+2      	; 0x2928 <free+0xa>
    2926:	87 c0       	rjmp	.+270    	; 0x2a36 <free+0x118>
    2928:	fc 01       	movw	r30, r24
    292a:	32 97       	sbiw	r30, 0x02	; 2
    292c:	13 82       	std	Z+3, r1	; 0x03
    292e:	12 82       	std	Z+2, r1	; 0x02
    2930:	c0 91 6a 0d 	lds	r28, 0x0D6A
    2934:	d0 91 6b 0d 	lds	r29, 0x0D6B
    2938:	20 97       	sbiw	r28, 0x00	; 0
    293a:	81 f4       	brne	.+32     	; 0x295c <free+0x3e>
    293c:	20 81       	ld	r18, Z
    293e:	31 81       	ldd	r19, Z+1	; 0x01
    2940:	28 0f       	add	r18, r24
    2942:	39 1f       	adc	r19, r25
    2944:	80 91 68 0d 	lds	r24, 0x0D68
    2948:	90 91 69 0d 	lds	r25, 0x0D69
    294c:	82 17       	cp	r24, r18
    294e:	93 07       	cpc	r25, r19
    2950:	79 f5       	brne	.+94     	; 0x29b0 <free+0x92>
    2952:	f0 93 69 0d 	sts	0x0D69, r31
    2956:	e0 93 68 0d 	sts	0x0D68, r30
    295a:	6d c0       	rjmp	.+218    	; 0x2a36 <free+0x118>
    295c:	de 01       	movw	r26, r28
    295e:	20 e0       	ldi	r18, 0x00	; 0
    2960:	30 e0       	ldi	r19, 0x00	; 0
    2962:	ae 17       	cp	r26, r30
    2964:	bf 07       	cpc	r27, r31
    2966:	50 f4       	brcc	.+20     	; 0x297c <free+0x5e>
    2968:	12 96       	adiw	r26, 0x02	; 2
    296a:	4d 91       	ld	r20, X+
    296c:	5c 91       	ld	r21, X
    296e:	13 97       	sbiw	r26, 0x03	; 3
    2970:	9d 01       	movw	r18, r26
    2972:	41 15       	cp	r20, r1
    2974:	51 05       	cpc	r21, r1
    2976:	09 f1       	breq	.+66     	; 0x29ba <free+0x9c>
    2978:	da 01       	movw	r26, r20
    297a:	f3 cf       	rjmp	.-26     	; 0x2962 <free+0x44>
    297c:	b3 83       	std	Z+3, r27	; 0x03
    297e:	a2 83       	std	Z+2, r26	; 0x02
    2980:	40 81       	ld	r20, Z
    2982:	51 81       	ldd	r21, Z+1	; 0x01
    2984:	84 0f       	add	r24, r20
    2986:	95 1f       	adc	r25, r21
    2988:	8a 17       	cp	r24, r26
    298a:	9b 07       	cpc	r25, r27
    298c:	71 f4       	brne	.+28     	; 0x29aa <free+0x8c>
    298e:	8d 91       	ld	r24, X+
    2990:	9c 91       	ld	r25, X
    2992:	11 97       	sbiw	r26, 0x01	; 1
    2994:	84 0f       	add	r24, r20
    2996:	95 1f       	adc	r25, r21
    2998:	02 96       	adiw	r24, 0x02	; 2
    299a:	91 83       	std	Z+1, r25	; 0x01
    299c:	80 83       	st	Z, r24
    299e:	12 96       	adiw	r26, 0x02	; 2
    29a0:	8d 91       	ld	r24, X+
    29a2:	9c 91       	ld	r25, X
    29a4:	13 97       	sbiw	r26, 0x03	; 3
    29a6:	93 83       	std	Z+3, r25	; 0x03
    29a8:	82 83       	std	Z+2, r24	; 0x02
    29aa:	21 15       	cp	r18, r1
    29ac:	31 05       	cpc	r19, r1
    29ae:	29 f4       	brne	.+10     	; 0x29ba <free+0x9c>
    29b0:	f0 93 6b 0d 	sts	0x0D6B, r31
    29b4:	e0 93 6a 0d 	sts	0x0D6A, r30
    29b8:	3e c0       	rjmp	.+124    	; 0x2a36 <free+0x118>
    29ba:	d9 01       	movw	r26, r18
    29bc:	13 96       	adiw	r26, 0x03	; 3
    29be:	fc 93       	st	X, r31
    29c0:	ee 93       	st	-X, r30
    29c2:	12 97       	sbiw	r26, 0x02	; 2
    29c4:	4d 91       	ld	r20, X+
    29c6:	5d 91       	ld	r21, X+
    29c8:	a4 0f       	add	r26, r20
    29ca:	b5 1f       	adc	r27, r21
    29cc:	ea 17       	cp	r30, r26
    29ce:	fb 07       	cpc	r31, r27
    29d0:	79 f4       	brne	.+30     	; 0x29f0 <free+0xd2>
    29d2:	80 81       	ld	r24, Z
    29d4:	91 81       	ldd	r25, Z+1	; 0x01
    29d6:	84 0f       	add	r24, r20
    29d8:	95 1f       	adc	r25, r21
    29da:	02 96       	adiw	r24, 0x02	; 2
    29dc:	d9 01       	movw	r26, r18
    29de:	11 96       	adiw	r26, 0x01	; 1
    29e0:	9c 93       	st	X, r25
    29e2:	8e 93       	st	-X, r24
    29e4:	82 81       	ldd	r24, Z+2	; 0x02
    29e6:	93 81       	ldd	r25, Z+3	; 0x03
    29e8:	13 96       	adiw	r26, 0x03	; 3
    29ea:	9c 93       	st	X, r25
    29ec:	8e 93       	st	-X, r24
    29ee:	12 97       	sbiw	r26, 0x02	; 2
    29f0:	e0 e0       	ldi	r30, 0x00	; 0
    29f2:	f0 e0       	ldi	r31, 0x00	; 0
    29f4:	8a 81       	ldd	r24, Y+2	; 0x02
    29f6:	9b 81       	ldd	r25, Y+3	; 0x03
    29f8:	00 97       	sbiw	r24, 0x00	; 0
    29fa:	19 f0       	breq	.+6      	; 0x2a02 <free+0xe4>
    29fc:	fe 01       	movw	r30, r28
    29fe:	ec 01       	movw	r28, r24
    2a00:	f9 cf       	rjmp	.-14     	; 0x29f4 <free+0xd6>
    2a02:	ce 01       	movw	r24, r28
    2a04:	02 96       	adiw	r24, 0x02	; 2
    2a06:	28 81       	ld	r18, Y
    2a08:	39 81       	ldd	r19, Y+1	; 0x01
    2a0a:	82 0f       	add	r24, r18
    2a0c:	93 1f       	adc	r25, r19
    2a0e:	20 91 68 0d 	lds	r18, 0x0D68
    2a12:	30 91 69 0d 	lds	r19, 0x0D69
    2a16:	28 17       	cp	r18, r24
    2a18:	39 07       	cpc	r19, r25
    2a1a:	69 f4       	brne	.+26     	; 0x2a36 <free+0x118>
    2a1c:	30 97       	sbiw	r30, 0x00	; 0
    2a1e:	29 f4       	brne	.+10     	; 0x2a2a <free+0x10c>
    2a20:	10 92 6b 0d 	sts	0x0D6B, r1
    2a24:	10 92 6a 0d 	sts	0x0D6A, r1
    2a28:	02 c0       	rjmp	.+4      	; 0x2a2e <free+0x110>
    2a2a:	13 82       	std	Z+3, r1	; 0x03
    2a2c:	12 82       	std	Z+2, r1	; 0x02
    2a2e:	d0 93 69 0d 	sts	0x0D69, r29
    2a32:	c0 93 68 0d 	sts	0x0D68, r28
    2a36:	df 91       	pop	r29
    2a38:	cf 91       	pop	r28
    2a3a:	08 95       	ret

00002a3c <memcpy>:
    2a3c:	fb 01       	movw	r30, r22
    2a3e:	dc 01       	movw	r26, r24
    2a40:	02 c0       	rjmp	.+4      	; 0x2a46 <memcpy+0xa>
    2a42:	01 90       	ld	r0, Z+
    2a44:	0d 92       	st	X+, r0
    2a46:	41 50       	subi	r20, 0x01	; 1
    2a48:	50 40       	sbci	r21, 0x00	; 0
    2a4a:	d8 f7       	brcc	.-10     	; 0x2a42 <memcpy+0x6>
    2a4c:	08 95       	ret

00002a4e <sprintf>:
    2a4e:	0f 93       	push	r16
    2a50:	1f 93       	push	r17
    2a52:	cf 93       	push	r28
    2a54:	df 93       	push	r29
    2a56:	cd b7       	in	r28, 0x3d	; 61
    2a58:	de b7       	in	r29, 0x3e	; 62
    2a5a:	2e 97       	sbiw	r28, 0x0e	; 14
    2a5c:	0f b6       	in	r0, 0x3f	; 63
    2a5e:	f8 94       	cli
    2a60:	de bf       	out	0x3e, r29	; 62
    2a62:	0f be       	out	0x3f, r0	; 63
    2a64:	cd bf       	out	0x3d, r28	; 61
    2a66:	0e 89       	ldd	r16, Y+22	; 0x16
    2a68:	1f 89       	ldd	r17, Y+23	; 0x17
    2a6a:	86 e0       	ldi	r24, 0x06	; 6
    2a6c:	8c 83       	std	Y+4, r24	; 0x04
    2a6e:	1a 83       	std	Y+2, r17	; 0x02
    2a70:	09 83       	std	Y+1, r16	; 0x01
    2a72:	8f ef       	ldi	r24, 0xFF	; 255
    2a74:	9f e7       	ldi	r25, 0x7F	; 127
    2a76:	9e 83       	std	Y+6, r25	; 0x06
    2a78:	8d 83       	std	Y+5, r24	; 0x05
    2a7a:	ae 01       	movw	r20, r28
    2a7c:	46 5e       	subi	r20, 0xE6	; 230
    2a7e:	5f 4f       	sbci	r21, 0xFF	; 255
    2a80:	68 8d       	ldd	r22, Y+24	; 0x18
    2a82:	79 8d       	ldd	r23, Y+25	; 0x19
    2a84:	ce 01       	movw	r24, r28
    2a86:	01 96       	adiw	r24, 0x01	; 1
    2a88:	10 d0       	rcall	.+32     	; 0x2aaa <vfprintf>
    2a8a:	ef 81       	ldd	r30, Y+7	; 0x07
    2a8c:	f8 85       	ldd	r31, Y+8	; 0x08
    2a8e:	e0 0f       	add	r30, r16
    2a90:	f1 1f       	adc	r31, r17
    2a92:	10 82       	st	Z, r1
    2a94:	2e 96       	adiw	r28, 0x0e	; 14
    2a96:	0f b6       	in	r0, 0x3f	; 63
    2a98:	f8 94       	cli
    2a9a:	de bf       	out	0x3e, r29	; 62
    2a9c:	0f be       	out	0x3f, r0	; 63
    2a9e:	cd bf       	out	0x3d, r28	; 61
    2aa0:	df 91       	pop	r29
    2aa2:	cf 91       	pop	r28
    2aa4:	1f 91       	pop	r17
    2aa6:	0f 91       	pop	r16
    2aa8:	08 95       	ret

00002aaa <vfprintf>:
    2aaa:	2f 92       	push	r2
    2aac:	3f 92       	push	r3
    2aae:	4f 92       	push	r4
    2ab0:	5f 92       	push	r5
    2ab2:	6f 92       	push	r6
    2ab4:	7f 92       	push	r7
    2ab6:	8f 92       	push	r8
    2ab8:	9f 92       	push	r9
    2aba:	af 92       	push	r10
    2abc:	bf 92       	push	r11
    2abe:	cf 92       	push	r12
    2ac0:	df 92       	push	r13
    2ac2:	ef 92       	push	r14
    2ac4:	ff 92       	push	r15
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	cd b7       	in	r28, 0x3d	; 61
    2ad0:	de b7       	in	r29, 0x3e	; 62
    2ad2:	2c 97       	sbiw	r28, 0x0c	; 12
    2ad4:	0f b6       	in	r0, 0x3f	; 63
    2ad6:	f8 94       	cli
    2ad8:	de bf       	out	0x3e, r29	; 62
    2ada:	0f be       	out	0x3f, r0	; 63
    2adc:	cd bf       	out	0x3d, r28	; 61
    2ade:	7c 01       	movw	r14, r24
    2ae0:	6b 01       	movw	r12, r22
    2ae2:	8a 01       	movw	r16, r20
    2ae4:	fc 01       	movw	r30, r24
    2ae6:	17 82       	std	Z+7, r1	; 0x07
    2ae8:	16 82       	std	Z+6, r1	; 0x06
    2aea:	83 81       	ldd	r24, Z+3	; 0x03
    2aec:	81 ff       	sbrs	r24, 1
    2aee:	b0 c1       	rjmp	.+864    	; 0x2e50 <vfprintf+0x3a6>
    2af0:	ce 01       	movw	r24, r28
    2af2:	01 96       	adiw	r24, 0x01	; 1
    2af4:	4c 01       	movw	r8, r24
    2af6:	f7 01       	movw	r30, r14
    2af8:	93 81       	ldd	r25, Z+3	; 0x03
    2afa:	f6 01       	movw	r30, r12
    2afc:	93 fd       	sbrc	r25, 3
    2afe:	85 91       	lpm	r24, Z+
    2b00:	93 ff       	sbrs	r25, 3
    2b02:	81 91       	ld	r24, Z+
    2b04:	6f 01       	movw	r12, r30
    2b06:	88 23       	and	r24, r24
    2b08:	09 f4       	brne	.+2      	; 0x2b0c <vfprintf+0x62>
    2b0a:	9e c1       	rjmp	.+828    	; 0x2e48 <vfprintf+0x39e>
    2b0c:	85 32       	cpi	r24, 0x25	; 37
    2b0e:	39 f4       	brne	.+14     	; 0x2b1e <vfprintf+0x74>
    2b10:	93 fd       	sbrc	r25, 3
    2b12:	85 91       	lpm	r24, Z+
    2b14:	93 ff       	sbrs	r25, 3
    2b16:	81 91       	ld	r24, Z+
    2b18:	6f 01       	movw	r12, r30
    2b1a:	85 32       	cpi	r24, 0x25	; 37
    2b1c:	21 f4       	brne	.+8      	; 0x2b26 <vfprintf+0x7c>
    2b1e:	b7 01       	movw	r22, r14
    2b20:	90 e0       	ldi	r25, 0x00	; 0
    2b22:	c7 d1       	rcall	.+910    	; 0x2eb2 <fputc>
    2b24:	e8 cf       	rjmp	.-48     	; 0x2af6 <vfprintf+0x4c>
    2b26:	51 2c       	mov	r5, r1
    2b28:	31 2c       	mov	r3, r1
    2b2a:	20 e0       	ldi	r18, 0x00	; 0
    2b2c:	20 32       	cpi	r18, 0x20	; 32
    2b2e:	a0 f4       	brcc	.+40     	; 0x2b58 <vfprintf+0xae>
    2b30:	8b 32       	cpi	r24, 0x2B	; 43
    2b32:	69 f0       	breq	.+26     	; 0x2b4e <vfprintf+0xa4>
    2b34:	30 f4       	brcc	.+12     	; 0x2b42 <vfprintf+0x98>
    2b36:	80 32       	cpi	r24, 0x20	; 32
    2b38:	59 f0       	breq	.+22     	; 0x2b50 <vfprintf+0xa6>
    2b3a:	83 32       	cpi	r24, 0x23	; 35
    2b3c:	69 f4       	brne	.+26     	; 0x2b58 <vfprintf+0xae>
    2b3e:	20 61       	ori	r18, 0x10	; 16
    2b40:	2c c0       	rjmp	.+88     	; 0x2b9a <vfprintf+0xf0>
    2b42:	8d 32       	cpi	r24, 0x2D	; 45
    2b44:	39 f0       	breq	.+14     	; 0x2b54 <vfprintf+0xaa>
    2b46:	80 33       	cpi	r24, 0x30	; 48
    2b48:	39 f4       	brne	.+14     	; 0x2b58 <vfprintf+0xae>
    2b4a:	21 60       	ori	r18, 0x01	; 1
    2b4c:	26 c0       	rjmp	.+76     	; 0x2b9a <vfprintf+0xf0>
    2b4e:	22 60       	ori	r18, 0x02	; 2
    2b50:	24 60       	ori	r18, 0x04	; 4
    2b52:	23 c0       	rjmp	.+70     	; 0x2b9a <vfprintf+0xf0>
    2b54:	28 60       	ori	r18, 0x08	; 8
    2b56:	21 c0       	rjmp	.+66     	; 0x2b9a <vfprintf+0xf0>
    2b58:	27 fd       	sbrc	r18, 7
    2b5a:	27 c0       	rjmp	.+78     	; 0x2baa <vfprintf+0x100>
    2b5c:	30 ed       	ldi	r19, 0xD0	; 208
    2b5e:	38 0f       	add	r19, r24
    2b60:	3a 30       	cpi	r19, 0x0A	; 10
    2b62:	78 f4       	brcc	.+30     	; 0x2b82 <vfprintf+0xd8>
    2b64:	26 ff       	sbrs	r18, 6
    2b66:	06 c0       	rjmp	.+12     	; 0x2b74 <vfprintf+0xca>
    2b68:	fa e0       	ldi	r31, 0x0A	; 10
    2b6a:	5f 9e       	mul	r5, r31
    2b6c:	30 0d       	add	r19, r0
    2b6e:	11 24       	eor	r1, r1
    2b70:	53 2e       	mov	r5, r19
    2b72:	13 c0       	rjmp	.+38     	; 0x2b9a <vfprintf+0xf0>
    2b74:	8a e0       	ldi	r24, 0x0A	; 10
    2b76:	38 9e       	mul	r3, r24
    2b78:	30 0d       	add	r19, r0
    2b7a:	11 24       	eor	r1, r1
    2b7c:	33 2e       	mov	r3, r19
    2b7e:	20 62       	ori	r18, 0x20	; 32
    2b80:	0c c0       	rjmp	.+24     	; 0x2b9a <vfprintf+0xf0>
    2b82:	8e 32       	cpi	r24, 0x2E	; 46
    2b84:	21 f4       	brne	.+8      	; 0x2b8e <vfprintf+0xe4>
    2b86:	26 fd       	sbrc	r18, 6
    2b88:	5f c1       	rjmp	.+702    	; 0x2e48 <vfprintf+0x39e>
    2b8a:	20 64       	ori	r18, 0x40	; 64
    2b8c:	06 c0       	rjmp	.+12     	; 0x2b9a <vfprintf+0xf0>
    2b8e:	8c 36       	cpi	r24, 0x6C	; 108
    2b90:	11 f4       	brne	.+4      	; 0x2b96 <vfprintf+0xec>
    2b92:	20 68       	ori	r18, 0x80	; 128
    2b94:	02 c0       	rjmp	.+4      	; 0x2b9a <vfprintf+0xf0>
    2b96:	88 36       	cpi	r24, 0x68	; 104
    2b98:	41 f4       	brne	.+16     	; 0x2baa <vfprintf+0x100>
    2b9a:	f6 01       	movw	r30, r12
    2b9c:	93 fd       	sbrc	r25, 3
    2b9e:	85 91       	lpm	r24, Z+
    2ba0:	93 ff       	sbrs	r25, 3
    2ba2:	81 91       	ld	r24, Z+
    2ba4:	6f 01       	movw	r12, r30
    2ba6:	81 11       	cpse	r24, r1
    2ba8:	c1 cf       	rjmp	.-126    	; 0x2b2c <vfprintf+0x82>
    2baa:	98 2f       	mov	r25, r24
    2bac:	9f 7d       	andi	r25, 0xDF	; 223
    2bae:	95 54       	subi	r25, 0x45	; 69
    2bb0:	93 30       	cpi	r25, 0x03	; 3
    2bb2:	28 f4       	brcc	.+10     	; 0x2bbe <vfprintf+0x114>
    2bb4:	0c 5f       	subi	r16, 0xFC	; 252
    2bb6:	1f 4f       	sbci	r17, 0xFF	; 255
    2bb8:	ff e3       	ldi	r31, 0x3F	; 63
    2bba:	f9 83       	std	Y+1, r31	; 0x01
    2bbc:	0d c0       	rjmp	.+26     	; 0x2bd8 <vfprintf+0x12e>
    2bbe:	83 36       	cpi	r24, 0x63	; 99
    2bc0:	31 f0       	breq	.+12     	; 0x2bce <vfprintf+0x124>
    2bc2:	83 37       	cpi	r24, 0x73	; 115
    2bc4:	71 f0       	breq	.+28     	; 0x2be2 <vfprintf+0x138>
    2bc6:	83 35       	cpi	r24, 0x53	; 83
    2bc8:	09 f0       	breq	.+2      	; 0x2bcc <vfprintf+0x122>
    2bca:	57 c0       	rjmp	.+174    	; 0x2c7a <vfprintf+0x1d0>
    2bcc:	21 c0       	rjmp	.+66     	; 0x2c10 <vfprintf+0x166>
    2bce:	f8 01       	movw	r30, r16
    2bd0:	80 81       	ld	r24, Z
    2bd2:	89 83       	std	Y+1, r24	; 0x01
    2bd4:	0e 5f       	subi	r16, 0xFE	; 254
    2bd6:	1f 4f       	sbci	r17, 0xFF	; 255
    2bd8:	44 24       	eor	r4, r4
    2bda:	43 94       	inc	r4
    2bdc:	51 2c       	mov	r5, r1
    2bde:	54 01       	movw	r10, r8
    2be0:	14 c0       	rjmp	.+40     	; 0x2c0a <vfprintf+0x160>
    2be2:	38 01       	movw	r6, r16
    2be4:	f2 e0       	ldi	r31, 0x02	; 2
    2be6:	6f 0e       	add	r6, r31
    2be8:	71 1c       	adc	r7, r1
    2bea:	f8 01       	movw	r30, r16
    2bec:	a0 80       	ld	r10, Z
    2bee:	b1 80       	ldd	r11, Z+1	; 0x01
    2bf0:	26 ff       	sbrs	r18, 6
    2bf2:	03 c0       	rjmp	.+6      	; 0x2bfa <vfprintf+0x150>
    2bf4:	65 2d       	mov	r22, r5
    2bf6:	70 e0       	ldi	r23, 0x00	; 0
    2bf8:	02 c0       	rjmp	.+4      	; 0x2bfe <vfprintf+0x154>
    2bfa:	6f ef       	ldi	r22, 0xFF	; 255
    2bfc:	7f ef       	ldi	r23, 0xFF	; 255
    2bfe:	c5 01       	movw	r24, r10
    2c00:	2c 87       	std	Y+12, r18	; 0x0c
    2c02:	4c d1       	rcall	.+664    	; 0x2e9c <strnlen>
    2c04:	2c 01       	movw	r4, r24
    2c06:	83 01       	movw	r16, r6
    2c08:	2c 85       	ldd	r18, Y+12	; 0x0c
    2c0a:	2f 77       	andi	r18, 0x7F	; 127
    2c0c:	22 2e       	mov	r2, r18
    2c0e:	16 c0       	rjmp	.+44     	; 0x2c3c <vfprintf+0x192>
    2c10:	38 01       	movw	r6, r16
    2c12:	f2 e0       	ldi	r31, 0x02	; 2
    2c14:	6f 0e       	add	r6, r31
    2c16:	71 1c       	adc	r7, r1
    2c18:	f8 01       	movw	r30, r16
    2c1a:	a0 80       	ld	r10, Z
    2c1c:	b1 80       	ldd	r11, Z+1	; 0x01
    2c1e:	26 ff       	sbrs	r18, 6
    2c20:	03 c0       	rjmp	.+6      	; 0x2c28 <vfprintf+0x17e>
    2c22:	65 2d       	mov	r22, r5
    2c24:	70 e0       	ldi	r23, 0x00	; 0
    2c26:	02 c0       	rjmp	.+4      	; 0x2c2c <vfprintf+0x182>
    2c28:	6f ef       	ldi	r22, 0xFF	; 255
    2c2a:	7f ef       	ldi	r23, 0xFF	; 255
    2c2c:	c5 01       	movw	r24, r10
    2c2e:	2c 87       	std	Y+12, r18	; 0x0c
    2c30:	2a d1       	rcall	.+596    	; 0x2e86 <strnlen_P>
    2c32:	2c 01       	movw	r4, r24
    2c34:	2c 85       	ldd	r18, Y+12	; 0x0c
    2c36:	20 68       	ori	r18, 0x80	; 128
    2c38:	22 2e       	mov	r2, r18
    2c3a:	83 01       	movw	r16, r6
    2c3c:	23 fc       	sbrc	r2, 3
    2c3e:	19 c0       	rjmp	.+50     	; 0x2c72 <vfprintf+0x1c8>
    2c40:	83 2d       	mov	r24, r3
    2c42:	90 e0       	ldi	r25, 0x00	; 0
    2c44:	48 16       	cp	r4, r24
    2c46:	59 06       	cpc	r5, r25
    2c48:	a0 f4       	brcc	.+40     	; 0x2c72 <vfprintf+0x1c8>
    2c4a:	b7 01       	movw	r22, r14
    2c4c:	80 e2       	ldi	r24, 0x20	; 32
    2c4e:	90 e0       	ldi	r25, 0x00	; 0
    2c50:	30 d1       	rcall	.+608    	; 0x2eb2 <fputc>
    2c52:	3a 94       	dec	r3
    2c54:	f5 cf       	rjmp	.-22     	; 0x2c40 <vfprintf+0x196>
    2c56:	f5 01       	movw	r30, r10
    2c58:	27 fc       	sbrc	r2, 7
    2c5a:	85 91       	lpm	r24, Z+
    2c5c:	27 fe       	sbrs	r2, 7
    2c5e:	81 91       	ld	r24, Z+
    2c60:	5f 01       	movw	r10, r30
    2c62:	b7 01       	movw	r22, r14
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	25 d1       	rcall	.+586    	; 0x2eb2 <fputc>
    2c68:	31 10       	cpse	r3, r1
    2c6a:	3a 94       	dec	r3
    2c6c:	f1 e0       	ldi	r31, 0x01	; 1
    2c6e:	4f 1a       	sub	r4, r31
    2c70:	51 08       	sbc	r5, r1
    2c72:	41 14       	cp	r4, r1
    2c74:	51 04       	cpc	r5, r1
    2c76:	79 f7       	brne	.-34     	; 0x2c56 <vfprintf+0x1ac>
    2c78:	de c0       	rjmp	.+444    	; 0x2e36 <vfprintf+0x38c>
    2c7a:	84 36       	cpi	r24, 0x64	; 100
    2c7c:	11 f0       	breq	.+4      	; 0x2c82 <vfprintf+0x1d8>
    2c7e:	89 36       	cpi	r24, 0x69	; 105
    2c80:	31 f5       	brne	.+76     	; 0x2cce <vfprintf+0x224>
    2c82:	f8 01       	movw	r30, r16
    2c84:	27 ff       	sbrs	r18, 7
    2c86:	07 c0       	rjmp	.+14     	; 0x2c96 <vfprintf+0x1ec>
    2c88:	60 81       	ld	r22, Z
    2c8a:	71 81       	ldd	r23, Z+1	; 0x01
    2c8c:	82 81       	ldd	r24, Z+2	; 0x02
    2c8e:	93 81       	ldd	r25, Z+3	; 0x03
    2c90:	0c 5f       	subi	r16, 0xFC	; 252
    2c92:	1f 4f       	sbci	r17, 0xFF	; 255
    2c94:	08 c0       	rjmp	.+16     	; 0x2ca6 <vfprintf+0x1fc>
    2c96:	60 81       	ld	r22, Z
    2c98:	71 81       	ldd	r23, Z+1	; 0x01
    2c9a:	88 27       	eor	r24, r24
    2c9c:	77 fd       	sbrc	r23, 7
    2c9e:	80 95       	com	r24
    2ca0:	98 2f       	mov	r25, r24
    2ca2:	0e 5f       	subi	r16, 0xFE	; 254
    2ca4:	1f 4f       	sbci	r17, 0xFF	; 255
    2ca6:	2f 76       	andi	r18, 0x6F	; 111
    2ca8:	b2 2e       	mov	r11, r18
    2caa:	97 ff       	sbrs	r25, 7
    2cac:	09 c0       	rjmp	.+18     	; 0x2cc0 <vfprintf+0x216>
    2cae:	90 95       	com	r25
    2cb0:	80 95       	com	r24
    2cb2:	70 95       	com	r23
    2cb4:	61 95       	neg	r22
    2cb6:	7f 4f       	sbci	r23, 0xFF	; 255
    2cb8:	8f 4f       	sbci	r24, 0xFF	; 255
    2cba:	9f 4f       	sbci	r25, 0xFF	; 255
    2cbc:	20 68       	ori	r18, 0x80	; 128
    2cbe:	b2 2e       	mov	r11, r18
    2cc0:	2a e0       	ldi	r18, 0x0A	; 10
    2cc2:	30 e0       	ldi	r19, 0x00	; 0
    2cc4:	a4 01       	movw	r20, r8
    2cc6:	27 d1       	rcall	.+590    	; 0x2f16 <__ultoa_invert>
    2cc8:	a8 2e       	mov	r10, r24
    2cca:	a8 18       	sub	r10, r8
    2ccc:	43 c0       	rjmp	.+134    	; 0x2d54 <vfprintf+0x2aa>
    2cce:	85 37       	cpi	r24, 0x75	; 117
    2cd0:	29 f4       	brne	.+10     	; 0x2cdc <vfprintf+0x232>
    2cd2:	2f 7e       	andi	r18, 0xEF	; 239
    2cd4:	b2 2e       	mov	r11, r18
    2cd6:	2a e0       	ldi	r18, 0x0A	; 10
    2cd8:	30 e0       	ldi	r19, 0x00	; 0
    2cda:	25 c0       	rjmp	.+74     	; 0x2d26 <vfprintf+0x27c>
    2cdc:	f2 2f       	mov	r31, r18
    2cde:	f9 7f       	andi	r31, 0xF9	; 249
    2ce0:	bf 2e       	mov	r11, r31
    2ce2:	8f 36       	cpi	r24, 0x6F	; 111
    2ce4:	c1 f0       	breq	.+48     	; 0x2d16 <vfprintf+0x26c>
    2ce6:	18 f4       	brcc	.+6      	; 0x2cee <vfprintf+0x244>
    2ce8:	88 35       	cpi	r24, 0x58	; 88
    2cea:	79 f0       	breq	.+30     	; 0x2d0a <vfprintf+0x260>
    2cec:	ad c0       	rjmp	.+346    	; 0x2e48 <vfprintf+0x39e>
    2cee:	80 37       	cpi	r24, 0x70	; 112
    2cf0:	19 f0       	breq	.+6      	; 0x2cf8 <vfprintf+0x24e>
    2cf2:	88 37       	cpi	r24, 0x78	; 120
    2cf4:	21 f0       	breq	.+8      	; 0x2cfe <vfprintf+0x254>
    2cf6:	a8 c0       	rjmp	.+336    	; 0x2e48 <vfprintf+0x39e>
    2cf8:	2f 2f       	mov	r18, r31
    2cfa:	20 61       	ori	r18, 0x10	; 16
    2cfc:	b2 2e       	mov	r11, r18
    2cfe:	b4 fe       	sbrs	r11, 4
    2d00:	0d c0       	rjmp	.+26     	; 0x2d1c <vfprintf+0x272>
    2d02:	8b 2d       	mov	r24, r11
    2d04:	84 60       	ori	r24, 0x04	; 4
    2d06:	b8 2e       	mov	r11, r24
    2d08:	09 c0       	rjmp	.+18     	; 0x2d1c <vfprintf+0x272>
    2d0a:	24 ff       	sbrs	r18, 4
    2d0c:	0a c0       	rjmp	.+20     	; 0x2d22 <vfprintf+0x278>
    2d0e:	9f 2f       	mov	r25, r31
    2d10:	96 60       	ori	r25, 0x06	; 6
    2d12:	b9 2e       	mov	r11, r25
    2d14:	06 c0       	rjmp	.+12     	; 0x2d22 <vfprintf+0x278>
    2d16:	28 e0       	ldi	r18, 0x08	; 8
    2d18:	30 e0       	ldi	r19, 0x00	; 0
    2d1a:	05 c0       	rjmp	.+10     	; 0x2d26 <vfprintf+0x27c>
    2d1c:	20 e1       	ldi	r18, 0x10	; 16
    2d1e:	30 e0       	ldi	r19, 0x00	; 0
    2d20:	02 c0       	rjmp	.+4      	; 0x2d26 <vfprintf+0x27c>
    2d22:	20 e1       	ldi	r18, 0x10	; 16
    2d24:	32 e0       	ldi	r19, 0x02	; 2
    2d26:	f8 01       	movw	r30, r16
    2d28:	b7 fe       	sbrs	r11, 7
    2d2a:	07 c0       	rjmp	.+14     	; 0x2d3a <vfprintf+0x290>
    2d2c:	60 81       	ld	r22, Z
    2d2e:	71 81       	ldd	r23, Z+1	; 0x01
    2d30:	82 81       	ldd	r24, Z+2	; 0x02
    2d32:	93 81       	ldd	r25, Z+3	; 0x03
    2d34:	0c 5f       	subi	r16, 0xFC	; 252
    2d36:	1f 4f       	sbci	r17, 0xFF	; 255
    2d38:	06 c0       	rjmp	.+12     	; 0x2d46 <vfprintf+0x29c>
    2d3a:	60 81       	ld	r22, Z
    2d3c:	71 81       	ldd	r23, Z+1	; 0x01
    2d3e:	80 e0       	ldi	r24, 0x00	; 0
    2d40:	90 e0       	ldi	r25, 0x00	; 0
    2d42:	0e 5f       	subi	r16, 0xFE	; 254
    2d44:	1f 4f       	sbci	r17, 0xFF	; 255
    2d46:	a4 01       	movw	r20, r8
    2d48:	e6 d0       	rcall	.+460    	; 0x2f16 <__ultoa_invert>
    2d4a:	a8 2e       	mov	r10, r24
    2d4c:	a8 18       	sub	r10, r8
    2d4e:	fb 2d       	mov	r31, r11
    2d50:	ff 77       	andi	r31, 0x7F	; 127
    2d52:	bf 2e       	mov	r11, r31
    2d54:	b6 fe       	sbrs	r11, 6
    2d56:	0b c0       	rjmp	.+22     	; 0x2d6e <vfprintf+0x2c4>
    2d58:	2b 2d       	mov	r18, r11
    2d5a:	2e 7f       	andi	r18, 0xFE	; 254
    2d5c:	a5 14       	cp	r10, r5
    2d5e:	50 f4       	brcc	.+20     	; 0x2d74 <vfprintf+0x2ca>
    2d60:	b4 fe       	sbrs	r11, 4
    2d62:	0a c0       	rjmp	.+20     	; 0x2d78 <vfprintf+0x2ce>
    2d64:	b2 fc       	sbrc	r11, 2
    2d66:	08 c0       	rjmp	.+16     	; 0x2d78 <vfprintf+0x2ce>
    2d68:	2b 2d       	mov	r18, r11
    2d6a:	2e 7e       	andi	r18, 0xEE	; 238
    2d6c:	05 c0       	rjmp	.+10     	; 0x2d78 <vfprintf+0x2ce>
    2d6e:	7a 2c       	mov	r7, r10
    2d70:	2b 2d       	mov	r18, r11
    2d72:	03 c0       	rjmp	.+6      	; 0x2d7a <vfprintf+0x2d0>
    2d74:	7a 2c       	mov	r7, r10
    2d76:	01 c0       	rjmp	.+2      	; 0x2d7a <vfprintf+0x2d0>
    2d78:	75 2c       	mov	r7, r5
    2d7a:	24 ff       	sbrs	r18, 4
    2d7c:	0d c0       	rjmp	.+26     	; 0x2d98 <vfprintf+0x2ee>
    2d7e:	fe 01       	movw	r30, r28
    2d80:	ea 0d       	add	r30, r10
    2d82:	f1 1d       	adc	r31, r1
    2d84:	80 81       	ld	r24, Z
    2d86:	80 33       	cpi	r24, 0x30	; 48
    2d88:	11 f4       	brne	.+4      	; 0x2d8e <vfprintf+0x2e4>
    2d8a:	29 7e       	andi	r18, 0xE9	; 233
    2d8c:	09 c0       	rjmp	.+18     	; 0x2da0 <vfprintf+0x2f6>
    2d8e:	22 ff       	sbrs	r18, 2
    2d90:	06 c0       	rjmp	.+12     	; 0x2d9e <vfprintf+0x2f4>
    2d92:	73 94       	inc	r7
    2d94:	73 94       	inc	r7
    2d96:	04 c0       	rjmp	.+8      	; 0x2da0 <vfprintf+0x2f6>
    2d98:	82 2f       	mov	r24, r18
    2d9a:	86 78       	andi	r24, 0x86	; 134
    2d9c:	09 f0       	breq	.+2      	; 0x2da0 <vfprintf+0x2f6>
    2d9e:	73 94       	inc	r7
    2da0:	23 fd       	sbrc	r18, 3
    2da2:	12 c0       	rjmp	.+36     	; 0x2dc8 <vfprintf+0x31e>
    2da4:	20 ff       	sbrs	r18, 0
    2da6:	06 c0       	rjmp	.+12     	; 0x2db4 <vfprintf+0x30a>
    2da8:	5a 2c       	mov	r5, r10
    2daa:	73 14       	cp	r7, r3
    2dac:	18 f4       	brcc	.+6      	; 0x2db4 <vfprintf+0x30a>
    2dae:	53 0c       	add	r5, r3
    2db0:	57 18       	sub	r5, r7
    2db2:	73 2c       	mov	r7, r3
    2db4:	73 14       	cp	r7, r3
    2db6:	60 f4       	brcc	.+24     	; 0x2dd0 <vfprintf+0x326>
    2db8:	b7 01       	movw	r22, r14
    2dba:	80 e2       	ldi	r24, 0x20	; 32
    2dbc:	90 e0       	ldi	r25, 0x00	; 0
    2dbe:	2c 87       	std	Y+12, r18	; 0x0c
    2dc0:	78 d0       	rcall	.+240    	; 0x2eb2 <fputc>
    2dc2:	73 94       	inc	r7
    2dc4:	2c 85       	ldd	r18, Y+12	; 0x0c
    2dc6:	f6 cf       	rjmp	.-20     	; 0x2db4 <vfprintf+0x30a>
    2dc8:	73 14       	cp	r7, r3
    2dca:	10 f4       	brcc	.+4      	; 0x2dd0 <vfprintf+0x326>
    2dcc:	37 18       	sub	r3, r7
    2dce:	01 c0       	rjmp	.+2      	; 0x2dd2 <vfprintf+0x328>
    2dd0:	31 2c       	mov	r3, r1
    2dd2:	24 ff       	sbrs	r18, 4
    2dd4:	11 c0       	rjmp	.+34     	; 0x2df8 <vfprintf+0x34e>
    2dd6:	b7 01       	movw	r22, r14
    2dd8:	80 e3       	ldi	r24, 0x30	; 48
    2dda:	90 e0       	ldi	r25, 0x00	; 0
    2ddc:	2c 87       	std	Y+12, r18	; 0x0c
    2dde:	69 d0       	rcall	.+210    	; 0x2eb2 <fputc>
    2de0:	2c 85       	ldd	r18, Y+12	; 0x0c
    2de2:	22 ff       	sbrs	r18, 2
    2de4:	16 c0       	rjmp	.+44     	; 0x2e12 <vfprintf+0x368>
    2de6:	21 ff       	sbrs	r18, 1
    2de8:	03 c0       	rjmp	.+6      	; 0x2df0 <vfprintf+0x346>
    2dea:	88 e5       	ldi	r24, 0x58	; 88
    2dec:	90 e0       	ldi	r25, 0x00	; 0
    2dee:	02 c0       	rjmp	.+4      	; 0x2df4 <vfprintf+0x34a>
    2df0:	88 e7       	ldi	r24, 0x78	; 120
    2df2:	90 e0       	ldi	r25, 0x00	; 0
    2df4:	b7 01       	movw	r22, r14
    2df6:	0c c0       	rjmp	.+24     	; 0x2e10 <vfprintf+0x366>
    2df8:	82 2f       	mov	r24, r18
    2dfa:	86 78       	andi	r24, 0x86	; 134
    2dfc:	51 f0       	breq	.+20     	; 0x2e12 <vfprintf+0x368>
    2dfe:	21 fd       	sbrc	r18, 1
    2e00:	02 c0       	rjmp	.+4      	; 0x2e06 <vfprintf+0x35c>
    2e02:	80 e2       	ldi	r24, 0x20	; 32
    2e04:	01 c0       	rjmp	.+2      	; 0x2e08 <vfprintf+0x35e>
    2e06:	8b e2       	ldi	r24, 0x2B	; 43
    2e08:	27 fd       	sbrc	r18, 7
    2e0a:	8d e2       	ldi	r24, 0x2D	; 45
    2e0c:	b7 01       	movw	r22, r14
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
    2e10:	50 d0       	rcall	.+160    	; 0x2eb2 <fputc>
    2e12:	a5 14       	cp	r10, r5
    2e14:	30 f4       	brcc	.+12     	; 0x2e22 <vfprintf+0x378>
    2e16:	b7 01       	movw	r22, r14
    2e18:	80 e3       	ldi	r24, 0x30	; 48
    2e1a:	90 e0       	ldi	r25, 0x00	; 0
    2e1c:	4a d0       	rcall	.+148    	; 0x2eb2 <fputc>
    2e1e:	5a 94       	dec	r5
    2e20:	f8 cf       	rjmp	.-16     	; 0x2e12 <vfprintf+0x368>
    2e22:	aa 94       	dec	r10
    2e24:	f4 01       	movw	r30, r8
    2e26:	ea 0d       	add	r30, r10
    2e28:	f1 1d       	adc	r31, r1
    2e2a:	80 81       	ld	r24, Z
    2e2c:	b7 01       	movw	r22, r14
    2e2e:	90 e0       	ldi	r25, 0x00	; 0
    2e30:	40 d0       	rcall	.+128    	; 0x2eb2 <fputc>
    2e32:	a1 10       	cpse	r10, r1
    2e34:	f6 cf       	rjmp	.-20     	; 0x2e22 <vfprintf+0x378>
    2e36:	33 20       	and	r3, r3
    2e38:	09 f4       	brne	.+2      	; 0x2e3c <vfprintf+0x392>
    2e3a:	5d ce       	rjmp	.-838    	; 0x2af6 <vfprintf+0x4c>
    2e3c:	b7 01       	movw	r22, r14
    2e3e:	80 e2       	ldi	r24, 0x20	; 32
    2e40:	90 e0       	ldi	r25, 0x00	; 0
    2e42:	37 d0       	rcall	.+110    	; 0x2eb2 <fputc>
    2e44:	3a 94       	dec	r3
    2e46:	f7 cf       	rjmp	.-18     	; 0x2e36 <vfprintf+0x38c>
    2e48:	f7 01       	movw	r30, r14
    2e4a:	86 81       	ldd	r24, Z+6	; 0x06
    2e4c:	97 81       	ldd	r25, Z+7	; 0x07
    2e4e:	02 c0       	rjmp	.+4      	; 0x2e54 <vfprintf+0x3aa>
    2e50:	8f ef       	ldi	r24, 0xFF	; 255
    2e52:	9f ef       	ldi	r25, 0xFF	; 255
    2e54:	2c 96       	adiw	r28, 0x0c	; 12
    2e56:	0f b6       	in	r0, 0x3f	; 63
    2e58:	f8 94       	cli
    2e5a:	de bf       	out	0x3e, r29	; 62
    2e5c:	0f be       	out	0x3f, r0	; 63
    2e5e:	cd bf       	out	0x3d, r28	; 61
    2e60:	df 91       	pop	r29
    2e62:	cf 91       	pop	r28
    2e64:	1f 91       	pop	r17
    2e66:	0f 91       	pop	r16
    2e68:	ff 90       	pop	r15
    2e6a:	ef 90       	pop	r14
    2e6c:	df 90       	pop	r13
    2e6e:	cf 90       	pop	r12
    2e70:	bf 90       	pop	r11
    2e72:	af 90       	pop	r10
    2e74:	9f 90       	pop	r9
    2e76:	8f 90       	pop	r8
    2e78:	7f 90       	pop	r7
    2e7a:	6f 90       	pop	r6
    2e7c:	5f 90       	pop	r5
    2e7e:	4f 90       	pop	r4
    2e80:	3f 90       	pop	r3
    2e82:	2f 90       	pop	r2
    2e84:	08 95       	ret

00002e86 <strnlen_P>:
    2e86:	fc 01       	movw	r30, r24
    2e88:	05 90       	lpm	r0, Z+
    2e8a:	61 50       	subi	r22, 0x01	; 1
    2e8c:	70 40       	sbci	r23, 0x00	; 0
    2e8e:	01 10       	cpse	r0, r1
    2e90:	d8 f7       	brcc	.-10     	; 0x2e88 <strnlen_P+0x2>
    2e92:	80 95       	com	r24
    2e94:	90 95       	com	r25
    2e96:	8e 0f       	add	r24, r30
    2e98:	9f 1f       	adc	r25, r31
    2e9a:	08 95       	ret

00002e9c <strnlen>:
    2e9c:	fc 01       	movw	r30, r24
    2e9e:	61 50       	subi	r22, 0x01	; 1
    2ea0:	70 40       	sbci	r23, 0x00	; 0
    2ea2:	01 90       	ld	r0, Z+
    2ea4:	01 10       	cpse	r0, r1
    2ea6:	d8 f7       	brcc	.-10     	; 0x2e9e <strnlen+0x2>
    2ea8:	80 95       	com	r24
    2eaa:	90 95       	com	r25
    2eac:	8e 0f       	add	r24, r30
    2eae:	9f 1f       	adc	r25, r31
    2eb0:	08 95       	ret

00002eb2 <fputc>:
    2eb2:	0f 93       	push	r16
    2eb4:	1f 93       	push	r17
    2eb6:	cf 93       	push	r28
    2eb8:	df 93       	push	r29
    2eba:	18 2f       	mov	r17, r24
    2ebc:	09 2f       	mov	r16, r25
    2ebe:	eb 01       	movw	r28, r22
    2ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec2:	81 fd       	sbrc	r24, 1
    2ec4:	03 c0       	rjmp	.+6      	; 0x2ecc <fputc+0x1a>
    2ec6:	8f ef       	ldi	r24, 0xFF	; 255
    2ec8:	9f ef       	ldi	r25, 0xFF	; 255
    2eca:	20 c0       	rjmp	.+64     	; 0x2f0c <fputc+0x5a>
    2ecc:	82 ff       	sbrs	r24, 2
    2ece:	10 c0       	rjmp	.+32     	; 0x2ef0 <fputc+0x3e>
    2ed0:	4e 81       	ldd	r20, Y+6	; 0x06
    2ed2:	5f 81       	ldd	r21, Y+7	; 0x07
    2ed4:	2c 81       	ldd	r18, Y+4	; 0x04
    2ed6:	3d 81       	ldd	r19, Y+5	; 0x05
    2ed8:	42 17       	cp	r20, r18
    2eda:	53 07       	cpc	r21, r19
    2edc:	7c f4       	brge	.+30     	; 0x2efc <fputc+0x4a>
    2ede:	e8 81       	ld	r30, Y
    2ee0:	f9 81       	ldd	r31, Y+1	; 0x01
    2ee2:	9f 01       	movw	r18, r30
    2ee4:	2f 5f       	subi	r18, 0xFF	; 255
    2ee6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ee8:	39 83       	std	Y+1, r19	; 0x01
    2eea:	28 83       	st	Y, r18
    2eec:	10 83       	st	Z, r17
    2eee:	06 c0       	rjmp	.+12     	; 0x2efc <fputc+0x4a>
    2ef0:	e8 85       	ldd	r30, Y+8	; 0x08
    2ef2:	f9 85       	ldd	r31, Y+9	; 0x09
    2ef4:	81 2f       	mov	r24, r17
    2ef6:	19 95       	eicall
    2ef8:	89 2b       	or	r24, r25
    2efa:	29 f7       	brne	.-54     	; 0x2ec6 <fputc+0x14>
    2efc:	2e 81       	ldd	r18, Y+6	; 0x06
    2efe:	3f 81       	ldd	r19, Y+7	; 0x07
    2f00:	2f 5f       	subi	r18, 0xFF	; 255
    2f02:	3f 4f       	sbci	r19, 0xFF	; 255
    2f04:	3f 83       	std	Y+7, r19	; 0x07
    2f06:	2e 83       	std	Y+6, r18	; 0x06
    2f08:	81 2f       	mov	r24, r17
    2f0a:	90 2f       	mov	r25, r16
    2f0c:	df 91       	pop	r29
    2f0e:	cf 91       	pop	r28
    2f10:	1f 91       	pop	r17
    2f12:	0f 91       	pop	r16
    2f14:	08 95       	ret

00002f16 <__ultoa_invert>:
    2f16:	fa 01       	movw	r30, r20
    2f18:	aa 27       	eor	r26, r26
    2f1a:	28 30       	cpi	r18, 0x08	; 8
    2f1c:	51 f1       	breq	.+84     	; 0x2f72 <__ultoa_invert+0x5c>
    2f1e:	20 31       	cpi	r18, 0x10	; 16
    2f20:	81 f1       	breq	.+96     	; 0x2f82 <__ultoa_invert+0x6c>
    2f22:	e8 94       	clt
    2f24:	6f 93       	push	r22
    2f26:	6e 7f       	andi	r22, 0xFE	; 254
    2f28:	6e 5f       	subi	r22, 0xFE	; 254
    2f2a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f2c:	8f 4f       	sbci	r24, 0xFF	; 255
    2f2e:	9f 4f       	sbci	r25, 0xFF	; 255
    2f30:	af 4f       	sbci	r26, 0xFF	; 255
    2f32:	b1 e0       	ldi	r27, 0x01	; 1
    2f34:	3e d0       	rcall	.+124    	; 0x2fb2 <__ultoa_invert+0x9c>
    2f36:	b4 e0       	ldi	r27, 0x04	; 4
    2f38:	3c d0       	rcall	.+120    	; 0x2fb2 <__ultoa_invert+0x9c>
    2f3a:	67 0f       	add	r22, r23
    2f3c:	78 1f       	adc	r23, r24
    2f3e:	89 1f       	adc	r24, r25
    2f40:	9a 1f       	adc	r25, r26
    2f42:	a1 1d       	adc	r26, r1
    2f44:	68 0f       	add	r22, r24
    2f46:	79 1f       	adc	r23, r25
    2f48:	8a 1f       	adc	r24, r26
    2f4a:	91 1d       	adc	r25, r1
    2f4c:	a1 1d       	adc	r26, r1
    2f4e:	6a 0f       	add	r22, r26
    2f50:	71 1d       	adc	r23, r1
    2f52:	81 1d       	adc	r24, r1
    2f54:	91 1d       	adc	r25, r1
    2f56:	a1 1d       	adc	r26, r1
    2f58:	20 d0       	rcall	.+64     	; 0x2f9a <__ultoa_invert+0x84>
    2f5a:	09 f4       	brne	.+2      	; 0x2f5e <__ultoa_invert+0x48>
    2f5c:	68 94       	set
    2f5e:	3f 91       	pop	r19
    2f60:	2a e0       	ldi	r18, 0x0A	; 10
    2f62:	26 9f       	mul	r18, r22
    2f64:	11 24       	eor	r1, r1
    2f66:	30 19       	sub	r19, r0
    2f68:	30 5d       	subi	r19, 0xD0	; 208
    2f6a:	31 93       	st	Z+, r19
    2f6c:	de f6       	brtc	.-74     	; 0x2f24 <__ultoa_invert+0xe>
    2f6e:	cf 01       	movw	r24, r30
    2f70:	08 95       	ret
    2f72:	46 2f       	mov	r20, r22
    2f74:	47 70       	andi	r20, 0x07	; 7
    2f76:	40 5d       	subi	r20, 0xD0	; 208
    2f78:	41 93       	st	Z+, r20
    2f7a:	b3 e0       	ldi	r27, 0x03	; 3
    2f7c:	0f d0       	rcall	.+30     	; 0x2f9c <__ultoa_invert+0x86>
    2f7e:	c9 f7       	brne	.-14     	; 0x2f72 <__ultoa_invert+0x5c>
    2f80:	f6 cf       	rjmp	.-20     	; 0x2f6e <__ultoa_invert+0x58>
    2f82:	46 2f       	mov	r20, r22
    2f84:	4f 70       	andi	r20, 0x0F	; 15
    2f86:	40 5d       	subi	r20, 0xD0	; 208
    2f88:	4a 33       	cpi	r20, 0x3A	; 58
    2f8a:	18 f0       	brcs	.+6      	; 0x2f92 <__ultoa_invert+0x7c>
    2f8c:	49 5d       	subi	r20, 0xD9	; 217
    2f8e:	31 fd       	sbrc	r19, 1
    2f90:	40 52       	subi	r20, 0x20	; 32
    2f92:	41 93       	st	Z+, r20
    2f94:	02 d0       	rcall	.+4      	; 0x2f9a <__ultoa_invert+0x84>
    2f96:	a9 f7       	brne	.-22     	; 0x2f82 <__ultoa_invert+0x6c>
    2f98:	ea cf       	rjmp	.-44     	; 0x2f6e <__ultoa_invert+0x58>
    2f9a:	b4 e0       	ldi	r27, 0x04	; 4
    2f9c:	a6 95       	lsr	r26
    2f9e:	97 95       	ror	r25
    2fa0:	87 95       	ror	r24
    2fa2:	77 95       	ror	r23
    2fa4:	67 95       	ror	r22
    2fa6:	ba 95       	dec	r27
    2fa8:	c9 f7       	brne	.-14     	; 0x2f9c <__ultoa_invert+0x86>
    2faa:	00 97       	sbiw	r24, 0x00	; 0
    2fac:	61 05       	cpc	r22, r1
    2fae:	71 05       	cpc	r23, r1
    2fb0:	08 95       	ret
    2fb2:	9b 01       	movw	r18, r22
    2fb4:	ac 01       	movw	r20, r24
    2fb6:	0a 2e       	mov	r0, r26
    2fb8:	06 94       	lsr	r0
    2fba:	57 95       	ror	r21
    2fbc:	47 95       	ror	r20
    2fbe:	37 95       	ror	r19
    2fc0:	27 95       	ror	r18
    2fc2:	ba 95       	dec	r27
    2fc4:	c9 f7       	brne	.-14     	; 0x2fb8 <__ultoa_invert+0xa2>
    2fc6:	62 0f       	add	r22, r18
    2fc8:	73 1f       	adc	r23, r19
    2fca:	84 1f       	adc	r24, r20
    2fcc:	95 1f       	adc	r25, r21
    2fce:	a0 1d       	adc	r26, r0
    2fd0:	08 95       	ret

00002fd2 <_exit>:
    2fd2:	f8 94       	cli

00002fd4 <__stop_program>:
    2fd4:	ff cf       	rjmp	.-2      	; 0x2fd4 <__stop_program>
